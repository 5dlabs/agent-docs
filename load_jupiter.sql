BEGIN;
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/misc/13-integrator-guidelines.md', 'sidebar_label: "Integrator Guidelines"
description: "Guidelines for integrations with Jupiter."
title: "Integrator Guidelines" 

     Integrator Guidelines 
     

 Jupiter provides developer tools and resources to help you integrate with Jupiter. The following section provides the guidelines when integrating with Jupiter. 
 Branding and Marketing 
 When integrating with Jupiter, you can use the following assets to help you brand and market your product:  Jupiter Brand Assets . 
 :::caution Labelling Routing Provider
Do note that, if you are using our routing engine (such as getting quotes from the Swap API), you are to label the routing provider as  "Jupiter Metis v1" , and not "Jupiter".
::: 
 Developer Support 
 There are currently 2 ways to get technical support: 
 
 Public Developer Support Channel in Discord 
 Portal Enquiry 
 
 :::warning
Please use the Discord channel for your technical questions, as it is a public channel, more people can help you and it promotes discovery/discussion. 
 If you open a ticket via the link that  does not relate  to Portal Enquiries, we will redirect you to the Discord channel.
::: 
 Customer Support 
 The Jupiter UI contains multiple safeguards, warnings and default settings to guide our users to trade safer. However, when you integrate with Jupiter, we cannot control these elements despite sharing best practices, hence, Jupiter is not liable for any losses incurred on your UI/platform. 
 The only exception is for Jupiter Ultra API, where you can use our ticketing system to provide support to your users. 
 :::warning
We are still in the process of finalizing the Ultra API customer support process. 
 Reach out to  us  to discuss what is the best way to support your users.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/misc/12-privacy-policy.md', 'Privacy Policy 
 
 Jupiter , accessible at: https://jup.ag, one of its main priorities is the privacy of participants who are visitors of https://jup.ag and its dApps  (the “Interface”) . Jupiter does it best to collect as minimum Personal Data as possible. This Privacy Policy document contains types of data that are collected, used, and recorded by Jupiter. 
 The Jupiter Interface backed by Block Raccoon S.A., a company incorporated in Panama, which is the controller for your Personal Data within the scope of this Privacy Policy. Jupiter decides “why” and “how” your Personal Data is processed in connection with the Interface. If you have additional questions or require more information about this Privacy Policy, do not hesitate to contact  privacy@jup.ag . 
 This Privacy Policy applies only to the Interface activities and is valid for participants who are visitors to the Interface with regards to the Personal Data that they share and/or which is collected within Jupiter Interface. This Privacy Policy is not applicable to any Personal Data collected offline or via channels other than the Interface. Please read this Privacy Policy carefully to understand our policies and practices regarding your data and how it will be treated by the Interface. 
 IF YOU DO NOT HAVE THE RIGHT, POWER AND AUTHORITY TO ACT ON BEHALF OF AND BIND THE BUSINESS, ORGANIZATION, OR OTHER ENTITY YOU REPRESENT, PLEASE DO NOT ACCESS OR OTHERWISE USE THE INTERFACE. IF YOU ARE INTERESTED IN HOW WE USE COOKIES AND YOU CAN CHANGE YOUR COOKIE CHOICE, PLEASE SEE SECTION 5 “COOKIES AND AUTOMATICALLY-COLLECTED DATA” 
 1. Changes to this Agreement​ 
 If our data processing practices change, we will update this Privacy Policy accordingly to let you know of them upfront and give you a possibility to either provide your consent, object to a particular processing, or undertake other action you are entitled to under the Regulation. Please keep track of any changes we may introduce to this Privacy Policy. Your continued access to and use of the Interface constitutes your awareness of all amendments made to this Privacy Policy as of the date of your accessing and use of the Interface. Therefore, we encourage you to review this Privacy Policy regularly as you shall be bound by it. If, for some reason, you are not satisfied with our personal data processing practices, your immediate recourse is to stop using the Interface. You do not have to inform us of this decision unless you intend to exercise some of the data protection rights stipulated by GDPR and defined below in this Privacy Policy. 
 2. Eligibility​ 
 Age. By accessing our using the Interface, you represent and warrant that you are at least eighteen (18) years of age. If you are under the age of eighteen (18), you may not, under any circumstances or for any reason, use the Interface. Please report to us any instances involving the use of the Interface by individuals under the age of 18, should they come to your knowledge. 
 3. Applicability​ 
 This Privacy Policy applies to all your interactions with us via the Interface and your interactions with us in connection therewith. 
 Below are the categories of our processors used on the Interface due to an internal data processing roadmap providing a brief grasp of our data processing activities with regard to each piece of the Personal Data we may collect through the Interface, as well as your place in every data processing event. It can be requested at  privacy@jup.ag . Below are the categories of our processors which can access and process your Personal Data through the Interface: 
 
 Technical maintenance vendors; 
 Project and team management vendors; 
 Communication vendors; 
 Analytics, statistics, performance, marketing vendors. 
 
 4. Data processing in connection with the Interface​ 
 Types of Data Collected 
 To the maximum extent possible, Jupiter tries to collect as minimum Personal Data from you as possible. Personal Data we collect: 
 
 IP address, MAC address, log files, domain server, data related to usage, performance, website security, traffic patterns, location information, browser and device information – only when you are using the Interface; 
 Wallet addresses (public blockchain addresses), transaction, and balance information (blockchain data) that is accessible when interacting with the Interface; We use public Blockchain addresses to identify a user’s journey through our product. We group and analyze these user journeys collectively in order to improve our product user experience. We do not use this data for any purpose at an individual user level. The legal basis for this processing is our legitimate interests, such as monitoring and improving the Interface, the proper protection of the Interface against risks, and partly the contract performance basis to provide you the Interface. Note that we are not responsible for your use of any of the blockchain and your data processed in these decentralized and permissionless networks; 
 Log Files. Jupiter follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and this kind of Personal Data may also be collected as a part of hosting services'' analytics. The data collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These kinds of data may be linked to data that is personally identifiable. The purpose of the data collection and processing is for analyzing trends, administering the website, tracking users'' movement on the website, and gathering demographic information; 
 
 Jupiter may also engage third-parties advertising platforms that are triggered only when their technical features (so-called “pixels”) are enabled through the Interface. The mentioned third-parties advertising platforms may collect Personal Data of Interface''s visitors only with the purpose to optimize their advertising possibilities through their platforms, target you with their advertisements, and possibly share your data with other advertising platforms and agencies for further use. Jupiter may engage with the mentioned Personal Data of Interfaces visitors. 
 In no event, are we going to ask you to share your private keys or wallet seed. Never trust anyone or any website that asks you to enter your private keys or wallet seed. 
 How and Why we use your Personal Data 
 We may use your Personal Data listed above only for: 
 
 Our internal and operational purposes, when: ensuring security, identifying irregular website behavior, preventing fraudulent activity, and improving security at all possible levels; 
 Assessing and improving the performance of the Interface; 
 Analyzing our website visitors’ actions to improve our Interface (section “Cookies and Automatically Collected Data”); 
 Analyzing the Interface behavior, including via: Google Analytics (please refer to Google''s Analytics Policy for more information); 
 Find and prevent fraud. 
 
 To clear any doubts, we may use Personal Data described above or any other Personal Data: 
 
 on the basis of contract performance or necessity to enter into a contract (where the Personal Data is required for us to perform our undertakings and obligations in accordance with a contract we are entering into when you use our services, or where we are at the negotiations phase); 
 on the basis of our or our processors’ legitimate interests to protect the Interface, prevent any malicious and harmful activities to the Interface, maintain our technical systems healthily and secure, improve services and products by using aggregate statistics; 
 to respond to legal requests of authorities, provide information upon court orders and judgments, or if we have a good-faith belief that such disclosure is necessary in order to comply with official investigations or legal proceedings initiated by governmental and/or law enforcement officials, or private parties, including but not limited to: in response to subpoenas, search warrants or court orders, and including other similar statutory obligations we or our processors are subjected to; 
 on the basis of your consent; and 
 on other legal bases set forth in the personal data protection laws. 
 
 Disclosure of Data 
 In continuation of legal bases for collecting and processing the Personal Data, We may disclose any Personal Data about you: 
 
 in connection with a merger, division, restructuring, or other association change; or 
 to our subsidiaries or affiliates (if any) only if necessary for operational purposes. If we must disclose any of your Personal Data in order to comply with official investigations or legal proceedings initiated by governmental and/or law enforcement officials, we may not be able to ensure that such recipients of your Personal Data will maintain the privacy or security of your Personal Data. 
 
 Data Retention Period 
 Jupiter maintains Personal Data exclusively within the time needed to follow prescribed herein legal purposes. When we no longer need Personal Data, the limitation period for storage of such Personal Data has expired, you have withdrawn your consent or objected to our or our processors’ legitimate interests, we securely delete or destroy it unless the statutory requirements we, our processors or other controllers are subjected to stipulate otherwise. Aggregated data, which cannot directly identify a device/browser (or individual) and is used for purposes of reporting and analysis, is maintained for as long as commercially necessary till you object to the processing of such data or withdraw your consent. 
 Sometimes legal requirements oblige us to retain certain data, for specific purposes, for an extended period of time. Reasons we might retain some data for longer periods of time include: 
 
 Security, fraud & abuse prevention; 
 Financial monitoring and record-keeping; 
 Complying with legal or regulatory requirements; 
 Ensuring the continuity of your interaction with the Interface. 
 
 Your Inquiries 
 You may contact us by email at the following email address:  privacy@jup.ag ; We use the data that you provide in an email to us, which you may give voluntarily, only in order to answer your question or to reply to your email in the best possible manner. 
 5. Cookies and Automatically Collected Data​ 
 As you navigate through and interact with our Interface, we may ask your consent to use cookies, which are small files placed on the hard drive/browser of your computer or mobile device, and web beacons, which are small electronic files located on pages of the Interface, to collect certain information about devices you use, browsing actions, and patterns. 
 The data automatically collected from cookies and web beacons may include information about your web browser (such as browser type and browser language) and details of your visits to the Interface, including traffic data, location data and logs, page views, length of visit, and website navigation paths as well as information about your device and internet connection, including your IP address and how you interact with the Interface. We collect this data in order to help us improve the Interface and interaction with it. 
 The information we collect automatically may also include statistical and performance information arising from your use of the Interface. This type of data will only be used by us in an aggregated and pseudonymized manner. 
 You can choose to disable cookies through your individual browser options. To get more detailed information about cookie management with specific web browsers, please find it on the browsers'' respective websites: 
 
 For Google Chrome browser please refer to these instructions: https://support.google.com/accounts/answer/32050?co=GENIE.Platform%3DDesktop&hl=en; 
 For Firefox browser please look up here: https://support.mozilla.org/en-US/kb/clear-cookies-and-site-data-firefox 
 For Safari browser please visit: https://support.apple.com/ru-ru/guide/safari/sfri11471/mac 
 For Internet Explorer browser please refer to: https://support.microsoft.com/en-us/windows/delete-and-manage-cookies-168dab11-0753-043d-7c16-ede5947fc64d 
 
 6. Your rights under GDPR​ 
 Under certain circumstances, you may have a number of privacy rights concerning the use, storage, and processing of your Personal Data (e.g., the right to delete your data). Here is a list of privacy rights: 
 
 right to be informed - we are publishing this Privacy Policy to keep you informed as to what we do with your Personal Data. You can ask us for Personal Data regarding you that we keep at any time. This information concerns, among other things, the data categories we process, for what purposes we process them, the origin of the data if we did not acquire them directly from you and, if applicable, the recipients to who we have sent your data. 
 right of access – You may ask us whether we process your Personal Data and you have the right to request a copy of the data we hold about you. 
 right of rectification – You have the right to correct inaccurate or incomplete data about you. 
 right to be forgotten – You can ask for the Personal Data that we hold about you to be erased from our system and we will comply with this request unless we have a legitimate reason, legal requirement, and other statutory basis not to do so. Even if we can delete (erase) the Personal Data subject to our active (ongoing) processing activities and cease its processing, we will nevertheless retain this particular Personal Data in our backup and archive storages to fulfill our statutory and other requirements. 
 right to restriction of processing – where certain conditions apply, you can ask us to ‘block’ the processing of your Personal Data. 
 right to data portability – You have the right to have the data we hold about you transferred to another organization and to receive Personal Data in a structured, commonly used format. Please apply to:  privacy@jup.ag  to find out whether we currently support the provision of the portable file containing Personal Data we process about you. 
 right to object - You can object to the processing of your data by applying to:  privacy@jup.ag  at any time for reasons that arise from your special situation provided the data processing is based on our legitimate interest or that of a third party, or where we carry out profiling, use machine learning or automated decision-making algorithms. In this case, we will no longer process your Personal Data. The latter does not apply if we are able to prove there are compelling, defensible reasons for the processing that outweigh your interests or we require your data to assert, exercise, or defend legal claims. 
 right to withdraw consent - withdraw the consent you gave us with regard to the processing of your Personal Data for certain purposes. 
 right to complain - we take your rights very seriously. However, if you are of the opinion that we have not dealt with your complaints adequately, you have the right to submit a complaint to the data privacy protection authorities responsible. You can send your complaints to the EEA supervisory authority of your country of residence. 
 
 Please email:  privacy@jup.ag  with any questions about exercising any of the above rights. If You wish to learn more about the GDPR and Your rights, the Information Commissioner’s Office website is a reliable source. 
 7. Privacy of children​ 
 Our Interface is not directed to collect any data from people under the age of 18. We do not knowingly allow anyone under 18 years old to submit any data to our Interface. If you believe your child may have provided us with their data, you can contact us using the information in this Policy and we will delete the data from our Interface. 
 8. Transfer of Personal Data​ 
 Transfers to third countries shall be made subject to appropriate safeguards, namely Standard Contractual Clauses adopted by the supervisory authority and approved by the Commission. Copy of the foregoing appropriate safeguards may be obtained by you upon a prior written request sent. We may instruct you on further steps to be taken with the purpose of obtaining such a copy, including your obligation to assume confidentiality commitments in connection with being disclosed the Jupiter proprietary and personal information of third parties as well as terms of their relationships with Jupiter. 
 Keep in mind that the use of the Interface based on public blockchains is intended to immutably record transactions across wide networks of computer systems. Many blockchains are open to forensic analysis which can lead to deanonymization and the unintentional revelation of Personal Data, in particular when blockchain data is combined with other data. Because blockchains are decentralized or third-party networks that are not controlled or operated by us, we are not able to erase, modify, or alter Personal Data from such networks. 
 9. Data Integrity & Security of Processing​ 
 We take data security very seriously. We work hard to protect the Personal Data you provide us from loss, misuse, or unauthorized access. We utilize a variety of safeguards such as encryption, digital and physical access controls, non-disclosure agreements, and other technical and organizational measures to protect the Personal Data submitted to us, both during transmission and once it is at rest. 
 Please note that no electronic transmission, storage, or processing of Personal Data can be entirely secure. We cannot guarantee that the security measures we have in place to safeguard Personal Data will never be defeated or fail, or that those measures will always be sufficient or effective. Therefore, although we are committed to protecting your privacy, we do not promise, and you should not expect that your Personal Data will always remain private or secure. 
 10. Supervisory authority oversight​ 
 If you are a data subject whose data we process, you may also have the right to lodge a complaint with a data protection regulator in one or more of the European Union member states. Here you can find a list of data protection authorities in Europe: ​​https://edpb.europa.eu/about-edpb/about-edpb/members_en', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/misc/10-sdk-api-license-agreement.md', 'SDK & API License Agreement 
 IMPORTANT:  This Jupiter API & SDK License Agreement ("Agreement") is a legally binding contract between you, as Licensee ("You", "Your" or "Licensee") and Block Raccoon S.A., an entity incorporated in Panama ("Jupiter," "we" or "our") and applies to your use of the Jupiter API or SDK, as defined herein, available through https://portal.jup.ag (collectively the "Service"). The Service includes an Application Programming Interface ("API") and a Software Development Kit (“SDK”), which is further discussed and defined below. If you do not agree to be bound by the terms and conditions of this Agreement, please do not proceed with the use of Service, the API, or the SDK. 
 This Agreement becomes effective as of the date you first access, download, copy or otherwise use the API or SDK ("Effective Date"). This Agreement shall continue until terminated either by us or by you. Even after termination of this Agreement, certain provisions will survive, as discussed herein. This Agreement also incorporates Jupiter`s Terms of Service link and Privacy Policy link which terms shall also govern your use of the Service. In the event of any conflict between this Agreement and the Terms of Service or Privacy Policy, the provisions of this Agreement shall prevail. 
 YOU ARE ENTERING A LEGALLY BINDING CONTRACT: BY COPYING, DOWNLOADING, OR OTHERWISE USING THE JUPITER API OR SDK YOU ARE EXPRESSLY AGREEING TO BE BOUND BY ALL TERMS OF THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF THIS AGREEMENT, YOU ARE NOT AUTHORIZED TO COPY, DOWNLOAD, INSTALL OR OTHERWISE USE THE JUPITER API or SDK. 
 The API and SDK are protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The API and SDK is licensed to you, and its use is subject to the terms of this Agreement. 
 1. Definitions​ 
 1.1  "Application Programming Interfaces"  or  "API"  or  "Jupiter API"  means the back-end smart routing algorithm which facilitates the user''s efficient swapping of digital assets at a variety of third party trading venues, which may include object code, software libraries, software tools, sample source code, published specifications and Documentation. Jupiter API shall include any future, updated or otherwise modified version(s) thereof furnished by Jupiter (in its sole discretion) to Licensee. 
 1.2  "Software Development Kit"  or  "SDK"  or  "Jupiter SDK"  means the ancillary tools and resources that allow the user to utilise or integrate the API. Jupiter SDK shall include any future, updated or otherwise modified version(s) thereof furnished by Jupiter (in its sole discretion) to Licensee. 
 1.3  "Documentation"  includes, but is not limited to programmer guides, manuals, materials, and information appropriate or necessary for use in connection with the API, and in particular shall include the Integrator Guidelines available at https://dev.jup.ag/docs/misc/integrator-guidelines. 
 2. Grant of License​ 
 2.1 Subject to the terms of this Agreement, Jupiter hereby grants Licensee a limited, non-exclusive, fee-bearing, non-transferable, non-sublicensable licence to use the API or SDK during the term of this Agreement solely for the purpose of Licensee''s internal development efforts to develop products or services integrating the API and/or SDK in any manner, including without limitation for any informational, comparison, or testing purpose (the  Licensee''s Product ). 
 2.2 Licensee shall have no right to distribute, license (whether or not through multiple tiers) or otherwise transfer the API or SDK to any third party. 
 2.3 Notwithstanding any of the provisions herein, where the Licensee uses the API or SDK (including without limitation for any informational, comparison, or testing purpose), it shall be required to strictly label/name/characterise the API and any output of the API as “Jupiter Metis v1" and not utilise any other label, name or characteristic, in particular where the same is visible to end users of the Licensee’s Product. The Licensee accepts that it is misleading and unethical to label/name/characterise the API and any output of the API as “Jupiter” or otherwise suggest it is the same product as the service available at https://jup.ag/. 
 2.4 In case of potential other API or SDK use that is not prescribed by this Agreement, please write to info@jup.ag to seek written consent. 
 2.5 Representations. Both Parties to this Agreement are duly organized and validly existing in good standing with all requisite power and authority to enter into this Agreement and conduct its business as is now being conducted. The Licensee is not identified on, or engages in any transactions with any party listed on, any sanctions list maintained by the U.S. Department of the Treasury’s Office of Foreign Asset Control (“OFAC”). 
 2.6 By providing access to the API and the SDK, Jupiter is solely providing a back-end technical service to the Licensee which allows the Licensee to provide swap-related services to end users of the Licensee''s products or services. Jupiter is not a party to any agreement for swap-related services between the Licensee, its end users, any counterparty or trading venue where swaps are performed, nor any trustee, custodian, bailee, manager, administrator or service provider in respect of any digital asset or otherwise. 
 2.7 Independent Contractor Relationship. The relationship between the Parties is that of independent contractors. Nothing in this Agreement shall be construed to create anything like the relationship of an employer and employee, joint venture, partnership, or joint association. 
 3. Other Rights and Limitations​ 
 3.1 Copies. Licensee may copy the API or SDK only as necessary for the purpose of the licence hereunder. 
 3.2 Except as expressly authorised under this Agreement or by Jupiter in writing, the Licensee agrees it shall not (and shall not permit or authorise any other person to): 
 a. use the API or SDK in any manner that is not expressly authorised by this Agreement; 
 b. use the API or SDK or develop or use the Licensee''s Product (i) for any illegal, unauthorised or otherwise improper purposes or (ii) in any manner which would violate this Agreement or the Documentation, breach any laws, regulations, rules or orders (including those relating to virtual assets, intellectual property, data privacy, data transfer, international communications or the export of technical or personal data) or violate the rights of third parties (including rights of privacy or publicity); 
 c. remove any legal, copyright, trademark or other proprietary rights notices contained in or on materials it receives or is given access to pursuant to this Agreement, including the API, the SDK and the Documentation; 
 d. sell, lease, share, transfer or sublicense the API, SDK or any content obtained through the API, directly or indirectly, to any third party; 
 e. use the API or SDK in a manner that, as determined by Jupiter in its sole discretion, exceeds reasonable request volume, constitutes excessive or abusive usage, or otherwise fails to comply or is inconsistent with any part of the Documentation; 
 f. access the API or SDK for competitive analysis or disseminate performance information (including uptime, response time and/or benchmarks) relating to the API; 
 g. use the API in conjunction with, or combine content from the API with, content obtained through scraping or any other means outside the API; 
 h. (i) interfere with, disrupt, degrade, impair, overburden or compromise the integrity of the API, Jupiter''s systems or any networks connected to the API or Jupiter''s systems (including by probing, scanning or testing their vulnerability), (ii) disobey any requirements, procedures, policies or regulations of networks connected to the API or Jupiter''s systems, (iii) attempt to gain unauthorised access to the API, Jupiter''s systems or any information not permitted by this Agreement or circumvent any access or usage limits imposed by Jupiter or (iv) transmit through the Licensee''s Product or the use of the API or SDK any (A) content that is illegal, tortious, defamatory, vulgar, obscene, racist, ethnically insensitive, or invasive of another person''s privacy, (B) content that promotes illegal or harmful activity, or gambling or adult content, (C) viruses, worms, defects, Trojan horses, or any other malicious programs or code or items of a destructive nature or (D) materials that could harm minors in any way; 
 i. copy, adapt, reformat, reverse-engineer, disassemble, decompile, download, translate or otherwise modify or create derivative works of the API, the SDK or the Documentation, Jupiter''s website, or any of Jupiter''s other content, products or services, through automated or other means; 
 j. interfere with Jupiter''s business practices or the way in which it licenses or distributes the API or SDK; 
 k. make any representations, warranties or commitments (i) regarding the API or SDK or (ii) on behalf of Jupiter; or 
 l. take any action that would subject the API or SDK to any third-party terms, including without limitation any open source software licence terms. 
 3.3 Without prejudice of the generality of the foregoing, where the Licensee''s Product is competitive (whether wholly or partially) with the API or the Service, Jupiter shall have the right to access the Licensee''s Product and/or request the Licensee for information regarding the Licensee''s Product. Jupiter shall be granted a non-exclusive, royalty-free, non-transferable, non-sublicensable licence to use the Licensee''s Product (including without limitation any application programming interface, software development kit, logos, brand information, technical information or data or information in connection with any aspect of the Licensee''s Product) for any purpose. 
 3.4 Third Party Software. Licensee acknowledges that effective utilization of the API and SDK may require the use of a development tool, compiler and other software and technology of third parties ("Third Party Software"). Licensee is solely responsible for procuring such Third-Party Software and technology and the necessary licenses for the use thereof. Jupiter makes no representation or warranty concerning Third Party Software and shall have no obligation or liability with respect to Third Party Software. 
 3.5 No right is granted to Licensee to sublicense its rights hereunder. All rights not expressly granted are reserved by Jupiter and, except as expressly set forth herein, no license is granted by Jupiter under this Agreement directly, by implication, estoppel or otherwise, under any patent, copyright, trade secret or trademark or other intellectual property rights of Jupiter. Nothing herein shall be deemed to authorize Licensee to use Jupiter`s trademarks or trade names in Licensee''s advertising, marketing, promotional, sales or related materials. Jupiter reserves all rights not otherwise expressly granted in this Agreement. 
 3.6 No assertion by Licensee. Licensee agrees not to assert any patent rights related to the API/SDK or applications developed using the API/SDK against Jupiter, Jupiter''s participants, or other licensees of the API/SDK for making, using, selling, offering for sale, or importing any products or technology developed using the API/SDK. 
 3.7 Jupiter may from time to time provide updates or upgrades to the API or SDK. Any such updates and upgrades will be performed according to Jupiter''s then-current operational policies, which may include automatic updating or upgrading of API or SDK currently in use at that time. Where the Licensee fails to accept such updates or upgrades, Jupiter shall be entitled to withhold access to the API, SDK and/or Service, and the same shall not constitute any breach of the terms of this Agreement. 
 4. Intellectual Property and proprietary rights 
 4.1 As between Jupiter and Licensee, Jupiter and/or its licensors shall own and retain all proprietary rights, including all patent, copyright, trade secret, trademark and other intellectual property rights, in and to the API and SDK and any corrections, bug fixes, enhancements, updates, improvements, or modifications thereto and (to the extent such rights accrue to the Licensee), the Licensee hereby irrevocably transfers, conveys and assigns to Jupiter all of its right, title, and interest therein. 
 4.2 Jupiter shall have the exclusive right to apply for or register any patents, mask work rights, copyrights, and such other proprietary protections with respect thereto. 
 4.3 The Licensee acknowledges that the license granted under this Agreement does not provide Licensee with title or ownership to the API or SDK, but only a right of limited use under the terms and conditions of this Agreement. 
 4.4 The Parties acknowledge that Jupiter does not store, send, or receive digital assets. Digital assets exist only by virtue of the ownership record maintained on the relevant blockchain network. Any creation or transfer of title that might occur in respect of any digital asset occurs on the relevant blockchain network (on the relevant contractual terms applicable to such creation and/or transfer) and is performed by the Licensee''s Product, and Jupiter does not have any role or responsibility in such transactions. Jupiter cannot guarantee that the Licensee''s Product, or any party can effect the transfer of such title or right to any digital asset. Accordingly, Jupiter cannot provide any guarantee, warranty or assurance regarding the authenticity, uniqueness, originality, quality, marketability, legality or value of any digital assets utilised in connection with the API and the Services. 
 5. No Obligation to Support​ 
 5.1 Subject to payment of fees as described herein, Jupiter would issue to the Licensee certain unique API keys, tokens, passwords and/or other credentials (collectively,  "Keys" ), for accessing the API and/or SDK and managing the Licensee''s access to the API. The Licensee may only access the API with the Keys issued to the Licensee by Jupiter. The Licensee acknowledges that access to the API may not always be available. The Licensee may not sell, transfer, sublicense or otherwise disclose its Keys to any other party or use them for any other purpose other than that expressly permitted by Jupiter. The Licensee is responsible for maintaining the secrecy and security of the Keys. The Licensee is fully responsible for all activities that occur using the Keys, regardless of whether such activities are undertaken by the Licensee or a third party. The Licensee is responsible for maintaining up-to-date and accurate information (including a current email address and other required contact information) for the Licensee''s access to the API and SFK. Jupiter may discontinue the Licensee''s access to the API and SDK if such contact information is not up-to-date and/or the Licensee does not respond to communications directed to such coordinates. 
 5.2 Jupiter makes no guarantees with respect to the performance, availability or uptime of the API or the SDK. Jupiter may conduct maintenance on or stop providing any of the API or the SDK at any time with or without written notice to the Licensee. In addition, Jupiter may change the method of access to the API, SDK and Documentation at any time. 
 5.3 Jupiter does not guarantee any support for the API or SDK under this Agreement. Nothing herein shall be construed to require Jupiter to provide consultations, support services or updates, upgrades, bug fixes or modifications to the API or SDK. In the event of degradation or instability of Jupiter''s system or an emergency, Jupiter may, in its sole discretion, suspend access to the API and/or SDK. 
 5.4 Jupiter reserves the right to change the method of access to the API or SDK at any time to ensure the safety and security of its environment. In the event of degradation or instability of Jupiter`s systems or in an emergency, you acknowledge and agree that Jupiter may, in its sole and absolute discretion, temporarily suspend your access to the API or SDK in order to minimize threats to and protect the operational stability and security of the Jupiter system. 
 6. Fees & Payment​ 
 6.1 Jupiter shall charge a subscription fee for usage of the Jupiter API and/or SDK. This may be a fixed fee, infrastructure fee and/or a variable fee based on revenue earned by the Licensee in respect of the Licensee''s Product. 
 6.2 The details of the level of fees charged shall be notified to you via the API portal at https://portal.jup.ag. By accessing, downloading, copying or otherwise using the API or SDK, you shall be deemed to have consented to said fees. 
 6.3 The Fees may be reviewed by Jupiter at any time commencing from three (3) months after the Effective Date. Any updated fees shall be notified to you via the API portal and your continued usage of the API or SDK shall be deemed consent to such updated fees. 
 7. Licensee''s Obligations 
 7.1 The Licensee agrees to report to Jupiter any errors or difficulties discovered related to the API or SDK, and the characteristic conditions and symptoms of such errors and difficulties. 
 7.2 The Licensee shall perform such sanity testing, cybersecurity testing or other technical checks in respect of the API or SDK as may be reasonably requested by Licensor from time to time. 
 7.3 The Licensee shall ensure that the offering/provision of the Licensee''s Product complies with all applicable laws and regulations, including without limitation all consumer protection, Know Your Customer (KYC) or Anti-money Laundering (AML) due diligence laws, sanctions, anti-money laundering or terrorist financing laws, securities laws, payment provider laws, or virtual assets regulations. Without prejudice to the generality of the foregoing, the Licensee shall obtain and maintain in force (or as applicable procure the obtaining and maintenance in force of) all necessary licenses, permissions, authorisations, consents and permits which may be necessary or desirable for the offering/provision of the Licensee''s Product and (b) perform transaction screening and monitoring of all digital wallets interacting with the Client’s Product, including blocking of sanctioned, blacklisted, prohibited, restricted, flagged, illicit, suspicious or crime-associated digital wallets, in accordance with prevailing best market practice. The Licensee shall be solely responsible for any failure to comply with the foregoing. 
 7.4 The Licensee acknowledges and agrees that all reporting, information gathering and other obligations under applicable Know Your Customer (KYC) or Anti-money Laundering (AML) due diligence laws, sanctions, anti-money laundering or terrorist financing laws, securities laws, payment provider laws, or virtual assets regulations with respect to the Licensee''s end-users are the responsibility of the Licensee; and Jupiter shall not be responsible or have any liability for any of the foregoing. The Licensee agrees to provide such information to Jupiter if reasonably requested by Jupiter. 
 7.5 Without prejudice to the foregoing, upon written request from Jupiter, the Licensee shall use all efforts to block any specific digital wallet or address from accessing the Licensee''s Product and/or the API integration. 
 7.6 The Licensee agrees to immediately notify Jupiter if (i) the Licensee becomes aware of any security event, including any cybersecurity breach, attack or economic exploit relating to the Licensee''s Product or (ii) the Licensee''s Product, API, SDK or the Service becomes subject to any legal or regulatory investigation or action. 
 7.7 The Licensee shall be responsible for all customer service for all its products and services (including the Licensee''s Product). 
 8. Confidentiality​ and Publicity 
 8.1 The API and SDK contains valuable proprietary information and trade secrets of Jupiter and its suppliers that remain the property of Jupiter. You shall protect the confidentiality of, and avoid disclosure and unauthorized use of, the API or SDK. 
 8.2 Without prejudice to the generality of the foregoing, you agree not to disparage Jupiter, any of its affiliates, or any of their directors, shareholders, employees, servants, contractors, or agents in any manner, or otherwise make any false, misleading or negative statements to any party about Jupiter or any of its affiliates, the Service (or any output of the Service), or any other product(s) or service(s) of Jupiter or any of its affiliates. 
 8.3 Jupiter may disclose and publicise the existence of the business relationship between Jupiter and you on its website and in promotional and marketing materials without requiring any further consent from you. 
 8.4 You shall ensure that the Licensee''s Product shall prominently display to end users of such product or service the message "Powered by Jupiter". 
 9. No Warranty​ 
 9.1 The API, SDK, and Documentation are provided "AS-IS" without any warranty whatsoever. To the full extent allowed by law, the foregoing warranties and remedies are exclusive and are in lieu of all other warranties, terms, or conditions, express or implied, either in fact or by operation of law, statutory or otherwise, including warranties, terms, or conditions of merchantability, fitness for a particular purpose, satisfactory quality, correspondence with description, and non-infringement, all of which are expressly disclaimed. 
 9.2 No advice or information, whether oral or written, obtained by you from Jupiter or through or from the API/SDK shall create any warranty not expressly stated in this agreement. Jupiter does not warrant that the API, SDK and Documentation are suitable for Licensee''s use, that the API, SDK or Documentation are without defect or error, that operation will be uninterrupted, or that defects will be corrected. Further, Jupiter makes no warranty regarding the results of the use of the API, SDK, and Documentation. 
 10. Limitation of Liability​ 
 JUPITER WILL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR RELATING TO THE USE OR THE INABILITY TO USE THE API, SDK AND ITS USE OR THE INABILITY TO USE WITH ANY THIRD PARTY SOFTWARE, ITS CONTENT OR FUNCTIONALITY, INCLUDING BUT NOT LIMITED TO DAMAGES FOR LOSS OF BUSINESS PROFITS OR REVENUE; BUSINESS INTERRUPTION OR WORK STOPPAGE; COMPUTER FAILURE OR MALFUNCTION; LOSS OF BUSINESS INFORMATION, DATA OR DATA USE; LOSS OF GOODWILL; DAMAGES CAUSED BY OR RELATED TO ERRORS, OMISSIONS, INTERRUPTIONS, DEFECTS, DELAY IN OPERATION OR TRANSMISSION, COMPUTER VIRUS, FAILURE TO CONNECT, NETWORK CHARGES, AND ALL OTHER DIRECT, INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES EVEN IF JUPITER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE EXCLUSIONS OR LIMITATIONS MAY NOT APPLY TO YOU. NOTWITHSTANDING THE FOREGOING, JUPITER TOTAL LIABILITY TO LICENSEE FOR ALL LOSSES, DAMAGES, CAUSES OF ACTION, INCLUDING BUT NOT LIMITED TO THOSE BASED ON CONTRACT, TORT, OR OTHERWISE, ARISING OUT OF YOUR USE OF THE API/SDK AND/OR INTELLECTUAL PROPERTY ON THIS TECHNOLOGY PLATFORM OR API/SDK, OR ANY OTHER PROVISION OF THIS AGREEMENT, SHALL NOT EXCEED THE AMOUNT OF 100 USD. THE FOREGOING LIMITATIONS, EXCLUSIONS, AND DISCLAIMERS SHALL APPLY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, EVEN IF ANY REMEDY FAILS ITS ESSENTIAL PURPOSE. 
 11. Indemnity​ 
 You agree to indemnify and hold harmless Jupiter and its contributors, subsidiaries, affiliates, officers, agents, Intellectual Property service providers, co-branders, customers, suppliers or other partners, and employees, from any loss, claim or demand, including reasonable attorneys'' fees, made by any third party due to or arising out of your negligence, error, omissions, or failure to perform relating to your use of the API/SDK, your connection to the API, or your violation of the Agreement. 
 12. Disclaimers 
 12.1 UNLESS SEPARATELY STATED IN A WRITTEN EXPRESS LIMITED WARRANTY, THE API AND SDK PROVIDED BY JUPITER IS PROVIDED "AS IS" AND ON AN "AS AVAILABLE" BASIS, WITHOUT WARRANTIES OF ANY KIND FROM JUPITER, EITHER EXPRESS OR IMPLIED. TO THE FULLEST EXTENT POSSIBLE PURSUANT TO APPLICABLE LAW, JUPITER DISCLAIMS ALL WARRANTIES EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY QUALITY OR WORKMANSHIP LIKE EFFORT, FITNESS FOR A PARTICULAR PURPOSE, RELIABILITY OR AVAILABILITY, ACCURACY, LACK OF VIRUSES, QUIET ENJOYMENT, NON- INFRINGEMENT OF THIRD-PARTY RIGHTS OR OTHER VIOLATIONS OF RIGHTS. SOME JURISDICTIONS DO NOT ALLOW EXCLUSIONS OR LIMITATIONS OF IMPLIED WARRANTIES, SO THE ABOVE EXCLUSIONS OR LIMITATIONS MAY NOT APPLY TO YOU. NO ADVICE OR INFORMATION, WHETHER ORAL OR WRITTEN, OBTAINED BY YOU FROM JUPITER OR ITS AFFILIATES SHALL BE DEEMED TO ALTER THIS DISCLAIMER BY JUPITER OF WARRANTY REGARDING THE API OR SDK OR THE AGREEMENT, OR TO CREATE ANY WARRANTY OF ANY SORT FROM JUPITER. 
 12.2 NEITHER JUPITER NOR THE API PROVIDES ANY DIGITAL ASSET EXCHANGE OR PORTFOLIO/FUND MANAGEMENT SERVICE. WHERE THE LICENSEE OR ANY END USER OF THE LICENSEE''S PRODUCT MAKES THE DECISION TO TRANSACT UTILISING THE API OR THE SERVICE, THEN SUCH DECISIONS AND TRANSACTIONS AND ANY CONSEQUENCES FLOWING THEREFROM ARE SUCH TRANSACTING PARTY''S SOLE RESPONSIBILITY. 
 12.3 THE API FUNCTIONS SOLELY AS A BACK-END SUPPORTING TECHNICAL SERVICE FOR A SMART ROUTING ALGORITHM FOR DIGITAL ASSET SWAPS ONLY; IN NO CIRCUMSTANCES SHALL JUPITER, THE API OR THE SDK BE CONSTRUED AS A DIGITAL ASSET EXCHANGE, BROKER, DEALER, FUND MANAGER, FINANCIAL INSTITUTION, EXCHANGE, CUSTODIAN, ROBO-ADVISOR, INTERMEDIARY, OR CREDITOR. 
 12.4 THE API DOES NOT FACILITATE OR ARRANGE DIGITAL ASSET TRANSACTIONS BETWEEN COUNTERPARTIES, INCLUDING WITH RESPECT TO ANY TRANSACTIONS THAT OCCUR IN CONNECTION WITH ANY DECENTRALISED EXCHANGE, LIQUIDITY POOL OR OTHER CENTRALISED OR DECENTALISED FINANCE PRODUCT / FACILITY, WHICH TRANSACTIONS OCCUR ON SUCH PLATFORM, PROTOCOL AND/OR THE RELEVANT BLOCKCHAIN NETWORK. JUPITER IS NOT A COUNTERPARTY TO ANY DIGITAL ASSET TRANSACTION FACILITATED BY THE API OR THE LICENSEE''S PRODUCT. 
 12.5 There may be various vulnerabilities, failures or abnormal behaviour of software relating to digital assets (e.g., token contract, wallet, smart contract), or relating to the relevant blockchain network, and Jupiter cannot be responsible for any losses in connection with the same, including without limitation any losses in connection with (i) user error, such as forgotten passwords or incorrectly construed smart contracts or other transactions, (ii) server failure or data loss, (iii) corrupted wallet files, or (iv) unauthorised access or activities by third parties, including but not limited to the use of viruses, phishing, brute-forcing or other means of attack against the API or SDK, the relevant blockchain network, or the Licensee''s or any end user''s digital wallet. 
 12.6 Jupiter disclaims any responsibility for any disclosure of information or any other practices of any third-party API provider. Jupiter expressly disclaims any warranty regarding whether your personal information is captured by any third-party API provider or the use to which such personal information may be put by such third-party API provider. 
 13. Term and Termination​ 
 13.1 The effective date of this Agreement is the start of use of the API or SDK by the Licensee. There shall be a minimum term of 30 days for usage of the API to be paid for in advance (or such other minimum term as notified to you via the API portal at https://portal.jup.ag). 
 13.2 This Agreement will terminate automatically if you fail to comply with any of the terms and conditions of this Agreement and you will be liable to Jupiter and its suppliers for damages or losses caused by your non-compliance. The waiver by Jupiter of a specific breach or default shall not constitute the waiver of any subsequent breach or default. 
 13.3 Either party shall have the right to terminate the Agreement (for any reason), by written notice to the other party and refunding a pro-rata portion of any unutilised fee paid (in the case of termination by Jupiter). For the purpose of the Licensee''s service of notice, it may contact legal@jup.ag. 
 13.4 Upon termination of this Agreement, Licensee will immediately cease using the API and the SDK, and Licensee agrees to destroy all adaptations or copies of the API, SDK, and Documentation or return them to Jupiter upon the termination of this License. 
 13.5 Jupiter shall have the right to review/audit your use of the API or SDK in conjunction with this Agreement, and you will provide reasonable assistance for this purpose. 
 13.6 The rights of Jupiter and your obligations contained in this Agreement survive any expiration or termination of this Agreement. 
 14. Applicable Law; Arbitration​ 
 14.1 Licensee and Jupiter agree to arbitrate any dispute arising from this Agreement, except for disputes in which either party seeks equitable and other relief for the alleged unlawful use of copyrights, trademarks, trade names, logos, trade secrets or patents. ARBITRATION PREVENTS LICENSEE FROM SUING IN COURT OR FROM HAVING A JURY TRIAL. 
 14.2 Licensee and Jupiter agree to notify each other in writing of any dispute within thirty (30) days of when it arises. Notice to Jupiter shall be sent to legal@jup.ag. 
 14.3 The Licensee and Jupiter shall cooperate in good faith to resolve any dispute, controversy or claim arising out of, relating to, or in connection with this Agreement, including with respect to the formation, applicability, breach, termination, validity or enforceability thereof (a "Dispute") shall be settled in accordance with the laws of Panama. The parties undertake to carry out any award without delay and waive their right to any form of recourse insofar as such waiver can validly be made. Judgment upon the award may be entered by any court having jurisdiction thereof or having jurisdiction over the relevant party or its assets. Jupiter and the Licensee will each pay their respective attorneys'' fees and expenses. Any dispute arising out of or related to this Agreement is personal to the Licensee and Jupiter and will not be brought as a class arbitration, class action, or any other type of representative proceeding. There will be no class arbitration or arbitration in which a person attempts to resolve a dispute as a representative of another person or group of persons. Further, a dispute cannot be brought as a class or other type of representative action, whether within or outside of arbitration, or on behalf of any other person or group of persons. 
 14.4 Any dispute between the parties will be governed by this Agreement and the laws of Panama, without giving effect to any conflict of laws principles that may provide for the application of the law of another jurisdiction. Whether the dispute is heard in arbitration or in court, Licensee and Jupiter will not commence against the other a class action, class arbitration or representative action or proceeding. 
 15. Changes to this Agreement​ 
 We may amend any portion of this Agreement at any time by posting the revised version of this Agreement on https://portal.jup.ag with an updated revision date. The changes will become effective and shall be deemed accepted by you, the first time you use or access the SDK or API after the initial posting of the revised Agreement and shall apply on a going-forward basis with respect to your use of the SDK and/or API. In the event that you do not agree with any such modification, your sole and exclusive remedy is to terminate your use of the SDK and/or API. 
 16. Miscellaneous​ 
 16.1 Assignment. Licensee may not assign this Agreement or any interest or rights granted hereunder to any third party without the prior written consent of Jupiter. A change of control or reorganization of Licensee pursuant to a merger, sale of assets or stock shall be deemed to be an assignment under this Agreement. This Agreement shall terminate immediately upon the occurrence of any prohibited assignment. 
 16.2 Waiver. No failure by either party to exercise or enforce any of its rights under this Agreement will act as a waiver of such rights and no waiver of a breach in a particular situation shall be held to be a waiver of any other or subsequent breach. 
 16.3 Severability. If any provision of this Agreement is found invalid or unenforceable, that provision will be enforced to the maximum extent possible and the other provisions of this Agreement will remain in force. 
 16.4 Entire agreement. This Agreement represents the complete agreement concerning the API, SDK and oral amendments are void. If any provision of this Agreement is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. 
 16.5 Neither Party hereto shall be responsible for any failure to perform its obligations under this Agreement if such failure is caused by acts of God, war, strikes, revolutions, lack or failure of transportation facilities, laws or governmental regulations or other causes that are beyond the reasonable control of such Party. Obligations hereunder, however, shall in no event be excused but shall be suspended only until the cessation of any cause of such failure. 
 16.6 By installing, copying, or otherwise using this API or SDK, you acknowledge that you have read, understand and agree to be bound by the terms and conditions indicated above.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/misc/14-audits.md', 'sidebar_label: "Audits"
description: "Audits of Jupiter''s protocols."
title: "Audits" 

     Audits 
     

 Jupiter''s protocols are audited by reputable security firms to ensure the highest level of security and reliability. The following section provides the audits of Jupiter''s protocols. 
 Jupiter Swap 
 
 Offside Labs  (v6) 
 Sec3  (v3) 
 
 Jupiter Limit Order 
 
 Offside Labs  (v2) 
 
 Jupiter DAO 
 
 Offside Labs 
 
 Jupiter Perpetuals 
 
 Offside Labs 
 OtterSec 
 Sec3 
 
 Jupiter Lend 
 
 Zenith Report: June 24th, 2025 - July 31, 2025 
 Offside Labs Liquidity report: July 10th, 2025 - July 18, 2025 
 Offside Labs Vaults report: July 23rd, 2025 - August 4th, 2025', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/misc/11-terms-of-use.md', 'Terms of Use 
 
 Jupiter , https://jup.ag, a website-hosted user interface (the "Interface") made available by Block Raccoon S.A. 
 The Interface is a visual representation of Jupiter protocol (the "Protocol") which comprises open source software deployed in a permissionless manner by Block Raccoon S.A. The Interface provides an interface which allows users to view and administer their interactions with the Protocol. 
 These Terms of Use and any terms and conditions incorporated herein by reference (collectively, the "Terms") govern your access to and use of the Interface. You must read the Terms carefully. 
 To make these Terms easier to read: 
 
 Block Raccoon S.A.is referred to as "Jupiter", "we", "us", "our" or "the Company". 
 "You", "your" and "user(s)" refers to anybody who accesses or uses, in any way, the Interface. If you are accessing or using the Interface on behalf of a company (such as your employer) or other legal entity, you represent and warrant that you have the authority to bind that entity to these Terms and, in that case, "you", "your" or "user(s)" will refer to that entity. 
 
 By accessing, browsing, or otherwise using the Interface, or by acknowledging agreement to the Terms on the Interface, you agree that you have read, understood, and accepted all of the Terms and our Privacy Policy (the "Privacy Policy"), which is incorporated by reference into the Terms. 
 IMPORTANT NOTE REGARDING ARBITRATION: WHEN YOU AGREE TO THESE TERMS BY USING OR ACCESSING THE INTERFACE, YOU ARE AGREEING TO RESOLVE ANY DISPUTE BETWEEN YOU AND JUPITER THROUGH BINDING, INDIVIDUAL ARBITRATION RATHER THAN IN COURT. AND YOU AGREE TO A CLASS ACTION WAIVER, BOTH OF WHICH IMPACT YOUR RIGHTS AS TO HOW DISPUTES ARE RESOLVED. 
 If you come up with any further questions, please, dont be shy and feel free to contact us at  legal@jup.ag . 
 1. Eligibility​ 
 General . You may not use the Interface if you are otherwise barred from using the Interface under applicable law. 
 Legality . You are solely responsible for adhering to all laws and regulations applicable to you and your use or access to the Interface. Your use of the Interface is prohibited by and otherwise violate or facilitate the violation of any applicable laws or regulations, or contribute to or facilitate any illegal activity. 
 The Interface and each of the Company''s services does not constitute, and may not be used for the purposes of, an offer or solicitation to anyone in any jurisdiction in which such offer or solicitation is not authorised, or to any person to whom it is unlawful to make such an offer or solicitation. 
 By using or accessing the Interface, you represent to us that you are not subject to sanctions or otherwise designated on any list of prohibited or restricted parties or excluded or denied persons, including but not limited to the lists maintained by the United Nations Security Council, the European Union or its Member States, or any other government authority. 
 We make no representations or warranties that the information, products, or services provided through our Interface, are appropriate for access or use in other jurisdictions. You are not permitted to access or use our Interface in any jurisdiction or country if it would be contrary to the law or regulation of that jurisdiction or if it would subject us to the laws of, or any registration requirement with, such jurisdiction. We reserve the right to limit the availability of our Interface to any person, geographic area, or jurisdiction, at any time and at our sole and absolute discretion. 
 Prohibited Localities . Jupiter does not interact with digital wallets located in, established in, or a resident of the United States, the Republic of China, Singapore, Myanmar (Burma), Cote D''Ivoire (Ivory Coast), Cuba, Crimea and Sevastopol, Democratic Republic of Congo, Iran, Iraq, Libya, Mali, Nicaragua, Democratic People’s Republic of Korea (North Korea), Somalia, Sudan, Syria, Yemen, Zimbabwe or any other state, country or region that is subject to sanctions enforced by the United States, the United Kingdom or the European Union. You must not use any software or networking techniques, including use of a Virtual Private Network (VPN) to modify your internet protocol address or otherwise circumvent or attempt to circumvent this prohibition. 
 Non-Circumvention . You agree not to access the Interface using any technology for the purposes of circumventing these Terms. 
 2. Compliance Obligations​ 
 The Interface may not be available or appropriate for use in all jurisdictions. By accessing or using the Interface, you agree that you are solely and entirely responsible for compliance with all laws and regulations that may apply to you. You further agree that we have no obligation to inform you of any potential liabilities or violations of law or regulation that may arise in connection with your access and use of the Interface and that we are not liable in any respect for any failure by you to comply with any applicable laws or regulations. 
 3. Access to the Interface​ 
 We reserve the right to disable access to the Interface at any time in the event of any breach of the Terms, including without limitation, if we, in our sole discretion, believe that you, at any time, fail to satisfy the eligibility requirements set forth in the Terms. Further, we reserve the right to limit or restrict access to the Interface by any person or entity, or within any geographic area or legal jurisdiction, at any time and at our sole discretion. We will not be liable to you for any losses or damages you may suffer as a result of or in connection with the Interface being inaccessible to you at any time or for any reason. 
 The Interface and the Protocol may rely on or utilise a variety of external third party services or software, including without limitation oracles, decentralised cloud storage services, analytics tools, hence the Interface or the Protocol may be adversely affected by any number of risks related to these third party services/software. These may include technical interruptions, network congestion/failure, security vulnerabilities, cyberattacks, or malicious activity. Access to the Interface or the Protocol may become degraded or unavailable during times of significant volatility or volume. This could result in the inability to interact with third-party services for periods of time and may also lead to support response time delays. The Company cannot guarantee that the Interface or the Protocol will be available without interruption and neither does it guarantee that requests to interact with third-party services will be successful. You agree that you shall not hold the Company responsible for any losses which occur due to any of the foregoing. 
 4. Your Use of Interface​ 
 By using or accessing the Interface, you represent and warrant that you understand that there are inherent risks associated with virtual currency, and the underlying technologies including, without limitation, cryptography and blockchain, and you agree that Jupiter is not responsible for any losses or damages associated with these risks. You specifically acknowledge and agree that the Interface facilitates your interaction with decentralized networks and technology and, as such, we have no control over any blockchain or virtual currencies and cannot and do not ensure that any of your interactions will be confirmed on the relevant blockchain and do not have the ability to effectuate any cancellation or modification requests regarding any of your interactions. 
 Without limiting the foregoing, you specifically understand and hereby represent your acknowledgment of the following: 
 
 The pricing information data provided through the Interface does not represent an offer, a solicitation of an offer, or any advice regarding, or recommendation to enter into, a transaction with the Interface. 
 The Interface does not act as an agent for any of the users. 
 The Interface does not own or control any of the underlying software through which blockchain networks are formed, and therefore is not responsible for them and their operation. 
 You are solely responsible for reporting and paying any taxes applicable to your use of the Interface. 
 Although it is intended to provide accurate and timely information on the Interface, the Interface or relevant tools may not always be entirely accurate, complete, or current and may also include technical inaccuracies or typographical errors. Accordingly, you should verify all information before relying on it, and all decisions based on information contained on the Interface or relevant tools are your sole responsibility. 
 
 In order to allow other users to have a full and positive experience of using the Interface you agree that you will not use the Interface in a manner that: 
 
 Breaches the Terms; 
 Infringes on or violates any copyright, trademark, service mark, patent, right of publicity, right of privacy, or other proprietary or intellectual property rights under the law; 
 Seeks to interfere with or compromise the integrity, security, or proper functioning of any computer, server, network, personal device, or other information technology system, including, but not limited to, the deployment of viruses and denial of service attacks; 
 Attempts, in any manner, to obtain the private key, password, account, or other security information from any other user, including such information about the digital wallet; 
 Decompiles, reverse engineer, or otherwise attempt to obtain the source code or underlying ideas or information of or relating to the Interface; 
 Seeks to defraud us or any other person or entity, including, but not limited to, providing any false, inaccurate, or misleading information in order to unlawfully obtain the property of another; 
 Violates any applicable law, rule, or regulation concerning the integrity of trading markets, including, but not limited to, the manipulative tactics commonly known as spoofing and wash trading; 
 Violates any applicable law, rule, or regulation of the United States or another relevant jurisdiction, including, but not limited to, the restrictions and regulatory requirements imposed by U.S. law; 
 Disguises or interferes in any way with the IP address of the computer you are using to access or use the Interface or that otherwise prevents us from correctly identifying the IP address of the computer you are using to access the Interface; 
 Transmits, exchanges, or is otherwise supported by the direct or indirect proceeds of criminal or fraudulent activity; 
 Contributes to or facilitates any of the foregoing activities. 
 
 As it has been already stated, we only provide you with the relevant interface and software and neither has control over your interactions with the blockchain nor encourages you to perform any. Any interaction performed by you via the Interface remains your sole responsibility. 
 All information provided in connection with your access and use of the Interface is for informational purposes only and should not be construed as professional advice. You should not take, or refrain from taking, any action based on any information contained in the Interface or any other information that we make available at any time, including, without limitation, blog posts, articles, links to third-party content, news feeds, tutorials, tweets, and videos. Before you make any financial, legal, or other decisions involving the Interface, you should seek independent professional advice from an individual who is licensed and qualified in the area for which such advice would be appropriate. 
 The Terms are not intended to, and do not, create or impose any fiduciary duties on us. To the fullest extent permitted by law, you acknowledge and agree that we owe no fiduciary duties or liabilities to you or any other party and that to the extent any such duties or liabilities may exist at law or in equity, those duties and liabilities are hereby irrevocably disclaimed, waived, and eliminated. You further agree that the only duties and obligations that we owe you are those set forth expressly in the Terms. 
 You understand that smart contract protocols such as the Protocol simply comprise a set of autonomous blockchain-based smart contracts deployed on the relevant blockchain network, operated directly by users calling functions on it (which allows them to interact with other users in a multi-party peer-to-peer manner). There is no further control by or interaction with the original entity which had deployed the smart contract, which entity solely functions as a provider of technical tools for users, and is not offering any sort of securities product or regulated service nor does it hold any user assets on custody. Any rewards earned by user interactions arise solely out of their involvement in the protocol by taking on the risk of interacting with other users and the ecosystem. 
 5. Non-custodial nature of Interface and Protocol 
 The Interface and Protocol are non-custodial in nature, therefore neither holds or controls your digital assets. Any digital assets which you may acquire through the usage of the Interface or the Protocol will be held and administered solely by you through your selected electronic wallet, and we shall have no access to or responsibility in regard to such electronic wallet or digital asset held therein. It is solely your responsibility to select the wallet service provider to use, and your use of such electronic wallet will be subject to the governing terms of use or privacy policy of the provider of such wallet. We neither own nor control your selected electronic wallet service, the relevant blockchain network, or any other third party site, product, or service that you might access, visit, or use for the purpose of enabling you to utilise the Interface or the Protocol. We will not be liable for the acts or omissions of any such third parties, nor will we be liable for any damage that you may suffer as a result of your transactions or any other interaction with any such third parties. 
 We will not create any hosted wallet for you or otherwise custody digital assets on your behalf, and it is your sole responsibility to maintain the security of your selected electronic wallet. You hereby irrevocably waive, release and discharge all claims, whether known or unknown to you, against us, our affiliates and their respective shareholders, members, directors, officers, employees, agents and representatives related to your use of any wallet software, associated loss of digital assets, transaction failures, or any other defects that arise in the course of your use of your electronic wallet, including any losses that may obtain as a result of any failure of the Interface or the Protocol. 
 Neither the Company, the Interface nor the Protocol provides any digital asset exchange or portfolio/fund management services. If you choose to engage in transactions with other users via the Interface or the Protocol, then such decisions and transactions and any consequences flowing therefrom are your sole responsibility. In no event shall the Company, its affiliates or their respective directors or employees be responsible or liable to you or anyone else, directly or indirectly, for any damage or loss arising from or relating to any interaction or continued interaction with the Interface or the Protocol or in reliance on any information provided on the Interface (including, without limitation, directly or indirectly resulting from errors in, omissions of or alterations to any such information). 
 "Know Your Customer" and "Anti-Money Laundering" checks
We reserve the right to conduct "Know Your Customer" and "Anti-Money Laundering" checks on you if deemed necessary by us (at our sole discretion) or such checks become required under applicable laws in any jurisdiction. Upon our request, you shall immediately provide us with information and documents that we, in our sole discretion, deem necessary or appropriate to conduct "Know Your Customer" and "Anti-Money Laundering" checks. Such documents may include, but are not limited to, passports, driver''s licenses, utility bills, photographs of associated individuals, government identification cards or sworn statements before notaries or other equivalent professionals. Notwithstanding anything herein, we may, in its sole discretion, refuse to provide access to the Interface to you until such requested information is provided, or in the event that, based on information available to us, you are suspected of using the Interface or the Protocol in connection with any money laundering, terrorism financing, or any other illegal activity. In addition, we shall be entitled to use any possible efforts for preventing money laundering, terrorism financing or any other illegal activity, including without limitation blocking of your access to the Interface or the Protocol, or providing your information to any regulatory authority. 
 6. Disclaimers​ 
 You understand and agree that the Interface enables access to an online, decentralized, and autonomous protocol and environment, and associated decentralized networks, that are not controlled by Jupiter. We do not have access to your private key and cannot initiate an interaction with your virtual currency or otherwise access your virtual currency. We are not responsible for any activities that you engage in when using your wallet, or the Interface. 
 Jupiter cannot and does not represent or guarantee that any of the information available through the Interface is accurate, reliable, current, complete or appropriate for your needs. The information displayed through the Interface including information about prices is provided by third parties and/or calculated for informational purposes. Your use of any third-party scripts, indicators, ideas, and other content is at your sole risk. 
 You expressly understand and agree that your use of the Interface is at your sole risk. We make and expressly disclaim all representations and warranties, express, implied or statutory, and with respect to the Interface and the code proprietary or open-source, we specifically do not represent and warrant and expressly disclaim any representation or warranty, express, implied or statutory, including without limitation, any representations or warranties of title, non-infringement, merchantability, usage, security, suitability or fitness for any particular purpose, or as to the workmanship or technical coding thereof, or the absence of any defects therein, whether latent or patent. We do not represent or warrant that the Interface, code, and any related information are accurate, complete, reliable, current, or error-free. The Interface is provided on an "as is" and "as available" basis, without warranties of any kind, either express or implied, including, without limitation, implied warranties of merchantability, fitness for a particular purpose, or non-infringement. 
 You acknowledge that no advice, information, or statement that we make should be treated as creating any warranty concerning the Interface. We do not endorse, guarantee, or assume responsibility for any advertisements, offers, or statements made by third parties concerning the Interface. You acknowledge that Jupiter is not responsible for transferring, safeguarding, or maintaining your private keys or any virtual currency associated therewith. If you lose, mishandle, or have stolen associated virtual currency private keys, you acknowledge that you may not be able to recover associated virtual currency and that Jupiter is not responsible for such loss. You acknowledge that Jupiter is not responsible for any loss, damage, or liability arising from your failure to comply with the terms hereunder. 
 By accessing and using the Interface, you represent that you understand (a) the Interface facilitates access to the Protocol, the use of which has many inherent risks, and (b) the cryptographic and blockchain-based systems have inherent risks to which you are exposed when using the Interface. You further represent that you have a working knowledge of the usage and intricacies of blockchain-based digital assets, including, without limitation, SPL token standard available on the Solana blockchain. You further understand that the markets for these blockchain-based digital assets are highly volatile due to factors that include, but are not limited to, adoption, speculation, technology, security, and regulation. You acknowledge that the cost and speed of transacting with blockchain-based systems, such as Solana, are variable and may increase or decrease, respectively, drastically at any time. You hereby acknowledge and agree that we are not responsible for any of these variables or risks associated with the Protocol and cannot be held liable for any resulting losses that you experience while accessing or using the Interface. Accordingly, you understand and agree to assume full responsibility for all of the risks of accessing and using the Interface to interact with the Protocol. 
 The Interface may contain references or links to third-party resources, including, but not limited to, information, materials, products, or services, that we do not own or control. In addition, third parties may offer promotions related to your access and use of the Interface. We do not endorse or assume any responsibility for any such resources or promotions. If you access any such resources or participate in any such promotions, you do so at your own risk, and you understand that the Terms do not apply to your dealings or relationships with any third parties. You expressly relieve us of any and all liability arising from your use of any such resources or participation in any such promotions. 
 7. Intellectual Proprietary Rights​ 
 We own all intellectual property and other rights in the Interface and its contents, including, but not limited to, software, text, images, trademarks, service marks, copyrights, patents, and designs. Unless expressly authorized by us, you may not copy, modify, adapt, rent, license, sell, publish, distribute, or otherwise permit any third party to access or use the Interface or any of its contents. Accessing or using the Interface does not constitute a grant to you of any proprietary intellectual property or other rights in the Interface or its contents. 
 You will retain ownership of all intellectual property and other rights in any information and materials you submit through the Interface. However, by uploading such information or materials, you grant us a worldwide, royalty-free, irrevocable license to use, copy, distribute, publish and send this data in any manner in accordance with applicable laws and regulations. 
 You may choose to submit comments, bug reports, ideas, or other feedback about the Interface, including, without limitation, about how to improve the Interface (collectively, "Feedback"). By submitting any Feedback, you agree that we are free to use such Feedback at our discretion and without additional compensation to you, and to disclose such Feedback to third parties (whether on a non-confidential basis or otherwise). If necessary under applicable law, then you hereby grant us a perpetual, irrevocable, non-exclusive, transferable, worldwide license under all rights necessary for us to incorporate and use your Feedback for any purpose. 
 If (i) you satisfy all of the eligibility requirements set forth in the Terms, and (ii) your access to and use of the Interface complies with the Terms, you hereby are granted a single, personal, limited license to access and use the Interface. This license is non-exclusive, non-transferable, and freely revocable by us at any time without notice or cause in our sole discretion. Use of the Interface for any purpose not expressly permitted by the Terms is strictly prohibited. 
 In the event that you utilise any intellectual property in any manner which infringes on the rights of any party (including by unauthorised incorporation of the same in any project, protocol, code or any digital token), the Company reserves the sole discretion to effectuate the takedown of any such project, protocol, code or any digital token (or underlying intellectual property) at any time, without notice, compensation or payment to you. In addition, and without prejudice to the Company''s other remedies under this Agreement, you shall indemnify the Company and its officers, directors, employees, contractors, agents, affiliates, and subsidiaries from and against all claims, damages, obligations, losses, liabilities, costs, and expenses arising from your aforesaid infringement of intellectual rights. 
 8. Indemnification​ 
 You agree to hold harmless, release, defend, and indemnify us and our officers, directors, employees, contractors, agents, affiliates, and subsidiaries from and against all claims, damages, obligations, losses, liabilities, costs, and expenses arising from (a) your access to and use of the Interface; (b) your violation of these Terms, the right of any third party, or any other applicable law, rule, or regulation; and (c) any other party’s access and use of the Interface with your assistance or using any device or account that you own or control. 
 9. Limitation of Liability​ 
 Under no circumstances shall we or any of our officers, directors, employees, contractors, agents, affiliates, or subsidiaries be liable to you for any indirect, punitive, incidental, special, consequential, or exemplary damages, including (but not limited to) damages for loss of profits, goodwill, use, data, or other intangible property, arising out of or relating to any access to or use of the Interface, nor will we be responsible for any damage, loss, or injury resulting from hacking, tampering, or other unauthorized access to or use of the Interface, or from any access to or use of any information obtained by any unauthorized access to or use of the Interface. We assume no liability or responsibility for any: (a) errors, mistakes, or inaccuracies of content; (b) personal injury or property damage, of any nature whatsoever, resulting from any access to or use of the Interface; (c) unauthorized access to or use of any secure server or database in our control or the use of any information or data stored therein; (d) interruption or cessation of function related to the Interface; (e) bugs, viruses, trojan horses, or the like that may be transmitted to or through the Interface; (f) errors or omissions in, or loss or damage incurred as a result of, the use of any content made available through the Interface; and (g) the defamatory, offensive, or illegal conduct of any third party. Under no circumstances shall we or any of our officers, directors, employees, contractors, agents, affiliates, or subsidiaries be liable to you for any claims, proceedings, liabilities, obligations, damages, losses, or costs in an amount exceeding the greater of (i) the amount you paid to us in exchange for access to and use of the Interface, or (ii) $100.00. This limitation of liability applies regardless of whether the alleged liability is based on contract, tort, negligence, strict liability, or any other basis, and even if we have been advised of the possibility of such liability. Some jurisdictions do not allow the exclusion of certain warranties or the limitation or exclusion of certain liabilities and damages. Accordingly, some of the disclaimers and limitations set forth in the Terms may not apply to you. This limitation of liability shall apply to the fullest extent permitted by law. 
 10. Arbitration and Class Action Waiver​ 
 Binding Arbitration . Except for disputes in which either party seeks to bring an individual action in small claims court or seeks injunctive or other equitable relief for the alleged unlawful use of copyrights, trademarks, trade names, logos, trade secrets or patents, you and the Jupiter: (a) waive the right to have any and all disputes or claims arising from these Terms, your use or access to the Interface or any other disputes with the Jupiter  (collectively, "Disputes")  resolved in a court; and (b) waive any right to a jury trial. Instead, you and the Jupiter agree to arbitrate Disputes that are not resolved informally (as described below) through binding arbitration (i.e. the referral of a Dispute to one or more persons charged with reviewing the Dispute and making a final and binding determination to resolve it) instead of having the Dispute decided by a judge or jury in court). 
 No Class Arbitrations, Class Actions or Representative Actions . You and Jupiter agree that any dispute is personal to you and Jupiter and that any such dispute will be resolved solely through individual arbitration and will not be brought as a class arbitration, class action, or any other type of representative proceeding. Neither party agrees to class arbitration or to an arbitration in which an individual attempts to resolve a dispute as a representative of another individual or group of individuals. Further, you and the Jupiter agree that a dispute cannot be brought as a class, or other types of representative action, whether within or outside of arbitration, or on behalf of any other individual or group of individuals. 
 Process . You and the Jupiter agree that each will notify the other, in writing, of any Dispute within thirty (30) days of when it arises so that the parties can attempt, in good faith, to resolve the Dispute informally. Notice to Jupiter shall be provided by sending an email to legal@jup.ag. Your notice must include (1) your name, postal address, and email address; (2) a description of the nature or basis of the Dispute; and (3) the specific action that you are seeking. If you and the Jupiter cannot resolve the Dispute within thirty (30) days of the Jupiter receiving the notice, either you or Jupiter may, as appropriate pursuant to this Section 12, commence an arbitration proceeding. You and Jupiter agree that any arbitration or claim must be commenced or filed within one (1) year after the Dispute arose; otherwise, you and the Jupiter agree that the claim is permanently barred (which means that you will no longer have the right to assert a claim regarding the Dispute). 
 Choice of Law . These Terms are governed by and will be construed under the laws of Panama, without regard to principles of conflict of laws, govern the Terms and any Dispute between you and us. Any Dispute under these Terms shall be finally settled by Binding Arbitration (as defined below). Any unresolved Dispute arising out of or in connection with these Terms shall be referred to and finally resolved by arbitration under the rules of the London Court of International Arbitration (LCIA), which rules are deemed to be incorporated by reference into this Section 12 to the extent they are consistent with it. Any dispute arising from or relating to the subject matter of these Terms shall be finally settled in London, United Kingdom, in English, in accordance with the LCIA Arbitration Rules. Unless we agree otherwise, the arbitrator may not consolidate your claims with those of any other party. Any judgment on the award rendered by the arbitrator may be entered in any court of competent jurisdiction, to the extent a court therein would be deemed to be a court of competent jurisdiction other than any court located in the United States of America. You further agree that the Interface shall be deemed to be based solely in Panama and that, although the Interface may be available in other jurisdictions, its availability does not give rise to general or specific personal jurisdiction in any forum outside Panama. 
 Authority of Arbitrator . As limited by these Terms and applicable arbitration rules, the arbitrator will have: (a) the exclusive authority and jurisdiction to make all procedural and substantive decisions regarding a Dispute; and (b) the authority to grant any remedy that would otherwise be available in court. The arbitrator may only conduct an individual arbitration and may not consolidate more than one individual s claims, preside over any type of class or representative proceeding or preside over any proceeding involving more than one individual. 
 11. Miscellaneous​ 
 Changes . We may amend any portion of these Terms at any time by posting the revised version of these Terms with an updated revision date. The changes will become effective and shall be deemed accepted by you, the first time you use or access the Interface after the initial posting of the revised Terms and shall apply on a going-forward basis with respect to your use of the Interface including any transactions initiated after the posting date. In the event that you do not agree with any such modification, your sole and exclusive remedy are to terminate your use of the Interface. 
 Entire Agreement . These Terms (and any additional terms, rules, and conditions of participation that may be posted on the website of Jupiter) including the Privacy Policy constitute the entire agreement with respect to the Interface and supersedes any prior agreements, oral or written. 
 Privacy Policy . The Privacy Policy describes the ways we collect, use, store and disclose your personal information. You agree to the collection, use, storage, and disclosure of your data in accordance with the Privacy Policy. 
 Severability . If any provision of these Terms shall be determined to be invalid or unenforceable under any rule, law, or regulation of any local, state, or federal government agency, such provision will be changed and interpreted to accomplish the objectives of the provision to the greatest extent possible under any applicable law and the validity or enforceability of any other provision of these Terms shall not be affected. If such construction is not possible, the invalid or unenforceable portion will be severed from these Terms but the rest of these Terms will remain in full force and effect. 
 Survival . Upon termination of these Terms for any reason, all rights and obligations of the parties that by their nature are continuing will survive such termination. 
 English language . Notwithstanding any other provision of these Terms, any translation of these Terms is provided for your convenience. The meanings of terms, conditions, and representations herein are subject to their definitions and interpretations in the English language. In the event of conflict or ambiguity between the English language version and translated versions of these terms, the English language version shall prevail. You acknowledge that you have read and understood the English language version of these Terms. 
 If you have any questions, claims, complaints, or suggestions, please, contact us at  legal@jup.ag .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/600-routing/dex-integration.md', 'sidebar_label: "Jupiter Metis v1"
description: "Integrate your DEX into Jupiter Metis v1 Routing Engine."
title: "DEX Integration" 

     DEX Integration 
     

 Jupiter is one of the most widely integrated protocols, so a lot of work is involved in minimizing issues on new integrations and making each integration valuable to our users and partners. Our top priority is ensuring security and providing the best prices and the best token selection for our users, so we will focus on DEXes that will bring the most benefits to them. 
 In this section, we will walk you through the process of integrating your DEX into the Jupiter Metis v1 Routing Engine that powers the Swap API. 
 :::warning We do not charge fees for integration.
::: 
 Integration Prerequisites 
 As Solana grows and more DEXes are built, we have to be more cautious in the DEXes we integrate, we look into a variety of factors. 
 
 Code health : It will help with integration and ensure maintainability in the future. 
 Security audit : This is important to ensure users'' funds are secure and the program is not malicious. 
 Traction : We look at the traction of the DEX to ensure it has market demand and is well-used. 
 Team and backers : This is a good indicator of the quality of the DEX if they are backed by or built by reputable or verifiable entities. 
 
 AMM Interface 
 To facilitate integration of your DEX into the Jupiter Core Engine: 
 
 Provide a DEX SDK that works with the  Jupiter AMM Interface . 
 Enable us to fork your SDK, this ensures our users that we can guarantee maintenance, support for the SDK, and fix potential bugs related to integrated DEXs. 
 
 :::note
 get_accounts_to_update  provides the necessary accounts to fetch, they are batched and cached by the Jupiter Core Engine and delivered through  update  to the AMM instance, there might be multiple calls to  quote  using the same cache so  we do not allow any network calls  in the entire implementation.
::: 
 :::info Resource and Support
You can refer to the implementation guide https://github.com/jup-ag/rust-amm-implementation for easier integration with Jupiter. 
 If you require assistance or have questions, reach out to us at  Discord 
::: 
 
     
        AMM Interface Code Example
     
        ```rust
        pub trait Amm {
            // Maybe trait was made too restrictive?
            fn from_keyed_account(keyed_account: &KeyedAccount, amm_context: &AmmContext) -> Result 
            where
                Self: Sized;
            /// A human readable label of the underlying DEX
            fn label(&self) -> String;
            fn program_id(&self) -> Pubkey;
            /// The pool state or market state address
            fn key(&self) -> Pubkey;
            /// The mints that can be traded
            fn get_reserve_mints(&self) -> Vec ;
            /// The accounts necessary to produce a quote
            fn get_accounts_to_update(&self) -> Vec ;
            /// Picks necessary accounts to update it''s internal state
            /// Heavy deserialization and precomputation caching should be done in this function
            fn update(&mut self, account_map: &AccountMap) -> Result<()>;
         fn quote(&self, quote_params: &QuoteParams) -> Result<Quote>;

        /// Indicates which Swap has to be performed along with all the necessary account metas
        fn get_swap_and_account_metas(&self, swap_params: &SwapParams) -> Result<SwapAndAccountMetas>;

        /// Indicates if get_accounts_to_update might return a non constant vec
        fn has_dynamic_accounts(&self) -> bool {
            false
        }

        /// Indicates whether `update` needs to be called before `get_reserve_mints`
        fn requires_update_for_reserve_mints(&self) -> bool {
            false
        }

        // Indicates that whether ExactOut mode is supported
        fn supports_exact_out(&self) -> bool {
            false
        }

        fn get_user_setup(&self) -> Option<AmmUserSetup> {
            None
        }

        fn clone_amm(&self) -> Box<dyn Amm + Send + Sync>;

        /// It can only trade in one direction from its first mint to second mint, assuming it is a two mint AMM
        fn unidirectional(&self) -> bool {
            false
        }

        /// For testing purposes, provide a mapping of dependency programs to function
        fn program_dependencies(&self) -> Vec<(Pubkey, String)> {
            vec![]
        }

        fn get_accounts_len(&self) -> usize {
            32 // Default to a near whole legacy transaction to penalize no implementation
        }

        /// The identifier of the underlying liquidity
        ///
        /// Example:
        /// For RaydiumAmm uses Openbook market A this will return Some(A)
        /// For Openbook market A, it will also return Some(A)
        fn underlying_liquidities(&self) -> Option<HashSet<Pubkey>> {
            None
        }

        /// Provides a shortcut to establish if the AMM can be used for trading
        /// If the market is active at all
        fn is_active(&self) -> bool {
            true
        }
    }
    ```
 
 
 
 Market Listing 
 This section explains how markets are listed and maintained on Jupiter. It covers the different types of routing (instant and normal), the criteria for a market to be included in routing, and the liquidity requirements that must be met for a market to remain routable. Understanding these rules is essential for DEX teams to ensure their markets are eligible for and remain in the Jupiter Metis routing engine. 
 Routing Type 
 There are 2 types of market listing on Jupiter. 
 
 
 Instant routing 
 
 We automatically list all new markets that are created on specific DEXes (list is below). 
 These markets have a grace period, where the liquidity criteria is not applied. 
 After the grace period has passed, the liquidity criteria will apply (refer to normal routing). 
 For bonding curves, if it does not graduate after the grace period, it will be removed from routing.
 
 Only when the bonding curve has graduated to a new market, the graduated market will be added to routing. 
 
 
 
  
      
         List of DEXes that are eligible for Instant Routing
      
         - Meteora Dynamic Bonding Curve
         - Meteora Dynamic AMM
         - Meteora DAMM V2
         - Meteora DLMM
         - Raydium
         - Raydium CLMM
         - Raydium CPMM
         - Raydium Launchlab
         - Pump.fun AMM
         - Pump.fun
         - Fluxbeam
         - Whirlpool
         - Moonshot
         - Virtuals
         - Boop.fun
  
 
 
 Normal routing 
 
 This is the default for all markets. 
 Every 30 minutes, we will check the liquidity of the market. 
 If the liquidity is not enough, we will remove the market from routing. 
 
 
 
 Market Liquidity Requirements 
 The market must fit one of the following criteria for it to be routable: 
 
 
 Less than 30% price difference on $500 
 Using a benchmark position size of $500, a user should encounter less than 30% price difference after buying $500 worth and then selling back on the same market. 
 Price Difference = ($500 - Final USD value) / $500
If the price difference is more than 30%, it means that there is insufficient liquidity in the market for the benchmark position size of $500. 
 
 
 Less than 20% price impact on market 
 If the above (sell back $500 worth) fails, we will compare the price per token received from buying $1000 worth vs the price per token received from buying $500 worth to calculate price impact. 
 If the price impact is more than 20%, it means that the market is illiquid.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/600-routing/rfq-integration.md', 'sidebar_label: "Jupiter Z (RFQ)"
description: "Integrate your DEX into Jupiter."
title: "RFQ Integration" 

     RFQ Integration 
     

 This section will cover the integration of your RFQ service into Jupiter''s routing system. 
 :::caution
The integration requirements are subjected to change and please provide suggestions or feedbacks on ways to improve the integration process.
::: 
 
 Integration Prerequisites 
 
 Host a service that adheres to our RFQ API schema 
 Provide a webhook for Jupiter to send quotes and swap transactions 
 Complete end-to-end integration tests 
 When ready, you will be onboarded to Edge before going live on production 
 
 :::note
Please reach out to us in  Discord  in the  Developer Support channel 
 
 If you are interested to participate in Jupiter Z 
 If you need any help or clarification regarding the integration. 
 To begin onboarding to Edge.
::: 
 
 Example Integration 
 To facilitate the integration, we provide an  integration SDK in this repository . 
 
 Sample server : Implements the webhook API in Rust. 
 API Schema : OpenAPI schema for the RFQ API. 
 Integration tests : Verify the implementation of the webhook. 
 Troubleshooting : Common issues that arise during integration. 
 
 
 RFQ API Schema 
 To facilitate the integration into Jupiter''s RFQ module, you will need to provide a webhook for us to register the quotation and swap endpoints with the corresponding request and response format. 
 Endpoint Method URL Description 
 Base URL - https://your-api-endpoint.com/jupiter/rfq Example URL that we will register into our API. 
 Quote POST https://your-api-endpoint.com/jupiter/rfq/quote Called to request quotes. 
 Swap POST https://your-api-endpoint.com/jupiter/rfq/swap Called to execute swaps. 
 Tokens GET https://your-api-endpoint.com/jupiter/rfq/tokens Called periodically to fetch supported tokens ( see the token section below ). 
 
 :::note API Key
If you require an API key to access your endpoints, please provide it to us during the registration process. The API Key will be passed to the webhook as a header  X-API-KEY .
::: 
 
 Response Codes 
 Market Makers should return appropriate HTTP status codes along with error messages. 
 Status Code Description 
 200 OK The request was successful, and the webhook will return a quote. 
 404 Not Found The webhook will not return a quote for this request (e.g. the pair or the size are not supported). 
 400 Bad Request The request sent to the webhook is malformed (e.g. missing an expected parameter). 
 401 Unauthorized Authorization failed. For example the  X-API-KEY  is missing or incorrect. 
 50x Server Errors The webhook is offline or unable to respond. If the status persist, the webhook will be temporarily suspended and will not receive requests. 
 
 :::note Timeouts
A webhook must adhere to the  fulfillment and response time requirements . When sending the quote request, the RFQ system includes the following headers: 
 Header Description 
 x-request-start The millisecond timestamp indicating when the request was sent. 
 x-request-timeout The millisecond timeout for the request (currently set to 250 ms). 
 ::: 
 
 Integration Notes 
 Order Engine 
 The RFQ functionality depends on the mainnet deployment of the  Order Engine Program  for order fulfillment. 
 
 Source Code : The program''s source is located in the  programs/order-engine  directory. 
 IDL : The Interface Definition Language (IDL) file is available  here . 
 
 
 Fulfillment Requirements 
 To ensure market makers stay competitive and responsive, we enforce a minimum benchmark for fulfillment and response times. 
 
 Fulfillment : Market makers are expected to comply and fulfill  95%  of the quotes provided within a 1-hour window. If this is not met, the market maker will be turned off. 
 Response Time : A webhook must respond within  250 ms  of receiving a quote request. If it fails to do so, the RFQ system will proceed with the available quotes at the time. 
 
 :::caution
To resume operations, we will need to manually re-enable your webhook, please reach out to us if this happens.
::: 
 
 Expiry 
 We enforce a fixed expiry timing flow for all quotes and transactions. This simplifies the integration by removing the need for market makers to specify custom expiry times in quote requests, providing consistent behavior across all quotes and transactions, and establishing clear timeout boundaries at different stages of the flow. 
 Breakdown of the expiry flow: 
 
 Total of 50 seconds : Transaction expiry time 
 1st 25 seconds : Reserved for the webhook to verify, sign, and send the transaction on-chain 
 2nd 25 seconds : Allocated for the user to accept the quote 
 
 :::note
The frontend automatically re-quotes every 5 seconds.
::: 
 :::caution
These expiry thresholds may be adjusted based on performance and feedback.
::: 
 
 Fees 
 Jupiter RFQ allows MMs a way to provide liquidity, adjust their quotes without being subject to the volatility of on-chain gas prices or chain health. RFQ fills are also much less CU intensive (< 10x) compared to AMM swaps, and can save gas in the long run on fills. Today, RFQ, when operating in Ultra mode, charges a dynamic fee that is selected based on factors like tokens and size. 
 Dynamic Fee 
 The dynamic fee amount is forwarded to webhooks in the quote request parameters and it is contained in the message that both taker and maker sign ( see the payload section below ). In manual mode, the fee is a flat 2pbs. 
 Fee Calculation 
 Webhooks do not need to account for fees when quoting, the fee is applied directly by the RFQ system during transaction building. 
 
 For example, for a quote of 1 SOL to 1,000 USDC with a fee of 100 bps 
 Only 990 USDC will be transferred out of the market maker account 
 While 10 USDC will be collected as a fee 
 
 :::note
The fee is not automatically transferred and will be accounted for asynchronously on a regular basis. 
 This is subject to change in the future.
::: 
 
 Non-standard payload 
 The transaction data includes, beside the instruction data for the order-engine, 3 additional bytes that are appended to the instruction data. These bytes are not processed by the program and are only information and to be consumed by an off-chain consumer. The first 2 bytes contains the fee amount in basis points (u16) and the third byte (u8) is a bit mask where the least significant bit indicates if the swap is exact-in (0) or exact-out (1). 
 
 Advertising Supported Tokens 
 In order to receive relevant quote requests, market makers need to advertise the tokens they support. This is done by providing a list of supported tokens in the response to the  /tokens  route. The response should be a JSON array of token addresses. The list of tokens is refreshed every 10 minutes. 
 FAQ 
 Does RFQ support native SOL? 
 Yes, native SOL is fully supported in the order-engine program for both the taker (user) and the maker. However, for now, we assume the maker will use WSOL (Wrapped SOL). 
 Do faster quotes receive priority? 
 No, the RFQ system dispatches the quote request to all registered webhooks simultaneously. All quotes received within the quote timeout are compared to select the best one. The selection prioritizes the quote value first (In the unlikely scenario where two quotes have identical values, the quote from the webhook with the faster response time will be actually prioritized). 
 Shall a webhook verify swap requests? 
 Yes, the RFQ system will verify the swap requests before forwarding them to the webhooks. However, webhooks are encouraged to verify the swap requests as well to ensure the integrity of the system. The checks that the RFQ system performs can be found in the  validate_similar_fill_sanitized_message  function. 
 Is there a penalty for not providing a quote (status code 404)? 
 No, there is no penalty. It is up to the webhook to decide whether to respond with a quote ( 200 OK ) or indicate that it cannot provide one ( 404 Not Found ). 
 For example, suppose a webhook provides quotes for USDC/SOL only within a range of 100 to 1000 USDC. If it receives a quote request for 10 USDC → SOL, it will respond with  404 Not Found , since the amount is outside its quoting range. 
 In another case, a webhook may only support one-way quotes (USDC → SOL) but not SOL → USDC. If it receives a request for SOL → USDC, it will also return  404 Not Found . 
 Is there a fee applied to stable-to-stable swaps? 
 No. Stable to stable swaps are exempt from fees.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/600-routing/README.md', 'sidebar_label: "About Routing"
description: "About Jupiter Routing"
title: "About Routing" 

     About Routing 
     
 
 :::note
If you are an exchange or market maker and want to participate in our routing system, please refer to our  DEX Integration  and  RFQ Integration  guides.
::: 
 Juno Liquidity Engine 
 Juno is Jupiter''s latest liquidity engine, it is built with the combined learnings from Metis and JupiterZ, with one single objective - to ensure the best possible execution price and success rate across all engines and liquidity sources. Juno employs a sophisticated self-learning mechanism to maintain high availability of competitive routes while automatically sidelining underperforming or potentially problematic quotes. Juno will be incrementally introducing new third-party liquidity sources and a continual effort to improve Metis and JupiterZ routing capabilities. 
 
 Multi-liquidity sources Integrates third-party liquidity sources and Jupiter''s proprietary routing engines to ensure best possible rates. Currently, Juno consists of Metis, JupiterZ, Hashflow, DFlow and more in the pipeline. 
 Self-learning Automatically detects and sidelines underperforming or problematic sources, while continuously learning to provide competitive quotes. 
 Continuous optimizations By integrating external liquidity sources directly, Juno creates a competitive environment that drives continuous improvement across all routing engines. This approach ensures users consistently receive optimal execution rates while providing valuable performance data to enhance both Metis and JupiterZ routing capabilities. 
 
 Juno is directly powering the Ultra Swap on Jupiter frontend (jup.ag) and is also accessible via  Ultra API : The Jupiter Ultra API is the  only  API you ever need to experience or build the best trading experience on Solana - Jupiter handles all the complexities such as RPCs, slippage, broadcast method and landing rates, all while accessing the best liquidity available through Juno. 
 Jupiter Metis Routing Engine 
 Since its inception in 2023, Jupiter''s proprietary DEX aggregation engine, Metis v1, has become a cornerstone of Solana blockchain''s DeFi ecosystem. Metis functions as a sophisticated aggregation layer for on-chain liquidity, with one single objective - to algorithmically determine the most efficient trade route for any given token pair, considering factors like price, slippage, and quoted-to-executed price across multiple DEXes and AMMs. This ensures users receive the best possible execution price available on-chain at the moment that they wish to trade. 
 As of 2025, we''ve deployed Metis v1.5 which has experimented with modified algorithms to enable more granular splits and allows for a larger set of tokens to act as intermediate tokens in a route. From our analysis so far, this translates to 4.6x less spread between quoted and executed price. This is a continued effort to experiment with better configurations and algorithms to improve Metis. 
 Read more about Metis''s history, learnings and future plans . 
 
 Overcoming SVM constraints Employs a sophisticated and efficient transaction construction to enable multi-hop-multi-split swaps. 
 Integrating diverse DEXes Utilizes a standardized interface to integrate with a wide range of DEXes, abstracting away the complexities of each individual DEX. 
 Optimizing for price and execution Ensuring the quoted price is as close as the actual price, while also ensuring the transaction is executed successfully. 
 Accessing markets immediately and safely Employs necessary infrastructure powered by a network of robust RPC nodes to include markets and checks their liquidity in real-time. 
 
 The engine integrates with most DEXes on Solana and is accessible via the Swap API. You can find a complete list of supported DEXes via the  /swap/v1/program-id-to-label  endpoint. 
 Metis v1 
 Metis v1''s impact extends far beyond simple facilitation of on-chain trades. It is the de-facto liquidity engine on Solana, playing an instrumental role in onboarding millions of users to the network and facilitating trillions of dollars in cumulative trading volume. Its stability and general-purpose design have made it a reliable foundation for countless developers and protocols building on Solana. 
 Currently, Metis v1 powers the  Swap API : A robust interface designed for developers and applications requiring programmatic access to Solana''s liquidity. It currently has tens of thousands of requests per second, with demonstrated capacity to handle peak loads reaching hundreds of thousands of requests per second. 
 Jupiter Z (RFQ) Routing Engine 
 Since its launch in 2024, Jupiter Z has emerged as a transformative addition to Jupiter''s routing capabilities. Jupiter Z functions as an RFQ (Request For Quote) system that connects users directly with market makers, enabling market makers to provide competitive quotes for top token pairs. This ensures users receive the best possible execution price available from both on-chain and off-chain liquidity at the moment they wish to trade. 
 
 Intent-based architecture Employs an intent-based system where users express their desired trade and market makers compete to fulfill it. 
 Integrating diverse market makers Utilizes a standardized interface to integrate with multiple market makers, abstracting away the complexities of each liquidity provider. 
 Optimizing for price and execution Creates a competitive environment where market makers compete to provide the best quotes, while ensuring the transaction is executed successfully and efficiently. 
 Real-time quote aggregation Employs a versatile proxy to collect and compare quotes from multiple routing sources (such as Jupiter Metis v1 and Jupiter Z) in real-time. 
 Gasless transactions Enables users to execute trades without incurring transaction fees, providing a seamless and cost-effective trading experience. 
 
 Jupiter Z has been handling a large portion of trades on the Jupiter frontend (jup.ag) - which has demonstrated Jupiter Z''s reliability and effectiveness in providing competitive quotes and successful trade execution. 
 Currently, Jupiter Z is accessible through the  Ultra API : A streamlined interface that makes it simple for developers and applications to tap into Metis v1, Jupiter Z and other routing sources. 
 For more information about Jupiter Z, please refer to our  RFQ Integration  guide.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/sample.md', 'sidebar_label: "Welcome"
description: "Welcome to the Jupiter Documentation. Integrate APIs for swaps, payments, and more effortlessly. Explore robust tools now!"
hide_table_of_contents: true
title: Welcome to Jupiter Developer Documentation 

     Developer Documentation 
     

 import DocsLanding from ''@site/src/components/DocsLanding'';', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/3-api-setup.md', 'sidebar_label: "API Key Setup"
description: "Guide to setting up API Keys to access Jupiter APIs."
title: "API Key Setup" 

     API Setup 
     

 Get started by setting up an account on the dashboard to generate API Keys and managing payments via Helio. 
 :::note API Usage
Refer to  API Rate Limit  for more detailed information. 
 API Tier Rate Limit Model API Key Base URL 
 Lite Fixed (Free Tier) No https://lite-api.jup.ag/** 
 Pro Fixed (Tiered) Yes https://api.jup.ag/** 
 Ultra Dynamic Yes https://api.jup.ag/ultra/** 
 
 headers: {
    ''Content-Type'': ''application/json'',
    ''x-api-key'': '''' // enter api key here
},
 
 ::: 
 Overview 
 
 Open Portal at https://portal.jup.ag/ 
 Browse and select plan 
 Connect via email 
 Pay via Helio (Payment is currently done on per month basis) 
 Setup API Keys 
 
 Types of Plans 
 :::note
You can always change your plans later. 
 You can upgrade/downgrade your Pro plans on the UI any time.
::: 
 Depending on your needs, you can choose from the following plans: 
 Plan Rate Limit Model Why choose this plan 
 Lite Free Tier You are just starting out and want to test the Jupiter APIs. 
 Pro Fixed Tiered Rate Limits Both small projects or large enterprises can utilize this with the tiered rate limits. Rate limits range from 1 RPS to 500 RPS plans. 
 Ultra Dynamic Rate Limits based on executed swap volume Using Ultra API comes with many benefits  where Jupiter will handle slippage, transaction sending, and more without the need of an RPC from you. With that, the Ultra API is governed by a Dynamic Rate Limit model that will scale with your swap executions. 
 
 Payment 
 :::note
Refer to  Payment Method  for more details.
::: 
 :::info Plan Renewal
The payment is currently done on a monthly basis, which means you will need to manually renew each month. 
 
 7 days before the plan expires, you will see the state change in the dashboard''s table and receive an automated email as a reminder to renew. 
 Upon expiry, your key will remain valid for a grace period but will be disabled (but not deleted) when it ends. 
 The plan will be renewed to the same plan as the previous. 
 If you have any issues with the payment,  please open a ticket .
::: 
 
 The current payment method we support is via Helio. 
 
 Only Pro plans require payments. 
 The payment is currently done on a monthly basis. 
 The payment is done in Solana USDC only.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/3-get-balances.md', 'sidebar_label: "Get Balances (Deprecated)"
description: "Request for token balances of an account."
title: "Get Balances (Deprecated)" 

     Get Balances (Deprecated) 
     

 :::warning
This Ultra endpoint is not maintained in favour of the  Get Holdings  endpoint, please use that instead.
::: 
 Get Balances (Deprecated) 
 The Ultra API supports a simple endpoint to get the token balances of an account, you just need to pass in the required parameter of the user''s wallet address. 
 const balancesResponse = await (
  await fetch(`https://lite-api.jup.ag/ultra/v1/balances/3X2LFoTQecbpqCR7G5tL1kczqBKurjKPHhKSZrJ4wgWc`)
).json();

console.log(JSON.stringify(balancesResponse, null, 2));
 
 Balances Response 
 The balances response will return a list of token balances for the user''s wallet address. 
 Successful example response: 
 {
  "SOL": {
    "amount": "0",
    "uiAmount": 0,
    "slot": 324307186,
    "isFrozen": false
  }
}
 
 Failed example response: 
 {
  "error": "Invalid address"
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/3-get-holdings.md', 'sidebar_label: "Get Holdings"
description: "Request for detailed token holdings of an account including token account information"
title: "Get Holdings" 

     Get Holdings 
     

 :::note
Lite URL:  https://lite-api.jup.ag/ultra/v1/holdings 
Dynamic URL:  https://api.jup.ag/ultra/v1/holdings 
 Dynamic Rate Limits are now applied to Ultra API. 
 
 No Pro plans or payment needed. 
 Simply generate the universal API Key via  Portal 
 Rate limits scale together with your swap volume. 
 
 Read more about Ultra API Dynamic Rate Limit .
::: 
 :::tip API Reference
To fully utilize the Ultra API, check out the  Ultra API Reference .
::: 
 Get Holdings 
 The Ultra API supports a simple endpoint to get the detailed token holdings of an account, you just need to pass in the required parameter of the user''s wallet address. 
 const holdingsResponse = await (
  await fetch(`https://lite-api.jup.ag/ultra/v1/holdings/3X2LFoTQecbpqCR7G5tL1kczqBKurjKPHhKSZrJ4wgWc`)
).json();

console.log(JSON.stringify(holdingsResponse, null, 2));
 
 Holdings Response 
 The holdings response will return the following: 
 
 A list of token holdings for the user''s wallet address. 
 Token account information for each token holding. 
 Note that the top level response outside of  tokens  is the native SOL balance. 
 
 :::tip
For tokens with more than thousands of token holdings, the response may be slow - depending on the number of token holdings, the response time may vary. 
 If you only need the native SOL balance, you can use  /holdings/{address}/native  to get the native SOL balance.
::: 
 Successful example response: 
 {
    "amount": "1000000000",
    "uiAmount": 1,
    "uiAmountString": "1",
    "tokens": {
        "jupSoLaHXQiZZTSfEWMTRRgpnyFm8f6sZdosWBjx93v": [
            {
                "account": "tokenaccountaddress",
                "amount": "1000000000",
                "uiAmount": 1,
                "uiAmountString": "1",
                "isFrozen": false,
                "isAssociatedTokenAccount": true,
                "decimals": 9,
                "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
            }
        ]
    }
}
 
 Failed example response: 
 {
  "error": "Invalid address"
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/1-get-order.md', 'sidebar_label: "Get Order"
description: "Start using Jupiter Ultra API by getting a swap order."
title: "Get Order" 

     Get Order 
     

 :::note
Lite URL:  https://lite-api.jup.ag/ultra/v1/order 
Dynamic URL:  https://api.jup.ag/ultra/v1/order 
 Dynamic Rate Limits are now applied to Ultra API. 
 
 No Pro plans or payment needed. 
 Simply generate the universal API Key via  Portal 
 Rate limits scale together with your swap volume. 
 
 Read more about Ultra API Dynamic Rate Limit .
::: 
 :::tip API Reference
To fully utilize the Ultra API, check out the  Ultra API Reference .
::: 
 Get Order 
 To get a swap order, you need to pass in the required parameters such as: 
 
 inputMint : The input token mint address 
 outputMint : The output token mint address 
 amount : The amount of input token to swap 
 taker : The user''s wallet address
 
 Note: If the  taker  is not provided, there will still be an Order Response with no  transaction  field. 
 
 
 referralAccount : The referral account address - refer to the  Add Fees To Ultra  guide for the step by step process. 
 referralFee : The referral fee in basis points (bps) 
 
 const orderResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/ultra/v1/order?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000000&taker=jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3''
    )
  ).json();

console.log(JSON.stringify(orderResponse, null, 2));
 
 Order Response 
 In the order response, you will receive a number of fields that are important to note of, such as the  swapType ,  slippageBps , etc. 
 The main fields you should need: 
 
 transaction : The base64 encoded transaction that you need to sign before submitting to the network. 
 requestId : The request ID of the order to be used in the  Execute Order  endpoint. 
 
 Now, you are able to get a swap order, next steps is to make a post request to the  Execute Order  endpoint.  Let''s go ! 
 Example response of Aggregator Swap: 
 {
  "mode": "ultra",
  "swapType": "aggregator",
  "router": "metis",
  "requestId": "5421e18f-9d12-4709-8f5a-6c79c1032203",
  "inAmount": "1000000",
  "outAmount": "6652914",
  "otherAmountThreshold": "6644643",
  "swapMode": "ExactIn",
  "slippageBps": 15,
  "priceImpactPct": "0",
  "routePlan": [
    {
      "swapInfo": {
        "ammKey": "4bg8UDLXEm4T6pCyoW7iUizAz9HMoxhTAtMquSXigFZu",
        "label": "Meteora DLMM",
        "inputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        "outputMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
        "inAmount": "90000",
        "outAmount": "89991",
        "feeAmount": "9",
        "feeMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
      },
      "percent": 9,
      "bps": 900
    },
    {
      "swapInfo": {
        "ammKey": "5M7McNWX7yBBGrZGB6XhmHYhFwWwwB2ckrA1HEpkf3SA",
        "label": "Perena",
        "inputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        "outputMint": "2u1tszSeqZ3qBWF3uNGPFc8TzMk2tdiwknnRMWGWjGWH",
        "inAmount": "50000",
        "outAmount": "50007",
        "feeAmount": "5",
        "feeMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
      },
      "percent": 5,
      "bps": 500
    },
    {
      "swapInfo": {
        "ammKey": "6dB49iS94RnwUhQwJwjnE7mEqPedZDtU7XBZXaLBbfbt",
        "label": "Stabble Stable Swap",
        "inputMint": "2u1tszSeqZ3qBWF3uNGPFc8TzMk2tdiwknnRMWGWjGWH",
        "outputMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
        "inAmount": "50007",
        "outAmount": "49995",
        "feeAmount": "0",
        "feeMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
      },
      "percent": 100,
      "bps": 10000
    },
    {
      "swapInfo": {
        "ammKey": "BWBHrYqfcjAh5dSiRwzPnY4656cApXVXmkeDmAfwBKQG",
        "label": "Obric V2",
        "inputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        "outputMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
        "inAmount": "860000",
        "outAmount": "859910",
        "feeAmount": "6",
        "feeMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"
      },
      "percent": 86,
      "bps": 8600
    },
    {
      "swapInfo": {
        "ammKey": "D94tFiBfJzdZmcH6GtV39iXexWyVpNfwEH3CxEbqvsvr",
        "label": "Obric V2",
        "inputMint": "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
        "outputMint": "So11111111111111111111111111111111111111112",
        "inAmount": "999896",
        "outAmount": "6654624",
        "feeAmount": "343",
        "feeMint": "So11111111111111111111111111111111111111112"
      },
      "percent": 100,
      "bps": 10000
    }
  ],
  "inputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  "outputMint": "So11111111111111111111111111111111111111112",
  "feeMint": "So11111111111111111111111111111111111111112",
  "feeBps": 2,
  "taker": "5dMXLJ8GYQxcHe2fjpttVkEpRrxcajRXZqJHCiCbWS4H",
  "gasless": false,
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAFCkS+3LuGTbsYdcCPVuxlVEcq9wNOnR9+PBw6SEM3ACeKd1R4MYi595YUO8ViNwpWb17+Q9DxkVcz5fWpSqjtDyi/by2TOVyTUuu9HYAIH+8AvsAiyyBVh4I4Fsd9iyTJyeC0vJINbsjyglaB0IKJCaka7Xs7bD5H1KusZLVDh/7A+PTko52VL0CIM2xtl0WkvNslD6Wawxr7yd9HYllN4LxSYdFKrMW8DuxjXahwWh9wo57jWprPC/jyLMbOSQGdegMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAA50rZbONln9MTUQAoS/d4BFuFEKjzTkmMki7ub8MF+GkEedVb8jHAbu50xW7OaBUH/bGy3qP0jlECsc2iVrwTjwbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpPSwt5ThewuTEP350DNuqyKwGVEa4lpMRw26ckG/cO10EBgAFApE/CQAGAAkDSbc4AAAAAAAIVwkkAAEOEAIPJg0IIwguGi4bHg4EDzEcLiQJCS0uHRkIMyAPHw4DISIyJAknKyQfMQMEFBMREikqKCwJJy8LBwUMCg4EFhYWJAkvFQcFGBcQBBYWMCQJJTjBIJszQdacgQAFAAAAJgkABEcAAQUAAk9kAgQ6AVYABDoAZAQFQEIPAAAAAABthWUAAAAAAA8AAgkDAgAAAQkGFvHsWcITjSSy666/XikzqLiO11a0SwY8rT5d3C+q84sDvr+7ACm/lQcqT78E33F1k+c4vMwhJygVwkcagNn59VWw1IQlBBopKBgFAAMBFxV9wMcXAhzLZucTPtF6MmZ80NPWq9GD13dumGAXjalsagR49HT7BfFveXXzwVdRxcH4wwx5hrqgGgkua/Gonv4pzAZz/LU35B3ySlkEeHl2dwQsLXV6xTf8OXe5zg55RN15dUirCc2NlTbGZ63YLmpuzcw8rqYGaGqFaW1mAWfiYdGuN3McD0TMhBYpTLog607/NBju6DG/v6eBEjRZCQSVk5fMApSW",
  "prioritizationFeeLamports": 2252824,
  "inUsdValue": 0.999901896351375,
  "outUsdValue": 1.0004190022848067,
  "priceImpact": 0.05171566683877625,
  "swapUsdValue": 0.999901896351375,
  "totalTime": 735
}
 
 Example response of RFQ Swap: 
 {
  "mode": "ultra",
  "inputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  "outputMint": "So11111111111111111111111111111111111111112",
  "inAmount": "1000000",
  "outAmount": "6643102",
  "otherAmountThreshold": "6643102",
  "swapMode": "ExactIn",
  "slippageBps": 0,
  "priceImpactPct": "0",
  "routePlan": [
    {
      "swapInfo": {
        "ammKey": "CifhTfrKeMfSpTRLjJnXLXEALS37dKH3ziC8gjTLe5dD",
        "label": "JupiterZ",
        "inputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        "outputMint": "So11111111111111111111111111111111111111112",
        "inAmount": "1000000",
        "outAmount": "6643102",
        "feeAmount": "0",
        "feeMint": "11111111111111111111111111111111"
      },
      "percent": 100
    }
  ],
  "feeBps": 2,
  "transaction": "AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAIABgyuHR/2vkxfzU7FGy7oIwST/eu3qKGcgDNLQXNZqjhf/ES+3LuGTbsYdcCPVuxlVEcq9wNOnR9+PBw6SEM3ACeKLG4Kt0ZV/x7L9RaG1rdUmMMOr+NV9iN2t63tTwAhJqt3VHgxiLn3lhQ7xWI3ClZvXv5D0PGRVzPl9alKqO0PKK8uUfxZ6umAKD8aFHv43B/XRa4GxCNft1fWnLOBGKhCvT1zZhVaaLZKp6kLnLekwgoP5noPGw80QSK/+q5KDAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAABpuIV/6rgYT7aH9jRhjANdrEOdwa6ztVmKDwAAAAAAEG3fbh12Whk9nL4UbO63msHLSF7V9bN5E6jPWFfv8AqUpYSftyo7vpH9xbDmpX9jxaHLRbIGem7Qys02OVyKECxvp6877brTo9ZfNqq8l0MbG75MLS9uDkfKYCA0UvXWFUzz6zfmKnWYJxn4RVu8Gf4g/6x2CmlkWSbSUO82C+2wMHAAkDiQQAAAAAAAAHAAUCMa0AAAoMAQADAgoECwkICQYFI6hgt6NcCiigQEIPAAAAAACeXWUAAAAAAELqbGgAAAAAAgAAAA==",
  "gasless": true,
  "prioritizationFeeLamports": 0,
  "requestId": "9e39b39a-4e6d-2c03-3a4e-df0564d98531",
  "swapType": "rfq",
  "router": "jupiterz",
  "quoteId": "b8f818b8-4651-5d3b-ba57-1f921c6b0f62",
  "maker": "CifhTfrKeMfSpTRLjJnXLXEALS37dKH3ziC8gjTLe5dD",
  "taker": "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
  "expireAt": "1751968322",
  "platformFee": {
    "amount": "1328",
    "feeBps": 2
  },
  "inUsdValue": 0.999901896351375,
  "outUsdValue": 0.9993827964401991,
  "priceImpact": -0.05191508417676995,
  "swapUsdValue": 0.999901896351375,
  "totalTime": 721
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/4-get-shield.md', 'sidebar_label: "Get Shield"
description: "Request for token information and warnings of mints."
title: "Get Shield" 

     Get Shield 
     

 :::note
Lite URL:  https://lite-api.jup.ag/ultra/v1/shield 
Dynamic URL:  https://api.jup.ag/ultra/v1/shield 
 Dynamic Rate Limits are now applied to Ultra API. 
 
 No Pro plans or payment needed. 
 Simply generate the universal API Key via  Portal 
 Rate limits scale together with your swap volume. 
 
 Read more about Ultra API Dynamic Rate Limit .
::: 
 :::tip API Reference
To fully utilize the Ultra API, check out the  Ultra API Reference .
::: 
 Get Shield 
 The Ultra API provides an endpoint to retrieve token information and associated warnings for the specified mint addresses. To use this endpoint, provide one or more mint addresses for the required query parameter named mints. 
 This is useful when integrating with Jupiter Ultra or any other APIs, allowing you or your user to be informed of any potential malicious mints before conducting your transaction. 
 const shieldResponse = await (
  await fetch(`https://lite-api.jup.ag/ultra/v1/shield?mints=So11111111111111111111111111111111111111112,EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v,someTokenAddressForEducationalPurposes`)
).json();
 
 Shield Response 
 The shield response will return a list of objects, containing the token information and warnings of the mints passed in. 
 Do note that this is subject to changes, and we will be adding more warnings and improving the accuracy of the warnings over time. 
 For the full list of potential warnings, refer to the  Shield API Reference . 
 Successful example response: 
 {
  "warnings": {
    "someTokenAddressForEducationalPurposes": [
      {
        "type": "NOT_VERIFIED",
        "message": "This token is not verified, make sure the mint address is correct before trading",
        "severity": "info"
      },
      {
        "type": "LOW_ORGANIC_ACTIVITY",
        "message": "This token has low organic activity",
        "severity": "info"
      },
      {
        "type": "NEW_LISTING",
        "message": "This token is newly listed",
        "severity": "info"
      }
    ],
    "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v": [
      {
        "type": "HAS_FREEZE_AUTHORITY",
        "message": "The authority''s owner has the ability to freeze your token account, preventing you from further trading",
        "severity": "warning"
      },
      {
        "type": "HAS_MINT_AUTHORITY",
        "message": "The authority''s owner has the ability to mint more tokens",
        "severity": "info"
      }
    ],
    "So11111111111111111111111111111111111111112": []
  }
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/README.md', 'sidebar_label: "About Ultra API"
description: "Start using Jupiter Ultra API to swap with the best experience."
title: "About Ultra API" 

     Ultra API 
     

 The Jupiter Ultra API is the  only  API you ever need to experience or build the best trading experience on Solana. 
 Features 
 Ultra API is a holistic solution for developers to build all types of applications, without having to worry about the complexities of the underlying infrastructure: 
 Feature Description 
 Best Trading Experience Ultra is the best trading experience in crypto, it handles all the complexities and headaches such as slippage protection, transaction landing and more. 
 RPC-less You do not need to provide a RPC endpoint to send transactions, get token information, or get user balances - we handle everything for you. 
 Holistic Coverage Ultra API covers all the necessary features for you to build your application, including the features mentioned below and useful information such as user wallet balances, token information, and more. 
 Integrator Fees Ultra API allows you to add custom integrator fees to your transactions, on top of Jupiter''s fees. Refer to the  Add Fees To Ultra  guide for more information. 
 Developer Support Get the  best developer support in our Discord , the DevRel Working Group is here to help you with any issues you may face when using Ultra API. 
 World Class Support Ultra is the best trading experience in crypto, it handles all the complexities such as slippage protection and transaction landing, and if you ever face any issues or need help when using Ultra, our support team is here to assist you 24/7. Read more about  Ultra customer support . 
 
 Juno Liquidity Engine 
 Ultra utilizes the latest  Juno Liquidity Engine  which aggregates across multiple liquidity sources, including Jupiter''s proprietary routing engines both Metis and Jupiter Z (RFQ), and third-party liquidity sources, for the best possible price. It also includes self-learning capabilities (to detect and sideline low-quality liquidity sources) which creates a competitive environment for all liquidity sources to continously optimize their performance and price. 
 Transaction Sending 
 Over the years of experiment and development, we have optimized and continues to better our transaction sending service. Using various strategies involving multiple RPCs, priority fees/Jito tips estimation, and more, we are able to send transactions at a blazing fast speed with a high success rate (while still being  MEV-protected ). 
 :::info
95% of all swaps are executed under 2 seconds via our proprietary transaction sending engine. 
 For more information on latencies,  refer to the latency section .
::: 
 MEV Protection 
 According to both our internal monitoring system and external resources such as  Sandwiched.me , Ultra has the lowest incidence of MEV attacks across all existing applications, by far. Comparing using the ratio of volume to the amount of value extracted, Ultra has the highest volume yet the lowest value extracted. 
 Real Time Slippage Estimator 
 Building on top of our previous versions of slippage estimation/optimization engines, we have developed a new Real Time Slippage Estimator (RTSE), that is able to intelligently estimate the best possible slippage to use at the time of execution, balancing between trade success and price protection. RTSE uses a variety of heuristics, algorithms and monitoring to ensure the best user experience: 
 
 Heuristics : Token categories, historical and real-time slippage data, and more. 
 Algorithms : Exponential Moving Average (EMA) on slippage data, and more. 
 Monitoring : Real-time monitoring of failure rates to ensure reactiveness to increase slippage when necessary. 
 
 :::info RTSE vs Dynamic Slippage 
 API Ultra API Swap API 
 Types Real Time Slippage Estimator (RTSE) Dynamic Slippage 
 Description Comprehensive data, heuristics and algorithms, and real-time reactiveness to increase slippage when necessary. Only uses transaction simulations, though shares token categories heuristics. (Do note that we have discontinued development on Dynamic Slippage.) 
 ::: 
 
 Gasless 
 Ultra provides different gasless mechanisms for different scenarios. 
 
 Gasless via Jupiter Z (RFQ) : All swaps routed via Jupiter Z are gasless, as the market maker is the fee payer for the transaction. 
 Gasless via Gasless Support : Depending on the tokens and trade sizes of your swap, Ultra will automatically determine if it can provide gasless support to your swap by helping you pay for the transaction fee of your swap - you can identify this via the secondary signer in the transaction. 
 
 Latency 
 95% of all swaps are executed under 2 seconds via our proprietary transaction sending engine. 
 Endpoint Description Latency (P90 Average) 
 /order Aggregating across multiple liquidity sources and selecting the best price. 500ms 
 /execute Broadcasting the transaction to the network and polling for the status and result of the transaction. Metis: 1.5s JupiterZ: 5s 
 /balances Retrieving the user''s balances. 200ms 
 /shield Enhanced token security feature to provide critical token information. 400ms 
 
 
 What About Swap API? 
 Ultra API is the spiritual successor to Swap API, and is much simpler to use than Swap API. If you are first starting out on your Solana development journey, using Ultra API is highly recommended over Swap API. 
 However, unlike Ultra API, Swap API allows developers to: 
 
 Add custom instructions. 
 Add Cross Program Invocation (CPI) calls. 
 Choose the broadcasting strategy for the signed transaction (ie. via priority fee, Jito, etc.). 
 Choose which DEXes or AMMs to route through. 
 Modify the number of accounts to use in a transaction. 
 
 If you have a highly custom need like what is described above, then Swap API may be for you. However, with Swap API, there are many more things you need to worry about that Ultra API automatically handles for: 
 
 Upkeep of RPCs : To retrieve wallet balances, broadcast and retrieve transactions, etc. 
 Deciding transaction fee : Including, but not limited to, priority fee, Jito fee, etc. 
 Deciding slippage : The optimal slippage to use to balance between trade success and price protection. 
 Broadcasting the transaction : Ultra uses a proprietary transaction sending engine which dramatically improves landing rate and speed. 
 Parsing the swap results : Polling and parsing the resulting transaction from the RPC, including handling for success and error cases. 
 
 If the above sounds like too much work, then Ultra API will be the better choice. 
 Getting Started with Ultra API 
 
 Get Order : Request for a swap transaction then sign it. 
 Execute Order : Execute the swap transaction and get the execution status. 
 
 
 Get Balances : Additionally, you can request for token balances of an account from  /ultra/v1/balances . 
 Get Shield : Enhanced security feature via Shield API to provide critical token information, to help provide an informed trading decision. 
 
 Other Guides 
 
 Add Fees To Ultra : Add custom integrator fees to your Ultra transaction, on top of Jupiter''s fees. 
 
 FAQ 
 Can I add custom integrator fees to Ultra API? 
 
 Integrator without custom fees : Do note that when your users swap using Ultra, we take 0.1% (or 0.05% depending on the tokens) of the swap amount as a fee. 
 Integrator with custom fees : If you are an integrator, you can add custom integrator fees via Ultra API and Jupiter will take 20% of the integrator fees. Please refer to the  Add Fees To Ultra  guide for more information. 
 
 What is the rate limit for Ultra API? 
 
 Dynamic Rate Limits are now applied to Ultra API.
 
 No Pro plans or payment needed. 
 Simply generate the universal API Key via  Portal 
 Rate limits scale together with your swap volume. 
 Read more about Ultra API Dynamic Rate Limit .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/6-search-token.md', 'sidebar_label: "Search Token"
description: "Search tokens and their information by mint, name or symbol."
title: "Search Token" 

     Search Token 
     

 :::note
Lite URL:  https://lite-api.jup.ag/ultra/v1/search 
Dynamic URL:  https://api.jup.ag/ultra/v1/search 
 Dynamic Rate Limits are now applied to Ultra API. 
 
 No Pro plans or payment needed. 
 Simply generate the universal API Key via  Portal 
 Rate limits scale together with your swap volume. 
 
 Read more about Ultra API Dynamic Rate Limit .
::: 
 :::tip API Reference
To fully utilize the Ultra API, check out the  Ultra API Reference .
::: 
 Search Token 
 The Ultra API provides an endpoint to search tokens in the background for you and returns you the search results, along with the mint information. 
 This is useful in most user applications, as users need to choose which tokens they want to swap. This also provides a seamless developer experience as integrating this allows us to handle and abstract the token search mechanism, allowing you to focus on other user features. 
 :::tip Search 
 
 Search for a token and its information by its  symbol, name or mint address . 
 Comma-separate to search for multiple. 
 Limit to 100 mint addresses in query. 
 Default to 20 mints in response when searching via symbol or name.
::: 
 
 const searchResponse = await (
  await fetch(`https://lite-api.jup.ag/ultra/v1/search?query=So11111111111111111111111111111111111111112`)
).json();
 
 Search Response 
 The search response will return an array of mints, along with their information. 
 :::tip Useful Mint Information 
 
 Token Metadata like name, symbol, icon to display token information to users 
 Organic Score , Holder count, Market cap, etc can be useful to help make a better trading decision 
 And much more! 
 
 Do note that the response is subject to changes as we continue to improve. 
 Refer to  Ultra API Reference  for full schema.
::: 
 Successful example response: 
 [
  {
    id: ''So11111111111111111111111111111111111111112'',
    name: ''Wrapped SOL'',
    symbol: ''SOL'',
    icon: ''https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png'',
    decimals: 9,
    circSupply: 531207433.3986673,
    totalSupply: 603724547.3627878,
    tokenProgram: ''TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'',
    firstPool: {
      id: ''58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2'',
      createdAt: ''2021-03-29T10:05:48Z''
    },
    holderCount: 2342610,
    audit: {
      mintAuthorityDisabled: true,
      freezeAuthorityDisabled: true,
      topHoldersPercentage: 1.2422471238911812
    },
    organicScore: 98.92390784896082,
    organicScoreLabel: ''high'',
    isVerified: true,
    cexes: [
      ''Binance'', ''Bybit'',
      ''OKX'',     ''Upbit'',
      ''Bitget'',  ''Kraken'',
      ''KuCoin'',  ''MEXC'',
      ''Gate.io''
    ],
    tags: [ ''community'', ''strict'', ''verified'' ],
    fdv: 87824499429.22047,
    mcap: 77275352037.79674,
    usdPrice: 145.47114211747515,
    priceBlockId: 349038717,
    liquidity: 89970631.83880953,
    stats5m: {
      priceChange: 0.021175445311831707,
      liquidityChange: -0.01230267453174984,
      volumeChange: 4.855149318222242,
      buyVolume: 14644327.188370818,
      sellVolume: 14743625.023908526,
      buyOrganicVolume: 269570.2345543641,
      sellOrganicVolume: 204114.37436445671,
      numBuys: 49281,
      numSells: 54483,
      numTraders: 18155,
      numOrganicBuyers: 981,
      numNetBuyers: 3503
    },
    stats1h: {
      priceChange: -0.145099593531635,
      liquidityChange: -0.13450589635262783,
      volumeChange: -15.928930753985316,
      buyVolume: 171520842.22567528,
      sellVolume: 174057197.5207193,
      buyOrganicVolume: 3099405.8562825476,
      sellOrganicVolume: 2975660.0383528043,
      numBuys: 586069,
      numSells: 649275,
      numTraders: 78145,
      numOrganicBuyers: 2716,
      numNetBuyers: 14442
    },
    stats6h: {
      priceChange: 0.3790495974473589,
      liquidityChange: 0.1659230330014905,
      volumeChange: 14.571340846647542,
      buyVolume: 1084625651.9256022,
      sellVolume: 1094488293.656417,
      buyOrganicVolume: 31145072.655369382,
      sellOrganicVolume: 31647431.25353508,
      numBuys: 3789847,
      numSells: 4363909,
      numTraders: 272131,
      numOrganicBuyers: 10849,
      numNetBuyers: 37155
    },
    stats24h: {
      priceChange: 1.5076363979360274,
      liquidityChange: 2.417364079880319,
      volumeChange: -2.1516094834673254,
      buyVolume: 4273248565.256824,
      sellVolume: 4306065610.69747,
      buyOrganicVolume: 109007133.8196669,
      sellOrganicVolume: 118085567.17983335,
      numBuys: 15125444,
      numSells: 17582713,
      numTraders: 754618,
      numOrganicBuyers: 28590,
      numNetBuyers: 80961
    },
    ctLikes: 4232,
    smartCtLikes: 522,
    updatedAt: ''2025-06-25T05:02:21.034234634Z''
  }
]', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/2-execute-order.md', 'sidebar_label: "Execute Order"
description: "Start using Jupiter Ultra API by executing a swap order and getting the execution status."
title: "Execute Order" 

     Execute Order 
     

 :::note
Lite URL:  https://lite-api.jup.ag/ultra/v1/execute 
Dynamic URL:  https://api.jup.ag/ultra/v1/execute 
 Dynamic Rate Limits are now applied to Ultra API. 
 
 No Pro plans or payment needed. 
 Simply generate the universal API Key via  Portal 
 Rate limits scale together with your swap volume. 
 
 Read more about Ultra API Dynamic Rate Limit .
::: 
 :::tip API Reference
To fully utilize the Ultra API, check out the  Ultra API Reference .
::: 
 Sign Transaction 
 Using the Solana  web3.js   v1  library, you can sign the transaction as follows: 
 
   
    Set up imports and wallet for signing
   
 npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2
npm install bs58
npm install dotenv # if required for wallet setup
 
 :::note 
 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 If you want to store your private key in the project directly, you can do it via a  .env  file.
::: 
 
 To set up a development wallet via  .env  file, you can use the following script. 
 // index.js
import { Keypair } from ''@solana/web3.js'';
import dotenv from ''dotenv'';
require(''dotenv'').config();

const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ''''));
 
 # .env
PRIVATE_KEY=""
 
 To set up a development wallet via a wallet generated via  Solana CLI , you can use the following script. 
 import { Keypair } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/To/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
 
 
 // ... GET /order''s response

// Extract the transaction from the order response
const transactionBase64 = orderResponse.transaction

// Deserialize the transaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));

// Sign the transaction
transaction.sign([wallet]);

// Serialize the transaction to base64 format
const signedTransaction = Buffer.from(transaction.serialize()).toString(''base64'');
 
 Execute Order 
 By making a post request to the  /execute  endpoint, Jupiter executes the swap transaction on behalf of you/your users. This includes handling of slippage, priority fees, transaction landing and more. 
 To make a post request to execute a swap order, you need to pass in the required parameters: 
 
 signedTransaction : The signed transaction 
 requestId : The order response''s request ID 
 
 :::info  /execute  parameters
Both required parameters are found in the  order response , do note that the  transaction  field is the base64 encoded transaction that  you need to sign  before submitting to the network.
::: 
 const executeResponse = await (
    await fetch(''https://lite-api.jup.ag/ultra/v1/execute'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            signedTransaction: signedTransaction,
            requestId: orderResponse.requestId,
        }),
    })
).json();
 
 Execute Response 
 After making the post request to the  /execute  endpoint, you will receive a response with the status of the swap. 
 if (executeResponse.status === "Success") {
    console.log(''Swap successful:'', JSON.stringify(executeResponse, null, 2));
    console.log(`https://solscan.io/tx/${executeResponse.signature}`);
} else {
    console.error(''Swap failed:'', JSON.stringify(executeResponse, null, 2));
    console.log(`https://solscan.io/tx/${executeResponse.signature}`);
}
 
 Example response of successful swap: 
 {
  "status": "Success",
  "signature": "transaction signature",
  "slot": "323598314",
  "code": 0,
  "inputAmountResult": "9995000",
  "outputAmountResult": "1274698",
  "swapEvents": [
    {
      "inputMint": "So11111111111111111111111111111111111111112",
      "inputAmount": "9995000",
      "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "outputAmount": "1274698"
    }
  ]
}
 
 Example response of failed swap: 
 {
  "status": "Failed",
  "signature": "transaction signature",
  "error": "custom program error: #6023",
  "code": 4615026,
  "slot": "323597963"
}
 
 Response Codes 
 The following is a list of error codes that can be returned by the  /execute  endpoint. 
 Ultra Endpoint Codes 
 Code Description Debugging 
 0 Success - 
 -1 Missing cached order requestId  not found in cache, likely expired or not found 
 -2 Invalid signed transaction signedTransaction  is invalid, likely failed to sign the transaction correctly 
 -3 Invalid message bytes signedTransaction  is invalid, likely due to incorrect usage of  transaction  field in the order response 
 
 Aggregator Swap Type Codes 
 Code Description Debugging 
 -1000 Failed to land Transaction failed to land on the network 
 -1001 Unknown error - 
 -1002 Invalid transaction - 
 -1003 Transaction not fully signed - 
 -1004 Invalid block height - 
 
 RFQ Swap Type Codes 
 Code Description Debugging 
 -2000 Failed to land - 
 -2001 Unknown error - 
 -2002 Invalid payload - 
 -2003 Quote expired User did not respond in time or RFQ provider did not execute in time 
 -2004 Swap rejected User or RFQ provider rejected the swap', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/101-ultra-api/5-add-fees-to-ultra.md', 'sidebar_label: "Add Fees To Ultra"
description: "Jupiter Ultra API allows you to add fees."
title: "Add Fees To Ultra" 

     Add Fees To Ultra 
     

 In this guide, we will be walking through the steps to create the necessary accounts for adding fees to your Ultra transaction. 
 Important Notes 
 Note Description 
 Referral Dashboard UI Use the  Referral Dashboard  to create referral accounts through a user-friendly interface. This is the recommended approach for most users before proceeding with the SDK setup below. 
 Additional required accounts It is required to have a valid  referral account  and  referral token accounts  for the specific token mints. These accounts are initalized with the Referral Program under the  "Jupiter Ultra" Referral Project . 
 Fee mint In the  /order  response, you will see the  feeMint  field which is the token mint we will collect the fees in for that particular order. Since Jupiter will always dictate which token mint to collect the fees in, you must ensure that you have the valid referral token account created for the specific fee mint. If it is not initialized, the order will still return and can be executed without your fees. This is to ensure success rates and the best experience with Jupiter Ultra. 
 Jupiter fees By default, Jupiter Ultra incurs a 0.05% or 0.1% fee based on token mint. When you add a referral fee, Jupiter will take a flat 20% of your integrator fees, for example, if you plan to take 100bps, Jupiter will take 20bps from it. 
 Integrator fees You can configure  referralFee  to be between 50bps to 255bps. The  /order  response will show the total fee in  feeBps  field which should be exactly what you specified in  referralFee . Do note that, the referral token account has to be created before calling  /order  because during the request, we will check if the token account is initialized before applying your referral fee (if it is not applied, we will only apply our default fees). 
 Limitations Currently, we do not support fees for Token2022 tokens. Setting up the referral accounts and token accounts can only be done via the SDK (the scripts provided in this guide), and not via the Referral Dashboard. 
 
 Step-by-step 
 
 Install additional dependencies. 
 Create  referralAccount . 
 Create  referralTokenAccount  for each token mint. 
 Add  referralAccount  and  referralFee  to Ultra  /order  endpoint. 
 Sign and send the transaction via Ultra  /execute  endpoint. 
 Verify transaction and fees. 
 
 
     
        Full Code Example
     
```ts
import { ReferralProvider } from "@jup-ag/referral-sdk";
import { Connection, Keypair, PublicKey, sendAndConfirmTransaction, sendAndConfirmRawTransaction } from "@solana/web3.js";
import fs from ''fs'';
 const connection = new Connection("https://api.mainnet-beta.solana.com");
const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray)); 
 const provider = new ReferralProvider(connection);
const projectPubKey = new PublicKey(''DkiqsTrw1u1bYFumumC7sCG2S8K25qc2vemJFHyW2wJc''); 
 async function initReferralAccount() {
const transaction = await provider.initializeReferralAccountWithName({
payerPubKey: wallet.publicKey,
partnerPubKey: wallet.publicKey,
projectPubKey: projectPubKey,
name: "insert-name-here",
}); 
 const referralAccount = await connection.getAccountInfo(
transaction.referralAccountPubKey,
); 
 if (!referralAccount) {
const signature = await sendAndConfirmTransaction(connection, transaction.tx, [wallet]);
console.log(''signature:'',  https://solscan.io/tx/${signature} );
console.log(''created referralAccountPubkey:'', transaction.referralAccountPubKey.toBase58());
} else {
console.log(
 referralAccount ${transaction.referralAccountPubKey.toBase58()} already exists ,
);
}
} 
 async function initReferralTokenAccount() {
const mint = new PublicKey("So11111111111111111111111111111111111111112"); // the token mint you want to collect fees in 
 const transaction = await provider.initializeReferralTokenAccountV2({
payerPubKey: wallet.publicKey,
referralAccountPubKey: new PublicKey("insert-referral-account-pubkey-here"), // you get this from the initReferralAccount function
mint,
}); 
 const referralTokenAccount = await connection.getAccountInfo(
  transaction.tokenAccount,
);

if (!referralTokenAccount) {
  const signature = await sendAndConfirmTransaction(connection, transaction.tx, [wallet]);
  console.log(''signature:'', `https://solscan.io/tx/${signature}`);
  console.log(''created referralTokenAccountPubKey:'', transaction.tokenAccount.toBase58());
  console.log(''mint:'', mint.toBase58());
} else {
  console.log(
    `referralTokenAccount ${transaction.tokenAccount.toBase58()} for mint ${mint.toBase58()} already exists`,
  );
}
 
 } 
 async function claimAllTokens() {
const transactions = await provider.claimAllV2({
payerPubKey: wallet.publicKey,
referralAccountPubKey: new PublicKey("insert-referral-account-pubkey-here"),
}) 
 // Send each claim transaction one by one.
for (const transaction of transactions) {
transaction.sign([wallet]); 
 const signature = await sendAndConfirmRawTransaction(connection, transaction.serialize(), [wallet]);
console.log(''signature:'', `https://solscan.io/tx/${signature}`);
 
 }
} 
 // initReferralAccount(); // you should only run this once
// initReferralTokenAccount();
// claimAllTokens(); 
 </details>

### Dependencies

```bash
npm install @jup-ag/referral-sdk
npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2
npm install bs58
npm install dotenv # if required for wallet setup
 
 
     
        RPC Connection and Wallet Setup
     
**Set up RPC Connection**
 :::note
Solana provides a  default RPC endpoint . However, as your application grows, we recommend you to always use your own or provision a 3rd party provider’s RPC endpoint such as  Helius  or  Triton .
::: 
 import { Connection } from "@solana/web3.js";

const connection = new Connection(''https://api.mainnet-beta.solana.com'');
 
 Set up Development Wallet 
 :::note 
 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 If you want to store your private key in the project directly, you can do it via a  .env  file.
::: 
 
 To set up a development wallet via  .env  file, you can use the following script. 
 // index.js
import { Keypair } from ''@solana/web3.js'';
import dotenv from ''dotenv'';
require(''dotenv'').config();

const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ''''));
 
 # .env
PRIVATE_KEY=""
 
 To set up a development wallet via a wallet generated via  Solana CLI , you can use the following script. 
 import { Keypair } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/To/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
 
 
 Create  referralAccount 
 
 You should only need to create the referral account once. 
 After this step, you need to  create the referral token accounts for each token mint . 
 
 import { ReferralProvider } from "@jup-ag/referral-sdk";
import { Connection, Keypair, PublicKey, sendAndConfirmTransaction } from "@solana/web3.js";

const connection = new Connection("https://api.mainnet-beta.solana.com");
const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
const provider = new ReferralProvider(connection);
const projectPubKey = new PublicKey(''DkiqsTrw1u1bYFumumC7sCG2S8K25qc2vemJFHyW2wJc''); // Jupiter Ultra Referral Project

async function initReferralAccount() {
  const transaction = await provider.initializeReferralAccountWithName({
    payerPubKey: wallet.publicKey,
    partnerPubKey: wallet.publicKey,
    projectPubKey: projectPubKey,
    name: "insert-name-here",
  });

  const referralAccount = await connection.getAccountInfo(
    transaction.referralAccountPubKey,
  );

  if (!referralAccount) {
    const signature = await sendAndConfirmTransaction(connection, transaction.tx, [wallet]);
    console.log(''signature:'', `https://solscan.io/tx/${signature}`);
    console.log(''created referralAccountPubkey:'', transaction.referralAccountPubKey.toBase58());
  } else {
    console.log(
      `referralAccount ${transaction.referralAccountPubKey.toBase58()} already exists`,
    );
  }
}
 
 Create  referralTokenAccount 
 
 You need to  create the  referralAccount  first . 
 You need to create a  referralTokenAccount  for each token mint you want to collect fees in. 
 We don''t recommend creating a token account for  every  token mint, as it costs rent and most tokens might not be valuable, instead created token accounts for top mints to begin with (you can always add more later). 
 
 import { ReferralProvider } from "@jup-ag/referral-sdk";
import { Connection, Keypair, PublicKey, sendAndConfirmTransaction } from "@solana/web3.js";

const connection = new Connection("https://api.mainnet-beta.solana.com");
const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
const provider = new ReferralProvider(connection);

async function initReferralTokenAccount() {
  const mint = new PublicKey("So11111111111111111111111111111111111111112"); // the token mint you want to collect fees in
  
  const transaction = await provider.initializeReferralTokenAccountV2({
    payerPubKey: wallet.publicKey,
    referralAccountPubKey: new PublicKey("insert-referral-account-pubkey-here"),
    mint,
  });
  
    const referralTokenAccount = await connection.getAccountInfo(
      transaction.tokenAccount,
    );
  
    if (!referralTokenAccount) {
      const signature = await sendAndConfirmTransaction(connection, transaction.tx, [wallet]);
      console.log(''signature:'', `https://solscan.io/tx/${signature}`);
      console.log(''created referralTokenAccountPubKey:'', transaction.tokenAccount.toBase58());
      console.log(''mint:'', mint.toBase58());
    } else {
      console.log(
        `referralTokenAccount ${transaction.tokenAccount.toBase58()} for mint ${mint.toBase58()} already exists`,
      );
    }
}
 
 Usage in Ultra 
 
 After creating the necessary accounts, you can now add the  referralAccount  and  referralFee  to the Ultra  /order  endpoint. 
 From the order response, you should see the  feeMint  field, which is the token mint we will collect the fees in for that particular order. 
 From the order response, you should see the  feeBps  field, which is the total fee in bps, which should be exactly what you specified in  referralFee . 
 Then, you can sign and send the transaction via the Ultra  /execute  endpoint. 
 
 :::danger
Do note that, during your request to  /order , we will check if the specific fee mint''s referral token account is initialized. If it is not, the order will still return and can be executed without your fees. This is to ensure success rates and the best experience with Jupiter Ultra. 
 Hence, please verify the transaction when testing with a new referral token account, and always create the referral token account before calling  /order .
::: 
 import { Keypair, VersionedTransaction } from "@solana/web3.js";
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));

const orderResponse = await (
  await fetch(
      ''https://lite-api.jup.ag/ultra/v1/order?'' + 
      ''inputMint=So11111111111111111111111111111111111111112&'' +
      ''outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&'' +
      ''amount=100000000&'' +
      ''taker=jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3&'' +
      ''referralAccount=&'' + // insert referral account public key here
      ''referralFee=50'' // insert referral fee in basis points (bps)
  )
).json();

console.log(JSON.stringify(orderResponse, null, 2));

const transactionBase64 = orderResponse.transaction // Extract the transaction from the order response
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64'')); // Deserialize the transaction
transaction.sign([wallet]); // Sign the transaction
const signedTransaction = Buffer.from(transaction.serialize()).toString(''base64''); // Serialize the transaction to base64 format

const executeResponse = await (
    await fetch(''https://lite-api.jup.ag/ultra/v1/execute'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            signedTransaction: signedTransaction,
            requestId: orderResponse.requestId,
        }),
    })
).json();

if (executeResponse.status === "Success") {
    console.log(''Swap successful:'', JSON.stringify(executeResponse, null, 2));
    console.log(`https://solscan.io/tx/${executeResponse.signature}`);
} else {
    console.error(''Swap failed:'', JSON.stringify(executeResponse, null, 2));
    console.log(`https://solscan.io/tx/${executeResponse.signature}`);
}
 
 Claim All Fees 
 
 The  claimAllV2  method will return a list of transactions to claim all fees and are batched by 5 claims for each transaction. 
 The code signs and sends the transactions one by one - you can also Jito Bundle to send multiple at once, if preferred. 
 When claiming fees, the transaction will include the transfer of the fees to both your referral account and Jupiter''s (20% of your integrator fees). 
 
 import { ReferralProvider } from "@jup-ag/referral-sdk";
import { Connection, Keypair, PublicKey, sendAndConfirmRawTransaction } from "@solana/web3.js";

const connection = new Connection("https://api.mainnet-beta.solana.com");
const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
const provider = new ReferralProvider(connection);

async function claimAllTokens() {
  const transactions = await provider.claimAllV2({
    payerPubKey: wallet.publicKey,
    referralAccountPubKey: new PublicKey("insert-referral-account-pubkey-here"),
  })

  // Send each claim transaction one by one.
  for (const transaction of transactions) {
    transaction.sign([wallet]);

    const signature = await sendAndConfirmRawTransaction(connection, transaction.serialize(), [wallet]);
    console.log(''signature:'', `https://solscan.io/tx/${signature}`);
  }
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/5-api-rate-limit.md', 'sidebar_label: "API Rate Limiting"
description: "API rate limiting for the Jupiter API."
title: "API Rate Limiting" 

     API Rate Limiting 
     

 In this section, you can find the rate limiting details for the Jupiter API. 
 Overview 
 Fixed Rate Limit 
 
 All Jupiter APIs that are public and documented are free to use via the Lite tier. 
 By purchasing a Pro plan, you are only accessing higher rate limits with no differences in usage nor freshness of data. 
 
 Dynamic Rate Limit 
 
 Only Ultra API has a unique dynamic rate limit system,  you can find more details in this section . 
 
 API Key rules 
 
 API Keys are universal
 
 Use the same API Key for Ultra API (Dynamic Rate Limit) and all Pro APIs  api.jup.ag  (Fixed Rate Limit). 
 You do not need an API Key for Lite APIs  lite-api.jup.ag . 
 
 
 Rate limits apply on a per account basis, not to individual API keys. 
 
 API Tier Rate Limit Model API Key Required Base URL 
 Lite Fixed (Free Tier) No https://lite-api.jup.ag/** 
 Pro Fixed (Tiered) Yes https://api.jup.ag/** 
 Ultra Dynamic Yes https://api.jup.ag/ultra/** 
 
 Fixed Rate Limit 
 The Fixed Rate Limit system applies to the Lite and Pro plans (does not include Ultra API), using the sliding window method to enforce request quotas. 
 Property Lite Pro 
 Base URL https://lite-api.jup.ag/ https://api.jup.ag/ 
 Cost Free Paid per month, based on tier 
 API Key Not required Required 
 Requests Per Minute 60 Based on tier 
 Window 60 seconds 10 seconds 
 
 Rate Limit 
 Rate limits are defined over 10-second windows (except Lite at 60-second window). For example, if your tier allows 100 requests per 10 seconds, any more within that window will receive a 429 response, regardless of how few you used in the previous window. 
 Tier Est. Requests per Minute Requests Per Period Sliding Window Period 
 Lite 60 60 60 seconds 
 Pro I ~600 100 10 seconds 
 Pro II ~3,000 500 10 seconds 
 Pro III ~6,000 1,000 10 seconds 
 Pro IV ~30,000 5,000 10 seconds 
 
 Requests are distributed to each bucket: 
 
 Price API Bucket  – dedicated for  /price/v3/  only - separate from Default Bucket. 
 Default Bucket  – used for all APIs except the Price API. 
 
 :::note 
 
 Each bucket enforces its own sliding window independently. 
 For example, Pro II = 500 per 10 seconds to the Default Bucket and 500 per 10 seconds to the Price API Bucket. 
 Lite users do not have a separate Price API Bucket — all requests are counted against the Default Bucket.
::: 
 
 Dynamic Rate Limit (BETA) 
 The  Ultra API  uses a unique rate limiting mechanism that scales with your  executed swap volume  over time. 
 Property Dynamic 
 Base URL https://api.jup.ag/ultra/ 
 Cost Free to use, but Ultra incurs swap fees 
 API Key Required 
 Requests Per Minute Base Quota + Added Quota 
 
 How Dynamic Rate Limit Works 
 Every  10 minutes 
 
 The system aggregates your swap volume from  /execute  on Ultra for  the current rolling day  (volume of (current timestamp - 1 day) up to present). 
 After which, the Added Quota will update, which will be added on top of the Base Quota. 
 
 Swap Volume Requests Per Period Sliding Window Period 
 $0 50 Base + 0 Added = 50 10 seconds 
 $10,000 50 Base + 1 Added = 51 10 seconds 
 $100,000 50 Base + 11 Added = 61 10 seconds 
 $1,000,000 50 Base + 115 Added = 165 10 seconds 
 
 :::note
The formula is subject to changes as we experiment with the Dynamic Rate Limit system. 
 If you find that the rate limit is too restrictive, please reach out to us in Discord.
::: 
 Managing Rate Limits 
 If you receive a 429 response, you should: 
 
 Implement exponential backoff in your retry logic 
 Wait for sliding window to allow for more requests 
 Upgrade your tier (Pro)  or  scale your Ultra usage  to unlock higher limits. 
 
 :::caution
Bursting beyond your allocation may result in  temporary 429s/rate limits , even after the refill period. Avoid aggressive retry patterns.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/501-token-api/v2.md', 'sidebar_label: "V2 (Beta)"
description: "Use the Jupiter Token API to search and query tokens."
title: "Token API V2 (Beta)" 

     V2 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/tokens/v2 
 Pro URL:  https://api.jup.ag/tokens/v2 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 The Token API V2 provides different endpoints to query for mint information in specific searches, tags or categories. 
 :::tip Useful Mint Information 
 
 Token Metadata like name, symbol, icon to display token information to users 
 Organic Score , Holder count, Market cap, etc can be useful to help make a better trading decision 
 And much more! 
 
 Do note that the response is subject to changes as we continue to improve. 
 Refer to  Example Response  or  Token API V2 Reference  for full schema.
::: 
 Query by Mint 
 The Token API V2 provides an endpoint to search tokens in the background for you and returns you the search results, along with the mint information. 
 This is useful in most user applications, as users need to choose which tokens they want to swap. This also provides a seamless developer experience as integrating this allows us to handle and abstract the token search mechanism, allowing you to focus on other user features. 
 :::tip Search 
 
 Search for a token and its information by its  symbol, name or mint address . 
 Comma-separate to search for multiple. 
 Limit to 100 mint addresses in query. 
 Default to 20 mints in response when searching via symbol or name.
::: 
 
 const searchResponse = await (
  await fetch(`https://lite-api.jup.ag/tokens/v2/search?query=So11111111111111111111111111111111111111112`)
).json();
 
 Query by Tag 
 The Token API V2 provides an endpoint to query by tags. This is useful to help users distinguish between verified vs non-verified or specific groups of tokens like liquid-staked tokens (LSTs). 
 :::tip Tag 
 
 Only  lst  or  verified  tag. 
 Note that this will return the entire array of existing mints that belongs to the tag.
::: 
 
 const tagResponse = await (
  await fetch(`https://lite-api.jup.ag/tokens/v2/tag?query=verified`)
).json();
 
 Get Category 
 The Token API V2 provides an endpoint to get mints and their mint information by categories. These categories are useful for identifying tokens in specific trading scenarios, providing users with more information to trade with. 
 :::tip Category 
 
 Only  toporganicscore ,  toptraded  or  toptrending  category. 
 Added query by interval for more accuracy, using  5m ,  1h ,  6h ,  24h . 
 The result filters out generic top tokens like SOL, USDC, etc (since those tokens are likely always top of the categories). 
 Default to 50 mints in response (use  limit  to increase or decrease number of results).
::: 
 
 const categoryResponse = await (
  await fetch(`https://lite-api.jup.ag/tokens/v2/toporganicscore/5m?limit=100`)
).json();
 
 Get Recent 
 The Token API V2 provides an endpoint to get mints and their mint information by their recency. This is helpful to display to users a list of tokens that just had their first pool created, providing more information to trade with. 
 :::tip Recent 
 
 Do note that the definition of RECENT is the  token''s first pool creation time  (and not token''s mint/creation timestamp). 
 Default to 30 mints in response.
::: 
 
 const recentResponse = await (
  await fetch(`https://lite-api.jup.ag/tokens/v2/recent`)
).json();
 
 Example Response 
 All endpoints will return an array of mints, along with their information. 
 Successful example response: 
 [
  {
    id: ''So11111111111111111111111111111111111111112'',
    name: ''Wrapped SOL'',
    symbol: ''SOL'',
    icon: ''https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png'',
    decimals: 9,
    circSupply: 531207433.3986673,
    totalSupply: 603724547.3627878,
    tokenProgram: ''TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'',
    firstPool: {
      id: ''58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2'',
      createdAt: ''2021-03-29T10:05:48Z''
    },
    holderCount: 2342610,
    audit: {
      mintAuthorityDisabled: true,
      freezeAuthorityDisabled: true,
      topHoldersPercentage: 1.2422471238911812
    },
    organicScore: 98.92390784896082,
    organicScoreLabel: ''high'',
    isVerified: true,
    cexes: [
      ''Binance'', ''Bybit'',
      ''OKX'',     ''Upbit'',
      ''Bitget'',  ''Kraken'',
      ''KuCoin'',  ''MEXC'',
      ''Gate.io''
    ],
    tags: [ ''community'', ''strict'', ''verified'' ],
    fdv: 87824499429.22047,
    mcap: 77275352037.79674,
    usdPrice: 145.47114211747515,
    priceBlockId: 349038717,
    liquidity: 89970631.83880953,
    stats5m: {
      priceChange: 0.021175445311831707,
      liquidityChange: -0.01230267453174984,
      volumeChange: 4.855149318222242,
      buyVolume: 14644327.188370818,
      sellVolume: 14743625.023908526,
      buyOrganicVolume: 269570.2345543641,
      sellOrganicVolume: 204114.37436445671,
      numBuys: 49281,
      numSells: 54483,
      numTraders: 18155,
      numOrganicBuyers: 981,
      numNetBuyers: 3503
    },
    stats1h: {
      priceChange: -0.145099593531635,
      liquidityChange: -0.13450589635262783,
      volumeChange: -15.928930753985316,
      buyVolume: 171520842.22567528,
      sellVolume: 174057197.5207193,
      buyOrganicVolume: 3099405.8562825476,
      sellOrganicVolume: 2975660.0383528043,
      numBuys: 586069,
      numSells: 649275,
      numTraders: 78145,
      numOrganicBuyers: 2716,
      numNetBuyers: 14442
    },
    stats6h: {
      priceChange: 0.3790495974473589,
      liquidityChange: 0.1659230330014905,
      volumeChange: 14.571340846647542,
      buyVolume: 1084625651.9256022,
      sellVolume: 1094488293.656417,
      buyOrganicVolume: 31145072.655369382,
      sellOrganicVolume: 31647431.25353508,
      numBuys: 3789847,
      numSells: 4363909,
      numTraders: 272131,
      numOrganicBuyers: 10849,
      numNetBuyers: 37155
    },
    stats24h: {
      priceChange: 1.5076363979360274,
      liquidityChange: 2.417364079880319,
      volumeChange: -2.1516094834673254,
      buyVolume: 4273248565.256824,
      sellVolume: 4306065610.69747,
      buyOrganicVolume: 109007133.8196669,
      sellOrganicVolume: 118085567.17983335,
      numBuys: 15125444,
      numSells: 17582713,
      numTraders: 754618,
      numOrganicBuyers: 28590,
      numNetBuyers: 80961
    },
    ctLikes: 4232,
    smartCtLikes: 522,
    updatedAt: ''2025-06-25T05:02:21.034234634Z''
  }
]', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/501-token-api/README.md', 'sidebar_label: "About Token API"
description: "Use the Jupiter Token API for all tokens tradable or tagged via Jupiter."
title: "Token API" 

     Token API 
     

 The Jupiter Token API and verification system aims to provide a way to validate mint addresses and provide integrators a simply way to get mint information. 
 :::danger DEPRECATED
 Token API V1  will be/is deprecated by 1 August 2025. 
 Please migrate to  Token API V2  which consists of breaking changes.
::: 
 
 About 
 As Solana grew and exploded with tens of thousands of newly minted tokens a day, the Jupiter Token API and verification system has evolved to meet the demands of token verification and provide an ecosystem-wide source of truth to rely on. 
 A historical breakdown of the evolutions of the Token API and verification system. 
 
 Solana Token Registry  was deprecated in 2022. 
 Ecosystem Token List V1: Github : Maintained via Github with 4.8k Pull Requests verified manually. 
 Ecosystem Token List V2: Catdet List : Maintained by Catdets and community with simple metrics to aid review. 
 Ecosystem Token List V3: Verify : Using a variety of trading, social metrics and  Organic Score  to aid verification. 
 
 :::info More reading materials 
 
 Introducing a new token verification method  at https://verify.jup.ag 
 Background and History of the Ecosystem Token List V2 
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/501-token-api/v1.md', 'sidebar_label: "V1 (Deprecated)"
description: "Use the Jupiter Token API for all tokens tradable or tagged via Jupiter."
title: "Token API V1 (Deprecated)" 

     V1 (Deprecated) 
     

 :::danger DEPRECATED
 Token API V1  will be/is deprecated by 1 August 2025. 
 Please migrate to  Token API V2  which consists of breaking changes.
::: 
 In this guide, we will be going through a few examples of what Token API endpoints you can call to get the information you need. 
 :::note
Base URL:  https://lite-api.jup.ag/tokens/v1 
 For higher rate limits,  refer to the API Key Setup doc .
::: 
 
 Get Token Information 
 Using this endpoint, you can get the token information of the specific mint address. In the following example, we are looking at getting the token information of the JUP token. 
 :::tip Helpful Information
In the response, you can see that we have identified the  tags ,  freeze_authority  and  permanent_delegate  to help you or your users make informed decisions.
::: 
 const tokenInfoResponse = await (
    await fetch(''https://lite-api.jup.ag/tokens/v1/token/JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'')
).json();

console.log(tokenInfoResponse);
 
 From the above example, you should see this response. 
 {
    address: ''JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'',
    name: ''Jupiter'',
    symbol: ''JUP'',
    decimals: 6,
    logoURI: ''https://static.jup.ag/jup/icon.png'',
    tags: [ ''verified'', ''strict'', ''community'', ''birdeye-trending'' ],
    daily_volume: 79535977.0513354,
    created_at: ''2024-04-26T10:56:58.893768Z'',
    freeze_authority: null,
    mint_authority: null,
    permanent_delegate: null,
    minted_at: ''2024-01-25T08:54:23Z'',
    extensions: { coingeckoId: ''jupiter-exchange-solana'' }
}
 
 
 Get Tokens In Market 
 Using this endpoint, you can get a list of token mints that belong to a market/pool address. In the following example, we use a  Meteora SOL-USDC market . 
 const marketTokensResponse = await (
    await fetch(''https://lite-api.jup.ag/tokens/v1/market/BVRbyLjjfSBcoyiYFuxbgKYnWuiFaF9CSXEa5vdSZ9Hh/mints'')
).json();

console.log(marketTokensResponse);
 
 From the above example, you should see this response. 
 [
    ''So11111111111111111111111111111111111111112'',
    ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v''
]
 
 
 Get All Tradable Tokens 
 Using this endpoint, you can get a list of all token mints that are tradable on Jupiter. 
 
 A new token (before market liquidity checks) 
 Or tokens that has past the market liquidity checks 
 These tokens should return a quote from the  /quote  endpoint and is able to swap. 
 
 const allTradableResponse = await (
    await fetch(''https://lite-api.jup.ag/tokens/v1/mints/tradable'')
).json();

console.log(allTradableResponse);
 
 From the above example, you should see this response. 
 [
    ...

    ''So11111111111111111111111111111111111111112'',
    ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v''
    ''jupSoLaHXQiZZTSfEWMTRRgpnyFm8f6sZdosWBjx93v'',
    ''JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'',
    ''27G8MtK7VtTcCHkpASjSDdkWWYfoqT6ggEuKidVJidD4'',

    ...
]
 
 
 Get Tagged Tokens 
 Using this endpoint, you can get a list of token mints (with information) that are tagged according to the tag you pass in. In the following example, we use the  lst  tag. 
 :::tip
A list of useful tags are: 
 Token List Name Description 
 verified A list of verified tokens, consisting of community-verified tokens via  catdetlist.jup.ag  and the previous standard of Jupiter Strict. 
 lst A list of liquid staked tokens, maintained with Sanctum. 
 token-2022 A list of all token-2022 tokens. 
 
 You can pass in multiple tags using a comma separated list, refer to the API Reference for more details.
::: 
 const lstTaggedResponse = await (
    await fetch(''https://lite-api.jup.ag/tokens/v1/tagged/lst'')
).json();

console.log(lstTaggedResponse);
 
 From the above example, you should see this response. 
 ...

{
    address: ''jupSoLaHXQiZZTSfEWMTRRgpnyFm8f6sZdosWBjx93v'',
    name: ''Jupiter Staked SOL'',
    symbol: ''JupSOL'',
    decimals: 9,
    logoURI: ''https://static.jup.ag/jupSOL/icon.png'',
    tags: [ ''verified'', ''community'', ''strict'', ''lst'' ],
    daily_volume: 24017778.687489692,
    created_at: ''2024-04-26T10:57:45.759228Z'',
    freeze_authority: null,
    mint_authority: ''EMjuABxELpYWYEwjkKmQKBNCwdaFAy4QYAs6W9bDQDNw'',
    permanent_delegate: null,
    minted_at: ''2024-03-25T09:28:04Z'',
    extensions: { coingeckoId: ''jupiter-staked-sol'' }
},

...
 
 
 Get New Tokens 
 Using this endpoint, you can get a list of token mints (with information)  sorted by  created_at  their timestamps . 
 :::tip Paginate Large Response
The  /new  endpoint will return a large sized payload as response, you can utilize the  limit  and  offset  query parameters to help paginate the responses. 
 
 limit : Refers to how many counts of data to be in the output. 
 offset : Refers to how many counts of data to offset into the result set.
 
 Used in conjunction with  limit  to page through the data.
::: 
 
 
 
 const newTokensReponse = await (
    await fetch(''https://lite-api.jup.ag/tokens/v1/new'')
).json();

console.log(newTokensReponse);
 
 From the above example, you should see this response. 
 {
    mint: ''penguin'',
    created_at: ''1733481083'',
    metadata_updated_at: 1733481087,
    name: ''cool penguin'',
    symbol: ''penguin'',
    decimals: 6,
    logo_uri: ''https://jup.ag'',
    known_markets: [ ''market'' ],
    mint_authority: null,
    freeze_authority: null
},
{
    mint: ''cat'',
    created_at: ''1733481083'',
    metadata_updated_at: 1733481087,
    name: ''cat moon'',
    symbol: ''cat'',
    decimals: 6,
    logo_uri: ''https://jup.ag'',
    known_markets: [ ''market'' ],
    mint_authority: null,
    freeze_authority: null
},
 
 
 Get All Tokens 
 Using the endpoint, you can simply query with the  all  resource to get all tokens that Jupiter has indexed through our infrastructure. 
 :::warning
Do note that calling this endpoint''s resource will return  a large payload of 300+MB , which would introduce some latency in the call. Please use carefully and intentionally, else utilize the other endpoints. 
 This endpoint does not support  limit  or  offset .
::: 
 :::tip
To index your own tokens, you can use RPC APIs such as the  Metaplex Digital Asset Standard (DAS) . Major RPC providers like  Helius  and  Triton One  offer access to this API.
::: 
 const allResponse = await (
  await fetch("https://lite-api.jup.ag/tokens/v1/all")
).json();

console.log(allResponse);
 
 From the above example, you should see this response. 
 ...

{
    address: ''So11111111111111111111111111111111111111112'',
    name: ''Wrapped SOL'',
    symbol: ''SOL'',
    decimals: 9,
    logoURI: ''https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png'',
    tags: [ ''verified'', ''community'', ''strict'' ],
    daily_volume: 2873455332.377303,
    created_at: ''2024-04-26T10:56:58.893768Z'',
    freeze_authority: null,
    mint_authority: null,
    permanent_delegate: null,
    minted_at: null,
    extensions: { coingeckoId: ''wrapped-solana'' }
},
{
    address: ''JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN'',
    name: ''Jupiter'',
    symbol: ''JUP'',
    decimals: 6,
    logoURI: ''https://static.jup.ag/jup/icon.png'',
    tags: [ ''verified'', ''strict'', ''community'', ''birdeye-trending'' ],
    daily_volume: 79535977.0513354,
    created_at: ''2024-04-26T10:56:58.893768Z'',
    freeze_authority: null,
    mint_authority: null,
    permanent_delegate: null,
    minted_at: ''2024-01-25T08:54:23Z'',
    extensions: { coingeckoId: ''jupiter-exchange-solana'' }
},

...', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/501-token-api/organic-score.md', 'description: "About Organic Score"
title: "Organic Score" 

     Organic Score 
     

 Organic Score is a metric designed to measure the genuine activity and health of a token. Unlike traditional metrics that can be easily manipulated by artificial trading or bot activity, the Organic Score focuses on real user participation and authentic market metrics. This helps users, developers, and projects better understand the context of similar tokens and find the signal within the noise. 
 How Organic Score is Derived 
 Organic Score is derived from a set of core metrics, such as holder count, trading volume and liquidity. In order to ensure the authenticity and reliability of the score, we track the metrics participated by real user wallets (not bots, etc) in real time to derive the Organic Score. 
 :::info Organic Score
This is a high level depiction of how Organic Score is dervied, there are other heuristics and data involved to measure and derive it. 
 
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/501-token-api/token-tag-standard.md', 'description: "Token Tag Standard"
title: "Token Tag Standard" 

     Token Tag Standard 
     

 The Token API is built with a tagging system such as Verified, LSTs and more. In this section, we will be going through how you can get your tokens tagged for better visibility on Jupiter UI or via the Token API. 
 Requirements 
 
 An endpoint that points to a .csv file with a mint address per row . 
 A preferred word or acronym for your tag - one that''s short and mobile friendly. 
 A set interval for us to poll. 
 
 The endpoint should be public, with our IP whitelisted for rate limits where necessary. 
 How to get your tokens tagged 
 After you have completed the requirements, please reach out to us via  Discord . 
 Once we start ingesting your list, the tokens will be tagged automatically.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/2-development-basics.md', 'sidebar_label: "Development Basics"
description: "Under development basics on Solana to build with Jupiter API."
title: "Development Basics" 

     Development Basics 
     

 :::tip where is jupiter?
Jupiter is built on Solana MAINNET only!
::: 
 Solana uses an account-based architecture where data are stored in accounts. However, Solana keeps Programs (also known as smart contracts on other blockchains) and Accounts distinct. In order to mutate the data in Accounts, you will need to send transactions to the network which execute Instructions defined by Programs. 
 
 Programs  on Solana are executable code deployed on-chain. They are designed to execute instructions, process transactions and interact with accounts. 
 Instructions  on Solana are defined by the Program, similar to API endpoints exposed by a program. 
 Accounts  store data and are mutable, meaning they can be updated by the program who interacts with them. 
 Transactions  is what we send to interact with the network which can include one or more instructions to execute what is needed. 
 
 Interacting with Solana 
 The Solana Web3.js and Rust client libraries serve as essential interfaces for interacting with Solana in JavaScript/TypeScript and Rust environments, respectively. They abstract complex interactions with the network, providing easier and more accessible functions for developers building on Solana. Here’s an overview of what each library offers and some of the most common functions they simplify: 
 
 Connecting to the network via RPC (Remote Procedure Call) endpoints 
 Building Transactions 
 Interfacing with Solana Programs and Accounts 
 
 :::note links
Explore the rich features and detailed documentation of these libraries in the official Solana Developer Documentation:  Web3.js  and  Rust client 
::: 
 Interacting with Jupiter Programs 
 To interact with the Jupiter Swap Aggregator Program, there are a few ways to do it: 
 Method Description 
 Swap API Simply call the Quote API to get a quote based on Jupiter’s routing engine and call the Swap API to get a serialized transaction to send to the network. 
 Flash Fill method If you are building your own on-chain program, an alternative method from CPI, using Versioned Transaction and Address Lookup Tables, thus reducing the size of each account (used to be a limitation of using CPI method). 
 Cross Program Invocation (CPI) CPI method is now recommended. As of January 2025, Jupiter Swap via CPI is recommended for most users.  The  Loosen CPI restriction  feature has been deployed on Solana, you can read more here . 
 
 Building Transactions 
 Before you send a transaction to the network, you will need to build the transaction that defines the instructions to execute and accounts to read/write to. It can be complex to handle this yourself when building with Jupiter, you can  read more about it here . 
 However, good news! Most of our APIs and SDKs just handles it for you, so you get a response with the transaction to be prepared and sent to the network. 
 :::tip swap api tip
The Swap API returns you the serialized transaction which you can directly send it to your RPC endpoint to execute on Solana. Alternatively, if you plan to manipulate the instructions and build your own custom transactions, you can request from the  /swap-instructions  endpoint.
::: 
 Sending Transactions 
 Transactions on Solana can only be sent to the network through an RPC (Remote Procedure Call) endpoint. The Solana network operates with a client-server model where RPC nodes handle transactions and interact with the validators of the blockchain. We recommend using 3rd party RPC providers like  Triton  or  Helius  for production applications. 
 There are a few key points to note when sending transactions to the Solana network. At Jupiter, we do our best to help you optimize transaction sending and make it easier for you. 
 
 Solana transaction base fee 
 Priority fee 
 Compute units 
 Transaction broadcasting methods 
 Slippage (100% slippage will probably always work but also mean you can possibly get the worst outcome, so we need to find the balance between success optimizations and best output price) 
 
 More about these factors? 
 What is Priority Fee? 
 Transactions submitted to the blockchain are prioritized based on a fee-bidding process. The higher the priority fee, the higher your transaction will be placed in the execution queue. 
 :::info Overpaying Priority Fee
It is important to note that overpaying for priority fee can be detrimental in the long run. If transactions continuously outbid each other, the overall fees required to process across the network will increase over time.
::: 
 Priority Fee  is an optional fee you can pay additionally to improve the chance of landing your transactions faster. 
 
 Priority Fee =  Compute Budget * Compute Unit Price 
 This is excluding the base transaction fee (5,000 lamports or 0.000005 SOL) that you always need to pay. 
 You not only need to outbid other transactions trying to be included in the block, but also outbid those trying to write to the same account. 
 
 Terminologies 
 Global Priority Fee The Priority Fee estimation across the entire network. 
 Local Fee Market The Priority Fee estimation when modifying a writable account (or hot account). 
 Priority Fee Compute Budget * Compute Unit Price 
 Compute Budget How much compute unit the transaction is supposed to consume 
 Compute Unit Price Micro lamports per compute unit the transaction will use 
 
 When querying the micro-lamport per compute unit for a particular program or account, it will contain both the Global and Local Fee markets. 
 What is Compute Unit? 
 Compute Unit (CU) is a standardized metric for evaluating how much "work" or "resource" is required by the transaction to execute. Different operations on Solana has varying amounts of CUs. In order to keep the blockchain efficient yet fast, each transaction, the Solana runtime has an absolute max compute unit limit of 1.4 million CU and sets a default requested max limit of 200k CU per instruction. 
 :::tip Set custom Compute Unit Limit
A transaction can request a more specific and optimal compute unit limit by including a single  SetComputeUnitLimit  instruction. Either a higher or lower limit. But it may never request higher than the absolute max limit per transaction.
::: 
 However, we must note that higher CU also means higher Priority Fee it might need to help prioritize it. 
 What are some transaction broadcasting methods? 
 
 Typical RPCs 
 RPCs with SWQoS 
 Jito RPC 
 
 What is Slippage? 
 A percentage or bps threshold the user specify and if the actual executed output is less than quoted output by the percentage/bps, the transaction will fail. 
 It is more like a safeguard but the tighter threshold you go, the harder it can become to land the transaction as markets can move rapidly.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/7-api-payment-method.md', 'sidebar_label: "Payment Method"
description: "Payment Method in Jupiter Portal"
title: "Payment Method" 

     Payment Method 
     

 This section covers the payment method in Jupiter Portal. 
 Overview 
 The payment methods provided on Portal only applies to the  PRO PLAN . 
 
 Lite Plan : Free tier, no payment required. 
 Pro Plan : Tiered pricing. 
 Ultra Plan : No payment via Portal needed. 
 
 :::note
For Lite and Ultra plans, you can use the API directly without any payment on Portal. 
 (Note that Ultra plan will require a free API Key to be generated first. You can find more details in  API Setup  and  API Rate Limit  docs.)
::: 
 Payment Method 
 We currently support 2 payment methods: 
 
 Crypto - USDC on Solana via Helio 
 Credit card - USD via CoinFlow 
 
 To pay for higher rate limits on Pro plan, you can choose either of the payment methods via the Portal UI. 
 Crypto 
 Property Details 
 Payment The payment is done in Solana USDC only. 
 Cadence The payment is currently done on a monthly basis, which means you will need to revisit Portal and manually renew each month. 
 Expiry 7 days before the plan expires, you will see the state change in the dashboard''s table and receive an automated email as a reminder to renew. Upon expiry, your key will remain valid for a grace period but will be disabled (but not deleted) when it ends. 
 Renewal If you choose to "Renew", the plan will be renewed to the same plan as the previous month. To change plan, you can upgrade/downgrade your plan at any time and cost will be pro-rated. 
 Fee Jupiter incurs the payment service fees. 
 Changing of payment method From Crypto to Credit Card: 1. Wait for plan to expire 2. Pay using the credit card payment method. 
 
 Credit Card 
 Property Details 
 Payment The payment is done in USD only. 
 Cadence The subscription is automatically renewed and funds deducted on a monthly basis. 
 Fee User incurs the credit card payment service fees at 3.4% of the payment amount + $0.25. 
 Changing of cards For security, changing of cards require a few extra steps and cannot be done in the middle of the subscription. 1. Cancel current plan 2. Wait for plan to expire 3. Resubscribe a plan with the new card. 
 Upgrading of plans You can upgrade your plan at any time. - The cost of the new plan will be charged immediately, while the pro-rated unused cost of the previous plan will be refunded. - The subscription date will be updated to the date of the upgrade. - Do note that the refund will be processed at least 1-2 business days after the upgrade. 
 Downgrading of plans You can downgrade by cancelling your plan and subscribing to a lower plan after expiry. 
 Cancellation of plans No refund will be given for unused days and the Pro plan will continue until the expected expiry date. 
 Changing of payment method From Credit Card to Crypto: 1. Cancel current plan so it does not automatically renew 2. Wait for plan to expire 3. Pay using the crypto payment method. 
 Other Caveats - Registered card address must be the billing address. - No usage of disposable cards as payments are made for a recurring subscription plan.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/102-trigger-api/best-practices.md', 'sidebar_label: "Best Practices"
description: "Best Practices for using the Trigger API"
title: "Best Practices" 

     Best Practices 
     

 Some best practices when using the Trigger API. 
 Item Recommendation 
 The program will accept any value to create an order. On jup.ag, our frontend enforces a minimum of 5 USD per order to be created, this will ensure our keepers can accommodate for no loss in transaction fees coverage. However, programmatically, if you do not enforce this, the user can still create an order. 
 The program does not check the price or rate of the order, and the keeper will execute as instructed. On our frontend, when user attempts to set the rate to buy above market price, we provide warnings and disable the execution if above 5%. If the order is created with such rates, the keeper will execute as instructed. For example, if user sets to Sell 1000 USDC to Buy 1 SOL at the rate of 1000 SOL/USDC, the keeper will execute as instructed and the additional funds will be lost. 
 Tokens with transfer tax extension are disabled. Our frontend informs the user if the token has transfer tax. 
 Token2022 tokens with transfer tax extension are disabled. Our frontend informs the user if the token has transfer tax. 
 Trigger orders with slippage. By nature, trigger orders execute with 0 slippage. However, you can add slippage to the order to ensure the order is filled but at the cost of slippage.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/102-trigger-api/4-get-trigger-orders.md', 'sidebar_label: "Get Trigger Orders"
description: "Use the Jupiter Trigger API to get trigger orders."
title: "Get Trigger Orders" 

     Get Trigger Orders 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/trigger/v1/getTriggerOrders 
 Pro URL:  https://api.jup.ag/trigger/v1/getTriggerOrders 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 This is a GET request to  /getTriggerOrders  endpoint. 
 The response is paginated for every 10 orders and you can view different pages using the  page  parameter. The  hasMoreData  boolean will indicate if you have more data in the next page. 
 :::warning Change of Response Format
The  /getTriggerOrders  endpoint does not provide the same data format as the old  orderHistory  or  openOrders  endpoint.
::: 
 Active Orders 
 To get the active orders, you can pass in the  orderStatus  parameter as  active . 
 :::tip
You can optionally pass in the input and output token mint addresses to filter the open orders.
::: 
 const openOrdersResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/trigger/v1/getTriggerOrders?user=jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3&orderStatus=active''
    )
).json();
 
 Order History 
 To get the order history, you can pass in the  orderStatus  parameter as  history . 
 const orderHistoryResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/trigger/v1/getTriggerOrders?user=ErJKdNoarixqGGQTHbBtvHtg2nkcCqcKtYjGbVKUxY7D&orderStatus=history''
    )
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/102-trigger-api/README.md', 'sidebar_label: "About Trigger API"
description: "Start using Jupiter Trigger API to create limit orders."
title: "About Trigger API" 

     Trigger API 
     

 The Jupiter Trigger API enables you to create limit orders on Solana, allowing users to set target prices for token swaps that execute automatically when market conditions are met. 
 The Trigger API is ideal for: 
 
 DeFi applications that want to offer users more advanced trading options 
 Wallets looking to expand their trading features 
 Automated systems that need to execute at specific price points 
 
 Features 
 Feature Description 
 Custom integrator fees Integrators can choose to charge their own custom fees (on top of Jupiter''s fees). 
 Any token pair Create trigger orders between any token pairs supported on Jupiter''s Metis Routing Engine. 
 Best execution Orders are executed through Jupiter''s Metis Routing Engine to get the best possible price across all DEXes. 
 Price monitoring Our infrastructure continuously monitors prices to execute trigger orders as soon as conditions are met. 
 Order expiry Trigger orders can be set to expire after a certain period of time. 
 Slippage addition Add slippage to the target price, ideal for users who want to prioritize success rate over price. 
 
 Getting Started with Trigger API 
 
 Create Order : Create a new trigger order with your desired parameters. 
 Execute Order : Execute a trigger order. 
 Cancel Order : Cancel an existing trigger order. 
 Get Trigger Orders : Retrieve active/historical trigger orders for a specific wallet address 
 Best Practices : Best practices for using Trigger API. 
 
 FAQ 
 What is the fee for using Trigger API? 
 Trigger API takes 0.03% for stable pairs and 0.1% for every other pairs. 
 Can integrators take fees using Trigger API? 
 Yes, integrators can take fees on top of Jupiter''s fees. 
 How do jup.ag UI modes translate to the Trigger API? 
 When using trigger orders on the jup.ag frontend, you''ll see two execution modes: 
 jup.ag UI Mode API Implementation Description 
 Exact slippageBps: 0  (default) Orders execute with 0 slippage for precise price execution By default, trigger orders execute with 0 slippage (you can omit the  slippageBps  parameter) 
 Ultra slippageBps: <custom_value> Orders execute with custom slippage for higher success rates On the jup.ag UI, Ultra denotes that Jupiter sets the slippage for the user, however, in API implementation, you will need to evaluate and set it yourself.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/102-trigger-api/2-execute-order.md', 'sidebar_label: "Execute Order"
description: "Use the Jupiter Trigger API to execute orders."
title: "Execute Order" 

     Execute Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/trigger/v1/execute 
 Pro URL:  https://api.jup.ag/trigger/v1/execute 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 After getting the order transaction, you can sign and send to the network yourself or use the Trigger API''s  /execute  endpoint to do it for you. 
 Sign Transaction 
 Using the Solana  web3.js  v1 library, you can sign the transaction as follows: 
 // ... GET /order''s response

// Extract the transaction from the order response
const transactionBase64 = orderResponse.tx

// Deserialize the transaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));

// Sign the transaction
transaction.sign([wallet]);

// Serialize the transaction to base64 format
const signedTransaction = Buffer.from(transaction.serialize()).toString(''base64'');
 
 Execute Order 
 By making a post request to the  /execute  endpoint, Jupiter executes the order transaction on behalf of you/your users. This includes handling of transaction handling, priority fees, RPC connection, etc. 
 const executeResponse = await (
    await fetch(''https://lite-api.jup.ag/trigger/v1/execute'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            signedTransaction: signedTransaction,
            requestId: "370100dd-1a85-421b-9278-27f0961ae5f4",
        }),
    })
).json();
 
 Execute Order Response 
 After making the post request to the  /execute  endpoint, you will receive a response with the status of the order. 
 Example response of successful order: 
 {
  "signature": "...",
  "status": "Success"
}
 
 Example response of failed order: 
 {
  "error": "custom program error code: 1",
  "code": 500,
  "signature": "...",
  "status": "Failed"
}
 
 Send Transaction Yourself 
 If you want to handle the transaction, you can sign and send the transaction to the network yourself. 
 const transactionBase64 = createOrderResponse.transaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));

transaction.sign([wallet]);

const transactionBinary = transaction.serialize();

const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "finalized" });

const signature = await connection.sendRawTransaction(transactionBinary, {
    maxRetries: 1,
    skipPreflight: true
});

const confirmation = await connection.confirmTransaction({
signature,
blockhash: blockhashInfo.value.blockhash,
lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
}, "finalized");

if (confirmation.value.err) {
    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\n\nhttps://solscan.io/tx/${signature}`);
} else console.log(`Transaction successful: https://solscan.io/tx/${signature}`);', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/102-trigger-api/3-cancel-order.md', 'sidebar_label: "Cancel Order"
description: "Use the Jupiter Trigger API to cancel orders."
title: "Cancel Order" 

     Cancel Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/trigger/v1/cancelOrder 
 Pro URL:  https://api.jup.ag/trigger/v1/cancelOrder 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 If you want to cancel order(s), you need to do these steps: 
 
 Get a list of the order accounts you want to cancel via  /getTriggerOrders  endpoint. 
 Use the list of order accounts to make a post request to the  /cancelOrder  endpoint to get the transaction to cancel one or multiple orders. 
 Sign then send the transaction to the network either via  /execute  endpoint or by yourself. 
 
 :::info Get Trigger Orders
 Refer to the  /getTriggerOrders  section  to prepare the list of order accounts you want to cancel.
::: 
 :::note
To cancel multiple orders, you can use the  /cancelOrders  endpoint  to pass in a list of order accounts and it will build the transaction for multiple cancellations.
::: 
 Cancel Order 
 const cancelOrderResponse = await (
    await fetch(''https://lite-api.jup.ag/trigger/v1/cancelOrder'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            maker: "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
            computeUnitPrice: "auto",
            order: "3g2jF8txqXPp6GUStwtXMrWydeYWxU4qoBA8UDLoTnK7",
        })
    })
).json();
 
 Cancel Order Response 
 Success Example Response 
 {
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAA......QYHAwUIX4Ht8Agx34Q=",
  "requestId": "370100dd-1a85-421b-9278-27f0961ae5f4",
}
 
 Failed Example Response 
 {
  "error": "no matching orders found",
  "code": 400
}
 
 Cancel Orders 
 :::warning
If no orders are specified, the API will return the transaction to cancel  ALL  open orders, batched in groups of 5 orders.
::: 
 :::tip
Orders are batched in groups of 5, if you have 6 orders to cancel, you will receive 2 transactions. 
 Do note that you will receive a list of transactions, so you will need to access each transaction in it to sign and send individually. 
 If using  /execute  endpoint, you should pass in the same  requestId  for the different transactions.
::: 
 const cancelOrdersResponse = await (
    await fetch(''https://lite-api.jup.ag/trigger/v1/cancelOrders'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            maker: "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
            computeUnitPrice: "auto",
            orders: [
                "6fe8ByaiFHisjnYnH5qdpyiNtkn89mMBQUemRkVmKhro",
                "9jwzPKHxcrSozdrTYzPnTqy7psRvNGxaYUAiiyxwZKjj"
            ]
        })
    })
).json();
 
 Cancel Orders Response 
 Success Example Response 
 {
  "transactions": [
    "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA......DHfhA0JAAAJBQ0ODwsNCF+B7fAIMd+EDQkAAAMCDQ4PCw0IX4Ht8Agx34Q=",
    "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA......a8lAwQABQLAqAAABAAJAy48AAAAAAAABQkAAAIBBQYHAwUIX4Ht8Agx34Q="
  ],
  "requestId": "370100dd-1a85-421b-9278-27f0961ae5f4",
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/102-trigger-api/1-create-order.md', 'description: "Use the Jupiter Trigger API to create orders."
title: "Create Order" 

     Create Order 
     

 :::warning New Paths
The  /limit/v2  path will be deprecated soon, please update your API calls to use the  /trigger/v1  path immediately. 
 When updating to the new path, please refer to the documentation as there are some breaking changes. 
 
 /execute  endpoint is introduced. 
 /createOrder  endpoint now includes an additional  requestId  parameter to be used with the  /execute  endpoint. 
 /cancelOrder  endpoint only builds the transaction for 1 order, while  /cancelOrders  endpoint builds the transaction for multiple orders. 
 The  tx  field in the responses are now  transaction  or  transactions . 
 /getTriggerOrders  endpoint is introduced to get either active or historical orders (based on the query parameters) in a new format.
::: 
 
 :::note 
 
 Lite URL:  https://lite-api.jup.ag/trigger/v1/createOrder 
 Pro URL:  https://api.jup.ag/trigger/v1/createOrder 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Create Order 
 This is a POST request to  /createOrder  endpoint, where you pass in the necessary parameters and our backend will create the transaction for you to sign and send to the network seamlessly. 
 :::tip Optional Parameters
Do note that there are a few optional parameters that you can use, such as: 
 
 Adding slippage to the order: This corresponds to the "Ultra" mode on jup.ag frontend. Higher slippage increases execution success rate but may result in less favorable prices. Omitting this parameter (or setting it to 0) corresponds to "Exact" mode.  Learn more about UI modes vs API implementation . 
 Setting an expiry date on the order. 
 Adding fees through our referral program, please ensure that your  feeAccount  has the necessary  referralTokenAccount s of the output mint of the limit order for it to work, you can learn more about creating them dynamically in the  Add Fees To Swap  guide. (Note that the fees are transferred only after the trigger order has been executed.)
::: 
 
 Create a POST request to the  /createOrder  endpoint. 
 const createOrderResponse = await (
    await fetch(''https://api.jup.ag/trigger/v1/createOrder'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            inputMint: inputMint.toString(),
            outputMint: outputMint.toString(),
            maker: "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
            payer: "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
            params: {
                makingAmount: "1000000",
                takingAmount: "300000",
                // slippageBps: "", // Optional, by nature, trigger orders execute with 0 slippage
                // expiredAt: "", // In unix seconds (e.g. Date.now()/1_000) or optional
                // feeBps: "", // Requires referral account or optional
            },
            computeUnitPrice: "auto",
            // feeAccount: "", // Optional but if specified it is the referral token account of the output mint
            // wrapAndUnwrapSol: true, // Default true or optional
        })
    })
).json();

console.log(createOrderResponse);
 
 Now that you have the order transaction, you can sign and send to the network. There are 2 methods, after signing the transaction, you can either send it to the network yourself or use the Trigger API''s  /execute  endpoint to do it for you. 
 Let''s execute the order 
 Create Order Response 
 Success Example Response 
 {
  "order": "CFG9Bmppz7eZbna96UizACJPYT3UgVgps3KkMNNo6P4k",
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAA......AgAKCAkBAQsPAAADBAEMCwcKCQkIBg0LIoVuSq9wn/WfdskdmHlfUulAQg8AAAAAAICpAwAAAAAAAAAJAwEAAAEJAA==",
  "requestId": "370100dd-1a85-421b-9278-27f0961ae5f4"
}
 
 Failed Example Response 
 {
  "error": "invalid create order request",
  "cause": "input mint making amount must be at least 5 USD, received: 2",
  "code": 400
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/1-get-quote.md', 'sidebar_label: "Get Quote"
description: "Start using Jupiter Swap API by getting a Quote."
title: "Get Quote" 

     Get Quote 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/swap/v1/quote 
 Pro URL:  https://api.jup.ag/swap/v1/quote 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::warning Please use the Swap API at your own discretion. 
 The Jupiter UI at https://jup.ag/ contains multiple safeguards, warnings and default settings to guide our users to trade safer. Jupiter is not liable for losses incurred by users on other platforms. 
 If you need clarification or support, please reach out to us in  Discord .
::: 
 :::warning Routing Engine
The quotes from Swap API are from the Jupiter Metis v1 Routing Engine.
::: 
 The Quote API enables you to tap into the Jupiter Metis v1 Routing Engine, which accesses the deep liquidity available within the DEXes of Solana''s DeFi ecosystem. In this guide, we will walkthrough how you can get a quote for a specific token pair and other related parameters. 
 Let’s Get Started 
 In this guide, we will be using the Solana web3.js package. 
 If you have not set up your environment to use the necessary libraries and the connection to the Solana network, please head over to  Environment Setup . 
 :::tip API Reference
To fully utilize the Quote API, check out the  Quote API Reference .
::: 
 Quote API 
 The most common trading pair on Solana is SOL and USDC, to get a quote for this specific token pair, you need to pass in the required parameters such as: 
 Parameters Description 
 inputMint The pubkey or token mint address e.g. So11111111111111111111111111111111111111112 
 outputMint The pubkey or token mint address e.g. EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v 
 amount The number of  input  tokens before the decimal is applied, also known as the “raw amount” or “integer amount” in lamports for SOL or atomic units for all other tokens. 
 slippageBps The number of basis points you can tolerate to lose during time of execution. e.g. 1% = 100bps 
 
 Get Quote 
 Using the root URL and parameters to pass in, it is as simple as the example code below! 
 const quoteResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000000&slippageBps=50&restrictIntermediateTokens=true''
    )
  ).json();
  
console.log(JSON.stringify(quoteResponse, null, 2));
 
 Example response: 
 {
  "inputMint": "So11111111111111111111111111111111111111112",
  "inAmount": "100000000",
  "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  "outAmount": "16198753",
  "otherAmountThreshold": "16117760",
  "swapMode": "ExactIn",
  "slippageBps": 50,
  "platformFee": null,
  "priceImpactPct": "0",
  "routePlan": [
    {
      "swapInfo": {
        "ammKey": "5BKxfWMbmYBAEWvyPZS9esPducUba9GqyMjtLCfbaqyF",
        "label": "Meteora DLMM",
        "inputMint": "So11111111111111111111111111111111111111112",
        "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        "inAmount": "100000000",
        "outAmount": "16198753",
        "feeAmount": "24825",
        "feeMint": "So11111111111111111111111111111111111111112"
      },
      "percent": 100
    }
  ],
  "contextSlot": 299283763,
  "timeTaken": 0.015257836
}
 
 :::tip
 outAmount  refers to the best possible output amount based on the route at time of quote, this means that  slippageBps  does not affect.
::: 
 What’s Next 
 Now, you are able to get a quote, next steps is to submit a transaction to execute the swap based on the quote given. Let’s go! 
 
 Additional Resources 
 Restrict Intermediate Tokens 
 restrictIntermediateTokens  can be set to  true  . If your route is routed through random intermediate tokens, it will fail more frequently. With this, we make sure that your route is only routed through highly liquid intermediate tokens to give you the best price and more stable route. 
 Legacy Transactions 
 All Jupiter swaps are using Versioned Transactions and  Address Lookup Tables . However, not all wallets support Versioned Transactions yet, so if you detect a wallet that does not support versioned transactions, you will need to set the  asLegacyTransaction  parameter to  true . 
 Adding Fees 
 By using the Quote API in your app, you can add a fee to charge your users. You can refer to the  platformFeeBps  parameter and to add it to your quote and in conjuction, add  feeAccount  (it can be any valid token account) to your swap request. 
 Direct Routes 
 In some cases, you may want to restrict the routing to only go through 1 market. You can use the  onlyDirectRoutes  parameter to achieve this. This will ensure routing will only go through 1 market. 
 :::note 
 
 If there are no direct routes, there will be no quote. 
 If there is only 1 market but it is illiquid, it will still return the route with the illiquid market.
::: 
 
 :::warning unfavorable trades
Please be aware that using  onlyDirectRoutes  can often yield unfavorable trades or outcomes.
::: 
 Max Accounts 
 In some cases, you may want to add more accounts to the transaction for specific use cases, but it might exceed the transaction size limit. You can use the  maxAccounts  parameter to limit the number of accounts in the transaction. 
 :::warning unfavorable trades
Please be aware that the misuse of  maxAccounts  can yield unfavorable trades or outcomes.
::: 
 :::tip 
 
 Refer to the  Requote with Lower Max Accounts  guide for more information on how to requote and adjust the swap when using  maxAccounts .
::: 
 
 :::note 
 
 maxAccounts  is an estimation and the actual number of accounts may vary. 
 maxAccounts  only applies to the total number of accounts of the inner swaps in the swap instruction and not any of the setup, cleanup or other instructions (see the example below). 
 We recommend setting  maxAccounts  to 64 
 Keep  maxAccounts  as large as possible, only reduce  maxAccounts  if you exceed the transaction size limit. 
 If  maxAccounts  is set too low, example to 30, the computed route may drop DEXes/AMMs like Meteora DLMM that require more than 30 accounts. 
 
 
**Jupiter has 2 types of routing instructions**, if you plan to limit `maxAccounts`, you will need to account for if the market is routable with [ALTs](https://docs.solana.com/developing/lookup-tables) or not:
- **`Routing Instruction`** (Simple Routing): The market is still new, and we do not have ALTs set up for the market, hence the number of accounts required is higher as there are more accounts required.
- **`Shared Accounts Routing Instruction`**: The market has sufficient liquidity (and has been live for a while), and we have [ALTs](https://docs.solana.com/developing/lookup-tables) set up for the market to be used in the routing instruction, hence the number of accounts required is lower as there are less accounts required.
:::
 
     
         
             
                 Counting the accounts using an example transaction 
             
         
     
 In this transaction : 
 <img src="/dev/max_accounts_stabble.png" alt="Max Accounts Stabble Example" style={{ width: "50%" }} />
<img src="/dev/max_accounts_lifinity_v2.png" alt="Max Accounts Lifinity V2 Example" style={{ width: "50%" }} />
<img src="/dev/max_accounts_shared_accounts_route.png" alt="Max Accounts Shared Accounts Route Example" style={{ width: "50%" }} /> 
 
 You can see that there are a total of 2 inner swaps where the number of accounts respectively are
 
 Stabble Stable Swap: 12 
 Lifinity Swap V2: 13 
 Total: 25 
 
 
 The  maxAccounts  parameter is to control this value - to limit the total number of accounts in the inner swaps. 
 It doesn’t take into the consideration of a few things:
 
 Each of the inner swap''s program address, so 2 in this case. 
 Top level routing instruction accounts where in this case Shared Accounts Route is 13 and Route is 9. 
 There are also other accounts that are required to set up, clean up, etc which are not counted in the  maxAccounts  parameter 
 
 
 
 
 
     
         
             
                 List of DEXes and their required accounts 
             
         
     
 Notes: 
 
 Values in the table are only estimations and the actual number of accounts may vary. 
 Min accounts are needed when we have already created the necessary  ALTs  for a specific pool resulting in less accounts needed in a Shared Accounts Routing context. 
 Sanctum and Sanctum Infinity are unique, and their accounts are dynamic. 
 
 DEX Max Min 
 Meteora DLMM 47 19 
 Meteora 45 18 
 Moonshot 37 15 
 Obric 30 12 
 Orca Whirlpool 30 12 
 Pumpfun AMM 42 17 
 Pumpfun Bonding Curve 40 16 
 Raydium 45 18 
 Raydium CLMM 45 19 
 Raydium CPMM 37 14 
 Sanctum 80 80 
 Sanctum Infinity 80 80 
 Solfi 22 9', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/2-build-swap-transaction.md', 'sidebar_label: "Build Swap Transaction"
description: "Jupiter Swap API helps you to build your swap transaction using the quote."
title: "Build Swap Transaction" 
 import Tabs from ''@theme/Tabs'';
import TabItem from ''@theme/TabItem''; 

     Build Swap Transaction 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/swap/v1/swap 
 Pro URL:  https://api.jup.ag/swap/v1/swap 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 The Swap API is one of the ways for you to interact with the Jupiter Swap Aggregator program. Before you send a transaction to the network, you will need to build the transaction that defines the instructions to execute and accounts to read/write to. 
 It can be complex to handle this yourself, but good news! Most of our APIs and SDKs just handles it for you, so you get a response with the transaction to be prepared and sent to the network. 
 :::tip Use Swap API to handle it for you or ... 
 If you are looking to interact with the Jupiter Swap Aggregator program in a different way, check out the other guides: 
 Swap Instructions 
 To compose with instructions and build your own transaction,  read how to use the  /swap-instructions  in this section . 
 Flash Fill or Cross Program Invocation (CPI) 
 To interact with your own Solana program,  read how to use the  Flash Fill method  or  CPI  in this section .
::: 
 Let’s Get Started 
 In this guide, we will pick up from where  Get Quote  guide has left off. 
 If you have not set up your environment to use the necessary libraries, the RPC connection to the network and successfully get a quote from the Quote API, please start at  Environment Setup  or  get quote . 
 :::tip API Reference
To fully utilize the Swap API, check out the  Swap API or Swap Instructions Reference .
::: 
 Swap API 
 From the previous guide on getting a quote, now using the quote response and your wallet, you can receive a  serialized swap transaction  that needs to be prepared and signed before sending to the network. 
 Get Serialized Transaction 
 Using the root URL and parameters to pass in, it is as simple as the example code below! 
 :::tip Optimizing for Transaction Landing is super super important!
This code block includes additional parameters that our Swap API supports, such as estimating compute units, priority fees and slippage, to optimize for transaction landing. 
 To understand how these parameters help, the next step,  Send Swap Transaction guide  will discuss them.
::: 
 const swapResponse = await (
await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
    method: ''POST'',
    headers: {
    ''Content-Type'': ''application/json'',
    },
    body: JSON.stringify({
    quoteResponse,
    userPublicKey: wallet.publicKey,
    
    // ADDITIONAL PARAMETERS TO OPTIMIZE FOR TRANSACTION LANDING
    // See next guide to optimize for transaction landing
    dynamicComputeUnitLimit: true,
    dynamicSlippage: true,
    prioritizationFeeLamports: {
          priorityLevelWithMaxLamports: {
            maxLamports: 1000000,
            priorityLevel: "veryHigh"
          }
        }
    })
})
).json();

console.log(swapResponse);
 
 From the above example, you should see this response. 
 {
    swapTransaction: ''AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAGDkS+3LuGTbs......+/oD9qb31dH6i0QZ2IHELXUX3Y1YeW79p9Stkqk12z4yvZFJiQ4GCQwLBwYQBgUEDggNTQ=='',
    lastValidBlockHeight: 279632475,
    prioritizationFeeLamports: 9999,
    computeUnitLimit: 388876,
    prioritizationType: {
        computeBudget: { 
            microLamports: 25715,
            estimatedMicroLamports: 785154 
        }
    },
    dynamicSlippageReport: {
        slippageBps: 50,
        otherAmount: 20612318,
        simulatedIncurredSlippageBps: -18,
        amplificationRatio: ''1.5'',
        categoryName: ''lst'',
        heuristicMaxSlippageBps: 100
    },
    simulationError: null
}
 
 What’s Next 
 Now, you are able to get a quote and use our Swap API to build the swap transaction for you. Next steps is to proceed to prepare and sign the transaction and send the signed transaction to the network. 
 Let’s go sign and send! 
 
 Additional Resources 
 Build Your Own Transaction With Instructions 
 If you prefer to compose with instructions instead of the provided transaction that is returned from the  /swap  endpoint (like the above example). You can post to  /swap-instructions  instead, it takes the same parameters as the  /swap  endpoint but returns you the instructions rather than the serialized transaction. 
 :::note
In some cases, you may add more accounts to the transaction, which may exceed the transaction size limits. To work around this, you can use the  maxAccounts  parameter in  /quote  endpoint to limit the number of accounts in the transaction. 
 Refer to the GET /quote''s  maxAccounts  guide for more details. 
::: 
 
     
         
             
                 /swap-instructions code snippet 
             
         
     
Example code snippet of using `/swap-instruction`
 const instructions = await (
    await fetch(''https://lite-api.jup.ag/swap/v1/swap-instructions'', {
    method: ''POST'',
    headers: {
        ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
        quoteResponse,
        userPublicKey: wallet.publicKey,
    })
    })
).json();

if (instructions.error) {
    throw new Error("Failed to get swap instructions: " + instructions.error);
}

const {
    tokenLedgerInstruction, // If you are using `useTokenLedger = true`.
    computeBudgetInstructions, // The necessary instructions to setup the compute budget.
    setupInstructions, // Setup missing ATA for the users.
    swapInstruction: swapInstructionPayload, // The actual swap instruction.
    cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.
    addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.
} = instructions;

const deserializeInstruction = (instruction) => {
    return new TransactionInstruction({
    programId: new PublicKey(instruction.programId),
    keys: instruction.accounts.map((key) => ({
        pubkey: new PublicKey(key.pubkey),
        isSigner: key.isSigner,
        isWritable: key.isWritable,
    })),
    data: Buffer.from(instruction.data, "base64"),
    });
};

const getAddressLookupTableAccounts = async (
    keys: string[]
): Promise<AddressLookupTableAccount[]> => {
    const addressLookupTableAccountInfos =
    await connection.getMultipleAccountsInfo(
        keys.map((key) => new PublicKey(key))
    );

    return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
    const addressLookupTableAddress = keys[index];
    if (accountInfo) {
        const addressLookupTableAccount = new AddressLookupTableAccount({
        key: new PublicKey(addressLookupTableAddress),
        state: AddressLookupTableAccount.deserialize(accountInfo.data),
        });
        acc.push(addressLookupTableAccount);
    }

    return acc;
    }, new Array<AddressLookupTableAccount>());
};

const addressLookupTableAccounts: AddressLookupTableAccount[] = [];

addressLookupTableAccounts.push(
    ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))
);

const blockhash = (await connection.getLatestBlockhash()).blockhash;
const messageV0 = new TransactionMessage({
    payerKey: payerPublicKey,
    recentBlockhash: blockhash,
    instructions: [
    // uncomment if needed: ...setupInstructions.map(deserializeInstruction),
    deserializeInstruction(swapInstructionPayload),
    // uncomment if needed: deserializeInstruction(cleanupInstruction),
    ],
}).compileToV0Message(addressLookupTableAccounts);
const transaction = new VersionedTransaction(messageV0);
 
 
 Build Your Own Transaction With Flash Fill Or CPI 
 If you prefer to interact with the Jupiter Swap Aggregator program with your own on-chain program. There are 2 ways to do it, typically on-chain program call  Cross Program Invocation (CPI)  to interact with each other, we also have another method called  Flash Fill  built by Jupiter (due to limitations of CPI in the past). 
 :::info CPI is now recommended!
As of January 2025, Jupiter Swap via CPI is recommended for most users. 
 The  Loosen CPI restriction  feature has been deployed on Solana, you can read more here .
::: 
 :::tip Why Flash Fill? 
 With Jupiter''s complex routing, best prices comes at a cost. It often means more compute resources and accounts are required as it would route across multiple DEXes in one transaction. 
 Solana transactions are limited to 1232 bytes, Jupiter is using  Address Lookup Tables (ALTs)  to include more accounts in one transaction. However, the CPI method cannot use ALTs, which means when you add more accounts to a Jupiter Swap transaction, it will likely fail if it exceeds the transaction size limits. 
 Flash Fill allows the use of Versioned Transaction and ALTs , hence, reducing the total accounts used for a Jupiter Swap transaction.
::: 
 
     
         
             
                 CPI References 
             
         
     
 A CPI transaction will be composed of these instructions: 
 
 Borrow enough SOL from the program to open a wSOL account that the program owns. 
 Swap X token from the user to wSOL on Jupiter via CPI. 
 Close the wSOL account and send it to the program. 
 The program then transfers the SOL back to the user. 
 
 Links and Resources: 
 
 https://github.com/jup-ag/jupiter-cpi-swap-example 
 https://github.com/jup-ag/sol-swap-cpi 
 
 
     
         
             
                 To ease integration via CPI, you may add the following crate  jupiter-cpi  to your program. 
             
         
     
 In cargo.toml 
 [dependencies]
jupiter-cpi = { git = "https://github.com/jup-ag/jupiter-cpi", rev = "5eb8977" }
 
 In your code 
 use jupiter_cpi;
...

let signer_seeds: &[&[&[u8]]] = &[...];

// Pass accounts to context one-by-one and construct accounts here
// Or in practise, it may be easier to use remaining_accounts
// https://book.anchor-lang.com/anchor_in_depth/the_program_module.html

let accounts = jupiter_cpi::cpi::accounts::SharedAccountsRoute {
    token_program: ,
    program_authority: ,
    user_transfer_authority: ,
    source_token_account: ,
    program_source_token_account: ,
    program_destination_token_account: ,
    destination_token_account: ,
    source_mint: ,
    destination_mint: ,
    platform_fee_account: ,
    token_2022_program: ,
};
let cpi_ctx = CpiContext::new_with_signer(
    ctx.accounts.jup.to_account_info(),
    accounts,
    signer_seeds,
);

jupiter_cpi::cpi::shared_accounts_route(
    cpi_ctx,
    id,
    route_plan,
    in_amount,
    quoted_out_amount,
    slippage_bps,
    platform_fee_bps,
);

...
 
 
 
 
     
         
             
                 Flash Fill References 
             
         
     
 A Flash Fill transaction will be composed of these instructions: 
 
 Borrow enough SOL for opening the wSOL account from this program. 
 Create the wSOL account for the borrower. 
 Swap X token to wSOL. 
 Close the wSOL account and send it to the borrower. 
 Repay the SOL for opening the wSOL account back to this program. 
 
 Links and resources: 
 
 https://github.com/jup-ag/sol-swap-flash-fill', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/README.md', 'sidebar_label: "About Swap API"
description: "Start using Jupiter Swap API to swap with the Metis Routing Engine."
title: "About Swap API" 

     Swap API 
     

 The Jupiter Swap API enables you to tap into the Jupiter Metis v1 Routing Engine, which aggregates across all liquidity available within the DEXes of Solana''s DeFi ecosystem, allowing you to swap seamlessly from any token to any token. 
 Features 
 Feature Description 
 Robust routing engine The Jupiter Metis v1 Routing Engine is a robust and battle-tested routing engine that has been in production for over 2 years with multiple DEXes integrated and trillions of dollars in volume. 
 Best on-chain price Trades can split across multiple different on-chain tokens and AMMs to ensure the best possible on-chain price. 
 Swap any token Swap from any token to another token. 
 Zero platform fees Swaps made via the Swap API do not incur any trading fees, both for you and your users. 
 Custom integrator fees Integrators can choose to charge their own custom fees. 
 Slippage protection Routes are intentionally chosen to decrease the likelihood of trade failures due to price slippage. 
 Fine-grained control Allows for full control of how your transaction is crafted and broadcasted. 
 
 What About Ultra API? 
 Ultra API is the spiritual successor to Swap API, and is much simpler to use than Swap API. If you are first starting out on your Solana development journey, using Ultra API is highly recommended over Swap API. 
 However, unlike Ultra API, Swap API allows developers to: 
 
 Add custom instructions. 
 Add Cross Program Invocation (CPI) calls. 
 Choose the broadcasting strategy for the signed transaction (ie. via priority fee, Jito, etc.). 
 Choose which DEXes or AMMs to route through. 
 Modify the number of accounts to use in a transaction. 
 
 If you have a highly custom need like what is described above, then Swap API may be for you. However, with Swap API, there are many more things you need to worry about that Ultra API automatically handles for: 
 
 Upkeep of RPCs : To retrieve wallet balances, broadcast and retrieve transactions, etc. 
 Deciding transaction fee : Including, but not limited to, priority fee, Jito fee, etc. 
 Deciding slippage : The optimal slippage to use to balance between trade success and price protection, do note that  RTSE is only available via Ultra API . 
 Broadcasting the transaction : Ultra uses a proprietary transaction sending engine which dramatically improves landing rate and speed. 
 Parsing the swap results : Polling and parsing the resulting transaction from the RPC, including handling for success and error cases. 
 
 If the above sounds like too much work, then Ultra API will be the better choice. 
 Getting Started with Swap API 
 
 Get Quote : Request for a quote which consists of the route plan, and other params such as integrator fee, slippage, etc. 
 Build Swap Transaction : Post the quote to build a swap transaction.
 
 You can utilize other methods to return swap instructions or use CPI rather than the default swap transaction. 
 You can utilize other parameters such as priority fee, dynamic slippage, etc to customize the transaction. 
 
 
 Send Swap Transaction : Sign and send the swap transaction to the network via your preferred RPC or other methods. 
 
 Other Guides 
 
 Adding Fees to Swap API : Add custom integrator fees to the swap transaction. 
 Using Swap API as a payment method : Use Swap API as a payment method for your users. 
 Using Jupiter Plugin : Lite version of Jupiter that provides end-to-end swap with just a few lines of code.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/common-errors.md', 'sidebar_label: "Common Errors"
description: "Common errors when using the Jupiter Swap API."
title: "Common Errors" 

     Common Errors 
     

 In this section, you can find the list of errors that can be returned by the Jupiter Swap API, Swap Program or from other programs like DEXes, System or Token programs. 
 Program Errors 
 Jupiter Swap Program Errors 
 :::note Jupiter Swap Program IDL
You can find the full Swap Program IDL here:
https://solscan.io/account/JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4#anchorProgramIdl
::: 
 :::info Abnormal Error Rates
If you face high or consistent amounts of errors, please reach out to  Jupiter Discord .
::: 
 Error Code Error Name Debug 
 6001 SlippageToleranceExceeded Try higher fixed slippage or try  dynamicSlippage 
 6008 NotEnoughAccountKeys Likely modified swap transaction causing missing account keys 
 6014 IncorrectTokenProgramID Likely attempted to take platform fees on a Token2022 token (This is also 0x177e) 
 6017 ExactOutAmountNotMatched Similar to slippage 
 
 Solana Program Errors 
 Program Link 
 Token Program https://github.com/solana-program/token/blob/main/program/src/error.rs 
 Token2022 Program https://github.com/solana-program/token-2022/blob/main/program/src/error.rs 
 Associated Token Account Program https://github.com/solana-program/associated-token-account/blob/main/program/src/error.rs 
 Other Solana Programs https://github.com/solana-program 
 
 DEX Program Errors 
 In the swap transaction, the DEX in routing may return errors. You can find some of their IDLs and/or error codes in an explorer. If they do not support public IDLs or open source code, you can reference the common errors below or if you need additional help, please reach out to  Jupiter Discord . 
 Error Description 
 Error related to tick array or bitmap extension account Similar to slippage, the price or market has "moved out of range", hence the swap transaction failed. 
 
 Routing Errors 
 The common routing errors you may encounter are usually related to attempting to swap a token that is not tradable on Jupiter, for reasons such as lack of liquidity or the token is not supported. 
 Error Description Debug 
 NO_ROUTES_FOUND No routes were found for the requested swap Check jup.ag if it''s routable Check the liquidity of the token''s markets 
 COULD_NOT_FIND_ANY_ROUTE Unable to find any valid route for the swap Check jup.ag if it''s routable Check the liquidity of the token''s markets 
 ROUTE_PLAN_DOES_NOT_ CONSUME_ALL_THE_AMOUNT The calculated route cannot process the entire input amount, you can get more output amount by reducing your input amount Try reducing your input amount 
 MARKET_NOT_FOUND The specified market address was not found Verify the market address exists and is active 
 TOKEN_NOT_TRADABLE The specified token mint is not available for trading Check jup.ag if it''s routable Check the liquidity of the token''s markets 
 NOT_SUPPORTED Generic error for unsupported operations Check the specific error message for details 
 CIRCULAR_ARBITRAGE_ IS_DISABLED Attempted to swap a token for itself Input and output tokens must be different 
 CANNOT_COMPUTE_ OTHER_AMOUNT_THRESHOLD Failed to calculate the minimum output amount based on slippage Verify the input amount and slippage parameters are valid 
 
 Swap Transaction Composing Errors 
 Error Description Debug 
 MAX_ACCOUNT_GREATER_THAN_MAX The specified number of accounts exceeds the maximum allowed Reduce the number of accounts in the transaction 
 INVALID_COMPUTE_UNIT_PRICE_AND_PRIORITIZATION_FEE Both compute unit price and prioritization fee were specified Use either compute unit price or prioritization fee, not both 
 FAILED_TO_GET_SWAP_AND_ACCOUNT_METAS Failed to generate the swap transaction Check the error message for specific details 
 
 Best Practices 
 It is important to understand the error codes when your products are user facing. This will help you provide a better experience for your users, helping them make an informed decision or follow up step to help their transaction succeed. 
 :::tip Jup.ag as a reference
You can use https://jup.ag/ as a reference to understand how we handle errors on the UI.
::: 
 Error Type Best Practice 
 Slippage exceeding threshold Show the user the current slippage tolerance and the incurred slippage 
 Insufficient funds Show the user the current balance of the account and the required balance 
 Non Jupiter Program Errors Allow the user to retry with a different route and/or exclude the specific DEX from the quote request 
 Token not tradable Show the user the token is not tradable and provide context on why it''s not tradable', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/5-payments-through-swap.md', 'sidebar_label: "Payments Through Swap"
description: "Jupiter Swap API allows you to set up payments solutions for your products."
title: "Payments Through Swap" 

     Payments Through Swap 
     

 The Jupiter Swap API can be utilized such that you, a merchant can allow your customer to pay in any tokens while you still receive in your preferred token payment at the end of the transaction. 
 Use Case 
 Let’s set the stage. You are selling a  jupcake!!!  to your customer and merchant might only accept in 1 USDC, but your customer only has 1 SOL. Well, you’re at the right place! By using the Swap API, merchant can let customer pay in SOL while merchant still receive USDC in order to complete the payment for a jupcake. 
 
 Customer has 1,000,000 SOL. 
 Merchant sells 1 jupcake for 1 USDC. 
 Use the Swap API to swap exactly 1 USDC output from Customer''s SOL. 
 Merchant receives the 1 USDC, as planned! 
 
 Let’s Get Started 
 1. Setup 
 You will need slightly different imports and also remember to set up connection to an RPC. If you have not set up the other typical libraries or are familiar with the Swap API, please follow this  Environment Setup  and  Get Quote and Swap  guide. 
 npm i @solana/spl-token
 
 import { PublicKey, Connection, Keypair, VersionedTransaction } from ''@solana/web3.js'';
import { getAssociatedTokenAddress, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from ''@solana/spl-token'';
 
 Before we start getting a quote and swap transaction, for example sake, we will need to prepare both merchant and customer accounts. In production scenario, you will need to dynamically pass this in and allow users to sign in their device interfaces. 
 :::note
Do note that you will need to have already set up: 
 
 A wallet in your machine to simulate yourself as the customer as the customer is the signer of the transaction  (similar to how we set up in  Environment Setup ). 
 trackingAccount  is an additional Solana Account you can pass in to track only Jupiter transactions easily.
::: 
 
 Set Up Accounts 
 const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const customerWallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));

const USDC_MINT = new PublicKey(''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v''); // Your preferred token payment
const customerAccount = customerWallet.publicKey;
const merchantAccount = new PublicKey(''ReplaceWithMerchantPubkey'');
// const trackingAccount = new PublicKey(''ReplaceWithPubkey''); // If required

console.log("USDC_MINT:", USDC_MINT.publicKey);
console.log("merchantAccount:", merchantAccount.publicKey);
// console.log("trackingAccount:", trackingAccount.publicKey);
 
 Set Up  destinationTokenAccount 
 One more thing you will need to set up! Later on, you will need to pass in  destinationTokenAccount  which will be your token account for your preferred token payment mint.  Do note that it is the merchant''s token account and it needs to be initialized. 
 // Get the associated token account for the merchant wallet
const merchantUSDCTokenAccount = await getAssociatedTokenAddress(
	  USDC_MINT,
	  merchantAccount,
	  true,
	  TOKEN_PROGRAM_ID,
	  ASSOCIATED_TOKEN_PROGRAM_ID
);

console.log("merchantUSDCTokenAccount:", merchantUSDCTokenAccount.publicKey);
 
 2. Set  swapMode  to  ExactOut  in Quote 
 Next, the merchant have to  Get Quote  for the customer. We are using the  ExactOut  mode because we know exactly how much output amount (1 USDC) the merchant want to receive but not sure how much input amount the customer should pay with. 
 By getting a quote first, the customer can know upfront the specific amount of input token before they approve and sign the transaction. 
 :::warning Limitations of  ExactOut 
Currently, there are some limitations as  ExactOut  is not widely supported across all DEXes. 
 
 Supported DEXes are only Orca Whirlpool, Raydium CLMM, and Raydium CPMM. 
 NOT ALL token pairs may be available.
::: 
 
 const quoteResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000&slippageBps=50&restrictIntermediateTokens=true&swapMode=ExactOut''
    )
  ).json();
  
console.log(JSON.stringify(quoteResponse, null, 2));
 
 From the this quote, you should get part of the response like this, where  amount  specified in the query parameter represents the  outAmount  in the response and of course,  swapMode: ExactOut . 
 {
    "inputMint": "So11111111111111111111111111111111111111112",
    "inAmount": "4434914",
    "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    "outAmount": "1000000",
    "otherAmountThreshold": "4434914",
    "swapMode": "ExactOut",
    ...
}
 
 3. Set  destinationTokenAccount  in Swap 
 The merchant then retrieves the serialized swap transaction, but the merchant need to specify the  destinationTokenAccount  in the parameters — this will build the swap transaction to swap but send to the  merchant''s specified token account which we defined earlier . 
 The  destinationTokenAccount  should be the merchant’s token account to receive the payment in. Also do note that  customerAccount  should be accounted for.  You can refer to the  Build Swap Transaction  guide for other parameters to be passed in. 
 const swapResponse = await (
    await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
        method: ''POST'',
        headers: {
        ''Content-Type'': ''application/json''
        },
        body: JSON.stringify({
            quoteResponse,
            userPublicKey: customerAccount.publicKey,
            destinationTokenAccount: merchantUSDCTokenAccount.publicKey,
            // trackingAccount: trackingAccount.publicKey,
        })
    })
).json();
 
 4. Prepare Transaction 
 We have walked through the steps here and explained some of the code, you can refer to  Send Swap Transaction - Prepare Transaction . The main difference for payments is to ensure that the customer is the fee payer (the merchant can be generous and be the fee payer too!) and the signer. 
 const transactionBase64 = swapResponse.swapTransaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));
transaction.feePayer = customerAccount.publicKey;
transaction.sign([customerWallet]);
const transactionBinary = transaction.serialize();
 
 5. Send Transaction 
 We have walked through the steps here and explained some of the code, you can refer to  Send Swap Transaction - Send Transaction . The main difference for payments is, you might want to try adjusting  maxRetries  to a higher count as it is not time sensitive and ideally this is used with tighter slippage and ensuring the  inputMint  is not too unstable. 
 Do note that more retries will cause the user to wait slightly longer, so find the balance between the two. Read more here: https://solana.com/docs/advanced/retry. 
 const signature = await connection.sendRawTransaction(transactionBinary, {
    maxRetries: 10,
});
  
const confirmation = await connection.confirmTransaction({ signature }, "finalized");

if (confirmation.value.err) {
    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\nhttps://solscan.io/${signature}/`);
} else console.log(`Transaction successful: https://solscan.io/tx/${signature}/`);
 
 The succeeded Swap Transaction should show: 
 
 Token A swaps from the customer''s token account 
 Token A swap to Token B 
 Token B sends to the merchant''s token account 
 
 If transactions are not landing well, you can refer to this section.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/4-add-fees-to-swap.md', 'sidebar_label: "Add Fees To Swap"
description: "Jupiter Swap API allows you to add fees."
title: "Add Fees To Swap" 

     Add Fees To Swap 
     

 :::info
As of January 2025, when integrating the Swap API, you no longer need to use the Referral Program to set up a  referralAccount  and  referralTokenAccount  to collect fees from the swaps you provide to the end users. 
 Simply, just pass in any valid token account as the  feeAccount  parameter in the Swap API. 
 However, do note that  it is still applicable to the Trigger API .
::: 
 :::note
You can still find information about the Referral Program. 
 The Referral Program is an open source program by Jupiter to provide referral fees for integrators who are integrating Jupiter Swap and Jupiter Limit Order. You can check out the code  here  to gain a better understanding of how it works.
::: 
 Use Case 
 By default, there are  zero  protocol fees on Jupiter Swap. Integrators have the option to introduce a platform fee denoted in basis points, e.g.  20 bps  for  0.2%  of the token input or output. 
 Important Notes 
 
 Input mint or the output mint  on the swap for ExactIn. 
 Input mint ONLY  on the swap for ExactOut. 
 Example, if you swap JUP to USDC, you cannot take fees in SOL, it has to be part of the swap. 
 It does not support Token2022 tokens. 
 Referral Program is no longer required. 
 
 
     
         
             
                 Via Referral Program (Required only for Trigger API) 
             
         
     
 Important Notes 
 
 The Jupiter Swap project account for the Referral Program is  45ruCyfdRkWpRNGEqWzjCiXRHkZs8WXCLQ67Pnpye7Hp . 
 The  referralTokenAccount  can either be:
 
 Input mint or the output mint  on the swap for ExactIn. 
 Input mint ONLY  on the swap for ExactOut. 
 
 
 You can use the  Dashboard ,  SDK  or  API  to set up the  referralAccount  and  referralTokenAccount  in this guide. 
 
 Let’s Get Started 
 1. Set up 
 You will need to complete the prerequisites and understanding of  Environment Setup  and  Get Quote and Swap  guide as this is reliant on the Swap API. 
 Obtain  referralAccount  and  referralTokenAccount 
 There are 3 ways you can set up a referral account. 
 
 Use our  referral dashboard  to create them. After creating, remember to find your  Referral Key  on the page and the associated token accounts. 
 Use our SDK to create them. You can use the  example scripts  to create. 
 Use our API to create them. You can use this  API reference  to create. 
 
 Obtain  mintAccount 
 As for the mint account, assuming you have an interface where a user swaps, you will know up front what are the input or output mints. For the sake of example, we will use a hardcoded mint public key. 
 const referralAccount = new Publickey(''ReplaceWithPubkey'');
const mintAccount = new Publickey(''So11111111111111111111111111111111111111112'');
 
 2. Set your referral fee in Quote 
 Setting your referral fee is simple, just add  platformFeeBps  parameter to the  /quote  endpoint. 
 In this example, we set  platformFeeBps  to  20  which equates to 0.2%. 
 const quoteResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000&slippageBps=50&restrictIntermediateTokens=true&platformFeeBps=20''
    )
  ).json();
  
console.log(JSON.stringify(quoteResponse, null, 2));
 
 3. Set your referral token account in Swap 
 In order to refer and receive fees from all types of tokens, you will need to have already initialize  referralTokenAccount s (owned by your  referralAccount ) for the mint in the swap. By calling the Swap API with the parameter  feeAccount , which is the  referralTokenAccount , you will receive the serialized swap transaction that will set a fee to be taken from the referred and sent to that token account. 
 In this code block, we will be using the SDK to try to find the  referralTokenAccount  based on our previously defined  referralAccount  and  mintAccount . 
 
 If the token account is found, it will proceed to the Swap API. 
 If the token account is not found, it will send a transaction to the network to attempt to initialize one for the mint.  Do note that transactions may fail due to various reasons like Priority Fees. 
 
 import { ReferralProvider } from "@jup-ag/referral-sdk";

const { tx, referralTokenAccountPubKey } = await provider.initializeReferralTokenAccount({
    payerPubKey: wallet.publicKey,
    referralAccountPubKey: referralAccount,
    mint: mintAccount,
});

const referralTokenAccount = await connection.getAccountInfo(referralTokenAccountPubKey);

// Attempt to initialize a token account
if (!referralTokenAccount) {
    const signature = await sendAndConfirmTransaction(connection, tx, [wallet]);
    console.log({ signature, referralTokenAccountPubKey: referralTokenAccountPubKey.toBase58() });

// Since initialized, it will carry on
} else {
    console.log(`referralTokenAccount ${referralTokenAccountPubKey.toBase58()} for mint ${mintAccount.toBase58()} already exists`);
};

const feeAccount = referralTokenAccountPubKey;
console.log(feeAccount);
 
 However, if you are confident that the  referralTokenAccount  for specific mints have been created, you can use this method to get it.  Do note that, even if the token account is not intialized, it will return a pubkey as it is a Program Derived Address.  Read more here. 
 const [feeAccount] = PublicKey.findProgramAddressSync(
    [
        Buffer.from("referral_ata"), // A string that signifies the account type, here "referral_ata."
        referralAccount.toBuffer(), //  The public key of the referral account converted into a buffer.
        mintAccount.toBuffer(), // The mint public key, converted into a buffer.
    ],
    new PublicKey("REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3") // The public key of the Referral Program
);
 
 Using the above, we will now know the  feeAccount  to be passed in as the parameter in Swap API. You can refer to the  Build Swap Transaction  guide to add any parameters where necessary to help transaction sending, etc. 
 const swapResponse = await (
    await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
        method: ''POST'',
        headers: {
        ''Content-Type'': ''application/json''
        },
        body: JSON.stringify({
            quoteResponse,
            userPublicKey: wallet.publicKey.toBase58(), // Pass in actual referred user in production
            feeAccount: feeAccount,
        })
    })
).json();
 
 
 1. Set up 
 You will need to complete the prerequisites and understanding of  Environment Setup  and  Get Quote and Swap  guide as this is reliant on the Swap API. 
 2. Set your fee in Quote 
 Setting your fee is simple, just add  platformFeeBps  parameter to the  /quote  endpoint. 
 In this example, we set  platformFeeBps  to  20  which equates to 0.2%. 
 const quoteResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000&slippageBps=50&restrictIntermediateTokens=true&platformFeeBps=20''
    )
  ).json();
 
 3. Set your feeAccount in Swap 
 In the  /swap  endpoint, you will need to pass in the  feeAccount  parameter. The  feeAccount  is any token account that will receive the fees from the swap. Do ensure that the token account is initialized and is the correct mint to receive the fees in. 
 const swapResponse = await (
    await fetch(''https://api.jup.ag/swap/v1/swap'', {
        method: ''POST'',
        headers: {
        ''Content-Type'': ''application/json''
        },
        body: JSON.stringify({
            quoteResponse,
            userPublicKey: wallet.publicKey, // Pass in actual referred user in production
            feeAccount: feeAccount,
        })
    })
).json();
 
 4. Sign and send transaction 
 Finally, the user can sign the transaction and it can be submitted to the network to be executed. You can refer to the  Send Swap Transaction  guide to complete this step. 
 Create Token Account 
 To create a token account, you can use the following code or refer to  Solana Cookbook . 
 
 The code creates the transaction to create the token account and handles the transaction siging and sending. 
 If the token account already exists, it will not create and might throw an error such as  Provided owner is not allowed . 
 
 import { createAssociatedTokenAccount } from "@solana/spl-token";

const mintPubkey = new PublicKey(
    "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
);

let ata = await createAssociatedTokenAccount(
    connection, // connection
    wallet, // fee payer
    mintPubkey, // mint
    wallet.publicKey, // owner of the token account
    // confirmOptions, // if you need to skip simulation and send the transaction immediately
    // programId, // if you need to use a different token program id such as token-2022
    // associatedTokenProgramId,
    // allowOwnerOffCurve, // if you need to allow the owner to be off curve
);
console.log(`ATA: ${ata.toBase58()}`);', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/7-requote-with-lower-max-accounts.md', 'sidebar_label: "Requote with Lower Max Accounts"
description: "Requote and adjust max accounts via the Swap API."
title: "Requote with Lower Max Accounts" 

     Requote with Lower Max Accounts 
     

 In some cases where you might be limited or require strict control by adding your own instructions to the swap transaction, you might face issues with exceeding transaction size limit. In this section, we will provide some helping code to help you requote when the transaction size is too large. 
 :::note
We provide a  maxAccounts  param in the  /quote  endpoint to allow you to reduce the total number of accounts used for a swap - this will allow you to add your own instructions. 
 Refer to this section for more information and do note its limitations and important notes before using .
::: 
 Example Code 
 
 Request for quote and the swap transaction as per normal. 
 Serialize the transaction. 
 Use the conditions to check if the transaction is too large.
 
 If too large, requote again with lower max accounts - do note that the route will change. 
 If not, sign and send to the network. 
 
 
 
 :::tip
We recommend  maxAccounts  64 and start as high as you can, then incrementally reduce when requoting. 
 Do note that with lower max accounts, it will might yield bad routes or no route at all.
::: 
 :::tip
When you serialize the transaction, you can log the number of raw bytes being used in the transaction. 
 You can either add your custom instructions before or after serializing the transaction.
::: 
 import {
    AddressLookupTableAccount,
    Connection,
    Keypair,
    PublicKey,
    TransactionInstruction,
    TransactionMessage,
    VersionedTransaction,
} from ''@solana/web3.js'';

// Set up dev environment
import fs from ''fs'';
const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/key'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
const connection = new Connection(''your-own-rpc'');

// Recommended
const MAX_ACCOUNTS = 64

async function getQuote(maxAccounts) {
    const params = new URLSearchParams({
        inputMint: ''insert-mint'',
        outputMint: ''insert-mint'',
        amount: ''1000000'',
        slippageBps: ''100'',
        maxAccounts: maxAccounts.toString()
    });

    const url = `https://lite-api.jup.ag/swap/v1/quote?${params}`;
    const response = await fetch(url);
    
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
    }
    
    const quoteResponse = await response.json();
    
    if (quoteResponse.error) {
        throw new Error(`Jupiter API error: ${quoteResponse.error}`);
    }
    
    return quoteResponse;
};

async function getSwapInstructions(quoteResponse) {
    const response = await fetch(''https://lite-api.jup.ag/swap/v1/swap-instructions'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            quoteResponse: quoteResponse,
            userPublicKey: wallet.publicKey.toString(),
            prioritizationFeeLamports: {
                priorityLevelWithMaxLamports: {
                    maxLamports: 10000000,
                    priorityLevel: "veryHigh"
                }
            },
            dynamicComputeUnitLimit: true,
        }, null, 2)
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const swapInstructionsResponse = await response.json();
    
    if (swapInstructionsResponse.error) {
        throw new Error(`Jupiter API error: ${swapInstructionsResponse.error}`);
    }

    return swapInstructionsResponse;
};

async function buildSwapTransaction(swapInstructionsResponse) {
    const {
        computeBudgetInstructions,
        setupInstructions,
        swapInstruction,
        cleanupInstruction,
        addressLookupTableAddresses,
    } = swapInstructionsResponse;
    
    const deserializeInstruction = (instruction) => {
        if (!instruction) return null;
        return new TransactionInstruction({
            programId: new PublicKey(instruction.programId),
            keys: instruction.accounts.map((key) => ({
                pubkey: new PublicKey(key.pubkey),
                isSigner: key.isSigner,
                isWritable: key.isWritable,
            })),
            data: Buffer.from(instruction.data, "base64"),
        });
    };

    const getAddressLookupTableAccounts = async (
        keys
    ) => {
        const addressLookupTableAccountInfos =
            await connection.getMultipleAccountsInfo(
                keys.map((key) => new PublicKey(key))
            );
    
        return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
            const addressLookupTableAddress = keys[index];
            if (accountInfo) {
                const addressLookupTableAccount = new AddressLookupTableAccount({
                    key: new PublicKey(addressLookupTableAddress),
                    state: AddressLookupTableAccount.deserialize(accountInfo.data),
                });
                acc.push(addressLookupTableAccount);
            }
    
            return acc;
        }, []);
    };

    const addressLookupTableAccounts = [];
    addressLookupTableAccounts.push(
        ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))
    );

    const blockhash = (await connection.getLatestBlockhash()).blockhash;

    // Create transaction message with all instructions
    const messageV0 = new TransactionMessage({
        payerKey: wallet.publicKey,
        recentBlockhash: blockhash,
        instructions: [
            ...(computeBudgetInstructions?.map(deserializeInstruction).filter(Boolean) || []),
            ...(setupInstructions?.map(deserializeInstruction).filter(Boolean) || []),
            deserializeInstruction(swapInstruction),
            ...(cleanupInstruction ? [deserializeInstruction(cleanupInstruction)].filter(Boolean) : []),
        ].filter(Boolean),
    }).compileToV0Message(addressLookupTableAccounts);

    const transaction = new VersionedTransaction(messageV0);

    return transaction;
}

async function checkTransactionSize(transaction) {
    // Max raw bytes of a Solana transaction is 1232 raw bytes
    // Using the conditions below, we can check the size of the transaction
    // (or if it is too large to even serialize)
    try {
        const transactionUint8Array = transaction.serialize();
        console.log(transactionUint8Array.length)

        // Use 1232 assuming you have added your instructions to the transaction above
        // If you have not add your instructions, you will need to know how much bytes you might use
        return (transactionUint8Array.length > 1232);

    } catch (error) {
        if (error instanceof RangeError) {
            console.log("Transaction is too large to even serialize (RangeError)");

            return true;

        } else {
            throw error; // Re-throw if it''s not a RangeError
        }
    }
}

// Main execution logic with retry mechanism
let counter = 0;
let transactionTooLarge = true;
let quoteResponse, swapInstructionsResponse, transaction;

while (transactionTooLarge && counter < MAX_ACCOUNTS) {
    try {
        console.log(`Attempting with maxAccounts: ${MAX_ACCOUNTS - counter}`);
        
        quoteResponse = await getQuote(MAX_ACCOUNTS - counter);
        swapInstructionsResponse = await getSwapInstructions(quoteResponse);
        transaction = await buildSwapTransaction(swapInstructionsResponse);
        transactionTooLarge = await checkTransactionSize(transaction);
        
        if (transactionTooLarge) {
            console.log(`Transaction too large (with ${MAX_ACCOUNTS - counter} maxAccounts), retrying with fewer accounts...`);
            counter++;
        } else {
            console.log(`Transaction size OK with ${MAX_ACCOUNTS - counter} maxAccounts`);
        }
        
    } catch (error) {
        console.error(''Error in attempt:'', error);
        counter += 2; // Incrementing by 1 account each time will be time consuming, you can use a higher counter
        transactionTooLarge = true;
    }
}

if (transactionTooLarge) {
    console.error(''Failed to create transaction within size limits after all attempts'');
} else {
    console.log(''Success! Transaction is ready for signing and sending'');
    
    // After, you can add your transaction signing and sending logic
}
 
 Example Response 
 Attempting with maxAccounts: 64
Transaction is too large to even serialize (RangeError)
Transaction too large (with 64 maxAccounts), retrying with fewer accounts...

Attempting with maxAccounts: 63
Transaction is too large to even serialize (RangeError)
Transaction too large (with 63 maxAccounts), retrying with fewer accounts...

...

Attempting with maxAccounts: 57
1244
Transaction too large (with 57 maxAccounts), retrying with fewer accounts...

Attempting with maxAccounts: 56
1244
Transaction too large (with 56 maxAccounts), retrying with fewer accounts...

...

Attempting with maxAccounts: 51
1213
Transaction size OK with 51 maxAccounts
Success! Transaction is ready for signing and sending', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/3-send-swap-transaction.md', 'sidebar_label: "Send Swap Transaction"
description: "Jupiter Swap API helps you to optimize sending transaction to the network."
title: "Send Swap Transaction" 

     Send Swap Transaction 
     

 Transaction sending can be very simple but optimizing for transaction landing can be challenging. This is critical in periods of network congestion when many users and especially bots are competing for block space to have their transactions processed. 
 :::tip Improve Transaction Landing Tip
By using Jupiter Swap API, you can enable Dynamic Slippage, Priority Fee estimation and Compute Unit estimation, all supported on our backend and served directly to you through our API.
::: 
 Let’s Get Started 
 In this guide, we will pick up from where  Get Quote  and  Build Swap Transaction  guide has left off. 
 If you have not set up your environment to use the necessary libraries, the RPC connection to the network and successfully get a quote from the Quote API, please start at  Environment Setup  or  get quote . 
 Prepare Transaction 
 :::info Who is the signer?
The most important part of this step is to sign the transaction. For the sake of the guide, you will be using the file system wallet you have set up to sign and send yourself. 
 However, for other production scenarios such as building your own program or app on top of the Swap API, you will need the user to be the signer which is often through a third party wallet provider, so do account for it.
::: 
 In the previous guide, we are able to get the  swapTransaction  from the Swap API response. However, you will need to reformat it to sign and send the transaction, here are the formats to note of. 
 Formats Description 
 Serialized Uint8array format The correct format to send to the network. 
 Serialized base64 format This is a text encoding of the Uint8array data, meant for transport like our Swap API or storage. You should not sign this directly. 
 Deserialized format This is the human-readable, object-like format before serialization. This is the state you will sign the transaction. 
 
 Here''s the code to deserialize and sign, then serialize. 
 
 swapTransaction  from the Swap API is a serialized transaction in the  base64 format . 
 Convert it to  Uint8array (binary buffer) format . 
 Deserialize it to a  VersionedTransaction  object to sign. 
 Finally, convert it back to  Uint8array  format to send the transaction. 
 
 const transactionBase64 = swapResponse.swapTransaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));
console.log(transaction);

transaction.sign([wallet]);

const transactionBinary = transaction.serialize();
console.log(transactionBinary);
 
 :::tip Blockhash Validity
If you look at the response of  console.log(transaction); , you can see that our backend has already handled the blockhash and last valid block height in your transaction. 
 The validity of a blockhash typically lasts for 150 slots, but you can manipulate this to reduce the validity of a transaction, resulting in faster failures which could be useful in certain scenarios. 
 Read more about transaction expiry here. 
::: 
 Send Transaction 
 Transaction Sending Options 
 Finally, there are a 2  transaction sending options  that we should take note of. Depending on your use case, these options can make a big difference to you or your users. For example, if you are using the Swap API as a payment solution, setting higher  maxRetries  allows the transaction to have more retries as it is not as critical compared to a bot that needs to catch fast moving markets. 
 
     
         
             
                 Transaction Sending Options 
             
         
     
 Options Description 
 maxRetries Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter is not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. 
 skipPreflight If true, skip the preflight transaction checks (default: false). Verify that all signatures are valid. Check that the referenced blockhash is within the last 150 blocks. Simulate the transaction against the bank slot specified by the preflightCommitment. 
 
 
 const signature = await connection.sendRawTransaction(transactionBinary, {
    maxRetries: 2,
    skipPreflight: true
});
 
 Transaction Confirmation 
 In addition, after sending the transaction, it is always a best practice to check the transaction confirmation state, and if not, log the error for debugging or communicating with your users on your interface.  Read more about transaction confirmation tips here. 
 const confirmation = await connection.confirmTransaction({signature,}, "finalized");

if (confirmation.value.err) {
    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\nhttps://solscan.io/tx/${signature}/`);
} else console.log(`Transaction successful: https://solscan.io/tx/${signature}/`);
 
 Swap Transaction Executed! 
 If you have followed the guides step by step without missing a beat, your transaction  should  theoretically land and you can view the link in console log to see the  transaction . 
 Oh? Transaction Not Landing? 
 As the Solana network grew and increased in activity over the years, it has become more challenging to land transactions. There are several factors that can drastically affect the success of your transaction: 
 
 Setting competitive priority fee 
 Setting accurate amount of compute units 
 Managing slippage effectively 
 Broadcasting transaction efficiently 
 Other tips 
 
 How Jupiter Estimates Priority Fee? 
 You can pass in  prioritizationFeeLamports  to Swap API where our backend will estimate the Priority Fee for you. 
 We are using  Triton’s  getRecentPrioritizationFees  to estimate using the local fee market in writable accounts of the transaction (comparing to the global fee market), across the past 20 slots and categorizing them into different percentiles. 
 Read more about Priority Fee here. 
 Parameters Description 
 maxLamports A maximum cap applied if the estimated priority fee is too high. This is helpful when you have users using your application and can be a safety measure to prevent overpaying. 
 global A boolean to choose between using a global or local fee market to estimate. If  global  is set to  false , the estimation focuses on fees relevant to the  writable accounts  involved in the instruction. 
 priorityLevel A setting to choose between the different percentile levels. Higher percentile will have better transaction landing but also incur higher fees. medium : 25th percentile high : 50th percentile veryHigh : 75th percentile 
 
 const swapResponse = await (
  await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
      method: ''POST'',
      headers: {
      ''Content-Type'': ''application/json''
      },
      body: JSON.stringify({
          quoteResponse,
          userPublicKey: wallet.publicKey,
          prioritizationFeeLamports: {
              priorityLevelWithMaxLamports: {
                  maxLamports: 10000000,
                  global: false,
                  priorityLevel: "veryHigh"
              }
          }
      })
  })
).json();
 
 How Jupiter Estimates Compute Unit Limit? 
 You can pass in  dynamicComputeUnitLimit  to Swap API where our backend will estimate the Compute Unit Limit for you. 
 When  true , it allows the transaction to utilize a dynamic compute unit rather than using incorrect compute units which can be detrimental to transaction prioritization. Additionally, the amount of compute unit used and the compute unit limit requested to be used are correlated to the amount of priority fees you pay. 
 Read more about Compute Budget, Compute Unit, etc here. 
 const swapTransaction = await (
  await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey,
      dynamicComputeUnitLimit: true
    })
  })
).json();
 
 How Jupiter Estimates Slippage? 
 Slippage is an unavoidable aspect of trading on decentralized exchanges (DEXes). 
 About Slippage 
 
 Token Pair:  The same fixed slippage setting can have very different effects depending on the tokens involved. For example, swapping between two stablecoins is much less volatile than swapping between two meme coins. 
 Timing:  The time between when you receive a quote and when you actually send the swap transaction matters. Any delay can result in the price moving outside your slippage threshold. 
 Transaction Landing:  How efficiently your transaction lands on-chain also affects slippage. Poorly optimized transactions may experience more slippage. 
 
 :::tip Use Ultra API! 
 
 If you use the Swap API:
 
 You are limited to fixed and dynamic slippage settings. 
 You are responsible for handling slippage and optimizing transaction landing yourself. 
 
 
 Alternatively, consider using the Ultra API :
 
 All of these optimizations are handled for you - without any RPC from you. 
 Additional routing is available to RFQ (Request for Quote) systems like Jupiterz where slippage is not an issue because the market maker fills your order exactly as quoted.
::: 
 
 
 
 Dynamic Slippage 
 Apart from the fixed slippage setting, you can use Dynamic Slippage: During swap transaction building, we will simulate the transaction and estimate a slippage value, which we then factor in the token categories heuristics to get the final slippage value. 
 :::info Dynamic Slippage vs Real Time Slippage Estimator (RTSE)
RTSE is very different from Dynamic Slippage and has provided a much better user experience and results. RTSE is able to intelligently estimate the best possible slippage to use at the time of execution, balancing between trade success and price protection. RTSE uses a variety of heuristics, algorithms and monitoring to ensure the best user experience: 
 
 Heuristics : Token categories, historical and real-time slippage data, and more. 
 Algorithms : Exponential Moving Average (EMA) on slippage data, and more. 
 Monitoring : Real-time monitoring of failure rates to ensure reactiveness to increase slippage when necessary. 
 
 Refer to Ultra API for more information on RTSE .
::: 
 :::warning
To use Dynamic Slippage, you will need to pass in  dynamicSlippage=true  to both the  /swap/v1/quote  and  /swap/v1/swap  endpoints. 
 Do note that we have discontinued development on Dynamic Slippage.
::: 
 const quoteResponse = await (
  await fetch(
    ''https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000000&slippageBps=50&restrictIntermediateTokens=true&dynamicSlippage=true''
  )
).json();

const swapTransaction = await (
  await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey,
      dynamicSlippage: true,
    })
  })
).json();
 
 How Jupiter Broadcast Transactions? 
 Transaction broadcasting is the process of submitting a signed transaction to the network so that validators can verify, process, and include it in a block. 
 Broadcasting Through RPCs 
 After you’ve built and signed your transaction, the signed transaction is serialized into a binary format and sent to the network via a Solana RPC node. The RPC node will verify and relay the transaction to the leader validator responsible for producing the next block. 
 Read more about how RPC nodes broadcast transactions. 
 This is the most typical method to send transactions to the network to get executed. It is simple but you need to make sure the transactions are: 
 
 Send in the serialized transaction format. 
 Use fresh blockhash and last valid blockheight. 
 Use optimal amount of priority fees and compute unit limit. 
 Free of error. 
 Utilize retries. 
 Configure your RPCs
 
 Optional but you can send your transaction to a staked RPC endpoint also known as  Stake-Weighted Quality of Service (SWQoS) . 
 Used dedicated RPC services versus free or shared, depending on how critical your usage is. 
 Propagate to multiple RPC rather than reliant on one. 
 
 
 
 Broadcasting Through Jito 
 To include Jito Tips in your Swap transaction, you can do specify in the Swap API parameters. However, please take note of these when sending your transaction to Jito and  you can find thsese information in their documentation : 
 
 You need to submit to a Jito RPC endpoint for it to work. 
 You need to send an appropriate amount of Jito Tip to be included to be processed. 
 
 :::note More about Jito
You can leverage  Jito  to send transactions via tips for faster inclusion and better outcomes. Similar to Priority Fees, Jito Tips incentivize the inclusion of transaction bundles during block production, enhancing users'' chances of securing critical transactions in competitive scenarios. 
 Additionally, Jito enables bundling transactions to ensure they execute together or not at all, helping protect against front-running and other MEV risks through “revert protection” if any part of the sequence fails, all while reducing transaction latency for timely execution. 
 Read more about how Jito works and other details here. 
::: 
 const swapTransaction = await (
  await fetch(''https://lite-api.jup.ag/swap/v1/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey,
      prioritizationFeeLamports: {
        jitoTipLamports: 1000000 // note that this is FIXED LAMPORTS not a max cap
      }
    })
  })
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/100-swap-api/6-solana-unity-sdk.md', 'sidebar_label: "Swap In Solana Unity SDK"
description: "Use Jupiter Swap API with Solana Unity SDK (C#) to add Swap into your game."
title: "Swap In Solana Unity SDK (C#)" 

     Solana Unity SDK (C#) 
     

 Jupiter is fully supported within the  Solana.Unity-SDK . The core library is independent of Unity and can be incorporated into Unreal Engine using the UnrealCLR library or in a C# backend. 
 Using the Solana.Unity-SDK, game developers can effortlessly incorporate Jupiter swaps into their games and achieve cross-platform compatibility without the need to modify a single line of code. 
 Within the SDK, the Jupiter Swap API can also be used as a  payment method , enabling you to utilize Jupiter + SolanaPay for facilitating user payments with any SPL token, allowing pricing in USDC or other tokens. 
 Documentation 
 For the detailed documentation, please visit:  Solana Unity SDK Jupiter Documentation 
 Demos 
 
 Watch this demo video showcasing an in-game swap powered by the Jupiter integration:  Watch Demo Video 
 Explore a live game demo here:  Live Demo', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/README.md', 'sidebar_position: 1
sidebar_label: "Get Started"
description: "Introduction to Jupiter APIs"
title: "Welcome!" 

     Get Started 
     

 Welcome to Jupiter Developer Documentation! You''ll find detailed API guides, schemas, and powerful tool kits built by the team and DevRel Working Group to help you build with Jupiter. 
 :::tip Breaking Changes
Refer to the  What''s New?  section for the latest API updates and breaking changes.
::: 
 Get Started 
 For new developers or new to blockchain development : We recommend you to start with the  Environment Setup  and  Development Basics  guides. 
 For existing developers : Please refer to the  What''s New?  section for the latest API updates and breaking changes. 
 For routing integrations : Please refer to the  DEX Integration  and  RFQ Integration  guides to complete the prerequisites before we look into integrating. 
 Quick Links  to APIs and Tool Kits: 
 
 Ultra API 
 Swap API 
 Lend API   NEW & BETA! 
 Trigger API 
 Recurring API 
 Token API 
 Price API 
 Send API   NEW & BETA! 
 Studio API   NEW & BETA! 
 Jupiter Plugin   REFRESHED! 
 Unified Wallet Kit 
 
 Reach out to us  on  Discord  for developer support 
 
 If you have any feedback. 
 If you have technical questions. 
 If you need API Portal support. 
 Refer to these channels to receive updates:  Telegram channel  or  Discord channel 
 
 What''s New? 
 :::caution Deprecation of Price API V2 and Token API V1
 Last updated: June 2025 
 Price API upgrades to V3  to support more reliable and timely pricing data - derived by the last swap price (across all transactions) and a set of heuristics to ensure the accuracy of the price and eliminate any outliers. 
 Token API upgrades to V2  to support an easier and reliable usage with new data addition such as  Organic Score , more trading categories like toporganicscore, and more. 
 :::danger ACTION REQUIRED 
 
 If you are using  Price API V2  and  Token API V1 
 Please migrate to their new versions respectively 
 The older version will be deprecated by 1 August 2025
::: 
 
 :::caution API Gateway: Improvements
 Last updated: March 2025 
 Improved API Gateway! 
 For those that have been using the new hostnames at  api.jup.ag/** , we have made improvements to the infrastructure 
 
 Reduced latency in responses and much more consistent now 
 Infrastructure costs reduction (will help us look into reducing costs of the plans with higher rate limits) 
 
 Dual endpoint moving forward. 
 We will be deploying 2 different endpoints, 1 for free usage and 1 for plans with higher rate limits via https://portal.jup.ag/ 
 
 api.jup.ag  will serve only pro/paid users 
 lite-api.jup.ag  will be the endpoint to provide free usage 
 
 :::danger ACTION REQUIRED
 ACTION REQUIRED (only for free usage) 
 
 Migrate to  lite-api.jup.ag   BY 1 MAY 2025 
 The paths remain unchanged, only domain change 
 The same rate limits still apply 
 You do not need an API Key to use the APIs for free 
 If you are still on  api.jup.ag  without an API key, you will get a 401 response 
 
 NO action required for higher rate limit plans via Portal 
 
 Your usage on  api.jup.ag  remains unchanged 
 You can only use  api.jup.ag  with an API Key
::: 
 
 :::caution Trigger API: New Hostname and Breaking Changes
 Last updated: March 2025 
 
 The  /limit/v2  path will be deprecated soon, please update your API calls to use the  /trigger/v1  path immediately. 
 /execute  endpoint is introduced. 
 /createOrder  endpoint now includes an additional  requestId  parameter to be used with the  /execute  endpoint. 
 /cancelOrder  endpoint only builds the transaction for 1 order, while  /cancelOrders  endpoint builds the transaction for multiple orders. 
 The  tx  field in the responses are now  transaction  or  transactions . 
 /getTriggerOrders  endpoint is introduces a new format to get either active or historical orders (based on the query parameters). 
 Please refer to the documentation for usage . 
 
 
     
        Hostname Changes
     
#### Trigger
 Old Hostnames New Hostnames 
 https://api.jup.ag/limit/v2/createOrder https://lite-api.jup.ag/trigger/v1/createOrder 
 https://api.jup.ag/limit/v2/executeOrder https://lite-api.jup.ag/trigger/v1/executeOrder 
 https://api.jup.ag/limit/v2/cancelOrder https://lite-api.jup.ag/trigger/v1/cancelOrder https://lite-api.jup.ag/trigger/v1/cancelOrders 
 https://api.jup.ag/limit/v2/openOrders https://api.jup.ag/limit/v2/orderHistory https://lite-api.jup.ag/trigger/v1/getTriggerOrders 
 
 
:::
 :::caution API Gateway: New Hostnames and API Keys
 Last updated: January 2025 
 
 API will now be served through new hostnames. 
 API will now be served through API keys. 
 API Keys will be distributed via https://portal.jup.ag (Refer to  API Setup  to get started). 
 Old hostnames will be slowly phased out. 
 Old hostnames during this period will have reduced rate limits to facilitate migration to the new API. 
 
 Service Types Description 
 Free with no API key Decreased rate limits to only accommodate for testing. 
 Paid plan with API key Fixed rate limits, self served through an API dashboard. 
 
 
     
        Hostname Changes
     
#### Swap
 Old Hostnames New Hostnames 
 https://quote-api.jup.ag/v6/quote https://lite-api.jup.ag/swap/v1/quote 
 https://quote-api.jup.ag/v6/swap https://lite-api.jup.ag/swap/v1/swap 
 https://quote-api.jup.ag/v6/swap-instructions https://lite-api.jup.ag/swap/v1/swap-instructions 
 https://quote-api.jup.ag/v6/program-id-to-label https://lite-api.jup.ag/swap/v1/program-id-to-label 
 
 Price 
 Old Hostnames New Hostnames 
 https://price.jup.ag/v6 https://lite-api.jup.ag/price/v2 
 
 Token 
 Old Hostnames New Hostnames 
 https://tokens.jup.ag/token/:mint https://lite-api.jup.ag/tokens/v1/token/:mint 
 https://tokens.jup.ag/tokens?tags=:tags https://lite-api.jup.ag/tokens/v1/tagged/:tag 
 https://tokens.jup.ag/tokens_with_markets https://lite-api.jup.ag/tokens/v1/mints/tradable 
 
 
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/800-send-api/invite-code.md', 'sidebar_label: "Invite Code (Beta)"
description: "Use the Jupiter Send API to gift, pay, or onboard anyone in seconds."
title: "Invite Code (Beta)" 

     Invite Code (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/send/v1 
 Pro URL:  https://api.jup.ag/send/v1 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Security 
 The Send API is designed for  transaction building only  - it expects and exchanges parameters such as public keys, amounts, and mint addresses. The API  does not handle private keys or invite codes  for security reasons. 
 All cryptographic operations must be performed client-side: 
 
 Invite code generation 
 Private key derivation from invite codes 
 Transaction signing 
 
 The following sections provide the complete implementation steps required before using the API. 
 :::danger
 CRITICAL SECURITY REQUIREMENTS 
 
 Never share invite codes or private keys  - treat them like passwords or seed phrases 
 Store invite codes securely  - use encrypted storage, secure vaults, or environment variables 
 Validate all inputs  - ensure invite codes meet expected format before processing 
 Implement proper error handling  - avoid exposing sensitive data in logs or error messages 
 
 ⚠️ Loss of funds:  Any exposure of invite codes or private keys may result in permanent loss of funds. Jupiter is not liable for losses due to compromised credentials.
::: 
 Overview 
 
 Create invite code. 
 From utils, derive the secret key - a deterministic 64-byte Solana secret key (32 bytes private + 32 bytes public key). 
 Create Solana Keypair instance from the secret key. 
 Post request to get Send transaction.
 
 If  craft-clawback , requires an additional  invitePDA  to be passed in. 
 
 
 Sign with both sender and recipient keypair, then send transaction and wait for confirmation. 
 
 
     
        Full Utils Code Snippet
     
 import crypto from "crypto";
import * as ed from "@noble/ed25519";
import { sha512 } from "@noble/hashes/sha512";
const hashFunction = (...messages) => sha512(ed.etc.concatBytes(...messages));
ed.etc.sha512Sync = hashFunction;

const { createHash } = await import("node:crypto");

// This function creates a random 12-character base58 invite code
// Uses 13 random bytes (~1.4 quintillion possible codes)
export async function create_invite_code() {
  const buf = crypto.randomBytes(13);

  // 58^12 = 1.449225352 e21
  return binary_to_base58(new Uint8Array(buf)).substring(0, 12);
};

// This function converts an invite code to a deterministic private key
// Uses SHA256 hash of `"invite:"` + `invite_code` as the seed
// Returns a 64-byte Solana keypair (32 bytes private + 32 bytes public key)
export function invite_code_to_priv_key(invite_code) {
  // Hash the invite code with a prefix
  const pre_hash = "invite:" + invite_code;
  const sha = createHash("sha256");
  const priv_key = crypto.createHash("sha256").update(pre_hash).digest();

  // Use ed25519 to get the public key
  const pub_key = ed.getPublicKey(new Uint8Array(priv_key));
  const solana_priv_key = new Uint8Array(64);
  solana_priv_key.set(priv_key);
  solana_priv_key.set(pub_key, 32);

  return solana_priv_key;
};

/////////////////////////////////////////////////////////////////////////////////////
// Taken from https://github.com/pur3miish/base58-js
const base58_chars =
  "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const create_base58_map = () => {
  const base58M = Array(256).fill(-1);
  for (let i = 0; i < base58_chars.length; ++i)
    base58M[base58_chars.charCodeAt(i)] = i;

  return base58M;
};

const base58Map = create_base58_map();
export function binary_to_base58(uint8array) {
  const result = [];

  for (const byte of uint8array) {
    let carry = byte;
    for (let j = 0; j < result.length; ++j) {
      const x = (base58Map[result[j]] << 8) + carry;
      result[j] = base58_chars.charCodeAt(x % 58);
      carry = (x / 58) | 0;
    }
    while (carry) {
      result.push(base58_chars.charCodeAt(carry % 58));
      carry = (carry / 58) | 0;
    }
  }

  for (const byte of uint8array)
    if (byte) break;
    else result.push("1".charCodeAt(0));

  result.reverse();

  return String.fromCharCode(...result);
}

export function base58_to_binary(base58String) {
  if (!base58String || typeof base58String !== "string")
    throw new Error(`Expected base58 string but got “${base58String}”`);
  if (base58String.match(/[IOl0]/gmu))
    throw new Error(
      `Invalid base58 character “${base58String.match(/[IOl0]/gmu)}”`
    );
  const lz = base58String.match(/^1+/gmu);
  const psz = lz ? lz[0].length : 0;
  const size =
    ((base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;

  return new Uint8Array([
    ...new Uint8Array(psz),
    ...base58String
      .match(/.{1}/gmu)
      .map((i) => base58_chars.indexOf(i))
      .reduce((acc, i) => {
        acc = acc.map((j) => {
          const x = j * 58 + i;
          i = x >> 8;
          return x;
        });
        return acc;
      }, new Uint8Array(size))
      .reverse()
      .filter(
        (
          (lastValue) => (value) =>
            (lastValue = lastValue || value)
        )(false)
      ),
  ]);
}
/////////////////////////////////////////////////////////////////////////////////////
 
 
 
     
        Full Usage Code Snippet
     
 import { create_invite_code, invite_code_to_priv_key } from "./utils.js";
import {
  Connection,
  Keypair,
  VersionedTransaction,
} from "@solana/web3.js";
import fs from "fs";

const connection = new Connection(''insert-rpc'');
const senderPrivateKey = JSON.parse(fs.readFileSync(''/Path/to/sender/id.json'', ''utf8'').trim());
const sender = Keypair.fromSecretKey(new Uint8Array(senderPrivateKey));

// STEP 1: Create 12-character invite code
const invite_code = await create_invite_code();

// STEP 2: Derive secret key (public and private key)
const secret_key = invite_code_to_priv_key(invite_code);

// STEP 3: Use secret key to create Solana Keypair instance
const recipient = Keypair.fromSecretKey(secret_key);

// STEP 4: Post request for a Send transaction
const craftSendTransaction = await (
    await fetch (''https://lite-api.jup.ag/send/v1/craft-send'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            inviteSigner: recipient.publicKey.toBase58(),
            sender: sender.publicKey.toBase58(),
            amount: "10000000", // atomic amount before decimals
            // mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // Defaults to SOL if `mint` is not provided
        }, null, 2)
    })
).json();

// STEP 5: Use sender and receipient keypair to sign and send to network
const transaction = VersionedTransaction.deserialize(Buffer.from(craftSendTransaction.tx, ''base64''));
transaction.sign([sender, recipient]); // SIGN with both SENDER and RECIPIENT keypair
const transactionBinary = transaction.serialize();
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "confirmed" });

const signature = await connection.sendRawTransaction(transactionBinary, {
  maxRetries: 0,
  skipPreflight: true,
});

// Log the signature immediately after sending, before confirmation
console.log(`Transaction sent: https://solscan.io/tx/${signature}`);
  
try {
  const confirmation = await connection.confirmTransaction({
    signature,
    blockhash: blockhashInfo.value.blockhash,
    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
  }, "confirmed");

  if (confirmation.value.err) {
    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);
  } else {
    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);
  };
} catch (error) {
  console.error(`Error confirming transaction: ${error}`);
  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);
};
 
 
 Prerequisite 
 Dependencies 
 npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2
npm install dotenv # Useful for testing and handling of invite code and private key
npm install @noble/ed25519
npm install @noble/hashes
 
 Imports 
 Create a utils file to add these functions 
 import crypto from "crypto";
import * as ed from "@noble/ed25519";
import { sha512 } from "@noble/hashes/sha512";
import { PublicKey } from "@solana/web3.js";

// Configure the ed25519 library to use SHA-512 for internal operations
// This is REQUIRED before using any ed25519 functions like getPublicKey()
// The library needs to know which hash function to use for key derivation and signing
const hashFunction = (...messages) => sha512(ed.etc.concatBytes(...messages));
ed.etc.sha512Sync = hashFunction;

// Import createHash function from Node.js crypto module using dynamic import
// This allows us to use the modern ''node:crypto'' protocol for better compatibility
// createHash is used for SHA-256 hashing in the invite code functions
const { createHash } = await import("node:crypto");
 
 Functions 
 Create Invite Code 
 // This function creates a random 12-character base58 invite code
// Uses 13 random bytes (~1.4 quintillion possible codes)
export async function create_invite_code() {
  const buf = crypto.randomBytes(13);

  // 58^12 = 1.449225352 e21
  return binary_to_base58(new Uint8Array(buf)).substring(0, 12);
};
 
 Derive Solana Secret Key 
 // This function converts an invite code to a deterministic private key
// Uses SHA256 hash of `"invite:"` + `invite_code` as the seed
// Returns a 64-byte Solana secret key (32 bytes private + 32 bytes public key)
export function invite_code_to_priv_key(invite_code) {
  // Hash the invite code with a prefix
  const pre_hash = "invite:" + invite_code;
  const sha = createHash("sha256");
  const priv_key = crypto.createHash("sha256").update(pre_hash).digest();

  // Use ed25519 to get the public key
  const pub_key = ed.getPublicKey(new Uint8Array(priv_key));
  const solana_priv_key = new Uint8Array(64);
  solana_priv_key.set(priv_key);
  solana_priv_key.set(pub_key, 32);

  return solana_priv_key;
};
 
 Convert Binary To Base58 
 /////////////////////////////////////////////////////////////////////////////////////
// Taken from https://github.com/pur3miish/base58-js
const base58_chars =
  "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const create_base58_map = () => {
  const base58M = Array(256).fill(-1);
  for (let i = 0; i < base58_chars.length; ++i)
    base58M[base58_chars.charCodeAt(i)] = i;

  return base58M;
};

const base58Map = create_base58_map();
export function binary_to_base58(uint8array) {
  const result = [];

  for (const byte of uint8array) {
    let carry = byte;
    for (let j = 0; j < result.length; ++j) {
      const x = (base58Map[result[j]] << 8) + carry;
      result[j] = base58_chars.charCodeAt(x % 58);
      carry = (x / 58) | 0;
    }
    while (carry) {
      result.push(base58_chars.charCodeAt(carry % 58));
      carry = (carry / 58) | 0;
    }
  }

  for (const byte of uint8array)
    if (byte) break;
    else result.push("1".charCodeAt(0));

  result.reverse();

  return String.fromCharCode(...result);
}

export function base58_to_binary(base58String) {
  if (!base58String || typeof base58String !== "string")
    throw new Error(`Expected base58 string but got “${base58String}”`);
  if (base58String.match(/[IOl0]/gmu))
    throw new Error(
      `Invalid base58 character “${base58String.match(/[IOl0]/gmu)}”`
    );
  const lz = base58String.match(/^1+/gmu);
  const psz = lz ? lz[0].length : 0;
  const size =
    ((base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;

  return new Uint8Array([
    ...new Uint8Array(psz),
    ...base58String
      .match(/.{1}/gmu)
      .map((i) => base58_chars.indexOf(i))
      .reduce((acc, i) => {
        acc = acc.map((j) => {
          const x = j * 58 + i;
          i = x >> 8;
          return x;
        });
        return acc;
      }, new Uint8Array(size))
      .reverse()
      .filter(
        (
          (lastValue) => (value) =>
            (lastValue = lastValue || value)
        )(false)
      ),
  ]);
}
/////////////////////////////////////////////////////////////////////////////////////', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/800-send-api/craft-send.md', 'sidebar_label: "Craft Send (Beta)"
description: "Use the Jupiter Send API to gift, pay, or onboard anyone in seconds."
title: "Craft Send (Beta)" 

     Craft Send (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/send/v1 
 Pro URL:  https://api.jup.ag/send/v1 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Overview 
 
 Create invite code. 
 From utils, derive the secret key - a deterministic 64-byte Solana secret key (32 bytes private + 32 bytes public key). 
 Create Solana Keypair instance from the secret key. 
 Post request to get Send transaction. 
 Sign with both sender and recipient keypair, then send transaction and wait for confirmation. 
 
 :::note
 Please ensure that you have set up the prerequisites .
::: 
 
     
        Full Code Snippet
     
 import { create_invite_code, invite_code_to_priv_key } from "./utils.js";
import {
  Connection,
  Keypair,
  VersionedTransaction,
} from "@solana/web3.js";
import fs from "fs";

const connection = new Connection(''insert-rpc'');
const senderPrivateKey = JSON.parse(fs.readFileSync(''/Path/to/sender/id.json'', ''utf8'').trim());
const sender = Keypair.fromSecretKey(new Uint8Array(senderPrivateKey));

// STEP 1: Create 12-character invite code
const invite_code = await create_invite_code();

// STEP 2: Derive secret key (public and private key)
const secret_key = invite_code_to_priv_key(invite_code);

// STEP 3: Use secret key to create Solana Keypair instance
const recipient = Keypair.fromSecretKey(secret_key);

// STEP 4: Post request for a Send transaction
const craftSendTransaction = await (
    await fetch (''https://lite-api.jup.ag/send/v1/craft-send'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            inviteSigner: recipient.publicKey.toBase58(),
            sender: sender.publicKey.toBase58(),
            amount: "10000000", // atomic amount before decimals
            // mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // Defaults to SOL if `mint` is not provided
        }, null, 2)
    })
).json();

// STEP 5: Use sender and receipient keypair to sign and send to network
const transaction = VersionedTransaction.deserialize(Buffer.from(craftSendTransaction.tx, ''base64''));
transaction.sign([sender, recipient]); // SIGN with both SENDER and RECIPIENT keypair
const transactionBinary = transaction.serialize();
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "confirmed" });

const signature = await connection.sendRawTransaction(transactionBinary, {
  maxRetries: 0,
  skipPreflight: true,
});

// Log the signature immediately after sending, before confirmation
console.log(`Transaction sent: https://solscan.io/tx/${signature}`);
  
try {
  const confirmation = await connection.confirmTransaction({
    signature,
    blockhash: blockhashInfo.value.blockhash,
    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
  }, "confirmed");

  if (confirmation.value.err) {
    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);
  } else {
    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);
  };
} catch (error) {
  console.error(`Error confirming transaction: ${error}`);
  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);
};
 
 
 Imports 
 import { create_invite_code, invite_code_to_priv_key } from "./utils.js";
import {
  Connection,
  Keypair,
} from "@solana/web3.js";
import fs from "fs";

const connection = new Connection(''insert-rpc'');
const senderPrivateKey = JSON.parse(fs.readFileSync(''/Path/to/sender/id.json'', ''utf8'').trim());
const sender = Keypair.fromSecretKey(new Uint8Array(senderPrivateKey));
 
 Create Invite Code 
 // STEP 1: Create 12-character invite code
const invite_code = await create_invite_code();

// STEP 2: Derive secret key (public and private key)
const secret_key = invite_code_to_priv_key(invite_code);

// STEP 3: Use secret key to create Solana Keypair instance
const recipient = Keypair.fromSecretKey(secret_key);
 
 Craft Send 
 :::note API Params 
 
 The  amount  is in its atomic value before applying decimals, e.g. 1 USDC is 1_000_000. 
 The  mint  defaults to SOL if not provided, if provided it can be any token mint.
::: 
 
 :::note Signing and sending 
 
 After getting the transaction, you need to sign with  both sender and recipient  keypair. 
 You can send the transaction to the network via any method.
::: 
 
 // STEP 4: Post request for a Send transaction
const craftSendTransaction = await (
    await fetch (''https://lite-api.jup.ag/send/v1/craft-send'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            inviteSigner: recipient.publicKey.toBase58(),
            sender: sender.publicKey.toBase58(),
            amount: "10000000",
            // mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        }, null, 2)
    })
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/800-send-api/README.md', 'sidebar_label: "About Send API"
description: "Use the Jupiter Send API to invite and send funds seamlessly!"
title: "About Send API" 

     Send API 
     

 Send is the perfect onboarding tool to gift, pay, or onboard anyone in seconds - even if they don''t have a wallet. 
 
 Send any token - SOL, USDC or memecoins. 
 Send to a new user without a wallet, existing user or anyone. 
 No fees to send or claim, only network transaction fees required. 
 Use Jupiter Mobile seamlessly - even if you sent non-SOL tokens, Ultra provides Gasless Support that pays for swap transaction fees. 
 
 About 
 Send API provides more opportunities for potential users to be onboarded from other websites, apps, or any where else! 
 
 API only supports creating Send and Clawback transactions. 
 Claiming needs to be done via Jupiter Mobile only. 
 You can gamify the experience post-claim once they are onboarded! 
 
 Jupiter Mobile Adapter 
 To maximize users experience, once your users have claimed via Jupiter Mobile, they can use the app to continue their journey on your app or other use cases. This can be done via  Jupiter Mobile Adapter , allowing Jupiter Mobile users to simply use the app to scan a QR code to login, they can utilize their wallets on Jupiter Mobile across any platform. 
 FAQ 
 How to does claim work? 
 
 The invite code can be in the format of a link or a QR code. 
 
 How to claim via API or on my own app? 
 
 No, Send claims should be done in Jupiter Mobile. 
 
 Can I get my funds back? 
 
 Send is end-to-end self-custodial, where if recipient never claims, the invite code becomes invalid and your tokens are sent back to you upon expiry. 
 Or use the clawback endpoint via the API to create the clawback transaction.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/800-send-api/craft-clawback.md', 'sidebar_label: "Craft Clawback (Beta)"
description: "Use the Jupiter Send API to gift, pay, or onboard anyone in seconds."
title: "Craft Clawback (Beta)" 

     Craft Clawback (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/send/v1 
 Pro URL:  https://api.jup.ag/send/v1 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Overview 
 
 Load invite code. 
 Load public key from invite. 
 Find the  Program Derived Address (PDA)  of the invite.
 
 Uses  "invite"  and the public key of recipient at seed. 
 
 
 Post request to get Clawback transaction. 
 Sign with sender keypair, then send transaction and wait for confirmation. 
 
 :::note
 Please ensure that you have set up the prerequisites .
::: 
 
     
        Full Code Snippet
     
 import { invite_code_to_priv_key } from "./utils.js";
import {
  Connection,
  Keypair,
  PublicKey,
  VersionedTransaction,
} from "@solana/web3.js";
import fs from "fs";

const connection = new Connection(''insert-rpc'');
const senderPrivateKey = JSON.parse(fs.readFileSync(''/Path/to/sender/id.json'', ''utf8'').trim());
const sender = Keypair.fromSecretKey(new Uint8Array(senderPrivateKey));
process.loadEnvFile(''.env'');

// STEP 1: Load invite code
const invite_code = process.env.INVITE_CODE;

// STEP 2: Load the public key from the invite code
const secret_key = invite_code_to_priv_key(invite_code);
const pubkey = Keypair.fromSecretKey(secret_key).publicKey;

// STEP 3: Find the Program Derived Address (PDA) for the invite
// Uses `"invite"` as seed + the public key
// PDAs are deterministic addresses owned by the program
const invite_pda = PublicKey.findProgramAddressSync(
    [Buffer.from("invite"), pubkey.toBuffer()],
    new PublicKey("inv1tEtSwRMtM44tbvJGNiTxMvDfPVnX9StyqXfDfks")
  )[0];

// STEP 4: Post request for a Clawback transaction
const craftClawbackTransaction = await (
    await fetch (''https://lite-api.jup.ag/send/v1/craft-clawback'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            invitePDA: invite_pda.toBase58(),
            sender: sender.publicKey.toBase58(),
        }, null, 2)
    })
).json();

// STEP 5: Use sender keypair to sign and send to network
const transaction = VersionedTransaction.deserialize(Buffer.from(craftClawbackTransaction.tx, ''base64''));
transaction.sign([sender]); // SIGN with SENDER
const transactionBinary = transaction.serialize();
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "confirmed" });

const signature = await connection.sendRawTransaction(transactionBinary, {
  maxRetries: 0,
  skipPreflight: true,
});

// Log the signature immediately after sending, before confirmation
console.log(`Transaction sent: https://solscan.io/tx/${signature}`);
  
try {
  const confirmation = await connection.confirmTransaction({
    signature,
    blockhash: blockhashInfo.value.blockhash,
    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
  }, "confirmed");

  if (confirmation.value.err) {
    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);
  } else {
    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);
  }
} catch (error) {
  console.error(`Error confirming transaction: ${error}`);
  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);
}
 
 
 Imports 
 import { invite_code_to_priv_key } from "./utils.js";
import {
  Connection,
  Keypair,
  PublicKey,
  VersionedTransaction,
} from "@solana/web3.js";
import fs from "fs";

const connection = new Connection(''insert-rpc'');
const senderPrivateKey = JSON.parse(fs.readFileSync(''/Path/to/sender/id.json'', ''utf8'').trim());
const sender = Keypair.fromSecretKey(new Uint8Array(senderPrivateKey));
process.loadEnvFile(''.env'');
 
 Invite Code and Public Key 
 // STEP 1: Load invite code
const invite_code = process.env.INVITE_CODE;

// STEP 2: Load the public key from the invite code
const secret_key = invite_code_to_priv_key(invite_code); // Follow the utils.js guide
const pubkey = Keypair.fromSecretKey(secret_key).publicKey;
 
 Invite PDA 
 // STEP 3: Find the Program Derived Address (PDA) for the invite
// Uses `"invite"` as seed + the public key
// PDAs are deterministic addresses owned by the program
const invite_pda = PublicKey.findProgramAddressSync(
    [Buffer.from("invite"), pubkey.toBuffer()],
    new PublicKey("inv1tEtSwRMtM44tbvJGNiTxMvDfPVnX9StyqXfDfks")
  )[0];
 
 Craft Clawback 
 :::note
The clawback will return the full amount including leftover transaction fees and/or rent back to the sender.
::: 
 // STEP 4: Post request for a Clawback transaction
const craftClawbackTransaction = await (
    await fetch (''https://lite-api.jup.ag/send/v1/craft-clawback'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            invitePDA: invite_pda.toBase58(),
            sender: sender.publicKey.toBase58(),
        }, null, 2)
    })
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/800-send-api/manage-invites.md', 'sidebar_label: "Manage Invites (Beta)"
description: "Use the Jupiter Send API to manage invites."
title: "Manage Invites (Beta)" 

     Manage Invites (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/send/v1 
 Pro URL:  https://api.jup.ag/send/v1 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Overview 
 
 Get pending invites. 
 Get invite history. 
 
 :::note
Both of the following endpoints only returns the invites that are set up by the sender and not from the perspective of the recipient. 
 
 Pending invites: Invites created by the sender that are not yet expired and can be clawback/claimed. 
 Invite history: Invites created by the sender and is either claimed, clawback, or expired. (You can also pass in a Recipient pubkey to get their history)
::: 
 
 :::tip
Depending on how you have set up to allow connection of wallets, either via  Jupiter Mobile Adapter  for QR code login, wallet extensions, or any other methods, you will need to handle the passing in of their pubkey to the API to get the necessary data.
::: 
 Get Pending Invites 
 const pendingInvites = await (
  await fetch(
    `https://lite-api.jup.ag/send/v1/pending-invites?address=${pubkey}`
  )
).json();
 
 Get Invite History 
 const inviteHistory = await (
  await fetch(
    `https://lite-api.jup.ag/send/v1/invite-history?address=${pubkey}`
  )
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/4-api-responses.md', 'sidebar_label: "API Responses"
description: "API responses for the Jupiter API."
title: "API Responses"
displayed_sidebar: docs 

     API Responses 
     

 In this section, you can find the list of responses that can be returned by the Jupiter API. 
 :::info Program Errors
For more information on error codes from programs, see the  Swap API - Common Errors .
::: 
 Common Codes Description Debug 
 200 Good Success! 
 400 Bad Request Likely a problem with the request, check the request parameters, syntax, etc. 
 401 Unauthorized Likely a problem with the API key, check if the API key is correct. 
 404 Not Found Likely a broken or invalid endpoint. 
 429 Rate Limited You are being rate limited. Either slow down requests, reduce bursts, or upgrade your plan. 
 500 Internal Server Error Please reach out in  Discord . 
 502 Bad Gateway Please reach out in  Discord . 
 503 Service Unavailable Please reach out in  Discord . 
 504 Gateway Timeout Please reach out in  Discord .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/999-studio-api/2-claim-fee.md', 'sidebar_label: ''Claim Fee (Beta)''
description: ''Claim creator trading fees via Jupiter Studio API.''
title: ''Claim Fee (Beta)'' 

     Claim Fee (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/studio/v1 : 100 requests per 5 minutes 
 Pro URL:  https://api.jup.ag/studio/v1 : 10 requests per 10 seconds (for all Tiers) 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::tip API Reference
To fully utilize the Studio API, check out the  Studio API Reference .
::: 
 Prerequisite 
 
     
         
             
                 Dependencies 
             
         
     
 npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2
npm install dotenv # If required for wallet setup
 
 
 
     
         
             
                 RPC 
             
         
     
 Set up RPC 
 :::note
Solana provides a  default RPC endpoint . However, as your application grows, we recommend you to always use your own or provision a 3rd party provider’s RPC endpoint such as  Helius  or  Triton .
::: 
 import { Connection } from ''@solana/web3.js'';
const connection = new Connection(''https://api.mainnet-beta.solana.com'');
 
 
 
     
         
             
                 Wallet 
             
         
     
 Set up Development Wallet 
 :::note 
 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 If you want to store your private key in the project directly, you can do it via a  .env  file.
::: 
 
 To set up a development wallet via  .env  file, you can use the following script. 
 // index.js
import { Keypair } from ''@solana/web3.js'';
import dotenv from ''dotenv'';
require(''dotenv'').config();

const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ''''));
 
 # .env
PRIVATE_KEY=''''
 
 To set up a development wallet via a wallet generated via  Solana CLI , you can use the following script. 
 import { Keypair } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/To/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
 
 
 
     
         
             
                 Transaction Sending Example 
             
         
     
 transaction.sign([wallet]);
const transactionBinary = transaction.serialize();
console.log(transactionBinary);
console.log(transactionBinary.length);
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: ''finalized'' });

const signature = await connection.sendRawTransaction(transactionBinary, {
  maxRetries: 0,
  skipPreflight: true,
});

console.log(`Transaction sent: https://solscan.io/tx/${signature}`);
  
try {
  const confirmation = await connection.confirmTransaction({
    signature,
    blockhash: blockhashInfo.value.blockhash,
    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
  }, ''confirmed'');

  if (confirmation.value.err) {
    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);
  } else {
    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);
  }
} catch (error) {
  console.error(`Error confirming transaction: ${error}`);
  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);
};
 
 
 Pool Address 
 Your successfully created token via Jupiter Studio, should have a newly generated token mint. By using the mint, you can get the config key and pool addresses associated to it: Dynamic Bonding Curve pool and Meteora DAMM V2 pool. 
 const poolAddressResponse = await (
    await fetch(
      `https://lite-api.jup.ag/studio/v1/dbc-pool/addresses/${mint}`,
    )
).json();
 
 Fee 
 Using the Pool Address, you will be able to get the total and current unclaimed fees in the Dynamic Bonding Curve pool. 
 const feeResponse = await (
    await fetch (
      ''https://lite-api.jup.ag/studio/v1/dbc/fee'', 
      {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            poolAddress: poolAddressResponse.data.dbcPoolAddress,
        }, null, 2)
    })
).json();
 
 Claim Fee 
 In order to claim fees from a Dynamic Bonding Curve pool, you will need to pass in the pool address into this endpoint and we will create the Claim Fee transaction for you. After receiving the transaction, you will need to sign and submit the transaction to the network on your own ( refer to Transaction Sending Example above ). 
 const claimTransaction = await (
    await fetch (
      ''https://lite-api.jup.ag/studio/v1/dbc/fee/create-tx'', 
      {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            ownerWallet: wallet.publicKey.toBase58(),
            poolAddress: poolAddressResponse.data.dbcPoolAddress,
            maxQuoteAmount: 1000000, // e.g. 1 USDC (depending on quote mint and decimals)
        }, null, 2)
    })
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/999-studio-api/README.md', 'sidebar_label: "About Studio API"
description: "Use the Jupiter Studio API launch tokens on Meteora Dynamic Bonding Curve."
title: "Studio API" 

     Studio API 
     

 Studio is built for culture architects who want: 
 
 Aggressive experimentation. 
 Tools for growth and alignment. 
 Collaborative and supportive vibe culture between Studio projects. 
 
 About 
 Studio is a powerful playground equipped with a suite of tools for creators. Each feature is strategic towards how creators might want to customize to fit their needs - like flexible bonding curves, custom vesting schedules, and selectable quote mints to encode your vision. 
 Features 
 
 LP Fees: 50% before AND after graduation. 
 LP Locking: Optional 50% of the graduated LP unlocks after 1 year. 
 Vested Tokens: 0 - 80% of token supply, with optional vesting schedule and cliff. 
 Flexible parameters: Quote mint, Market cap bonding, etc. 
 Other helpful tools: Anti-sniper suite, Lp Locking. 
 
 Dedicated Studio Token Page 
 Apart from the strategic levers, start rallying your community with the dedicated Studio page with seamless content integration with jup.ag''s token page. 
 
 Dedicated Studio page for each token. 
 Content from Studio shows up in jup.ag''s token page. 
 
 :::note Readings 
 
 Design intentions: https://x.com/9yointern/status/1940431614103937517 
 Launch post: https://x.com/jup_studio/status/1940620377602011566 
 General FAQ: https://support.jup.ag/hc/en-us/categories/21148110700060-Studio
::: 
 
 FAQ 
 Why is my Studio token page showing "Token not found"? 
 
 In order for us to track and store your token information, header image or token description, you  must  send your signed transaction from the  create_tx  endpoint to the  submit  endpoint. 
 This will allow us to store your token into our database and reflect it as a Studio token on our frontend. 
 If you submit the transaction on your own or some other way, the token will not have a dedicated Studio page. 
 
 What do I do with the presigned URLs? 
 
 Those URLs are for you to upload your token''s metadata and image to a static endpoint, which will be in the token''s URI metadata onchain. 
 You are required to make a PUT request to those endpoints,  you can refer to this section on the usage . 
 If you do not upload your token image and metadata to this endpoint, your token will not have any image/metadata reflected onchain. 
 
 What is the rate limit of Studio API? 
 
 Lite URL:  https://lite-api.jup.ag/studio/v1 : 100 requests per 5 minutes 
 Pro URL:  https://api.jup.ag/studio/v1 : 10 requests per 10 seconds (for all Tiers)', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/999-studio-api/1-create-token.md', 'sidebar_label: ''Create Token (Beta)''
description: ''Create and launch tokens on Jupiter Studio via API.''
title: ''Create Token (Beta)'' 

     Create Token (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/studio/v1 : 100 requests per 5 minutes 
 Pro URL:  https://api.jup.ag/studio/v1 : 10 requests per 10 seconds (for all Tiers) 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::tip API Reference
To fully utilize the Studio API, check out the  Studio API Reference .
::: 
 Prerequisite 
 
     
         
             
                 Dependencies 
             
         
     
 npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2
npm install dotenv # If required for wallet setup
 
 
 
     
         
             
                 Wallet 
             
         
     
 Set up Development Wallet 
 :::note 
 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 If you want to store your private key in the project directly, you can do it via a  .env  file.
::: 
 
 To set up a development wallet via  .env  file, you can use the following script. 
 // index.js
import { Keypair } from ''@solana/web3.js'';
import dotenv from ''dotenv'';
require(''dotenv'').config();

const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ''''));
 
 # .env
PRIVATE_KEY=''''
 
 To set up a development wallet via a wallet generated via  Solana CLI , you can use the following script. 
 import { Keypair } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/To/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
 
 
 Create Transaction 
 This endpoint helps you create a few key components to launch your token on Studio. 
 
 transaction : A base64-encoded unsigned transaction. 
 mint : The mint of the token that is being created. 
 imagePresignedUrl : A  PUT  request endpoint to upload your token image. 
 metadataPresignedUrl : A  PUT  request endpoint to upload your token metadata. 
 imageUrl : The token''s static image url to be used in the metadata. 
 
 :::tip Presets
On https://jup.ag/studio, you can find a few different presets to get you started. 
 
     
         
             
                 Meme 
             
         
     
**Great for memes, similar profile to traditional meme launches.**
- People begin buying your token at 16K Market Cap (MC) in USDC.
- It graduates to a Meteora pool at 69K MC.
- Your pool raises ~17.94K USDC before graduation.
 buildCurveByMarketCapParam: {
    quoteMint: ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'',
    initialMarketCap: 16000,
    migrationMarketCap: 69000,
    tokenQuoteDecimal: 6,
    lockedVestingParam: {
        totalLockedVestingAmount: 0,
        cliffUnlockAmount: 0,
        numberOfVestingPeriod: 0,
        totalVestingDuration: 0,
        cliffDurationFromMigrationTime: 0,
    },
},
antiSniping: false,
fee: {
    feeBps: 100,
},
isLpLocked: true,
tokenName: '''',
tokenSymbol: '''',
tokenImageContentType: ''image/jpeg'',
creator: wallet.publicKey.toBase58(),
 
 
 
     
         
             
                 Indie 
             
         
     
**For projects ready to take it up a notch. More capital required to bond, but you''ll have deeper liquidity and more LP fees when you graduate.**
- People begin buying your token at 32k Market Cap (MC) in USDC.
- It graduates to a Meteora pool at 240k MC.
- Your pool raises ~57.78K USDC before graduation.
- 10% of total supply will be vested daily over 12 months.
 buildCurveByMarketCapParam: {
    quoteMint: ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'',
    initialMarketCap: 32000,
    migrationMarketCap: 240000,
    tokenQuoteDecimal: 6,
    lockedVestingParam: {
        totalLockedVestingAmount: 100000000,
        cliffUnlockAmount: 0,
        numberOfVestingPeriod: 365,
        totalVestingDuration: 31536000,
        cliffDurationFromMigrationTime: 0,
    },
},
antiSniping: true,
fee: {
    feeBps: 100,
},
isLpLocked: true,
tokenName: '''',
tokenSymbol: '''',
tokenImageContentType: ''image/jpeg'',
creator: wallet.publicKey.toBase58(),
 
 
 
     
         
             
                 Custom 
             
         
     
Just pass in the parameters you need!
 
:::
 const createTransaction = await (
    await fetch (
      ''https://lite-api.jup.ag/studio/v1/dbc-pool/create-tx'', 
      {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            buildCurveByMarketCapParam: {
                quoteMint: ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'', // or SOL or JUP
                initialMarketCap: 16000, // This means 16_000 USDC
                migrationMarketCap: 69000, // This means 69_000 USDC
                tokenQuoteDecimal: 6,
                lockedVestingParam: {
                    totalLockedVestingAmount: 0,
                    cliffUnlockAmount: 0,
                    numberOfVestingPeriod: 0,
                    totalVestingDuration: 0,
                    cliffDurationFromMigrationTime: 0,
                },
            },
            antiSniping: true,
            fee: {
                feeBps: 100,
            },
            isLpLocked: true,
            tokenName: '''',
            tokenSymbol: '''',
            tokenImageContentType: ''image/jpeg'',
            creator: wallet.publicKey.toBase58(),
        }, null, 2)
    })
).json();
 
 Token Metadata 
 The following 2 steps, are to upload your token image and metadata to the  static URL , which will be the URI in the onchain metadata of your token. 
 Example 
 
 URI/ Off-chain Metadata:  https://static-create.jup.ag/metadata/{mint}.json 
 Image:  https://static-create.jup.ag/images/{mint} 
 
 You can refer to this to understand Token Metadata on Solana: https://developers.metaplex.com/token-metadata 
 Upload Image 
 From the response of the  create-tx  endpoint, we will need the  imagePresignedUrl  to make a  PUT  request  to the url provided, in order to upload the token image. 
 const imageResponse = await fetch(createTransaction.imagePresignedUrl, {
    method: ''PUT'',
    headers: {
        ''Content-Type'': ''image/jpeg'', // Adjust based on the image type passed in previously
    },
    body: fs.readFileSync(''./token.jpeg''), // Assuming the image file is located in the same folder
});
 
 Upload Metadata 
 From the response of the  create-tx  endpoint, we will need the  metadataPresignedUrl  to make a  PUT  request  to the url provided, in order to upload the token metadata. 
 const metadataResponse = await fetch(createTransaction.metadataPresignedUrl, {
    method: ''PUT'',
    headers: {
        ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
        name: '''',
        symbol: '''',
        description: '''',
        image: createTransaction.imageUrl,
        website: '''',
        twitter: '''',
        telegram: '''',
    }, null, 2),
});
 
 Submit Transaction 
 After you have uploaded your token image and token metadata, you can proceed to signing and making a post request to the  submit  endpoint - this will allow Jupiter Studio to complete the transaction and submit it to the network on your behalf. 
 :::note 
 
 Do note that the endpoint expects the  requestBody ''s  content  to be in  multipart/form-data  format . 
 Ensure the file types and size of the image file is manageable.
::: 
 
 :::note
The  content  and  headerImage  refers to the Studio dedicated page''s token description and header image of the page, they are not on-chain metadata. This is meant for you to customize the Studio dedicated page as you wish - to include lore, story or just a nice looking banner! 
 The  content  and  headerImage  are stored off-chain for our frontend to ingest and display. 
 Do not confuse this with the uploading of token metadata, they are done separately. 
::: 
 import { VersionedTransaction } from ''@solana/web3.js'';
import fs from ''fs'';

const transaction = VersionedTransaction.deserialize(Buffer.from(createTransaction.transaction, ''base64''));
transaction.sign([wallet]);
const signedTransaction = Buffer.from(transaction.serialize()).toString(''base64'');

const formData = new FormData();
formData.append(''transaction'', signedTransaction);
formData.append(''owner'', wallet.publicKey.toBase58());
formData.append(''content'', '''');
formData.append(
    ''headerImage'',
    new File(
        [fs.readFileSync(''/Path/to/header.jpeg'')],
        ''header.jpeg'',
        { type: ''image/jpeg'' },
    )
);

const result = await (
    await fetch (
      ''https://lite-api.jup.ag/studio/v1/dbc-pool/submit'', 
      {
        method: ''POST'',
        body: formData,
    })
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/500-price-api/v3.md', 'sidebar_label: "V3 (Beta)"
description: "Get price data of tokens via Price API V3."
title: "Price API V3 (Beta)" 

     Price API V3 
     

 Price API V3 aims to provide a one source of truth across all Jupiter UIs and integrator platforms. The simplified format allows easy integration while letting Jupiter handle the complexity of ensuring the accuracy of the provided prices. 
 :::note 
 
 Lite URL:  https://lite-api.jup.ag/price/v3 
 Pro URL:  https://api.jup.ag/price/v3 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::info
This is in Beta and subject to changes, if you need help please reach out to us in  Discord 
::: 
 How Price is Derived 
 Price API V3 price tokens by using the  last swapped price (across all transactions) . The swaps are priced by working outwards from a small set of reliable tokens (like SOL) whose price we get from external oracle sources. 
 While and also after deriving the last swap price, we also utilize a number of heuristics to ensure the accuracy of the price and eliminate any outliers: 
 
 Asset origin and launch method 
 Market liquidity metrics 
 Market behaviour patterns 
 Holder distribution statistics 
 Trading activity indicators 
 Organic Score 
 
 Get Price 
 Simply request via the base URL with the query parameters of your desired mint addresses. You can also comma-separate them to request for multiple prices. 
 const price = await (
    await fetch(
        ''https://lite-api.jup.ag/price/v3?ids=So11111111111111111111111111111111111111112,JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN''
    )
).json();
console.log(JSON.stringify(price, null, 2));
 
 Price Response 
 Here is the sample response, notice a few details here: 
 
 The  usdPrice  is the only price. 
 The  decimals  response is helpful to display price information on the UI. 
 The  blockId  can be used to verify the recency of the price. 
 
 {
  "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
    "usdPrice": 0.4056018512541055,
    "blockId": 348004026,
    "decimals": 6,
    "priceChange24h": 0.5292887924920519
  },
  "So11111111111111111111111111111111111111112": {
    "usdPrice": 147.4789340738336,
    "blockId": 348004023,
    "decimals": 9,
    "priceChange24h": 1.2907622140620008
  }
}
 
 Limitations 
 Query limits 
 
 You can query up to 50  ids  at once. 
 
 If the price of a token cannot be found 
 
 Typically, it is likely that the token has not been traded recently - in the last 7 days. 
 Additionally, we also use the aforementioned heuristics to determine the price of a token and if the price is reliable - if certain combinations of these factors indicate potential issues with price reliability or market health, the token will be flagged and not provided a price. 
 The token is flagged as suspicious and this can be cross referenced with the Token API V2''s  audit.isSus  field. 
 
 V2 had more information 
 
 Yes V2 had more information, however, we think that it is not the best representation of price and it also caused different interpretations of price across the different platforms. 
 With Price API V3, we are handling the complexities to ensure price accuracy and elimate outliers  using the heuristics as mentioned above , so there will only be one stable and accurate price source for all. 
 If you require more information like Price API V2, you can use the  /quote  endpoint of the Swap API to derive those data ( you can refer to this post about how Price API V2 is derived ).', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/500-price-api/v2.md', 'sidebar_label: "V2 (Deprecated)"
description: "Deprecated version of Price API (V2)."
title: "Price API V2 (Deprecated)" 

     Price API V2 (Deprecated) 
     

 :::danger DEPRECATED
This version of the Price API V2 will be/is deprecated by 1 August 2025. 
 Please migrate to  Price API V3  which consists of breaking changes.
::: 
 Price API V2 aims to enhance accuracy by incorporating both  buy  and  sell-side liquidity  to derive the  average price  of the two. This provides more reliable real-time data for SPL tokens. Additionally, V2 provides extra help information like depth and confidence to aid you or your users with decisions. 
 :::tip
The prices are derived  from Jupiter Swap , which is an aggregate of most markets on Solana.
::: 
 Let’s Get Started 
 In this guide, we will be going through the simple price responses and the extra help information. 
 Get Price (Only Price) 
 Using the root URL and parameters to pass in, it is as simple as the example code below! 
 Notice the  ids  parameter with the public key or token address of a token mint, you can also input more than 1 address by comma-separating them. 
 Price vs USDC by default 
 const priceResponse = await fetch(
    ''https://lite-api.jup.ag/price/v2?ids=JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN,So11111111111111111111111111111111111111112''
);

const priceData = await priceResponse.json();

console.log(priceData);
 
 Price vsToken 
 console.log(JSON.stringify(priceData, null, 2));

const priceResponseWithVsToken = await fetch(
    ''https://lite-api.jup.ag/price/v2?ids=JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN,So11111111111111111111111111111111111111112&vsToken=So11111111111111111111111111111111111111112''
);

const priceDataWithVsToken = await priceResponseWithVsToken.json();
  
console.log(JSON.stringify(priceDataWithVsToken, null, 2));
 
 From the above example, you should see this response. 
 Notice 2 details here: 
 
 Usage of  vsToken : The first set of data shows price denoted in USDC while the second set of data denotes in the price of SOL. 
 With no  showExtraInfo : There is only 1 price, the derived price is the buy price. 
 
 {
  "data": {
    "So11111111111111111111111111111111111111112": {
      "id": "So11111111111111111111111111111111111111112",
      "type": "derivedPrice",
      "price": "210.195311500"
    },
    "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
      "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
      "type": "derivedPrice",
      "price": "1.084247"
    }
  },
  "timeTaken": 0.00488491
}
{
  "data": {
    "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
      "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
      "type": "derivedPrice",
      "price": "0.005158283466279884"
    },
    "So11111111111111111111111111111111111111112": {
      "id": "So11111111111111111111111111111111111111112",
      "type": "derivedPrice",
      "price": "1"
    }
  },
  "timeTaken": 0.00203215
}
 
 Get Price (with Extra Info) 
 To get extra help information such as confidence level or depth, you will need to pass in  showExtraInfo=true . However, do note that if this is set to  true , you will not be able to apply  vsToken . 
 const priceResponseShowExtraInfo = await fetch(
    ''https://lite-api.jup.ag/price/v2?ids=JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN,So11111111111111111111111111111111111111112&showExtraInfo=true''
);

const priceDataShowExtraInfo = await priceResponseShowExtraInfo.json();
  
console.log(JSON.stringify(priceDataShowExtraInfo, null, 2));
 
 Here is the sample response. 
 Notice a few details here: 
 
 You can see both last swap and current quote prices. 
 You can see both buy and sell prices of the different types. 
 You can see the unix timestamps. 
 You can see the confidence and depth information. 
 
 {
  "data": {
    "So11111111111111111111111111111111111111112": {
      "id": "So11111111111111111111111111111111111111112",
      "type": "derivedPrice",
      "price": "210.734462500",
      "extraInfo": {
        "lastSwappedPrice": {
          "lastJupiterSellAt": 1731599242,
          "lastJupiterSellPrice": "210.52136418853988",
          "lastJupiterBuyAt": 1731599242,
          "lastJupiterBuyPrice": "210.5553945976539"
        },
        "quotedPrice": {
          "buyPrice": "210.578367000",
          "buyAt": 1731599236,
          "sellPrice": "210.890558000",
          "sellAt": 1731599236
        },
        "confidenceLevel": "high",
        "depth": {
          "buyPriceImpactRatio": {
            "depth": {
              "10": 0.08186978526745424,
              "100": 0.1154072102743595,
              "1000": 0.13766677800178445
            },
            "timestamp": 1731599207
          },
          "sellPriceImpactRatio": {
            "depth": {
              "10": 0.1211367007033883,
              "100": 0.059088081285986374,
              "1000": 0.16445602954342006
            },
            "timestamp": 1731599207
          }
        }
      }
    },
    "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
      "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
      "type": "derivedPrice",
      "price": "1.088080",
      "extraInfo": {
        "lastSwappedPrice": {
          "lastJupiterSellAt": 1731599239,
          "lastJupiterSellPrice": "1.0857748923629837",
          "lastJupiterBuyAt": 1731599241,
          "lastJupiterBuyPrice": "1.0879206578017573"
        },
        "quotedPrice": {
          "buyPrice": "1.088085",
          "buyAt": 1731599236,
          "sellPrice": "1.088076",
          "sellAt": 1731599236
        },
        "confidenceLevel": "high",
        "depth": {
          "buyPriceImpactRatio": {
            "depth": {
              "10": 0.05662764967204097,
              "100": 0.17463135504551536,
              "1000": 0.7379832960897882
            },
            "timestamp": 1731599207
          },
          "sellPriceImpactRatio": {
            "depth": {
              "10": 0.03504801758790863,
              "100": 0.16858843747627028,
              "1000": 3.0578377037958586
            },
            "timestamp": 1731599207
          }
        }
      }
    }
  },
  "timeTaken": 0.003665979
}
 
 Limitations 
 Query limits 
 
 You can query up to 100  id s at once. 
 
 If the price for a token cannot be found, it is either because 
 
 The token is not tradable on Jupiter - it does not fit Jupiter’s routing criteria. 
 There is no route for this token to SOL. 
 sellPrice ,  sellAt  &  lastSwappedPrice  might be null in cases 
 If  sellPrice  &  sellAt  is not cached and cannot be retrieved the provided information will be  buyPrice . 
 lastSwappedPrice  might be null if the token has not been traded recently or cannot be retrieved. 
 Tokens that have not been traded via USDC in the last 3 days. 
 Note that this is only for swaps done via Jupiter, it will not be done for swaps done e.g. directly on Raydium’s platform 
 
 buyPriceImpactRatio  &  sellPriceImpactRatio  in the depth field might be null in cases 
 
 We are to get the respective price impacts for the 10, 100 and 1000 SOL buys or sells 
 It could be because the token’s liquidity does not have enough liquidity for larger values 
 We cannot find the sell quote for the respective token and the buy/sell values 
 
 Read about how we derive confidenceLevel or depth in Price API V2 here.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/500-price-api/README.md', 'sidebar_label: "About Price API"
description: "Understand the mechanisms and challenges behind deriving token prices."
title: "About Price API" 

     About Price API 
     

 The Jupiter Price API aims to be the source of truth of token prices across all Jupiter UIs and integrator platforms, providing a seamless experience for developers and a reliable and accurate price source for users. 
 :::danger DEPRECATED
 Price API V2  will be/is deprecated by 1 August 2025. 
 Please migrate to  Price API V3  which consists of breaking changes.
::: 
 
 Challenges 
 Accurately pricing tokens on-chain is deceptively complex. Unlike traditional markets with centralized pricing mechanisms and consistent liquidity, decentralized finance (DeFi) presents a set of dynamic and often adversarial conditions. The Price API V3 is built with these realities in mind, abstracting away challenges to deliver accurate, real-time token prices with integrity and consistency. 
 Challenge Description 
 Gamification of Price In decentralized environments, token prices can be manipulated or "gamed" for appearances or exploitative purposes. Common patterns include: Wash trading to inflate volume or imply activity Circular swaps to fabricate higher valuations 
 Fragmented, Volatile or Imbalanced Liquidity Across Venues Liquidity on Solana (and other chains) is spread across numerous protocols and AMMs. No single source can represent the entire market. Different pools might have wildly different pricing and can change very quickly. 
 Low Liquidity Tokens Some tokens trade rarely or only within shallow pools. In such cases, even small orders can cause large price swings, making pricing unreliable. 
 
 
 How Price is Derived 
 The latest version of Price API is V3 - which uses the  last swapped price (across all transactions) . The swaps are priced by working outwards from a small set of reliable tokens (like SOL) whose price we get from external oracle sources. 
 While and also after deriving the last swap price, we also utilize a number of heuristics to ensure the accuracy of the price and eliminate any outliers: 
 
 Asset origin and launch method 
 Market liquidity metrics 
 Market behaviour patterns 
 Holder distribution statistics 
 Trading activity indicators 
 Market value to liquidity ratios 
 
 :::caution
When using Price API, do note that you may face many tokens where price is not available or returns null. 
 This is because, we use the aforementioned heuristics to determine the price of a token and if the price is reliable - if certain combinations of these factors indicate potential issues with price reliability or market health, the token will be flagged and not provided a price. 
 This is to safeguard users and prevent an inaccurate price from being returned.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/best-practices.md', 'sidebar_label: "Best Practices"
description: "Best Practices for using the Recurring API"
title: "Best Practices" 

     Best Practices 
     

 Some best practices when using the Recurring API. 
 Item Recommendation 
 Understand the Recurring Product. The Recurring API supports order creation for both recurring and smart recurring strategies. Understand the difference between the two and choose the appropriate one for your needs. 
 Both types of orders require minimum total amount of 100 USD. As per the Jupiter Recurring API''s requirements to prevent small orders from being created. This is similar to jup.ag''s frontend check for minimum order amount. 
 Time-based orders require minimum number of orders of 2 and 50 USD per order. As per the Jupiter Recurring API''s requirements to prevent small orders from being created. This is similar to jup.ag''s frontend check for minimum order amount. 
 Token-2022 tokens The Recurring API does not currently support Token-2022 mints. Ensure you’re only scheduling orders for standard SPL tokens (Token Program) until Token-2022 support is added.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/5-withdraw-price-order.md', 'sidebar_label: "Withdraw Price Order"
description: "Use the Jupiter Recurring API to withdraw price-based orders."
title: "Withdraw Price Order" 

     Withdraw Price Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/recurring/v1/priceWithdraw 
 Pro URL:  https://api.jup.ag/recurring/v1/priceWithdraw 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::caution
Price-based orders via API is deprecated.
::: 
 Withdraw Order 
 If you want to withdraw funds from a price-based order, you need to do these steps: 
 
 Get a list of the order accounts you want to withdraw via  /getRecurringOrders  endpoint. 
 Choose the order account to deposit by making a post request to the  /priceDeposit  endpoint to get the transaction to deposit into the order. 
 Sign then send the transaction to the network either via  /execute  endpoint or by yourself. 
 
 :::info Get Recurring Orders
 Refer to the  /getRecurringOrders  section  to prepare order account you want to withdraw from.
::: 
 :::warning
If you do not pass in  amount , the transaction will be built to withdraw the full amount of the order.
::: 
 const priceWithdrawResponse = await (
    await fetch(''https://lite-api.jup.ag/recurring/v1/priceWithdraw'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            order: "EpTsCUnKComCd8FDNZn3kVrQBQo2uEn5rRzYk9ocqFPH",
            user: wallet.publicKey,
            inputOrOutput: "In", // either "In" or "Out" mint, note that price-based orders auto withdraws the output tokens to the user''s wallet every time the order is executed
            amount: 1000000
        }),
    })
).json();
 
 Withdraw Order Response 
 Success Example Response 
 {
  "requestId": "cb1c0e03-8e4a-4f85-ac36-e353c7981f5b",
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAcNRL7cu4ZNuxh1wI9W7GVURyr3A06dH348HDpIQzcAJ4oHNtIX+MwRgQakd3fYovqoEXuKqaHTmdCmjuWoQiMiby7TSszpu+tgf+jdiEM5n3uMiCD/N3AS0uVWTp10QrcFd1R4MYi595YUO8ViNwpWb17+Q9DxkVcz5fWpSqjtDyjKhKdx27tkl2VPxhBBJcKx9gSuUqMJnrF2JWtuKPpRPM1Qmt8G5sH80c9QL+SQJRbRoHSG7z7KaEAztDAAXRb0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBkZv5SEXMv/srbpyw5vnvIzlu8X3EmssQ5s6QAAAAAabiFf+q4GE+2h/Y0YYwDXaxDncGus7VZig8AAAAAABBt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKmMlyWPTiSJ8bs9ECkUjg2DC1oTmdr/EIQEjnvY2+n4Wcb6evO+2606PWXzaqvJdDGxu+TC0vbg5HymAgNFL11h22bCn6+jaw4yO0OzNgqgKrh+NYPQDG7Wi2D35hzKmzcjGx2VRtfxzpYauPv7ArfDDH2VHlwLKs45O0rZTboL4wMHAAUCnqwAAAcACQNADQMAAAAAAAEOAAAFCwgCAwEEBgkKDAEStxJGnJRtoSIBQEIPAAAAAAAA"
}
 
 Failed Example Response 
 {
  "code": 400,
  "error": "Failed to deserialize account data: failed to fill whole buffer",
  "status": "Bad Request"
}
 
 Execute Withdraw Order 
 To sign then send the transaction to the network to execute the withdrawal, you can use the  /execute  endpoint or by yourself. 
 Refer to the  Execute Order  section for more details.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/6-get-recurring-orders.md', 'sidebar_label: "Get Recurring Orders"
description: "Use the Jupiter Recurring API to get both active or historical recurring orders."
title: "Get Recurring Orders" 

     Get Recurring Orders 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/recurring/v1/getRecurringOrders 
 Pro URL:  https://api.jup.ag/recurring/v1/getRecurringOrders 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 This is a GET request to  /getRecurringOrders  endpoint. The response is paginated for every 10 orders and you can view different pages using the  page  parameter. 
 Get Recurring Orders 
 :::note 
 
 orderStatus can be either  active  or  history 
 recurringType can be either  time  ( price  is deprecated) 
 includeFailedTx can be either  true  or  false 
::: 
 
 :::caution
Price-based orders via API is deprecated.
::: 
 Active Orders 
 To get the active orders, you can pass in the  orderStatus  parameter as  active . 
 :::tip
You can optionally pass in the input and output token mint addresses to filter the open orders.
::: 
 const openOrdersResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/recurring/v1/getRecurringOrders?user=replaceWithPublicKey&orderStatus=active&recurringType=time''
    )
).json();
 
 Order History 
 To get the order history, you can pass in the  orderStatus  parameter as  history . 
 const orderHistoryResponse = await (
    await fetch(
        ''https://lite-api.jup.ag/recurring/v1/getRecurringOrders?user=replaceWithPublicKey&orderStatus=history&recurringType=price''
    )
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/README.md', 'sidebar_label: "About Recurring API"
description: "Start using Jupiter Recurring API to create time or price based recurring orders."
title: "About Recurring API" 

     Recurring API 
     

 The Jupiter Recurring API enables you to create automated recurring orders on Solana, allowing users to set up regular token swaps that execute automatically based on time intervals or price conditions. 
 The Recurring API is ideal for: 
 
 DeFi applications that want to offer dollar-cost average or value average features 
 Wallets and platforms looking to provide automated investment options 
 Projects that want to implement treasury management strategies 
 
 Features 
 Feature Description 
 Time-based recurring Set up regular token swaps that execute automatically at specified time intervals. 
 Price-based recurring Create price-based recurring orders that execute when certain market conditions are met. 
 Any token pair Create recurring orders between any token pairs supported on Jupiter''s Metis Routing Engine. 
 Best execution Orders are executed through Jupiter''s Metis Routing Engine to get the best possible price across all DEXes. 
 Flexible scheduling Configure the frequency and timing of recurring orders to match your needs. 
 Price strategy Set a price range in time-based recurring orders. 
 
 Getting Started with Recurring API 
 
 Create Order : Create a new recurring order with your desired parameters. 
 Cancel Order : Cancel an existing recurring order. 
 Deposit in Price-based Orders : Deposit funds in price-based orders. 
 Withdraw from Price-based Orders : Withdraw funds from price-based orders. 
 Get Recurring Orders : Retrieve the history of recurring orders for a specific wallet address. 
 Best Practices : Best practices for using Recurring API. 
 
 FAQ 
 What is the fee for using Recurring API? 
 Recurring API takes 0.1% as fees. 
 Can integrators take fees using Recurring API? 
 Currently no.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/2-execute-order.md', 'sidebar_label: "Execute Order"
description: "Use the Jupiter Recurring API to execute orders."
title: "Execute Order" 

     Execute Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/recurring/v1/execute 
 Pro URL:  https://api.jup.ag/recurring/v1/execute 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 After getting the order transaction, you can sign and send to the network yourself or use the Recurring API''s  /execute  endpoint to do it for you. 
 Sign Transaction 
 Using the Solana  web3.js  v1 library, you can sign the transaction as follows: 
 // ... GET /createOrder''s response

// Extract the transaction from the order response
const transactionBase64 = createOrderResponse.transaction

// Deserialize the transaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));

// Sign the transaction
transaction.sign([wallet]);

// Serialize the transaction to base64 format
const signedTransaction = Buffer.from(transaction.serialize()).toString(''base64'');
 
 Execute Order 
 By making a post request to the  /execute  endpoint, Jupiter executes the order transaction on behalf of you/your users. This includes handling of transaction handling, priority fees, RPC connection, etc. 
 :::info
Do note that you need both the signed transaction and the order id to execute the order. 
 The order id is returned in the  createOrder  response .
::: 
 const executeResponse = await (
    await fetch(''https://lite-api.jup.ag/recurring/v1/execute'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            signedTransaction: signedTransaction,
            requestId: createOrderResponse.requestId,
        }),
    })
).json();
 
 Execute Order Response 
 After making the post request to the  /execute  endpoint, you will receive a response with the status of the order. 
 Example response of successful order: 
 {
  "signature": "...",
  "status": "Success",
  "order": "4DWzP4TdTsuwvYMaMWrRqzya4UTFKFoVjfUWNWh8zhzd",
  "error": null
}
 
 Example response of failed order: 
 {
  "signature": "...",
  "status": "Failed",
  "order": null,
  "error": "Insufficient funds for the operation requested.",
}
 
 Send Transaction Yourself 
 If you want to handle the transaction, you can sign and send the transaction to the network yourself. 
 const transactionBase64 = createOrderResponse.transaction
const transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, ''base64''));

transaction.sign([wallet]);

const transactionBinary = transaction.serialize();

const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "finalized" });

const signature = await connection.sendRawTransaction(transactionBinary, {
    maxRetries: 1,
    skipPreflight: true
});

const confirmation = await connection.confirmTransaction({
signature,
blockhash: blockhashInfo.value.blockhash,
lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
}, "finalized");

if (confirmation.value.err) {
    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\n\nhttps://solscan.io/tx/${signature}`);
} else console.log(`Transaction successful: https://solscan.io/tx/${signature}`);', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/4-deposit-price-order.md', 'sidebar_label: "Deposit Price Order"
description: "Use the Jupiter Recurring API to deposit price-based orders."
title: "Deposit Price Order" 

     Deposit Price Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/recurring/v1/priceDeposit 
 Pro URL:  https://api.jup.ag/recurring/v1/priceDeposit 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::caution
Price-based orders via API is deprecated.
::: 
 Deposit Order 
 If you want to deposit funds into a price-based order, you need to do these steps: 
 
 Get a list of the order accounts you want to deposit via  /getRecurringOrders  endpoint. 
 Choose the order account to deposit by making a post request to the  /priceDeposit  endpoint to get the transaction to deposit into the order. 
 Sign then send the transaction to the network either via  /execute  endpoint or by yourself. 
 
 :::info Get Recurring Orders
 Refer to the  /getRecurringOrders  section  to prepare the order account you want to deposit into.
::: 
 const priceDepositResponse = await (
    await fetch(''https://lite-api.jup.ag/recurring/v1/priceDeposit'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            order: "EpTsCUnKComCd8FDNZn3kVrQBQo2uEn5rRzYk9ocqFPH",
            user: wallet.publicKey,
            amount: 1000000
        }),
    })
).json();
 
 Deposit Order Response 
 Success Example Response 
 {
  "requestId": "cbc021a6-8a61-49cd-8c5a-9ea29fc2dd4d",
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAcLRL7cu4ZNuxh1wI9W7GVURyr3A06dH348HDpIQzcAJ4ou00rM6bvrYH/o3YhDOZ97jIgg/zdwEtLlVk6ddEK3BXdUeDGIufeWFDvFYjcKVm9e/kPQ8ZFXM+X1qUqo7Q8ozVCa3wbmwfzRz1Av5JAlFtGgdIbvPspoQDO0MABdFvQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAABt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkHNtIX+MwRgQakd3fYovqoEXuKqaHTmdCmjuWoQiMib4yXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZxvp6877brTo9ZfNqq8l0MbG75MLS9uDkfKYCA0UvXWHbZsKfr6NrDjI7Q7M2CqAquH41g9AMbtaLYPfmHMqbN3la+2QyLhVSaIunpVo3X8k4VAEj0cBT/ANSk2IKq9g1BAUABQL3nQAABQAJA0ANAwAAAAAACAYAAgAJBAYBAQcIAAMJAQIGCgcQ8iPGiVLh8rZAQg8AAAAAAA=="
}
 
 Failed Example Response 
 {
  "code": 400,
  "error": "Failed to deserialize account data: failed to fill whole buffer",
  "status": "Bad Request"
}
 
 Execute Deposit Order 
 To sign then send the transaction to the network to execute the deposit, you can use the  /execute  endpoint or by yourself. 
 Refer to the  Execute Order  section for more details.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/3-cancel-order.md', 'sidebar_label: "Cancel Order"
description: "Use the Jupiter Recurring API to cancel orders."
title: "Cancel Order" 

     Cancel Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/recurring/v1/cancelOrder 
 Pro URL:  https://api.jup.ag/recurring/v1/cancelOrder 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Cancel Order 
 If you want to cancel order(s), you need to do these steps: 
 
 Get a list of the order accounts you want to cancel via  /getRecurringOrders  endpoint. 
 Choose the order account to cancel by making a post request to the  /cancelOrder  endpoint to get the transaction to cancel the order. 
 Sign then send the transaction to the network either via  /execute  endpoint or by yourself. 
 
 :::info Get Recurring Orders
 Refer to the  /getRecurringOrders  section  to prepare the list of order accounts you want to cancel.
::: 
 :::note
The  /cancelOrder  endpoint only supports 1 cancellation per transaction.
::: 
 :::caution
Price-based orders via API is deprecated.
::: 
 const cancelOrderResponse = await (
    await fetch(''https://lite-api.jup.ag/recurring/v1/cancelOrder'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            order: "4DWzP4TdTsuwvYMaMWrRqzya4UTFKFoVjfUWNWh8zhzd",
            user: wallet.publicKey,
            recurringType: "time",
        }),
    })
).json();
 
 Cancel Order Response 
 Success Example Response 
 {
  "requestId": "36779346-ae51-41e9-97ce-8613c8c50553",
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAgORL7cu4ZNuxh1wI9W7GVURyr3A06dH348HDpIQzcAJ4oZOZHXAukWalAX/odOiV55UZa1ePBg8d2tRKQyqCjV6C/H8IQcrfZR4QeOJFykenP3QJznc6vNpqe2D57HTD7Gd1R4MYi595YUO8ViNwpWb17+Q9DxkVcz5fWpSqjtDyiji2RfCl7yoUfzkV42QPexQNFjBK5/+pJhV8QuWShN6r9vLZM5XJNS670dgAgf7wC+wCLLIFWHgjgWx32LJMnJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADBkZv5SEXMv/srbpyw5vnvIzlu8X3EmssQ5s6QAAAAAabiFf+q4GE+2h/Y0YYwDXaxDncGus7VZig8AAAAAABBt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKmMlyWPTiSJ8bs9ECkUjg2DC1oTmdr/EIQEjnvY2+n4WbB1qAZjecpv43A3/wwo1VSm5NY22ehRjP5uuuk/Ujb+tSfUXWQOPsFfYV1bDiOlSpa4PwuCC/cGNfJDSsZAzATG+nrzvtutOj1l82qryXQxsbvkwtL24OR8pgIDRS9dYVCj/auTzJLgPke1v9c3puAy81rBYgsabmuLUTEQsZyVAwcABQL9WQEABwAJA0ANAwAAAAAADA0AAg0IAQQDBQYJCgsMCBYHIWKotyLz"
}
 
 Failed Example Response 
 {
  "code": 400,
  "error": "Failed to deserialize account data: failed to fill whole buffer",
  "status": "Bad Request"
}
 
 Execute Cancel Order 
 To sign then send the transaction to the network to execute the cancellation, you can use the  /execute  endpoint or by yourself. 
 Refer to the  Execute Order  section for more details.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/103-recurring-api/1-create-order.md', 'description: "Use the Jupiter Recurring API to create orders."
title: "Create Order" 

     Create Order 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/recurring/v1/createOrder 
 Pro URL:  https://api.jup.ag/recurring/v1/createOrder 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 Create Order 
 This is a POST request to  /createOrder  endpoint, where you pass in the necessary parameters and our backend will create the transaction for you to sign and send to the network seamlessly. 
 :::info
The Recurring API supports both Time-based and Price-based (DEPRECATED) strategies. 
 The  createOrder  endpoint is used to create both types of orders based on the parameters you pass in.
::: 
 Time-based Order 
 Pass in the  time  object in the  params  field. 
 :::note
Some notes to help you understand the parameters. 
 
 The amount to be spent per cycle is calculated based on your input amount and the total number of orders. 
 
 Amount to be spent per cycle = inAmount / numberOfOrders
e.g. 1_000 USDC / 10 orders = 100 USDC per order
 
 
 The total time to complete is definite as the amount to be spent per cycle is fixed. 
 
 Total time to complete = numberOfOrders * interval
e.g. 10 orders * 86_400 seconds = 864_000 seconds = 10 days
 
 ::: 
 const createOrderResponse = await (
    await fetch(''https://lite-api.jup.ag/recurring/v1/createOrder'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            user: wallet.publicKey,
            inputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            outputMint: "So11111111111111111111111111111111111111112",
            params: {
                time: {
                    inAmount: 104000000, // Raw amount of input token to deposit now (before decimals)
                    numberOfOrders: 2, // Total number of orders to execute
                    interval: 86400, // Time between each order in unix seconds
                    minPrice: null, // Minimum price or null
                    maxPrice: null, // Maximum price or null
                    startAt: null, // Unix timestamp of start time or null - null starts immediately
                },
            },
        }),
    })
).json();
 
 Price-based Order (DEPRECATED) 
 Pass in the  price  object in the  params  field. 
 :::caution
Price-based orders via API is deprecated.
::: 
 :::note
Some notes to help you understand the parameters. 
 
 Price-based orders are opened indefinitely until the user closes them. 
 Once low on funds, the order will not be closed and can continue to execute if the user deposits more into the order. Refer to the  Deposit Price Order  endpoint to deposit more funds into the order. 
 Alternatively, the user can also withdraw funds from the order without closing it. Refer to the  Withdraw Price Order  endpoint to withdraw funds from the order. 
 Do note that the price-based orders auto withdraws the output tokens to the user''s wallet every time the order is executed. 
 The total time to use up all funds is not definite as the amount to be spent per cycle is variable based on the USDC value of the input token.
::: 
 
 const createOrderResponse = await (
    await fetch(''https://lite-api.jup.ag/recurring/v1/createOrder'', {
        method: ''POST'',
        headers: {
            ''Content-Type'': ''application/json'',
        },
        body: JSON.stringify({
            user: wallet.publicKey,
            inputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            outputMint: "So11111111111111111111111111111111111111112",
            params: {
                price: {
                    depositAmount: 110000000, // Raw amount of input token to deposit now (before decimals)
                    incrementUsdcValue: 10000000, // Raw amount of USDC to increment per cycle (before decimals)
                    interval: 86400, // Time between each cycle in unix seconds
                    startAt: null, // Unix timestamp of start time or null - null starts immediately
                },
            },
        }),
    })
).json();
 
 Now that you have the order transaction, you can sign and send to the network. There are 2 methods, after signing the transaction, you can either send it to the network yourself or use the Recurring API''s  /execute  endpoint to do it for you. 
 Let''s execute the order ! 
 Create Order Response 
 The response from the  createOrder  endpoint is as follows. 
 :::info
Do note that both time-based and price-based orders will return the same response structure.
::: 
 Successful Example Response 
 {
  "requestId": "1d1f3586-eb72-4337-8c7e-1bbb9870ee4b",
  "transaction": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAgNRL7cu4ZNuxh1wI9W7GVURyr3A06dH348HDpIQzcAJ4o8bJlCl2Wc6MzpcvkV0INcJ7u23GV89soNJ/8i5QPLuk+NOvCjbAbTzOyNoSWuhO5fYq+hNGrGQ2JdDy82Gw0bv28tkzlck1LrvR2ACB/vAL7AIssgVYeCOBbHfYskycnT/icRrhr4nbjk0DzDqAkM4ntju8NXHrILEpE0TUKNKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwZGb+UhFzL/7K26csOb57yM5bvF9xJrLEObOkAAAAAGm4hX/quBhPtof2NGGMA12sQ53BrrO1WYoPAAAAAAAQbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpjJclj04kifG7PRApFI4NgwtaE5na/xCEBI572Nvp+FmwdagGY3nKb+NwN/8MKNVUpuTWNtnoUYz+brrpP1I2/rUn1F1kDj7BX2FdWw4jpUqWuD8Lggv3BjXyQ0rGQMwExvp6877brTo9ZfNqq8l0MbG75MLS9uDkfKYCA0UvXWG7njQ5EK9zaEM059+IQanso4m+YzpvFchLCtBxOCdR5QcGAAUCGSwAAAYACQNADQMAAAAAAAkGAAMABwUIAQEFAgADDAIAAAAAwusLAAAAAAgBAwERCw0EAAAHDAMBAgUICQoLK453K22iNAuxgF7IZwAAAAAAwusLAAAAAADh9QUAAAAALAEAAAAAAAAAAAAIBAMAAAABCQ=="
}
 
 Failed Example Response 
 {
  "code": 400,
  "error": "Order is valued at 2.99 USDC, minimum is 100.00 USDC",
  "status": "Bad Request"
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/6-api-faq.md', 'sidebar_label: "API FAQ"
description: "Frequently aksed questions about Jupiter Portal and API Keys."
title: "API FAQ" 

     API FAQ 
     

 This section covers the FAQ of the API Key set up and rate limits systems. Please read  API Setup  and  API Rate Limit  docs as well. 
 Does Lite or Ultra plan need payment? 
 
 No, you do not need to pay for Lite or Ultra. 
 For Lite, just request directly to  lite-api.jup.ag  without an API Key. 
 For Ultra, you will need to log in first to generate an API Key and use it with  api.jup.ag/ultra 
 
 Does Pro plan have any advantages from Lite? 
 
 By purchasing a Pro plan, you are only accessing higher rate limits with no differences in usage nor freshness of data. 
 
 Can I use the same API key for all Jupiter APIs? 
 
 Yes, API keys are universal across both Fixed Rate Limit and Dynamic Rate Limit system. 
 
 Does the API Key apply immeidately? 
 
 No, it will take 2-5 minutes for it to reflect. 
 
 What happens if I upgrade/downgrade my plan? 
 
 You can only upgrade/downgrade your Pro plan. 
 The amount payable is pro-rated. 
 Upgrade happens immediately (2 - 5 minutes) is still required to be reflected. 
 Downgrade will happen at the end of the billing period if you are to renew the plan. 
 
 Can I use both Pro and Ultra APIs together? 
 
 Yes. You can maintain a Pro subscription for all other API routes while integrating Ultra endpoints separately. 
 Do note that purchasing a Pro plan, does not apply its rate limits to Ultra API. 
 
 For more support! 
 
 Please reach out to us. 
 If you have increasing demand and growth in your app, and need custom rate limits or payment options beyond the provided in Portal. 
 If you require higher base quota for Ultra plan to bootstrap your product. 
 If you have questions or need support on Portal,  open a ticket . 
 Join the  Telegram channel  or  Discord channel  to subscribe to updates.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/1-environment-setup.md', 'sidebar_label: "Environment Setup"
description: "Get Started with setting up libraries, connection and local wallet to build with Jupiter API."
title: "Environment Setup" 

     Environment Setup 
     

 :::note about the documentation
In the documentation, we are using the Solana  web3.js  library to set up connection, sign transactions, etc.
::: 
 Useful Libraries 
 JavaScript Libraries 
 
 @solana/web3.js 
 @solana/spl-token 
 @jup-ag/referral-sdk 
 
 Useful Scripts 
 Set up RPC Connection 
 :::note
Solana provides a  default RPC endpoint . However, as your application grows, we recommend you to always use your own or provision a 3rd party provider’s RPC endpoint such as  Helius  or  Triton .
::: 
 const connection = new Connection(''https://api.mainnet-beta.solana.com'');
 
 Set up Development Wallet 
 :::note 
 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 If you want to store your private key in the project directly, you can do it via a  .env  file.
::: 
 
 To set up a development wallet via  .env  file, you can use the following script. 
 // index.js
import { Keypair } from ''@solana/web3.js'';
import dotenv from ''dotenv'';
require(''dotenv'').config();

const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || '''')));
 
 // .env
PRIVATE_KEY=""
 
 To set up a development wallet via a wallet generated via  Solana CLI , you can use the following script. 
 import { Keypair } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/900-lend-api/1-earn.md', 'sidebar_label: "Earn (Beta)"
description: "Use Jupiter Lend to borrow assets."
title: "Earn (Beta)" 

     Earn (Beta) 
     

 :::note 
 
 Lite URL:  https://lite-api.jup.ag/quote 
 Pro URL:  https://api.jup.ag/swap/v1/quote 
 
 To upgrade to Pro or understand our rate limiting, please refer to this section. 
 
 API Key Setup 
 API Rate Limit 
::: 
 
 :::tip API Reference
To fully utilize the Lend API, check out the  Lend API Reference .
::: 
 Prerequisite 
 
     
         
             
                 Dependencies 
             
         
     
 npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2
npm install dotenv # If required for wallet setup
 
 
 
     
         
             
                 RPC 
             
         
     
 Set up RPC 
 :::note
Solana provides a  default RPC endpoint . However, as your application grows, we recommend you to always use your own or provision a 3rd party provider’s RPC endpoint such as  Helius  or  Triton .
::: 
 import { Connection } from "@solana/web3.js";
const connection = new Connection(''https://api.mainnet-beta.solana.com'');
 
 
 
     
         
             
                 Wallet 
             
         
     
 Set up Development Wallet 
 :::note 
 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 If you want to store your private key in the project directly, you can do it via a  .env  file.
::: 
 
 To set up a development wallet via  .env  file, you can use the following script. 
 // index.js
import { Keypair } from ''@solana/web3.js'';
import dotenv from ''dotenv'';
require(''dotenv'').config();

const wallet = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ''''));
 
 # .env
PRIVATE_KEY=""
 
 To set up a development wallet via a wallet generated via  Solana CLI , you can use the following script. 
 import { Keypair } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/To/.config/solana/id.json'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
 
 
 
     
         
             
                 Transaction Sending Example 
             
         
     
 transaction.sign([wallet]);
const transactionBinary = transaction.serialize();
console.log(transactionBinary);
console.log(transactionBinary.length);
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "finalized" });

const signature = await connection.sendRawTransaction(transactionBinary, {
  maxRetries: 0,
  skipPreflight: true,
});

console.log(`Transaction sent: https://solscan.io/tx/${signature}`);
  
try {
  const confirmation = await connection.confirmTransaction({
    signature,
    blockhash: blockhashInfo.value.blockhash,
    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
  }, "confirmed");

  if (confirmation.value.err) {
    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);
  } else {
    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);
  }
} catch (error) {
  console.error(`Error confirming transaction: ${error}`);
  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);
};
 
 
 Deposit and Withdraw 
 Using the Deposit or Withdraw endpoint, the user can do so based on the  amount  of assets to be deposited/withdrawn. 
 :::note Usage steps 
 
 User chooses the token. 
 User chooses the amount of assets to deposit or withdraw in the specific token mint. 
 Post request to get the transaction. 
 User sign and send the transaction to the network. 
 The mint authority mints/burns the vault tokens to/from the user.
::: 
 
 const depositTransactionResponse = await (
    await (
        await fetch(''https://lite-api.jup.ag/lend/v1/earn/deposit'', {
            method: ''POST'',
            headers: {
                ''Content-Type'': ''application/json'',
            },
            body: JSON.stringify({
                asset: mint,
                amount: ''100000'',
                signer: wallet.publicKey,
            })
        })
    )
);
 
 const withdrawTransactionResponse = await (
    await (
        await fetch(''https://lite-api.jup.ag/lend/v1/earn/withdraw'', {
            method: ''POST'',
            headers: {
                ''Content-Type'': ''application/json'',
            },
            body: JSON.stringify({
                asset: mint,
                amount: ''100000'',
                signer: wallet.publicKey,
            })
        })
    )
);
 
 Mint and Redeem 
 Using the Mint or Redeem endpoint, the user can do so based on the number  shares  to be minted/redeemed. 
 :::note Usage steps 
 
 User chooses the token. 
 User chooses the number of shares to deposit or withdraw in the specific token mint. 
 Post request to get the transaction. 
 User sign and send the transaction to the network. 
 The mint authority mints/burns the vault tokens to/from the user.
::: 
 
 const mintTransactionResponse = await (
    await (
        await fetch(''https://lite-api.jup.ag/lend/v1/earn/mint'', {
            method: ''POST'',
            headers: {
                ''Content-Type'': ''application/json'',
            },
            body: JSON.stringify({
                asset: mint,
                signer: wallet.publicKey,
                shares: ''100000'',
            })
        })
    )
);
 
 const redeemTransactionResponse = await (
    await (
        await fetch(''https://lite-api.jup.ag/lend/v1/earn/redeem'', {
            method: ''POST'',
            headers: {
                ''Content-Type'': ''application/json'',
            },
            body: JSON.stringify({
                asset: mint,
                signer: wallet.publicKey,
                shares: ''100000'',
            })
        })
    )
);
 
 
 Build Your Own Transaction 
 The Lend API provides 2 ways to interface with the Earn functions in the Jupiter Lend Program. You can either make a post request to directly get the  Transaction , or  Instruction  which can be used for CPI or composing with additional instructions. 
 Transaction 
 To use the Transaction method, simply request to the endpoints without  -instructions  suffix directly, as shown in the examples above. The API will respond with an unsigned base64 transaction for the signer to sign, then sent to the network for execution. 
 Instruction 
 In some use cases, you''d prefer to utilize the instructions instead of the serialized transaction, so you can utilize with CPI or compose with other instructions. You can make a post request to  -instructions endpoints instead. 
 
     
         
             
                 Building with Instuctions Code Snippet 
             
         
     
Example code snippet of using `/deposit-instructions` endpoint and building a transaction with the instructions.
 import { Connection, Keypair, PublicKey, TransactionMessage, TransactionInstruction, VersionedTransaction } from ''@solana/web3.js'';
import fs from ''fs'';

const privateKeyArray = JSON.parse(fs.readFileSync(''/Path/to/private/key'', ''utf8'').trim());
const wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));
const connection = new Connection(''insert-your-own-rpc'');

const depositIx = await (
    await fetch (
        ''https://lite-api.jup.ag/lend/v1/earn/deposit-instructions'', {
            method: ''POST'',
            headers: {
                ''Content-Type'': ''application/json'',
            },
            body: JSON.stringify({
                asset: ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'',
                amount: ''1000000'',
                signer: wallet.publicKey,
            }, null, 2)
        }
    )
).json();

console.log(JSON.stringify(depositIx, null, 2));

const deserializeInstruction = (instruction) => {
    return new TransactionInstruction({
    programId: new PublicKey(instruction.programId),
    keys: instruction.accounts.map((key) => ({
        pubkey: new PublicKey(key.pubkey),
        isSigner: key.isSigner,
        isWritable: key.isWritable,
    })),
    data: Buffer.from(instruction.data, ''base64''),
    });
};

const blockhash = (await connection.getLatestBlockhash()).blockhash;
const messageV0 = new TransactionMessage({
    payerKey: wallet.publicKey,
    recentBlockhash: blockhash,
    instructions: [
        ...depositIx.instructions.map(deserializeInstruction)
    ],
}).compileToV0Message();

const transaction = new VersionedTransaction(messageV0);
transaction.sign([wallet]);
const transactionBinary = transaction.serialize();
console.log(transactionBinary);
console.log(transactionBinary.length);
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "finalized" });

const signature = await connection.sendRawTransaction(transactionBinary, {
  maxRetries: 0,
  skipPreflight: true,
});

console.log(`Transaction sent: https://solscan.io/tx/${signature}`);
  
try {
  const confirmation = await connection.confirmTransaction({
    signature,
    blockhash: blockhashInfo.value.blockhash,
    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,
  }, "confirmed");

  if (confirmation.value.err) {
    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);
  } else {
    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);
  }
} catch (error) {
  console.error(`Error confirming transaction: ${error}`);
  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);
};
 
 
 CPI 
 
 Refer to https://github.com/jup-ag/jupiter-lend/blob/main/docs/earn/cpi.md for CPI example 
 Refer to https://github.com/jup-ag/jupiter-lend/blob/main/target/idl/lending.json for IDL 
 
 
 Tokens 
 Jupiter Lend provides Earnings for individual tokens, meaning SOL and USDC will be deposited in isolation. To get all token information such as the underlying token, supply, rates and liquidity information. 
 const vaults = await (
    await fetch (
        ''https://lite-api.jup.ag/lend/v1/earn/tokens''
    )
).json();
 
 User Data 
 Below are the endpoints to aid user to better manage their positions with data of each existing positions, earnings, etc. 
 Positions 
 Given a user, you are able to get their existing position data such as shares, underlying assets, balance and allowance. 
 const userPositions = await (
    await fetch (
        ''https://lite-api.jup.ag/lend/v1/earn/positions?users={user1},{user2}''
    )
).json();
 
 Earnings 
 Given a user, you are able to get the rewards of a specific position, for example, the amount earned for USDC token position. 
 const userRwards = await (
    await fetch (
        ''https://lite-api.jup.ag/lend/v1/earn/earnings?user={user1}&positions={position1},{position2}''
    )
).json();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/900-lend-api/oracle.md', 'sidebar_label: "Oracles"
description: "Oracles for Jupiter Lend."
title: "About Oracles" 

     Oracles 
     

 The Oracle Program delivers accurate price data to the protocol by integrating with trusted oracle providers. It calculates exchange rates by combining multiple price sources in a structured sequence, ensuring reliable asset valuations. 
 :::note
The Oracle program has been audited by Zenith and Offside.
::: 
 Oracle Program Address:   jupnw4B6Eqs7ft6rxpzYLJZYSnrpRgPcr589n5Kv4oc 
 Hop-Based Oracle System 
 The system computes exchange rates by processing prices from up to four sources in a sequential chain. Each source contributes to the final rate through multiplication or division, with the option to invert values as needed. Currently, Pyth is the supported source type. 
 For example, to derive the JUPSOL/SOL rate, the system combines JUPSOL/USD and SOL/USD feeds, inverting the latter to obtain USD/SOL, resulting in an accurate exchange rate. 
 This design enables the system to: 
 
 Aggregate rates from multiple feeds, reducing dependency on any single provider 
 Adjust for varying units or scales using predefined multipliers and divisors 
 Validate data integrity at each step 
 
 Freshness Enforcement 
 To ensure prices reflect current market conditions, the system enforces strict time-based validity checks: 
 
 User Operations : Prices must be no older than 60 seconds to be considered valid for actions like borrowing or supplying assets 
 Liquidations : Prices can be up to 1800 seconds (30 minutes) old, allowing liquidations to proceed during temporary oracle delays while avoiding reliance on outdated data 
 
 These checks prevent the protocol from using stale prices for liquidation or health factor calculations. 
 Confidence Interval Validation 
 The system evaluates the confidence interval provided by Pyth price feeds to ensure data reliability: 
 
 User Operations : The confidence interval must be within 2% of the reported price 
 Liquidations : The confidence interval must be within 4% of the reported price 
 
 If a price feed''s confidence exceeds these thresholds, it is rejected. 
 Providers 
 The program currently utilizes Pyth push feeds for price data. Integration with Chainlink streams is underway to broaden the range of sources. 
 Oracle Verification Script 
 Use this script to verify oracle prices by providing a nonce: 
 import { Program, AnchorProvider } from "@coral-xyz/anchor";
import { Connection, PublicKey } from "@solana/web3.js";
import axios from "axios";

const NONCE = 2; // Change this to test different oracles
const ORACLE_PROGRAM_ID = new PublicKey("jupnw4B6Eqs7ft6rxpzYLJZYSnrpRgPcr589n5Kv4oc");
const IDL_URL = "https://raw.githubusercontent.com/jup-ag/jupiter-lend/refs/heads/main/target/idl/oracle.json";
const RPC_URL = "<RPC URL>";

class OracleReader {
  private program: Program;

  private constructor(program: Program) {
    this.program = program;
  }

  static async create(): Promise<OracleReader> {
    const connection = new Connection(RPC_URL);
    const response = await axios.get(IDL_URL);
    const idl = response.data;

    const wallet = {
      signTransaction: () => { throw new Error("Read-only"); },
      signAllTransactions: () => { throw new Error("Read-only"); },
      publicKey: new PublicKey("11111111111111111111111111111111"),
    };

    const provider = new AnchorProvider(connection, wallet, {});
    const program = new Program(idl, provider);
    return new OracleReader(program);
  }

  private findOraclePDA(nonce: number): PublicKey {
    const [pda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("oracle"),
        Buffer.from(new Uint8Array(new Uint16Array([nonce]).buffer)),
      ],
      ORACLE_PROGRAM_ID
    );
    return pda;
  }

  async getPrice(nonce: number) {
    const oraclePDA = this.findOraclePDA(nonce);
    const oracleAccount = await this.program.account.oracle.fetch(oraclePDA);
    
    const remainingAccounts = oracleAccount.sources.map((source: any) => ({
      pubkey: source.source,
      isWritable: false,
      isSigner: false,
    }));

    const price = await this.program.methods
      .getExchangeRateOperate(nonce)
      .accounts({ oracle: oraclePDA })
      .remainingAccounts(remainingAccounts)
      .view();

    return {
      nonce,
      oraclePDA: oraclePDA.toString(),
      price: price.toString(),
      sources: oracleAccount.sources.length
    };
  }
}

async function main() {
  const reader = await OracleReader.create();
  const result = await reader.getPrice(NONCE);
  console.log(result);
}

main().catch(console.error);', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/900-lend-api/README.md', 'sidebar_label: "About Lend API"
description: "Start using Jupiter Lend API to earn yield and borrow assets."
title: "About Lend API" 

     Lend API 
     

 The Jupiter Lend API is built on top of Jupiter Lend Program. 
 About Earn 
 
 
 What is the Jupiter  Earn  Protocol? 
 The Earn Protocol is the ''Deposit and Earn'' side of Jupiter Lend. Simply deposit assets to the Jupiter Earn and earn yield. 
 
 
 Why is this separate from borrowing? 
 Jupiter Lend uses a unified liquidity layer where both Earn (lending) and Borrow (vault) protocol can source liquidity from. For depositors this means you earn the best possible rate at all times without having to migrate your funds when new protocols are launched on Jupiter Lend. You can supply once and earn the most up to date yield from the Jupiter Lend protocol. 
 
 
 Are there supply or withdraw limits? 
 There is no limits on supplying funds to the Earn Protocol. Withdrawals from Jupiter Lend utilize an Automated Debt Ceiling. Withdrawals increase every block creating a smoothing curve for withdrawals preventing any sudden large movements. 
 
 
 What are the risk? 
 Jupiter Lend is a novel protocol and like all DeFi protocols contains smart contract risk, market risk and other factors which can cause loss of user funds. 
 
 
 What are the fees for the Earn Protocol? 
 There are no fees to use the Earn Protocol on Jupiter Lend. 
 
 
 About Borrow 
 
 
 What is Jupiter  Borrow  Protocol? 
 Borrow Vaults are a known standard mechanism for locking collateral and borrowing debt. Jupiter Lend utilizes this familiar single asset - single debt vault approach. Jupiter Lend takes borrow vaults to the next level by being the most capital efficient and optimized protocol enabling up to 95% LTV on collateral. 
 
 
 How does Jupiter Lend achieve such high LTV? 
 Jupiter borrow vaults has the most advanced liquidation mechanisms, and are able to provide the highest LTVs in the market, the protocol easily removes bad debt and enables the most gas efficient liquidation mechanism in DeFi. 
 
 
 What happens if I am liquidated? 
 When your NFT or position is liquidated, a portion of your collateral is sold to repay your debt and return your position to a safe state. In addition to selling a part of your collateral, a liquidation penalty is also charged. 
 
 
 What is the Max Liquidation Threshold? 
 While the Liquidation Threshold determines when a vault can be liquidated, the protocol also has a ''hard'' ceiling for liquidation. When a vault passes the max liquidation threshold it is entirely (100%) liquidated automatically. 
 
 
 My vault passed the liquidation threshold but is not liquidated, will I be liquidated? 
 Yes your position is still at risk of being liquidated!  Once your position passes the threshold it can be liquidated, but it may not happen immediately.
If your position is still at risk you can take the time now to unwind/reduce your risk ratio to make your position safe and prevent a liquidation event. 
 
 
 Program ID 
 
 LIQUIDITY_PROGRAM:  jupeiUmn818Jg1ekPURTpr4mFo29p46vygyykFJ3wZC 
 LENDING_PROGRAM:  jup3YeL8QhtSx1e253b2FDvsMNC87fDrgQZivbrndc9 
 LRRM_PROGRAM:  jup7TthsMgcR9Y3L277b8Eo9uboVSmu1utkuXHNUKar 
 ORACLE_PROGRAM:  jupnw4B6Eqs7ft6rxpzYLJZYSnrpRgPcr589n5Kv4oc 
 VAULTS_PROGRAM:  jupr81YtYssSyPt8jbnGuiWon5f6x9TcDEFxYe3Bdzi 
 IDL 
 Audits', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/900-lend-api/sdk.md', 'sidebar_label: "Lend SDK"
description: "SDK for Jupiter Lend."
title: "Lend SDK" 

     Jupiter Lend SDK 
     

 The Jupiter Lend SDK provides a TypeScript interface for interacting with the Jupiter lending protocol. This documentation covers two main integration approaches: getting instruction objects for direct use and getting account contexts for Cross-Program Invocation (CPI) integrations. 
 Installation 
 npm install @jup-ag/lend
 
 Setup 
 import {
    Connection,
    Keypair, 
    PublicKey, 
    TransactionMessage, 
    TransactionInstruction, 
    VersionedTransaction
} from "@solana/web3.js";
import {
  getDepositIx, getWithdrawIx, // get instructions
  getDepositContext, getWithdrawContext, // get context accounts for CPI
} from "@jup-ag/lend/earn";
import { BN } from "bn.js";

const connection = new Connection("https://api.mainnet-beta.solana.com");
const signer = Keypair.fromSecretKey(new Uint8Array(privateKey));

// Example asset mints
const usdc = new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"); // USDC mainnet
 
 
 Instruction 
 Get Deposit Instruction 
 const depositIx = await getDepositIx({
    amount: new BN(1000000), // amount in token decimals (1 USDC)
    asset: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), // asset mint address
    signer: signer.publicKey, // signer public key
    connection, // Solana connection
    cluster: "mainnet",
});
 
 Get Withdraw Instruction 
 const withdrawIx = await getWithdrawIx({
    amount: new BN(1000000), // amount in token decimals (1 USDC)
    asset: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), // asset mint address
    signer: signer.publicKey, // signer public key
    connection, // Solana connection
    cluster: "mainnet",
});
 
 Example Instruction Usage 
 import {
    Connection,
    Keypair, 
    PublicKey, 
    TransactionMessage, 
    Transaction,
    TransactionInstruction,
    VersionedTransaction
} from "@solana/web3.js";
import {
    getDepositIx,
} from "@jup-ag/lend/earn";
import { BN } from "bn.js";

const signer = Keypair.fromSecretKey(new Uint8Array(privateKey));
const connection = new Connection(''https://api.mainnet-beta.solana.com'');

// Get deposit instruction
const depositIx = await getDepositIx({
    amount: new BN(1000000), // amount in token decimals (1 USDC)
    asset: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), // asset mint address
    signer: signer.publicKey, // signer public key
    connection, // Solana connection
    cluster: "mainnet",
});

// Convert the raw instruction to TransactionInstruction
const instruction = new TransactionInstruction({
    programId: new PublicKey(depositIx.programId),
    keys: depositIx.keys.map((key) => ({
        pubkey: new PublicKey(key.pubkey),
        isSigner: key.isSigner,
        isWritable: key.isWritable,
    })),
    data: Buffer.from(depositIx.data),
});

const latestBlockhash = await connection.getLatestBlockhash();
const messageV0 = new TransactionMessage({
    payerKey: signer.publicKey,
    recentBlockhash: latestBlockhash.blockhash,
    instructions: [instruction],
}).compileToV0Message();

const transaction = new VersionedTransaction(messageV0);
transaction.sign([signer]);
const serializedTransaction = transaction.serialize();
const blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: "finalized" });

const signature = await connection.sendRawTransaction(serializedTransaction);
console.log(`https://solscan.io/tx/${signature}`);
 
 CPI 
 For Anchor programs that need to make CPI calls to Jupiter Lend, use the context methods. 
 Deposit Context Accounts 
 const depositContext = await getDepositContext({
    asset: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), // asset mint address
    signer: signer.publicKey, // signer public key
    connection,
});
 
 
     
         
             
                 Deposit Context Accounts Table 
             
         
     
 Account Purpose 
 signer User''s wallet public key 
 depositorTokenAccount User''s underlying token account (source) 
 recipientTokenAccount User''s fToken account (destination) 
 mint Underlying token mint 
 lendingAdmin Protocol configuration PDA 
 lending Pool-specific configuration PDA 
 fTokenMint fToken mint account 
 supplyTokenReservesLiquidity Liquidity protocol token reserves 
 lendingSupplyPositionOnLiquidity Protocol''s position in liquidity pool 
 rateModel Interest rate calculation model 
 vault Protocol vault holding deposited tokens 
 liquidity Main liquidity protocol PDA 
 liquidityProgram Liquidity protocol program ID 
 rewardsRateModel Rewards calculation model PDA 
 
 
 Withdraw Context Accounts 
 const withdrawContext = await getWithdrawContext({
    asset: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), // asset mint address
    signer: signer.publicKey, // signer public key
    connection,
});
 
 
     
         
             
                 Withdraw Context Accounts Table 
             
         
     
Similar to deposit context, but includes:
 
 ownerTokenAccount : User''s fToken account (source of fTokens to burn) 
 claimAccount : Additional account for withdrawal claim processing 
 
 Account Purpose 
 signer User''s wallet public key 
 ownerTokenAccount User''s underlying token account (source) 
 recipientTokenAccount User''s fToken account (destination) 
 claimAccount Additional account for withdrawal 
 mint Underlying token mint 
 lendingAdmin Protocol configuration PDA 
 lending Pool-specific configuration PDA 
 fTokenMint fToken mint account 
 supplyTokenReservesLiquidity Liquidity protocol token reserves 
 lendingSupplyPositionOnLiquidity Protocol''s position in liquidity pool 
 rateModel Interest rate calculation model 
 vault Protocol vault holding deposited tokens 
 liquidity Main liquidity protocol PDA 
 liquidityProgram Liquidity protocol program ID 
 rewardsRateModel Rewards calculation model PDA 
 
 
 Example CPI Usage 
 const depositContext = await getDepositContext({
  asset: usdcMint,
  signer: userPublicKey,
});

// Pass these accounts to your Anchor program
await program.methods
  .yourDepositMethod(amount)
  .accounts({
    // Your program accounts
    userAccount: userAccount,

    // Jupiter Lend accounts (from context)
    signer: depositContext.signer,
    depositorTokenAccount: depositContext.depositorTokenAccount,
    recipientTokenAccount: depositContext.recipientTokenAccount,
    lendingAdmin: depositContext.lendingAdmin,
    lending: depositContext.lending,
    fTokenMint: depositContext.fTokenMint,
    // ... all other accounts from context

    lendingProgram: new PublicKey(
      "jup3YeL8QhtSx1e253b2FDvsMNC87fDrgQZivbrndc9"
    ),
  })
  .rpc();
 
 
 Read Functions 
 The Jupiter Lend SDK provides several read functions to query protocol data and user positions, this can be helpful to display on your frontend. 
 Get All Lending Tokens 
 Retrieves all available lending tokens in the Jupiter Lend Earn protocol. 
 :::note
The  getLendingTokens  function returns an array of  PublicKey  objects.
::: 
 import { getLendingTokens } from "@jup-ag/lend/earn";

const allTokens = await getLendingTokens({ connection });
 
 [
    PublicKey,
    PublicKey,
    ...
]
 
 Get Token Details 
 Fetches detailed information about a specific lending token. 
 import { getLendingTokenDetails } from "@jup-ag/lend/earn";

const tokenDetails = await getLendingTokenDetails({
    lendingToken: new PublicKey("9BEcn9aPEmhSPbPQeFGjidRiEKki46fVQDyPpSQXPA2D"), // allTokens[x] from the previous example
    connection,
});
 
 {
  id: number; // ID of jlToken, starts from 1
  address: PublicKey; // Address of jlToken
  asset: PublicKey; // Address of underlying asset
  decimals: number; // Decimals of asset (same as jlToken decimals)
  totalAssets: BN; // Total underlying assets in the pool
  totalSupply: BN; // Total shares supply
  convertToShares: BN; // Multiplier to convert assets to shares
  convertToAssets: BN; // Multiplier to convert shares to assets
  rewardsRate: BN; // Rewards rate (1e4 decimals, 1e4 = 100%)
  supplyRate: BN; // Supply APY rate (1e4 decimals, 1e4 = 100%)
}
 
 Get User Position 
 Retrieves a user''s lending position for a specific asset: 
 import { getUserLendingPositionByAsset } from "@jup-ag/lend/earn";

const userPosition = await getUserLendingPositionByAsset({
    asset: new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"), // The address of underlying asset or tokenDetails.asset
    user: signer.publicKey, // User''s wallet address
    connection,
});
 
 {
  lendingTokenShares: BN; // User''s shares in jlToken
  underlyingAssets: BN; // User''s underlying assets
  underlyingBalance: BN; // User''s underlying balance
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/900-lend-api/2-borrow.md', 'sidebar_label: "Borrow (Soon)"
description: "Use Jupiter Lend to borrow assets."
title: "Borrow (Soon)" 

     Borrow (Soon) 
     

 :::warning
The Jupiter Lend Borrow API is still a  work in progress , stay tuned!
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/200-perp-api/204-custody-account.md', 'sidebar_label: "Custody Account"
description: "Understand and integrate the Jupiter Perp Program."
title: "Custody Account" 

     Custody Account 
     

 This page contains an overview of the  Solana account types  used in the Jupiter Perpetuals Program, and specifically the  Custody  account. 
 The  Custody  account is a struct which represents a set of parameters and states associated to custodies (tokens) managed by the JLP pool which consists of the following custodies. 
 
   
     Custodies 
   
   
     SOL 
     ETH 
     BTC 
     USDC 
     USDT 
   
 
 :::tip Example Typescript Repository
This  repository  contains Typescript code samples on interacting with the Jupiter Perpetuals program IDL with  anchor  and  @solana/web3.js 
 You can also find the  Custody Account fields in the repository  or on a  blockchain explorer .
::: 
 Account Details 
 Each  Custody  account contains the following data: 
 Field Description 
 pool Type:   publicKey The public key for the pool that this custody belongs to (i.e. the JLP pool). 
 mint Type:   publicKey The public key for the custody''s token mint account. 
 tokenAccount Type:   publicKey The associated token account of the custody which holds the tokens under management for the pool. 
 decimals Type:   u8 The number of decimals used for the token which is the same as the number of decimals specified in the token mint account. This is stored for convenience. 
 isStable Type:   bool A boolean flag indicating if the token in custody is a stable asset. 
 oracle Type:   OracleParams Contains data for the price oracle used for the custody. 
 pricing Type:   PricingParams Contains data for the custody''s price-related logic. 
 permissions Type:   Permissions A set of global flags that can be set by the protocol''s administrator to enable or disable trade actions which is useful during program upgrades or black swan events. 
 targetRatioBps Type:   u64 The target weightage (in basis points) for the custody in the JLP pool. 
 assets Type:   Assets Contains data used to calculate PNL, AUM, and core business logic for the program. 
 fundingRateState Type:   FundingRateState Contains data used to calculate borrow fees for open positions. 
 
 PricingParams 
 Field Description 
 tradeImpactFeeScalar Type:   u64 Sets the base value when calculating price impact fees when opening or closing positions. 
 maxLeverage Type:   u64 Sets the max leverage for this custody''s positions. The max leverage for all custodies is 500x at the time of writing. 
 maxGlobalLongSizes Type:   u64 The maximum total position size (USD) for long positions. 
 maxGlobalShortSizes Type:   u64 The maximum total position size (USD) for short positions. 
 
 Assets 
 Field Description 
 feesReserves Type:   u64 The fees collected by all open positions for the custody.  feesReserves  resets to zero when the fees are distributed to the pool and protocol. 
 owned Type:   u64 The number of tokens owned by the pool for the custody. - The owned value is increased either by providing liquidity to the pool or depositing collateral when opening or updating positions. - Conversely, the owned value decreases when liquidity is removed from the pool or collateral is withdrawn from closing positions. 
 locked Type:   u64 The number of tokens locked by the pool for the custody to pay off potential profits for open positions. 
 guaranteedUsd Type:   u64 This value represents the total amount borrowed in USD (position size - collateral) across all long positions. It is updated whenever traders modify their collateral through deposits or withdrawals. The system uses this aggregated figure to efficiently calculate the total profit and loss (PNL) for all long positions, which in turn is used to calculate the AUM of the JLP pool. 
 globalShortSizes Type:   u64 Stores the total amount (USD) position sizes for all short positions. 
 globalShortAveragePrices Type:   u64 Stores the average price (USD) for all short positions. This value and  globalShortSizes  are used to calculate the PNL for all short positions efficiently, and is again used to calculate the AUM of the JLP pool. 
 
 FundingRateState 
 Field Description 
 cumulativeInterestRate Type:   u128 Traders are required to pay hourly borrow fees for opening leveraged positions. This fee is calculated based on two primary factors: the size of the trader''s position and the current utilization of the pool for the custody. To calculate borrow fees more efficiently, each custody account contains a value called  cumulativeInterestRate . Correspondingly, each position account stores a  cumulativeInterestSnapshot  which captures the value of  cumulativeInterestRate  at the time of the position''s last update. Whenever there''s a change in either the borrowed assets or the total assets within a custody, the  cumulativeInterestRate  for the custody is updated. The difference between the custody''s  cumulativeInterestRate  and the position''s  cumulativeInterestSnapshot  is then used to calculate the position''s borrow fees. 
 lastUpdate Type:   i64 The UNIX timestamp for when the custody''s borrow fee data was last updated. 
 hourlyFundingDbps Type:   u64 A constant used to calculate the hourly borrow fees for the custody. The Jupiter Perpetuals exchange works with Gauntlet and Chaos Labs to update and fine tune the  hourlyFundingDbps  to respond to traders'' feedback and market conditions.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/200-perp-api/201-position-account.md', 'sidebar_label: "Position Account"
description: "Understand and integrate the Jupiter Perp Program."
title: "Position Account" 

     Position Account 
     

 This page contains an overview of the  Solana account types  used in the Jupiter Perpetuals Program, and specifically the  Position  account. 
 The  Position  account is a struct which represents a set of parameters and states associated to trade position data for a given token. 
 :::note  Position  account derivation
The  Position  account''s address is derived from the trader''s wallet address / public key, the custody account, the collateral custody account, and a few other constant seeds. This means traders will always have the same Position account address for their open positions. 
 This also means that traders only have nine positions available at one time: 
 
 Long SOL 
 Long wETH 
 Long wBTC 
 Short SOL (USDC as collateral) 
 Short SOL (USDT as collateral) 
 Short wETH (USDC as collateral) 
 Short wETH (USDT as collateral) 
 Short wBTC (USDC as collateral) 
 Short wBTC (USDT as collateral) 
 
 This is an example  Position  account .
::: 
 :::tip Example Typescript Repository
This  repository  contains Typescript code samples on interacting with the Jupiter Perpetuals program IDL with  anchor  and  @solana/web3.js 
 You can also find the  Custody Account fields in the repository  or on a  blockchain explorer .
::: 
 Account Details 
 Each  Position  account contains the following data: 
 Field Description 
 owner Type:   publicKey The public key of the trader''s account. 
 pool Type:   publicKey The public key of the  JLP pool account . 
 custody Type:   publicKey The public key of the position''s  custody  account . 
 collateralCustody Type:   publicKey The public key of the position''s collateral custody account. Like the  custody  account, a  collateralCustody  account contains information for the token that''s used as collateral for the position (SOL / wETH / wBTC for long positions, USDC / USDT for short positions). The borrow rates for the position will also be calculated based on the position''s  collateralCustody . 
 openTime Type:   i64 The open time of the position in UNIX timestamp format. 
 updateTime Type:   i64 The last updated time of the position in UNIX timestamp format. 
 side Type:   Side The position''s side, either  long  or  short . 
 price Type:   u64 The entry price of the position when it was opened. The entry price is an integer in the atomic value (before decimals), a USDC (6 decimals) value of  158225872  is equivalent to $158.22. 
 sizeUsd Type:   u64 The position size after leverage in USD in the atomic value (before decimals). A position with  sizeUsd = 0  is treated as a closed position. 
 collateralUsd Type:   u64 The position''s collateral size after fees in USD in the atomic value (before decimals). 
 realisedPnlUsd Type:   i64 The position''s realized PNL when closing the position partially. When a position is closed completely, the position''s  realisedPnlUsd  will be  0  as the position is considered closed (as described in  sizeUsd ). 
 cumulativeInterestSnapshot Type:   u128 Stores the position''s interest rate snapshot when it was last updated. - The  collateralCustody  account for the respective collateral token stores a monotonically increasing counter in  collateralCustody .fundingRateState .cumulativeInterestRate . The difference between the  collateralCustody .fundingRateState .cumulativeInterestRate  and the position''s  cumulativeInterestSnapshot  is used to calculate the borrow fees for the position. 
 lockedAmount Type:   u64 The amount of tokens (SOL / wETH / wBTC for long positions, USDC / USDT for short positions) locked to pay off the position''s max potential profit. It acts as a cap on the maximum potential profit of the position. This amount is locked in the collateral custody to ensure the platform has sufficient tokens to pay out profitable trades. 
 bump Type:   u8 The bump seed used to derive the PDA for the  Position  account.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/200-perp-api/203-pool-account.md', 'sidebar_label: "Pool Account"
description: "Understand and integrate the Jupiter Perp Program."
title: "Pool Account" 

     Pool Account 
     

 This page contains an overview of the  Solana account types  used in the Jupiter Perpetuals Program, and specifically the  Pool  account. 
 The  Pool  account is a struct which represents a set of parameters and states associated to the data for JLP pool, including AUM and  Custody  data. 
 :::note only one pool account
There is only one  Pool  account .
::: 
 :::tip Example Typescript Repository
This  repository  contains Typescript code samples on interacting with the Jupiter Perpetuals program IDL with  anchor  and  @solana/web3.js 
 You can also find the  Custody Account fields in the repository  or on a  blockchain explorer .
::: 
 Account Details 
 Each  Pool  account contains the following data: 
 Field Description 
 name Type:   string The name for the account. 
 custodies Type:   publicKey An array containing the public keys for the custodies (tokens) managed by the JLP pool. 
 aumUsd Type:   u128 The current AUM value (USD) for the JLP pool. The  aumUsd  value''s calculation can be summarized by getting the USD value of the tokens managed by the pool minus the USD value reserved to pay off trader profits. Refer to the  Custody account  details for more details on AUM calculation. 
 limit Type:   Limit Contains values for the pool''s limits. 
 fees Type:   Fees Sets the fee amounts or percentages for the Jupiter Perpetuals exchange. 
 poolApr Type:   PoolApr Contains data related to the pool''s APR / APY calculations. 
 
 Limit 
 Field Description 
 maxAumUsd Type:   u128 The max AUM for the JLP pool. This acts as a max cap / ceiling as the JLP will not accept deposits when the cap is hit. 
 tokenWeightageBufferBps Type:   u128 The token weightage buffer (in basis points) to calculate the token''s maximum or minimum current weightage based on the target weightage. Currently,  tokenWeightageBufferBps  is set to  2000  which means the the current weightage cannot be lower or higher than + / - 20% of the token''s target weightage. For example, if SOL''s target weightage for the JLP pool is 50%, the current weightage cannot be less than 40% or exceed 60%. The pool will not allow deposits or withdrawals if the action causes the token to exceed its target weightage. 
 maxPositionUsd Type:   u64 Sets the maximum position size. The current  maxPositionUsd  value is  2_500_000_000_000  which means a position''s max size is $2,500,000. 
 
 Fees 
 Field Description 
 increasePositionBps Type:   string A fixed fee of 6 BPS (0.06%) is charged for opening or increasing a position. 
 decreasePositionBps Type:   publicKey A fixed fee of 6 BPS (0.06%) is charged for closing or decreasing a position. 
 addRemoveLiquidityBps Type:   u128 Fee charged when adding or removing liquidity to/from the pool. 
 swapBps Type:   Limit Swap fee for exchanging non-stablecoin tokens routed through the liquidity pool. swap fee = swapBps ± swapTaxBps 
 taxBps Type:   PoolApr Tax fee for non-stablecoins, determined based on the difference between the current and target weightage. A larger difference results in a higher tax fee, encouraging liquidity providers to rebalance the pool to the target weightage. 
 stableSwapBps Type:   Limit Swap fee for exchanges involving stablecoins, routed through the liquidity pool. swap fee = stableSwapBps ± stableSwapTaxBps 
 stableSwapTaxBps Type:   Fees Tax fee for stablecoin swaps. Similar to taxBps, this fee is determined by the difference between the current and target weightage. 
 protocolShareBps Type:   PoolApr Jupiter takes a share of 2500 BPS (25%) from the fees collected by the pool. 
 
 PoolApr 
 Field Description 
 lastUpdated Type:   i64 The UNIX timestamp when the pool''s APR data was last updated. 
 feeAprBps Type:   u64 The pool''s APR in BPS format. The APR is calculated weekly by dividing the pool''s realized fees (minus the 25% collected by the protocol) by the total pool value, adjusting for the 1 week time period to annualize the rate. 
 realizedFeeUsd Type:   u64 The fees collected by the pool so far. This fee is reinvested back into the pool and is also used to calculate the APR as mentioned above. realizedFeeUsd resets to zero when the fee is reinvested into the pool hence causing the APR value to fluctuate weekly.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/200-perp-api/README.md', 'sidebar_label: "About Perp API"
description: "Use the Jupiter Perp API to trade or analyze."
title: "About Perp API" 

     About Perp API 
     

 :::warning
The Perp API is still a  work in progress , stay tuned!
::: 
 :::tip
In the meantime, you can use this amazing github repository to direct Anchor IDL parse the Perp Program. 
 
 Fetch Perp or JLP pool data 
 Interact with the Perp Program 
 
 https://github.com/julianfssen/jupiter-perps-anchor-idl-parsing
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/200-perp-api/202-position-request-account.md', 'sidebar_label: "PositionRequest Account"
description: "Understand and integrate the Jupiter Perp Program."
title: "PositionRequest Account" 

     PositionRequest Account 
     

 This page contains an overview of the  Solana account types  used in the Jupiter Perpetuals Program, and specifically the  PositionRequest  account. 
 The  PositionRequest  account is a struct which represents a set of parameters and states associated to a request to open or close a position, the  PositionRequest  account consists of mostly similar properties as  Position  account . 
 :::note  PositionRequest  Account Derivation
It is a Program-Derived Address (PDA) derived from the underlying  Position  account''s address, several constant seeds, and a random integer seed which makes each  PositionRequest  account unique. 
 The is an example  PositionRequest  account .
::: 
 :::info  PositionRequestATA  account
A  PositionRequestATA  account is created for each  PositionRequest  account. 
 The  PositionRequestATA  account is an  associated token account  derived from the  PositionRequest  that contains the tokens from the trader''s deposits or withdrawals from withdrawing collateral or closing positions. 
 The tokens are then transferred to the position token''s custody token account or returned to the trader''s wallet when the  PositionRequestATA  account is closed.
::: 
 :::info Take Profit / Stop Loss Requests
 PositionRequest  accounts for non TP / SL requests are closed as soon as the request is executed or rejected. 
 TP / SL requests are also stored onchain via  PositionRequest  accounts. However, they will only be closed when the TP / SL request is triggered and executed. 
 Active TP / SL requests can be fetched onchain (through blockchain explorers like Solscan or SolanaFM) by searching for the  PositionRequest  address or public key associated with the TP / SL request.
::: 
 :::tip Example Typescript Repository
This  repository  contains Typescript code samples on interacting with the Jupiter Perpetuals program IDL with  anchor  and  @solana/web3.js 
 You can also find the  Custody Account fields in the repository  or on a  blockchain explorer .
::: 
 Account Details 
 Each  PositionRequest  account contains the following data: 
 Field Description 
 owner Type:   publicKey The public key of the trader''s account. 
 pool Type:   publicKey The public key of the  JLP pool account . 
 custody Type:   publicKey The public key of the position''s  custody  account . 
 collateralCustody Type:   publicKey The public key of the position''s collateral custody account. Like the  custody  account, a  collateralCustody  account contains information for the token that''s used as collateral for the position (SOL / wETH / wBTC for long positions, USDC / USDT for short positions). The borrow rates for the position will also be calculated based on the position''s  collateralCustody . 
 mint Type:   publicKey For opening positions and collateral deposits, mint refers to the input mint requested by the trader. For example, if a trader opens a position by providing the initial margin with SOL, then mint will be equal to SOL''s mint address. If the trader deposits collateral in USDC, then mint will be equal to USDC''s mint address. For closing positions and collateral withdrawals, mint is equal the to position collateral token''s mint address. For example, if a trader closes a long SOL position, mint will be equal to SOL''s mint address. If a trader closes a short SOL position, mint is equal to USDC or USDT''s mint address depending on the position''s collateral. 
 openTime Type:   i64 The time when the request of position is created in UNIX timestamp format. 
 updateTime Type:   i64 The time when the request of position is last updated in UNIX timestamp format. 
 sizeUsdDelta Type:   u64 The USD amount to increase or decrease the position size by. The amount is an integer in the atomic value (before decimals which is 6 for USDC / UST mints). For example, a position request to increase an open position''s size by 10 USDC will have a  sizeUsdDelta = 10000000 . 
 collateralDelta Type:   u64 For opening positions and collateral deposits,  collateralDelta  is the token amount to increase or decrease the position collateral size by. The token amount is represented in atomic values (before decimals). 
 requestChange Type:   RequestChange requestChange  will be equal to  Increase  for open position and collateral deposit requests, and  Decrease  for close position and collateral withdrawal requests. 
 requestType Type:   RequestType Market  for all position requests except for TP / SL requests, which have a different  requestType  known as  Trigger . 
 side Type:   Side Long  for long positions,  Short  for short positions 
 priceSlippage Type:   u64 The maximum price with slippage for position requests when opening, closing, or updating the position size. - When increasing the size of a long position or decreasing the size of a short position, the request will fail if the current price of the position''s token is greater than  priceSlippage . - When decreasing the size of a long position or increasing the size of a short position, the request will fail if  priceSlippage  is greater than the current price of the position''s token. 
 jupiterMinimumOut Type:   u64 For requests that require token swaps, the output amount of the token swap must be greater than or equal to  jupiterMinimumOut , else the request will fail. 
 preSwapAmount Type:   u64 This is an internal attribute used by the program to calculate the  collateralDelta  for position requests that require token swaps. 
 triggerPrice Type:   u64 The price (USD) used for TP / SL position requests. 
 triggerAboveThreshold Type:   bool When  triggerAboveThreshold  is true, the TP / SL position request will be triggered when the position''s token price is greater than or equal to  triggerPrice . When  triggerAboveThreshold  is false, the TP / SL position request will be triggered when the position''s token price is less than or equal to  triggerPrice . 
 entirePosition Type:   bool This attribute is only checked when closing or decreasing position sizes. When  entirePosition  is true, the entire position will be closed (i.e. a close position request). When  entirePosition  is false, the position size will be reduced according to sizeUsdDelta. 
 executed Type:   bool Determines whether the position request is executed or not. 
 counter Type:   u64 The random integer seed used to derive the position request address. 
 bump Type:   u8 The bump seed used to derive the position request address.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/plugin/react-app-example.md', 'sidebar_label: "React App Example"
description: "A step-by-step guide to integrating Jupiter Plugin into a React application."
title: "React App Example" 

     Plugin React App Example 
     

 In this guide, we''ll walk you through from scratch the steps to integrate Jupiter Plugin into a React application. 
 Prerequisites 
 Before you begin, make sure you have the following installed on your system. 
 Node.js and npm : Download and install from  nodejs.org 
 Step 1: Create a New React Project 
 Head to your preferred directory and create a new React project using  create-react-app  with TypeScript template (you can use other templates or methods to start your project too): 
 npx create-react-app plugin-demo --template typescript
cd plugin-demo
npm start
 
 Step 2: Add TypeScript Support 
 Create a type declaration file  plugin.d.ts  in your project''s  /src/types  folder: 
 declare global {
  interface Window {
    Jupiter: JupiterPlugin;
  }
};
export {};
 
 
   
    Full TypeScript Declaration
   
 declare global {
    interface Window {
        Jupiter: JupiterPlugin;
    }
}

export type WidgetPosition = ''bottom-left'' | ''bottom-right'' | ''top-left'' | ''top-right'';
export type WidgetSize = ''sm'' | ''default'';
export type SwapMode = "ExactInOrOut" | "ExactIn" | "ExactOut";
export type DEFAULT_EXPLORER = ''Solana Explorer'' | ''Solscan'' | ''Solana Beach'' | ''SolanaFM'';

export interface FormProps {
    swapMode?: SwapMode;
    initialAmount?: string;
    initialInputMint?: string;
    initialOutputMint?: string;
    fixedAmount?: boolean;
    fixedMint?: string;
    referralAccount?: string;
    referralFee?: number;
}

export interface IInit {
    localStoragePrefix?: string;
    formProps?: FormProps;
    defaultExplorer?: DEFAULT_EXPLORER;
    autoConnect?: boolean;
    displayMode?: ''modal'' | ''integrated'' | ''widget'';
    integratedTargetId?: string;
    widgetStyle?: {
        position?: WidgetPosition;
        size?: WidgetSize;
    };
    containerStyles?: CSSProperties;
    containerClassName?: string;
    enableWalletPassthrough?: boolean;
    passthroughWalletContextState?: WalletContextState;
    onRequestConnectWallet?: () => void | Promise<void>;
    onSwapError?: ({
        error,
        quoteResponseMeta,
    }: {
        error?: TransactionError;
        quoteResponseMeta: QuoteResponse | null;
    }) => void;
    onSuccess?: ({
        txid,
        swapResult,
        quoteResponseMeta,
    }: {
        txid: string;
        swapResult: SwapResult;
        quoteResponseMeta: QuoteResponse | null;
    }) => void;
    onFormUpdate?: (form: IForm) => void;
    onScreenUpdate?: (screen: IScreen) => void;
}

export interface JupiterPlugin {
    _instance: JSX.Element | null;
    init: (props: IInit) => void;
    resume: () => void;
    close: () => void;
    root: Root | null;
    enableWalletPassthrough: boolean;
    onRequestConnectWallet: IInit[''onRequestConnectWallet''];
    store: ReturnType<typeof createStore>;
    syncProps: (props: { passthroughWalletContextState?: IInit[''passthroughWalletContextState''] }) => void;
    onSwapError: IInit[''onSwapError''];
    onSuccess: IInit[''onSuccess''];
    onFormUpdate: IInit[''onFormUpdate''];
    onScreenUpdate: IInit[''onScreenUpdate''];
    localStoragePrefix: string;
}

export { };
 
 
 Step 3: Embed the Plugin Script 
 In your  /public/index.html , add the Jupiter Plugin script: 
 <head>
  <script src="https://plugin.jup.ag/plugin-v1.js" data-preload defer></script>
</head>
 
 Step 4: Initialize Plugin 
 There are two ways to initialize Jupiter Plugin in a React application: 
 Method 1: Using Window Object 
 In your  /src/App.tsx , use the following code to initialize the plugin. 
 import React, { useEffect } from ''react'';
import ''./App.css'';
import ''./types/plugin.d'';

export default function App() {
  useEffect(() => {
    // Initialize plugin
    window.Jupiter.init({
      displayMode: "widget",
      integratedTargetId: "jupiter-plugin",
    });
  }, []);

  return (
    <div className="App">
      <h1>Jupiter Plugin Demo</h1>
      <div id="jupiter-plugin" />
    </div>
  );
}
 
 Method 2: Using @jup-ag/plugin Package 
 :::warning
Do note that using this method will require you to maintain its dependencies.
::: 
 
 Install the package: 
 
 npm install @jup-ag/plugin
 
 
 Initialize the plugin: 
 
 import React, { useEffect } from "react";
import "@jup-ag/plugin/css";
import "./App.css";
import "./types/plugin.d";

export default function App() {
  useEffect(() => {
    import("@jup-ag/plugin").then((mod) => {
      const { init } = mod;
      init({
        displayMode: "widget",
        integratedTargetId: "jupiter-plugin",
      });
    });
  }, []);

  return (
    <div>
      <h1>Jupiter Plugin Demo</h1>
      <div id="jupiter-plugin" />
    </div>
  );
}
 
 There you have it! You''ve successfully integrated Jupiter Plugin into your Next.js application. 
 
 Please test the swap functionality and check the transaction. 
 If you require more customizations, check out the  Plugin Playground  or the  Customization  documentation. 
 If you have any questions or issues, please refer to the  FAQ  or contact us on  Discord .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/plugin/customization.md', 'sidebar_label: "Customizing Plugin"
description: "Learn how to customize Jupiter Plugin''s appearance and behavior."
title: "Customizing Plugin" 

     Customizing Plugin 
     

 Try out the  Plugin Playground  to experience the full swap features and see the different customization options with code snippets. 
 For the full customization options, you can refer to the  repository . 
 If you are using TypeScript, you can use the type declaration file to get the full type definitions for the Plugin. 
 
   
    Full TypeScript Declaration
   
 declare global {
    interface Window {
        Jupiter: JupiterPlugin;
    }
}

export type WidgetPosition = ''bottom-left'' | ''bottom-right'' | ''top-left'' | ''top-right'';
export type WidgetSize = ''sm'' | ''default'';
export type SwapMode = "ExactInOrOut" | "ExactIn" | "ExactOut";
export type DEFAULT_EXPLORER = ''Solana Explorer'' | ''Solscan'' | ''Solana Beach'' | ''SolanaFM'';

export interface FormProps {
    swapMode?: SwapMode;
    initialAmount?: string;
    initialInputMint?: string;
    initialOutputMint?: string;
    fixedAmount?: boolean;
    fixedMint?: string;
    referralAccount?: string;
    referralFee?: number;
}

export interface IInit {
    localStoragePrefix?: string;
    formProps?: FormProps;
    defaultExplorer?: DEFAULT_EXPLORER;
    autoConnect?: boolean;
    displayMode?: ''modal'' | ''integrated'' | ''widget'';
    integratedTargetId?: string;
    widgetStyle?: {
        position?: WidgetPosition;
        size?: WidgetSize;
    };
    containerStyles?: CSSProperties;
    containerClassName?: string;
    enableWalletPassthrough?: boolean;
    passthroughWalletContextState?: WalletContextState;
    onRequestConnectWallet?: () => void | Promise<void>;
    onSwapError?: ({
        error,
        quoteResponseMeta,
    }: {
        error?: TransactionError;
        quoteResponseMeta: QuoteResponse | null;
    }) => void;
    onSuccess?: ({
        txid,
        swapResult,
        quoteResponseMeta,
    }: {
        txid: string;
        swapResult: SwapResult;
        quoteResponseMeta: QuoteResponse | null;
    }) => void;
    onFormUpdate?: (form: IForm) => void;
    onScreenUpdate?: (screen: IScreen) => void;
}

export interface JupiterPlugin {
    _instance: JSX.Element | null;
    init: (props: IInit) => void;
    resume: () => void;
    close: () => void;
    root: Root | null;
    enableWalletPassthrough: boolean;
    onRequestConnectWallet: IInit[''onRequestConnectWallet''];
    store: ReturnType<typeof createStore>;
    syncProps: (props: { passthroughWalletContextState?: IInit[''passthroughWalletContextState''] }) => void;
    onSwapError: IInit[''onSwapError''];
    onSuccess: IInit[''onSuccess''];
    onFormUpdate: IInit[''onFormUpdate''];
    onScreenUpdate: IInit[''onScreenUpdate''];
    localStoragePrefix: string;
}

export { };
 
 
 Display Modes 
 Jupiter Plugin offers three distinct display modes to suit different use cases: 
 1. Integrated Mode 
 The integrated mode embeds the swap form directly into your application''s layout. This is ideal for creating a seamless swap experience within your dApp. 
 {
  displayMode: "integrated";
  integratedTargetId: string; // Required: ID of the container element
  containerStyles?: {
    width?: string;
    height?: string;
    borderRadius?: string;
    overflow?: string;
  };
  containerClassName?: string
}
 
 2. Widget Mode 
 The widget mode creates a floating swap form that can be positioned in different corners of the screen. Perfect for quick access to swaps without taking up too much space. 
 {
  displayMode: "widget";
  widgetStyle?: {
    position?: "top-left" | "top-right" | "bottom-left" | "bottom-right";
    size?: "sm" | "default";
  };
}
 
 3. Modal Mode 
 The modal mode displays the swap form in a popup overlay. This is useful when you want to keep the swap form hidden until needed. 
 {
  displayMode: "modal";
}
 
 Form Props Configuration 
 The  formProps  object allows you to customize the initial state and behavior of the swap form! This can be useful for use cases like fixed token swaps for memecoin communities or fixed amount payments. 
 {
  displayMode: "modal";
  formProps?: {
    swapMode?: SwapMode; // Set the swap mode to "ExactIn", "ExactOut", or default to "ExactInOrOut"

    initialAmount?: string; // Pre-fill the swap amount (e.g. "100")
    initialInputMint?: string; // Pre-select the input token by its mint address
    initialOutputMint?: string; // Pre-select the output token by its mint address

    fixedAmount?: boolean; // When true, users cannot change the swap amount
    fixedMint?: string; // Lock one side of the swap to a specific token by its mint address

    referralAccount?: string; // Set the referral account for the swap
    referralFee?: number; // Set the referral fee for the swap
  }
}
 
 Wallet Integration 
 Jupiter Plugin supports third-party wallet integration through the  enableWalletPassthrough  prop. This allows your application to pass through an existing wallet provider''s connection in your application to Plugin. If you do not have an existing wallet provider, Plugin will provide a wallet adapter and connection - powered by  Unified Wallet Kit . 
 {
  // When true, wallet connection are handled by your dApp,
  // and use `syncProps()` to syncronise wallet state with Plugin.
  enableWalletPassthrough?: boolean;

  // Optional, if wallet state is ready, 
  // you can pass it in here, or just use `syncProps()`
  passthroughWalletContextState?: WalletContextState;
  
  // When enableWalletPassthrough is true, this allows Plugin 
  // to callback your app''s wallet connection flow
  onRequestConnectWallet?: () => void | Promise<void>;
}
 
 Event Handling 
 Jupiter Plugin provides event handlers to track swap operations: 
 {
  onSuccess: ({ txid, swapResult, quoteResponseMeta }) => {
    // Handle successful swap
    console.log("Swap successful:", txid);
  };
  onSwapError: ({ error, quoteResponseMeta }) => {
    // Handle swap errors
    console.error("Swap failed:", error);
  }
}
 
 Branding 
 Jupiter Plugin supports branding through the  branding  prop. This allows you to customize the Plugin''s logo and name to include your own branding. 
 {
  branding?: {
    logoUri?: string;
    name?: string;
  };
}
 
 Color Theme 
 Jupiter Plugin supports a simplified way to customize the color theme. This allows you to match the appearance of the Plugin to your brand. 
 /* In your global CSS file */
:root {
  --jupiter-plugin-primary: 199, 242, 132;
  --jupiter-plugin-background: 0, 0, 0;
  --jupiter-plugin-primaryText: 232, 249, 255;
  --jupiter-plugin-warning: 251, 191, 36;
  --jupiter-plugin-interactive: 33, 42, 54;
  --jupiter-plugin-module: 16, 23, 31;
}
 
 Examples 
 Fixed SOL Swap 
 window.Jupiter.init({
  displayMode: "integrated";
  integratedTargetId: "jupiter-plugin";
  formProps: {
    initialInputMint: "So11111111111111111111111111111111111111112"; // SOL
    initialOutputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // USDC
    fixedMint: "So11111111111111111111111111111111111111112";
  };
});
 
 Payment Integration 
 window.Jupiter.init({
  displayMode: "modal";
  formProps: {
    swapMode: "ExactOut";
    initialAmount: "10";
    fixedAmount: true;
    initialOutputMint: "YOUR_TOKEN_MINT";
    fixedMint: "YOUR_TOKEN_MINT";
  };
});
 
 Floating Widget 
 window.Jupiter.init({
  displayMode: "widget";
  widgetStyle: {
    position: "bottom-right";
    size: "sm";
  };
});', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/plugin/faq.md', 'sidebar_label: "FAQ"
description: "Plugin FAQ"
title: "FAQ" 

     Plugin FAQ 
     

 1. How do I feature request or get support? 
 
 For feature requests, please open an issue on the  GitHub repository  and tag us on Discord. 
 For support, please join the  Discord server  and get help in the developer channels. 
 
 2. How do I add fees to Plugin? 
 
 Creating Referral Account and Token Accounts : You can create via  scripts  or  Referral Dashboard . 
 Adding to FormProps : You can set the referral account and fee in the  formProps  interface  when you initialize the Plugin. 
 
 3. Integrated Mode: Token Search Modal Collapses Plugin 
 
 Ensure you establish a fixed height for the swap form container under  containerStyles 
 
 {
   displayMode: "integrated",
   integratedTargetId: "jupiter-plugin",
   containerStyles: {
      height: "500px",
   },
}
 
 Best Practices for Customization 
 1. Responsive Design 
 
 Use percentage-based widths for container styles 
 Test on different screen sizes 
 Consider mobile-first design 
 
 2. User Experience 
 
 Position widgets in easily accessible locations 
 Consider fixed token pairs for specific use cases 
 Implement proper error handling and prompts 
 
 3. Security 
 
 Use environment variables for sensitive data 
 Implement proper error boundaries 
 Validate user inputs', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/plugin/README.md', 'description: "An overview of Jupiter Plugin and its core features."
title: "Integrate Jupiter Plugin" 
 
 Jupiter Plugin is an open-source, lightweight, plug-and-play version of Jupiter that allows you to seamlessly integrate end-to-end swap functionality into your application with minimal effort - with just a few lines of code, you can embed a fully functional swap interface directly into your website while providing the same powerful Ultra Mode swap experience found on https://jup.ag. 
 :::info Plugin Playground
Try out the  Plugin Playground  to experience the full swap features and see the different customization options with code snippets. 
 To view the open-source code, visit the  GitHub repository .
::: 
 :::info Quick Start
To quick start your integration, check out the  Next.js ,  React  or  HTML  app examples.
::: 
 Key Features 
 
 Seamless Integration : Embed Jupiter''s swap functionality directly into your application without redirects. 
 Multiple Display Options : Choose between integrated, widget, or modal display modes. 
 Customizable Options : Configure the swap form to match your application''s needs. 
 RPC-less : Integrate Plugin without any RPCs, Ultra handles transaction sending, wallet balances and token information. 
 Ultra Mode : Access to all features of Ultra Mode, read more about it in the  Ultra API docs . 
 
 Getting Started 
 When integrating Plugin, there are a few integration methods to think about, and choose the one that best fits your application''s architecture and requirements. 
 Integration Methods 
 
 Using Window Object  - Simplest way to add and initialize Plugin. 
 Using NPM Package  - Install via  npm install @jup-ag/plugin  and initialize as a module (will require you to maintain its dependencies). 
 
 Wallet Integration 
 
 Wallet Standard Support : For applications without existing wallet provider, Plugin will provide a wallet adapter and connection - powered by  Unified Wallet Kit . 
 Passthrough Wallet : For applications with existing wallet provider(s), set  enableWalletPassthrough=true  with context, and Plugin will allow the application to pass through the existing wallet provider''s connection to Plugin. 
 
 Adding Fees to Plugin 
 
 Referral Account : You can create a referral account via  scripts  or  Referral Dashboard . 
 Referral Fee : You can set the referral fee and account in the  formProps  interface when you initialize the Plugin. 
 
 Quick Start Guides 
 In the next sections, we''ll walk you through the steps to integrate Jupiter Plugin into different types of web applications from scratch. 
 
 Next.js 
 React 
 HTML 
 
 By integrating Jupiter Plugin into your application, you can seamlessly integrate a fully functional swap interface into your application with minimal effort, while staying at the forefront of Solana DeFi innovation.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/plugin/html-app-example.md', 'sidebar_label: "HTML App Example"
description: "A step-by-step guide to integrating Jupiter Plugin into a HTML application."
title: "HTML App Example" 

     Plugin HTML App Example 
     

 In this guide, we''ll walk you through from scratch the steps to integrate Jupiter Plugin into a HTML application. 
 Prerequisites 
 Before you begin, make sure you have the following installed on your system. 
 Node.js and npm : Download and install from  nodejs.org 
 http-server : Download and install  http-server from npm 
 Step 1: Create a New HTML Project 
 Head to your preferred directory and create a new folder for your project: 
 mkdir plugin-demo
cd plugin-demo
touch index.html
 
 Step 2: Add the Plugin Script 
 Add the Plugin script to your project: 
 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jupiter Plugin Demo</title>
    <script src="https://plugin.jup.ag/plugin-v1.js" data-preload defer></script>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Jupiter Plugin Demo</h1>
        <div id="jupiter-plugin"></div>
    </div>

    <script>
        window.onload = function() {
            window.Jupiter.init({
                displayMode: "widget",
                integratedTargetId: "jupiter-plugin",
            });
        };
    </script>
</body>
</html>
 
 Step 3: Run the Project 
 Run the project using  http-server : 
 http-server
 
 There you have it! You''ve successfully integrated Jupiter Plugin into your HTML application. 
 
 Please test the swap functionality and check the transaction. 
 If you require more customizations, check out the  Plugin Playground  or the  Customization  documentation. 
 If you have any questions or issues, please refer to the  FAQ  or contact us on  Discord .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/plugin/nextjs-app-example.md', 'sidebar_label: "Next.js App Example"
description: "A step-by-step guide to integrating Jupiter Plugin into a Next.js application."
title: "Next.js App Example" 

     Plugin Next.js App Example 
     

 In this guide, we''ll walk you through from scratch the steps to integrate Jupiter Plugin into a Next.js application. 
 Prerequisites 
 Before you begin, make sure you have the following installed on your system. 
 Node.js and npm : Download and install from  nodejs.org 
 Step 1: Create a New Next.js Project 
 Head to your preferred directory and create a new Next.js project using  create-next-app  with TypeScript template (you can use other templates or methods to start your project too): 
 npx create-next-app@latest plugin-demo --typescript
cd plugin-demo
npm run dev
 
 Step 2: Add TypeScript Support 
 Create a type declaration file  plugin.d.ts  in your project''s  /src/types  folder: 
 declare global {
  interface Window {
    Jupiter: JupiterPlugin;
  }
};
export {};
 
 
   
    Full TypeScript Declaration
   
 declare global {
    interface Window {
        Jupiter: JupiterPlugin;
    }
}

export type WidgetPosition = ''bottom-left'' | ''bottom-right'' | ''top-left'' | ''top-right'';
export type WidgetSize = ''sm'' | ''default'';
export type SwapMode = "ExactInOrOut" | "ExactIn" | "ExactOut";
export type DEFAULT_EXPLORER = ''Solana Explorer'' | ''Solscan'' | ''Solana Beach'' | ''SolanaFM'';

export interface FormProps {
    swapMode?: SwapMode;
    initialAmount?: string;
    initialInputMint?: string;
    initialOutputMint?: string;
    fixedAmount?: boolean;
    fixedMint?: string;
    referralAccount?: string;
    referralFee?: number;
}

export interface IInit {
    localStoragePrefix?: string;
    formProps?: FormProps;
    defaultExplorer?: DEFAULT_EXPLORER;
    autoConnect?: boolean;
    displayMode?: ''modal'' | ''integrated'' | ''widget'';
    integratedTargetId?: string;
    widgetStyle?: {
        position?: WidgetPosition;
        size?: WidgetSize;
    };
    containerStyles?: CSSProperties;
    containerClassName?: string;
    enableWalletPassthrough?: boolean;
    passthroughWalletContextState?: WalletContextState;
    onRequestConnectWallet?: () => void | Promise<void>;
    onSwapError?: ({
        error,
        quoteResponseMeta,
    }: {
        error?: TransactionError;
        quoteResponseMeta: QuoteResponse | null;
    }) => void;
    onSuccess?: ({
        txid,
        swapResult,
        quoteResponseMeta,
    }: {
        txid: string;
        swapResult: SwapResult;
        quoteResponseMeta: QuoteResponse | null;
    }) => void;
    onFormUpdate?: (form: IForm) => void;
    onScreenUpdate?: (screen: IScreen) => void;
}

export interface JupiterPlugin {
    _instance: JSX.Element | null;
    init: (props: IInit) => void;
    resume: () => void;
    close: () => void;
    root: Root | null;
    enableWalletPassthrough: boolean;
    onRequestConnectWallet: IInit[''onRequestConnectWallet''];
    store: ReturnType<typeof createStore>;
    syncProps: (props: { passthroughWalletContextState?: IInit[''passthroughWalletContextState''] }) => void;
    onSwapError: IInit[''onSwapError''];
    onSuccess: IInit[''onSuccess''];
    onFormUpdate: IInit[''onFormUpdate''];
    onScreenUpdate: IInit[''onScreenUpdate''];
    localStoragePrefix: string;
}

export { };
 
 
 Step 3: Embed the Plugin Script 
 For Next.js applications, you can add the script in two ways: 
 Using App Router (Next.js 13+) 
 In your  app/layout.tsx : 
 import Script from "next/script";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        <Script
          src="https://plugin.jup.ag/plugin-v1.js"
          strategy="beforeInteractive"
          data-preload
          defer
        />
      </head>
      <body>{children}</body>
    </html>
  );
}
 
 Using Pages Router 
 In your  pages/_app.tsx : 
 import "@/styles/globals.css";
import type { AppProps } from "next/app";
import Script from "next/script";

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Script
        src="https://plugin.jup.ag/plugin-v1.js"
        strategy="beforeInteractive"
        data-preload
        defer
      />
      <Component {...pageProps} />
    </>
  );
}
 
 Step 4: Initialize Plugin 
 There are two ways to initialize Jupiter Plugin in a Next.js application: 
 Method 1: Using Window Object 
 Create a new component for the plugin at  components/plugin.tsx : 
 "use client";

import React, { useEffect } from "react";

export default function PluginComponent() {
  useEffect(() => {
    if (typeof window !== "undefined") {
      window.Jupiter.init({
        displayMode: "widget",
        integratedTargetId: "jupiter-plugin",
      });
    }
  }, []);

  return (
    <div>
      <h1>Jupiter Plugin Demo</h1>
      <div
        id="jupiter-plugin"
      />
    </div>
  );
}
 
 Method 2: Using @jup-ag/plugin Package 
 :::warning
Do note that using this method will require you to maintain its dependencies.
::: 
 
 Install the package: 
 
 npm install @jup-ag/plugin
 
 
 Create a new component for the plugin at  components/plugin.tsx : 
 
 "use client";

import React, { useEffect } from "react";
import "@jup-ag/plugin/css";

export default function PluginComponent() {
  useEffect(() => {
    import("@jup-ag/plugin").then((mod) => {
      const { init } = mod;
      init({
        displayMode: "widget",
        integratedTargetId: "jupiter-plugin",
      });
    });
  }, []);

  return (
    <div>
      <h1>Jupiter Plugin Demo</h1>
      <div id="jupiter-plugin" />
    </div>
  );
}
 
 Step 5: Add the Plugin Component to Your Page 
 In your  app/page.tsx  (or  pages/index.tsx  if you''re using Pages Router): 
 import PluginComponent from ''@/components/plugin'';

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <PluginComponent />
    </div>
  );
}
 
 There you have it! You''ve successfully integrated Jupiter Plugin into your Next.js application. 
 
 Please test the swap functionality and check the transaction. 
 If you require more customizations, check out the  Plugin Playground  or the  Customization  documentation. 
 If you have any questions or issues, please refer to the  FAQ  or contact us on  Discord .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/README.md', 'sidebar_label: "About Tool Kits"
description: "Introduction to Jupiter Developer Tool Kits"
title: "About Tool Kits" 

     About Tool Kits 
     

 Jupiter Tool Kits are a collection of developer tools and SDKs that help you integrate Jupiter''s powerful swap infrastructure into your applications. These tools are designed to make it easy to build on top of Solana and Jupiter. 
 Why Use Jupiter Tool Kits? 
 
 Accelerate Development : Get your applications to market faster with our pre-built components and SDKs. 
 Open Source : All our tools are open source, allowing you to inspect, modify and contribute to the codebase. 
 Low Code Solutions : Many of our tools require minimal coding, making integration quick and straightforward. 
 Community Driven : Join a vibrant community of developers building and improving these tools. 
 
 Jupiter Tool Kits 
 
 Jupiter Plugin : A ready-to-use swap interface that can be embedded into any website. 
 Jupiter Mobile Adapter : A wallet interface to allow Jupiter Mobile QR code login. 
 Unified Wallet Kit : A wallet interface that can be embedded into any website. 
 
 Community Contributions 
 
 Jupiverse Kit : A ready-to-use React components for building with Jupiter Plugin and Unified Wallet Kit. 
 DevRel Examples : A wealth of scripts and examples for building with Solana and Jupiter. 
 
 How to Contribute 
 We welcome contributions from the anyone! Here''s how you can help: 
 
 Submit pull requests to our repositories. 
 Submit issues to our repositories. 
 If you''re a vibe coder or non-technical, join our  Discord  to discuss any ideas you have. 
 Help us by spreading the word about the tool kits.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/mobile-adapter/README.md', 'sidebar_label: "Getting Started"
description: "Using Jupiter Mobile Adapter to login to apps"
title: "Jupiter Mobile Adapter" 

     Jupiter Mobile Adapter 
     

 The Jupiter Mobile Adapter allows you to integrate Jupiter Mobile login functionality into your app! By allowing Jupiter Mobile users to simply use the app to scan a QR code to login, they can utilize their wallets on Jupiter Mobile across any platform. 
 
 Install  @jup-ag/jup-mobile-adapter 
 Use  useWrappedReownAdapter  (Prerequisite to create an app id on https://dashboard.reown.com/) 
 Add the  jupiterAdapter  within the wrapped adapter 
 
 :::tip
 Example code reference from Jupiverse Kit 
::: 
 import { WalletProvider } from ''@solana/wallet-adapter-react'';
import { useWrappedReownAdapter } from "@jup-ag/jup-mobile-adapter";

const WalletConnectionProvider: React.FC<PropsWithChildren> = ({
  children,
}) => {
  // Refer to https://reown.com/appkit
  const { reownAdapter, jupiterAdapter } = useWrappedReownAdapter({
    appKitOptions: {
      metadata: {
        name: "",
        description: ``,
        url: "<YOUR_DOMAIN>", // origin must match your domain & subdomain
        icons: [
          // add icons here
        ],
      },
      projectId: "<YOUR_PROJECT_ID>",
      features: {
        analytics: false,
        socials: ["google", "x", "apple"],
        email: false,
      },
      enableWallets: false,
    },
  });

  const wallets = useMemo(
    () => [
      reownAdapter,
      jupiterAdapter,
      // add more wallets here
    ],
    []
  );

  return (
    <WalletProvider wallets={wallets} autoConnect>
      {children}
    </WalletProvider>
  );
};', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/wallet-kit/README.md', 'sidebar_label: "Getting Started"
description: An open source, streamlined Unified Wallet Kit adapter designed to simplify development on Solana.
title: Unified Wallet Kit 

     Unified Wallet Kit 
     

 The Unified Wallet Kit is an open-source, Swiss Army Knife wallet adapter designed to streamline your development on Solana. Integrating multiple wallets into a single interface can be cumbersome, the Unified Wallet Kit aims to eliminates redundancies by providing these building blocks in a simple, plug-and-play package. This allows developers to focus on what matters most: building innovative features for your users. 
 The Unified Wallet Kit will help you reduce repetitive tasks within your development process, including: 
 
 Creating a wallet notification system. 
 Managing wallet states (connected, disconnected, etc.). 
 Implementing a mobile-friendly wallet connector . 
 
 :::tip Unified Wallet Kit References 
 
 Wallet Kit Playground : To play with different settings,features and styling. 
 Open Source Repository : To understand and make use of the wallet adapter better. 
 Quick Examples : To reference code snippets and examples.
::: 
 
 Core Features 
 Feature Description 
 Compact Bundle Main ESM bundle is a lightweight 94KB (20KB gzipped). 
 Built-in Support Comes with Wallet Standard and Mobile Wallet Adapter support. 
 Abstracted Wallet Adapter Use the Bring Your Own Wallet (BYOW) approach to select custom and legacy wallets. 
 Mobile Responsive Designed to be mobile-first. 
 Smart Notification System Integrates seamlessly with your existing notification system or can be used independently. 
 Internationalization Supports multiple languages including English, Chinese, Vietnamese, French, Japanese, Bahasa Indonesia, and Russian. 
 Theming Options Choose from light, dark, and Jupiter modes, with more customization options coming soon. 
 New User Onboarding Simplifies the onboarding process for new users. 
 
 Let''s Get Started 
 TLDR Steps 
 
 Adjust the Theme Selector to your desired version. 
 Select your appropriate Language 
 Expand the "Show Snippet" box for the wallet configuration you would like in your app and 
 Select the  Copy to Clipboard  button for easy code insertion into your app. 
 Install the Unified Wallet Kit to your project dependencies. 
 
 Install the wallet adapter depenency 
 npm i @jup-ag/wallet-adapter
 
 Wrap your app with  <UnifiedWalletProvider /> 
 const ExampleBaseOnly = () => {
  return (
    <UnifiedWalletProvider
      wallets={[]}
      config={{
        autoConnect: false,
        env: ''mainnet-beta'',
        metadata: {
          name: ''UnifiedWallet'',
          description: ''UnifiedWallet'',
          url: ''https://jup.ag'',
          iconUrls: [''https://jup.ag/favicon.ico''],
        },
        notificationCallback: WalletNotification,
        walletlistExplanation: {
          href: ''https://station.jup.ag/docs/old/additional-topics/wallet-list'',
        },
      }}
    >
      <UnifiedWalletButton />
    </UnifiedWalletProvider>
  );
};

export default ExampleBaseOnly;
 
 :::info
This kit also supports the attachment of custom elements to specific wallets
::: 
 config={{
  walletAttachments: { 
    ''Phantom'': {
      attachment: <div tw="text-xs rounded-md bg-red-500 px-2 mx-2 text-center">Auto Confirm</div>
    } 
  }
}}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs/300-tool-kits/referral-program/README.md', 'sidebar_label: "Introduction"
description: An open source Solana referral program used by Jupiter Programs (or any other programs) to enable developers to earn fees.
title: Referral Program 

     Referral Program 
     

 The Referral Program is an open-source program used by Jupiter Programs (or any other programs) to enable developers to earn fees. 
 :::info Referral Program Source Code
 Open Source Repository : To understand and make use of the referral program better.
::: 
 Jupiter API Integrators 
 The Jupiter Programs use the Referral Program to allow developers to earn fees when integrating with Jupiter. Below are some resources to help you quickly get started. There are a different ways to setup such as via the Jupiter Referral Dashboard or using the provided scripts. 
 
 Jupiter Referral Dashboard : To view and manage your referral accounts used with Jupiter APIs. 
 Add Fees to Ultra API : To add fees to your Ultra API integration. 
 Add Fees to Swap and Trigger API : To add fees to your Swap and Trigger API integration. 
 Add Fees to Jupiter Plugin : To add fees to your Plugin integration. 
 
 Other Program Integrators 
 Project Usage 
 If you have a project/product that runs a program on the Solana blockchain, you can integrate the Referral Program to allow/share revenue with the integrators of your program. 
 Similar to how Jupiter Programs uses the Referral Program to help developers earn fees and/or share the revenue with Jupiter. For example, Jupiter Ultra uses the Jupiter Swap program which relies on the Referral Program. 
 
 Create a  Project  by calling  initialize_project  with your chosen  base  key and a project  name  ( base  key refers to a key identifier of your project). 
 Set a  default_share_bps  to share the fees with your referrers (or integrators). 
 An example of a  Project  account:  Jupiter Ultra Project 
 
 Referrer Usage 
 If you are a referrer such as a developer or integrator of a project that runs a program on the Solana blockchain, you can create the necessary accounts via the Referral Program to earn fees. 
 
 The program must be integrated with the Referral Program. 
 Create a  Referral  account by calling  initialize_referral_account  with the correct  Project  account, the  Referral  account, and your own  Partner  account ( Partner  account is the admin of this referral account). 
 Create the necessary  Referral  token accounts for the  Referral  account to receive fees in.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/README.md', 'Jupiter Developer Docs 
 Welcome to Jupiter Developer Documentation! You''ll find detailed API guides, schemas, and powerful tool kits built by the team and DevRel Working Group to help you build with Jupiter. 
 Get Started 
 For new developers or new to blockchain development : We recommend you to start with the  Environment Setup  and  Development Basics  guides. 
 For existing developers : Please refer to the  What''s New?  section for the latest API updates and breaking changes. 
 For routing integrations : Please refer to the  DEX Integration  guide to complete the prerequisites before we look into integrating. 
 For market maker integrations : Specifically, JupiterZ (RFQ), please refer to  rfq-webhook-toolkit repo . 
 Quick Links  to APIs and Tool Kits: 
 
 Ultra API 
 Swap API 
 Trigger API 
 Recurring API 
 Token API 
 Price API 
 Jupiter Plugin 
 Unified Wallet Kit 
 
 Reach out to us  on  Discord  for developer support 
 
 If you have any feedback. 
 If you have technical questions. 
 If you need API Portal support. 
 Refer to these channels to receive updates:  Telegram channel  or  Discord channel 
 
 Contributing 
 Setting up in local machine 
 This website is built using  Docusaurus , a modern static website generator. 
 To install: 
 pnpm install
 
 To build and start local development: 
 pnpm build && pnpm start
 
 For more detailed understanding of the structure of dev.jup.ag, please refer to the  contribution-readme.md  guide.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/5-jupiter-terminal/2-terminal-integration-guide.md', 'title: Jupiter Terminal Walkthrough
sidebar_label: "Walkthrough"
description: "Quickly integrate Jupiter Terminal with our guide. Enhance your Solana dapps with ease using our key resources and demos." 

     Jupiter Terminal Walkthrough: Streamlined Integrations 
     

 Jupiter Terminal is an open-sourced, lite version of Jupiter that provides end-to-end swap flow by linking it in your HTML with just a few lines of code. 
 :::tip Jupiter Terminal Links 
 
 Demo : See all available modes 
 Developer Docs : Jupiter Terminal in detail 
 Repo 
::: 
 
 Here''s a quick preview of the modes available. To see more, go to  our Demo page 
 
 Example: Jupiter Terminal integration on a Solana Dapp scaffold 
 Integrating Jupiter onto your website should be straight-forward. We provide a step-by-step guide here so anyone can do it. 
 Here''s what you can expect from this tutorial: You''ll get Jupiter Terminal launching from Solana Dapp in "Modal" mode. 
 
 This walkthrough is also available on Youtube: 
 
 Watch tutorial on YouTube 
 Step-by-step Walkthrough 
 Solana Labs Dapp scaffold Repo: https://github.com/solana-labs/dapp-scaffold 
 
 Clone Solana Dapp Scaffold repo into your local machine or working environment. 
 Update dependencies, in this example it will be  pnpm install 
 Fire up the development environment in your localhost, in this example it will be  pnpm dev 
 
 
 
 Next, change your network configuration from  devnet  to  mainnet-beta  in  NetworkConfigurationProvider.tsx  file. 
 
 
 
 Include Jupiter Terminal script into your  src/pages/_document.tsx  file. 
 
 <script src="https://terminal.jup.ag/main-v1.js" data-preload />
 
 
 
 Next, include some of the basic script into  src/views/home/index.tsx  file. 
 
 import { Connection, PublicKey, Transaction } from ''@solana/web3.js'';
import { notify } from ''utils/notifications'';
 
 More info on  @solana/web3.js 
 
 
 Next, you will need a working RPC endpoint for the transaction to work properly. In this example, we park our RPC_ENDPOINT in  src/views/home/constant.ts  and import or initialize with  import { RPC_ENDPOINT } from ''./constant'' . 
 
 
 :::info
It is recommended that you use your own RPC endpoint.
This RPC_ENDPOINT is only for demonstration purposes so that this example will run.
::: 
 
 Here comes the  fun part , this is where you can customize the setting and configuration that best fit your dApp or site in  Jupiter Terminal Playground 
 
 
 
 Lastly, there''s a Code snippet in the Terminal playground with your configuration. Copy the code snippet and plug it directly into your file, in this example it will be  src/views/home/index.tsx  file. 
 
 
 
 :::success Please reach out in discord if you need help
Feel free to reach out to us in  discord  if you experience difficulties, we can help you there.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/5-jupiter-terminal/1-jupiter-terminal.md', 'sidebar_label: "Overview"
description: Explore Jupiter Terminal for seamless DApp integration with a feature-rich API. Start now with easy templates and guides. Visit our demo!
title: Jupiter Terminal Docs 

     Jupiter Terminal Docs: Elevate Your DApp Integration 
     

 import Tabs from ''@theme/Tabs'';
import TabItem from ''@theme/TabItem'';
import ModalModeImgUrl from ''./modal-mode.jpg'';
import IntegratedModeImgUrl from ''./integrated-mode.jpg'';
import WidgetModeImgUrl from ''./widget-mode.jpg''; 
 
 Jupiter Terminal is an open-sourced, lite version of Jupiter. This terminal provides end-to-end swap flow functionality by linking it in your HTML with just a few lines of code. Terminal runs on the v3 swap protocol supporting Instant Routing, Smart Token Filtering, Ecosystem Token List support. 
 Provided with the code are several templates to get you started and auto generated code snippets. 
 
   
     
       It is as easy as this! 
     
   
 Copy paste this into a  .html  file and change your directory to that file. 
 Using for example  npx http-server  and you can view in your localhost 
 <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jupiter Terminal Integration</title>
  <!-- Preload script -->
  <script src="https://terminal.jup.ag/main-v2.js" data-preload></script>
</head>
<body>
  <!-- Container for the terminal -->
  <div id="jupiter-terminal"></div>

  <!-- Initialize the widget -->
  <script>
    window.addEventListener(''DOMContentLoaded'', () => {
      window.Jupiter.init({
        containerId: ''jupiter-terminal'', // ID of the container div
        endpoint: ''https://api.mainnet-beta.solana.com'', // Solana RPC endpoint
      });
    });
  </script>
</body>
</html>

 
 
 :::tip Jupiter Terminal Links 
 
 Demo: https://terminal.jup.ag/ 
 Repo: https://github.com/jup-ag/terminal 
 Detailed implementation guide:  Get a step-by-step walkthrough 
::: 
 
 Core Features 
 
 
 main-v2.js  bundle (~73.6Kb gzipped) 
 
 app bundle (~952Kb gzipped) are loaded on-demand when  init()  is called 
 alternatively, preload app bundle with  data-preload  attributes 
 
 
 
 Agnostic 
 
 Work with any dApp,  Integrated  or as a standalone  Widget , or  Modal 
 Any framework, React, Plain HTML, and other frameworks. 
 Responsive on any screen size 
 
 
 
 Form customisation 
 
 From Full swap experience, Payment Flow, to Ape-ing tokens 
 Fixed input/output amount, or mint 
 ExactIn, and ExactOut (e.g. Payment) swap mode 
 
 
 
 Built-in Wallets 
 
 Wallet Standard 
 Passthrough Wallet from your dApp 
 Powered by  Unified Wallet Kit 
 
 
 
 Lite, but powerful 
 
 Jupiter v6 API with Metis  (New✨) 
 State sharing with syncProps()  (New✨) 
 Price API integration, with high decimal/precision support to trade meme tokens 
 ExactOut (e.g Payment) 
 
 
 
 Fees Support 
 
 Customisable fees 
 Track fees with  Jupiter Referral Dashboard 
 
 
 
 Getting Started 
 
 Demo + Auto Code Gen 
 TLDR Example 
 
 1. Setup HTML 
 Terminal is designed to work anywhere the web runs, including React, Plain HTML/JS, and many other frameworks. 
 <!-- Attach the loading script in your <head /> -->
<script src="https://terminal.jup.ag/main-v2.js" />

<!-- Optionally, preload for better experience, or integrated mode -->
<script src="https://terminal.jup.ag/main-v2.js" data-preload />
 
 2. Initialize Jupiter Terminal 
 Scenario 1: Terminal as part of your dApp (Passthrough Wallet) 
 Your dApp already has a  <WalletProvider /> . 
 window.Jupiter.init({ enableWalletPassthrough: true });
 
 Then, synchronise wallet state between your dApp and Jupiter Terminal with  syncProps() 
 import { useWallet } from ''@solana/wallet-adapter-react''; // Or @jup-ag/wallet-adapter;

const passthroughWalletContextState = useWallet();
useEffect(() => {
  if (!window.Jupiter.syncProps) return;
  window.Jupiter.syncProps({ passthroughWalletContextState });
}, [passthroughWalletContextState.connected, props]);
 
 Scenario 2: Standalone Terminal 
 Your dApp does not have a  <WalletProvider /> , or is a plain HTML/JS website. 
 window.Jupiter.init({});
 
 3. Setup other props 
 :::tip Before you start, get a Free/Paid RPC
Some recommended RPC providers include  Quicknode ,  Helius  &  Triton One .
You can then use the RPC endpoint with Terminal.
::: 
 window.Jupiter.init({
  /** Required
   * Solana RPC endpoint
   * We do not recommend using the public RPC endpoint for production dApp, you will get severely rate-limited
  */
  endpoint: ''https://api.mainnet-beta.solana.com'',
  // ...other props
});
 
 4. Finishing touches 
 Terminals are light but full of features, such as customizing form behavior, fees, styling, and much more. 
 Go to our Demo  to explore all these features, with automatically generated integration code. 
 Or,  check out our fully typed API reference  for more details. 
 
 
 
 
 
 Additional API Reference 
 Typescript Support 
 Since Jupiter Terminal is only importable via CDN, to get proper typing, you can create a typing declaration  jupiter-terminal.d.ts  file in your project, and copy the contents in  src/types/index.d.ts 
 declare global {
  interface Window {
    Jupiter: JupiterTerminal;
  }
}
// ...
// ...
// ...
 
 
 Fee Support 
 Similar to Jupiter, Jupiter Terminal supports fee for integrators. 
 There are no protocol fees on Jupiter, but integrators can introduce a platform fee on swaps. The platform fee is provided in basis points, e.g. 20 bps for 0.2% of the token output. 
 Refer to Adding your own fees docs for more details. 
 Note: You will need to create the Token fee accounts to collect the platform fee. 
 import { getPlatformFeeAccounts } from ''@jup-ag/react-hook'';

// Jupiter Core provides a helper function that returns all your feeAccounts
const platformFeeAndAccounts = {
  feeBps: 50,
  feeAccounts: await getPlatformFeeAccounts(
    connection,
    new PublicKey(''BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9''), // The platform fee account owner
  ), // map of mint to token account pubkey
};

window.Jupiter.init({
  // ...
  platformFeeAndAccounts,
});
 
 
 Resuming / Closing Activity 
 
 
 Everytime  init()  is called, it will create a new activity. 
 
 
 If you want to resume the previous activity, you can use  resume() . 
 
 
 close()  function only hide the widget. 
 
 
 if (window.Jupiter._instance) {
  window.Jupiter.resume();
}

window.Jupiter.close();
 
 Strict Token List 
 
 strictTokenList?: boolean; 
 Default:  true 
 
 The Jupiter Token List API is an open, collaborative, and dynamic token list to make trading on Solana more transparent and safer for users and developers.
It is true by default to ensure that only validated tokens are shown. 
 
 Default Explorer 
 
 defaultExplorer?: ''Solana Explorer'' | ''Solscan'' | ''Solana Beach'' | ''SolanaFM''; 
 Default:  Solana Explorer 
 
 The default explorer is set to  Solana Explorer ; 
 You can change the default explorer by passing in the explorer name to the  defaultExplorer  prop. 
 
 onSuccess/onSwapError callback 
 onSuccess()  reference can be provided, and will be called when swap is successful. 
 While  onSwapError()  will be called when an error has occurred. 
 window.Jupiter.init({
  onSuccess: ({ txid, swapResult }) => {
    console.log({ txid, swapResult });
  },
  onSwapError: ({ error }) => {
    console.log(''onSwapError'', error);
  },
});
 
 Customising styles: CSSProperties 
 Any CSS-in-JS can be injected to the outer-most container via containerStyles API. 
 Examples: 
 
 Custom zIndex 
 
 window.Jupiter.init({
  // ...
  containerStyles: { zIndex: 100 },
});
 
 
 Custom height 
 
 window.Jupiter.init({
  // ...
  containerStyles: { maxHeight: ''90vh'' },
});
 
 Customising className: Tailwind className 
 Tailwind classes can be injected to the outer-most container via containerClassName API. 
 Example: 
 
 Custom breakpoints 
 
 window.Jupiter.init({
  // ...
  containerClassName: ''max-h-[90vh] lg:max-h-[600px]'',
});
 
 
 Upcoming feature / Experimentation 
 
 
Limit Order 
 
DCA 
 
Experiment separate bundle for passthroughWallet', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/5-jupiter-terminal/3-unified-wallet-kit.md', 'sidebar_label: "Unified Wallet Kit"
description: Explore Jupiter Terminal for seamless DApp integration with a feature-rich API. Start now with easy templates and guides. Visit our demo!
title: Unified Wallet Kit 

     Unified Wallet Kit - A Powerful Wallet Integration Tool 
     

 Overview 
 The Unified Wallet Kit is an open-source, Swiss Army Knife wallet adapter designed to streamline your development on Solana. This wallet kit is purpose built to help ease the burdens of integrating multiple wallets with seamless UI/UX into your custom program. Make your development process faster and more efficient with Jupiter’s Unified Wallet Kit. 
 The Unified Wallet Kit will help you reduce repetitive tasks within your development process, including: 
 
 Creating a wallet notification system 
 Managing wallet states (connected, disconnected, etc.) 
 Implementing a mobile-friendly wallet connector 
 
 The Unified Wallet Kit eliminates redundancies by providing these building blocks in a simple, plug-and-play package. This allows developers to focus on what matters most: building innovative features for your dApp. 
 :::tip Unified Wallet Adapter Links 
 
 Demo: https://unified.jup.ag/ 
 Repo: https://github.com/TeamRaccoons/Unified-Wallet-Kit
::: 
 
 Core Features 
 
 Compact Bundle: Main ESM bundle is a lightweight 94KB (20KB gzipped). 
 Built-in Support: Comes with Wallet Standard and Mobile Wallet Adapter support. 
 Abstracted Wallet Adapter: Use the Bring Your Own Wallet (BYOW) approach to select custom and legacy wallets. 
 Mobile Responsive: Designed to be mobile-first. 
 Smart Notification System: Integrates seamlessly with your existing notification system or can be used independently. 
 Internationalization: Supports multiple languages including English, Chinese, Vietnamese, French, Japanese, Bahasa Indonesia, and Russian. 
 Theming Options: Choose from light, dark, and Jupiter modes, with more customization options coming soon. 
 New User Onboarding: Simplifies the onboarding process for new users. 
 
 
 Unified Wallet Kit Usage Flow 
 
 Adjust the Theme Selector to your desired version. 
 Select your appropriate Language 
 Expand the "Show Snippet" box for the wallet configuration you would like in your app and 
 Select the  Copy to Clipboard  button for easy code insertion into your app. (See Image Below) 
 
 
 Implementation 
 Implementing the Unified Wallet Kit is straightforward and efficient. Here''s a quick guide to get you started: 
 
 Install the Unified Wallet Kit to your project dependencies. 
 
 pnpm i @jup-ag/wallet-adapter
 
 
 Wrap your app with  <UnifiedWalletProvider />  and pass in as little to as many wallets you would like to support. 
 
 An Example from the Unified Wallet Kit Repository 
 const ExampleBaseOnly = () => {
  return (
    <UnifiedWalletProvider
      wallets={[]}
      config={{
        autoConnect: false,
        env: ''mainnet-beta'',
        metadata: {
          name: ''UnifiedWallet'',
          description: ''UnifiedWallet'',
          url: ''https://jup.ag'',
          iconUrls: [''https://jup.ag/favicon.ico''],
        },
        notificationCallback: WalletNotification,
        walletlistExplanation: {
          href: ''https://station.jup.ag/docs/old/additional-topics/wallet-list'',
        },
      }}
    >
      <UnifiedWalletButton />
    </UnifiedWalletProvider>
  );
};

export default ExampleBaseOnly;
 
 :::info
This kit also supports the attachment of custom elements to specific wallets
::: 
 config={{
  walletAttachments: { 
    ''Phantom'': {
      attachment: <div tw="text-xs rounded-md bg-red-500 px-2 mx-2 text-center">Auto Confirm</div>
    } 
  }
}}
 
 Live Playground 
 :::info
See all of the available features the Unified Wallet Kit provides in real-time at our  live playground . To see more examples of how the code works view the  Unified Github Wallet Kit .
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/5-price-api-v2.md', 'sidebar_label: Price API V2
description: Get real-time on-chain prices for any token with Jupiter Price API V2.
title: "Price API V2: Improved On-Chain Price For Any Token" 

     Jupiter Price API V2: Improved On-Chain Pricing for Any Token 
     

 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 Jupiter Price API V2 is an improved version of the Price API, aiming to enhance accuracy by incorporating both  buy  and  sell-side liquidity  to derive the  average price  of the two. This provides more reliable real-time data for SPL tokens. 
 :::info Support
If you have a use case that is not supported yet, let us know in #developer-support in our discord:  discord.gg/jup 
::: 
 Usage 
 Jupiter Price API will always return  the unit buy price for the token  specified with the  ids  parameter. This price is based on the best pricing data available across all DEXes queried. Please remember the addresses are  case-sensitive . 
 For example, the most basic call will provide the unit price for the token based on the  buy amount of USDC . 
 # Unit price of 1 JUP & 1 SOL based on the Derived Price in USDC
https://api.jup.ag/price/v2?ids=JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN,So11111111111111111111111111111111111111112

{
    "data": {
        "So11111111111111111111111111111111111111112": {
            "id": "So11111111111111111111111111111111111111112",
            "type": "derivedPrice",
            "price": "133.890945000"
        },
        "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
            "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
            "type": "derivedPrice",
            "price": "0.751467"
        }
    },
    "timeTaken": 0.00395219
}
 
 Including  showExtraInfo  provides more detailed information, helping you determine the most suitable price for your use case. 
 # Unit price of 1 JUP & 1 SOL based on the Derived Price in USDC
https://api.jup.ag/price/v2?ids=JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN,So11111111111111111111111111111111111111112&showExtraInfo=true

{
    "data": {
        "So11111111111111111111111111111111111111112": {
            "id": "So11111111111111111111111111111111111111112",
            "type": "derivedPrice",
            "price": "132.176540000",
            "extraInfo": {
                "lastSwappedPrice": {
                    "lastJupiterSellAt": 1726232167,
                    "lastJupiterSellPrice": "132.1815918927837",
                    "lastJupiterBuyAt": 1726232168,
                    "lastJupiterBuyPrice": "132.3113422757551"
                },
                "quotedPrice": {
                    "buyPrice": "132.183970000",
                    "buyAt": 1726232166,
                    "sellPrice": "132.169110000",
                    "sellAt": 1726232168
                },
                "confidenceLevel": "high",
                "depth": {
                    "buyPriceImpactRatio": {
                        "depth": {
                            "10": 0.011976036126034885,
                            "100": 0.05308426581530216,
                            "1000": 0.1168049189323158
                        },
                        "timestamp": 1726232167
                    },
                    "sellPriceImpactRatio": {
                        "depth": {
                            "10": 0.01582101846363979,
                            "100": 0.03166775883921609,
                            "1000": 0.06880960201997424
                        },
                        "timestamp": 1726232167
                    }
                }
            }
        },
        "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
            "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
            "type": "derivedPrice",
            "price": "0.742851",
            "extraInfo": {
                "lastSwappedPrice": {
                    "lastJupiterSellAt": 1726232039,
                    "lastJupiterSellPrice": "0.7442999683998961",
                    "lastJupiterBuyAt": 1726232097,
                    "lastJupiterBuyPrice": "0.7431593824200015"
                },
                "quotedPrice": {
                    "buyPrice": "0.742917",
                    "buyAt": 1726232165,
                    "sellPrice": "0.742784",
                    "sellAt": 1726232168
                },
                "confidenceLevel": "high",
                "depth": {
                    "buyPriceImpactRatio": {
                        "depth": {
                            "10": 0.009393981894911491,
                            "100": 0.08127843280940066,
                            "1000": 0.3417234655853332
                        },
                        "timestamp": 1726232167
                    },
                    "sellPriceImpactRatio": {
                        "depth": {
                            "10": 0.05174412761856207,
                            "100": 0.06288330728860267,
                            "1000": 0.281508676845538
                        },
                        "timestamp": 1726232167
                    }
                }
            }
        }
    },
    "timeTaken": 0.00388851
}
 
 If you include a  vsToken , the buy token can be specified. 
 For example, this call will return the unit price for  1 JUP, based on the buy amount of Bonk . 
 Simply put, the  vsToken  argument tells you how much of the  vsToken  (Bonk in this case) you will need to buy the target token (JUP). For every one JUP we want to buy, we will need ~40,560 Bonk. 
 :::note
 vsToken  cannot be used with  showExtraInfo  when it''s true. A  response 400: Bad request  would be returned.
::: 
 # Unit price of 1 JUP based on the buy amount of Bonk
https://api.jup.ag/price/v2?ids=JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN&vsToken=DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263&showExtraInfo=true

{
  "data": {
    "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN": {
      "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
      "type": "derivedPrice",
      "price": "40560.32136735473"
    },
    "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263": {
      "id": "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
      "type": "derivedPrice",
      "price": "1"
    }
  },
  "timeTaken": 0.003043602
}
 
 Try it out! 
 Try the API calls by making simple GET request via your browser or one of the terminal commands below: 
 
   
     
       GET 
       https://api.jup.ag/price/v2 
     
   
 curl -X ''GET'' ''https://api.jup.ag/price/v2?ids=So11111111111111111111111111111111111111112&showExtraInfo=true''
 
 Parameters: 
 
 ids (required, string) : Supports symbol or address of a token. You can also pass in an array of ids to with  ,  as separator. Maximum of 100 unique IDs allowed.
 
 Address mode are case-sensitive
 
 mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So 
 mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So , So11111111111111111111111111111111111111112 
 
 
 
 
 showExtraInfo(Optional, boolean) :  A boolean flag to indicate whether to include additional information in the response.
 
 defaults to false if not specified 
 
 
 
 Response 
 
     
       •  
       
       200: OK 
        Success Response
       
     
 {
    "data": {
        "So11111111111111111111111111111111111111112": {
            "id": "So11111111111111111111111111111111111111112",
            "type": "derivedPrice",
            "price": "132.280970000",
            "extraInfo": {
                "lastSwappedPrice": {
                    "lastJupiterSellAt": 1726231876,
                    "lastJupiterSellPrice": "132.29239989531536",
                    "lastJupiterBuyAt": 1726231877,
                    "lastJupiterBuyPrice": "132.19714417319207"
                },
                "quotedPrice": {
                    "buyPrice": "132.286960000",
                    "buyAt": 1726231878,
                    "sellPrice": "132.274980000",
                    "sellAt": 1726231878
                },
                "confidenceLevel": "high",
                "depth": {
                    "buyPriceImpactRatio": {
                        "depth": {
                            "10": 0.03363618661226941,
                            "100": 0.08002735245686805,
                            "1000": 0.14333736423496682
                        },
                        "timestamp": 1726231876
                    },
                    "sellPriceImpactRatio": {
                        "depth": {
                            "10": 0.02031954946621532,
                            "100": 0.020354720955966937,
                            "1000": 0.06331837713363023
                        },
                        "timestamp": 1726231876
                    }
                }
            }
        }
    },
    "timeTaken": 0.00463168
}
 
 
   
   •  default   Error Response 
 
{
    "data": {
        "So11111111111111111111111111111111111111112": {
            "id": "So11111111111111111111111111111111111111112",
            "type": "derivedPrice",
            "price": "134.170633378"
        },
        "8agCopCHWdpj7mHk3JUWrzt8pHAxMiPX5hLVDJh9TXWv": null
    },
    "timeTaken": 0.003186833
}
 
 
 
 Rate Limits:  This endpoint is rate limited to  600 requests/min . 
 Making sense of the data 
 Field Explanation 
 type derivedPrice  is the midpoint between  buyPrice  and  sellPrice . 
 price based on the  type   above 
 extraInfo extraInfo  Fields (More info below) 
 buyPrice An  Option<String>  representing the quoted buy price. 
 sellPrice An  Option<String>  representing the quoted sell price. 
 timeTaken A  f32  representing the time taken for the request. 
 lastSwappedPrice A  SwapPrice  struct that holds the last  Jupiter  swapped price details. 
 
 extraInfo  Fields 
 Note: This is flattened, please refer to the JSON response. 
 lastJupiterSellAt Epoch seconds of the  lastJupiterSellPrice . 
 lastJupiterSellPrice Price of last  Jupiter  sell 
 lastJupiterBuyAt Epoch seconds of the  lastJupiterBuyPrice . 
 lastJupiterBuyPrice Price of last  Jupiter  buy 
 buyPrice An  Option<String>  representing the quoted buy price. 
 buyAt Epoch seconds of when the buy quote was retrieved. 
 sellPrice An  Option<String>  representing the quoted sell price. 
 sellAt Epoch seconds of when the sell quote was retrieved. 
 confidenceLevel A  String  indicating the confidence level (High, Medium, or Low). 
 buyPriceImpactRatio A  Map  broken down into 3 key-value pairs: 10, 100 & 1000 (SOL). The value is expressed as a  percentage . 
 sellPriceImpactRatio A  Map  broken down into 3 key-value pairs: 10, 100 & 1000 (SOL). The value is expressed as a  percentage . 
 
 Limitations 
 If the price for a token  cannot  be found, it is either because 
 
 The token is not tradable on Jupiter - it does not fit Jupiter’s routing criteria. 
 There is no route for this token to  SOL . 
 
 sellPrice ,  sellAt  &  lastSwappedPrice  might be  null  in cases 
 
 sellPrice  &  sellAt  is not cached and cannot be retrieved (in these cases  type  will be  buyPrice , same as PriceV1). 
 lastSwappedPrice  might be null if the token has not been traded recently or cannot be retrieved w
 
 Tokens that have not been traded via USDC in the last 3 days. 
 Note that this is only for swaps done via Jupiter, it will not be done for swaps done e.g. directly on Raydium’s platform 
 
 
 
 buyPriceImpactRatio   &  sellPriceImpactRatio  in the  depth  field might be null in cases 
 
 We are to get the respective price impacts for the 10, 100 and 1000 SOL buys or sells
 
 It could be because the token’s liquidity does not have enough liquidity for larger values 
 
 
 We cannot find the sell quote for the respective token and the buy/sell values 
 
 Want to find out more about how we derive  confidenceLevel  or  depth ?
Read our  research article  on the  Price V2 API .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/7-cpi.md', 'sidebar_label: "CPI / Smart Contract Integration"
description: Learn how to optimize your Solana projects with Jupiter Swap CPI for efficient token swaps and advanced API integration.
title: Jupiter Swap via CPI 

     Jupiter Swap CPI: Streamline Your Solana Integrations 
     

 To integrate your program with Jupiter Swap you can take two approaches. One is Flash Filling or you can utilize Cross Program Invocation (CPI). 
 :::note CPI is recommended
As of January 2025, Jupiter Swap via CPI is recommended for most users. 
 The  Loosen CPI restriction  feature has been deployed on Solana, you can find more information  here .
::: 
 :::danger CPI Limitations
As of August 2023, taking the CPI approach has some tradeoffs. Due to Solana''s transaction limit of 1232 bytes, swaps via CPI will likely fail at runtime since Jupiter routes may involve multiple DEXes in order to reduce price impact. You could set a limit to the number of accounts used for swaps via Jupiter''s swap API to fit it within your needs. However, limiting the accounts will likely incur greater price impact. 
 Note: when using Jupiter''s API, you can set maxAccounts to reduce the number of accounts. 
::: 
 :::info Use Flash-Fill
An alternative method is to use the flash-fill approach. The flash-fill approach takes advantage of  Versioned Transaction  in combination with  Address Lookup Tables  to allow for more accounts per transaction while keeping within the 1232 bytes limit.
::: 
 Example 
 Here we show an  example transaction  on how to utilize Jupiter Swap via CPI to swap from any tokens to SOL. This works even if the user doesn''t have enough SOL. You can even allow a third-party payer if the user doesn''t have any SOL at all. 
 How does this work? 
 For a CPI to work, the transaction will be composed of these instructions: 
 
 Borrow enough SOL from the program to open a wSOL account that the program owns. 
 Swap X token from the user to wSOL on Jupiter via CPI. 
 Close the wSOL account and send it to the program. 
 The program then transfers the SOL back to the user. 
 
 Code Repo 
 Here is the GitHub repo:  https://github.com/jup-ag/sol-swap-cpi . You should check out the  program code  and the  client code . 
 Here is the  transaction on chain  on how this works. 
 Rust Crate 
 To ease integration via CPI, you may add the following crate  jupiter-cpi  to your program. 
 Cargo.toml 
 [dependencies]
jupiter-cpi = { git = "https://github.com/jup-ag/jupiter-cpi", rev = "5eb8977" }
... other dependencies
 
 use jupiter_cpi;

...

let signer_seeds: &[&[&[u8]]] = &[...];

// pass accounts to context one-by-one and construct accounts here.
// Or in practice, it may be easier to use `remaining_accounts` https://book.anchor-lang.com/anchor_in_depth/the_program_module.html
let accounts = jupiter_cpi::cpi::accounts::SharedAccountsRoute {
    token_program: ,
    program_authority: ,
    user_transfer_authority: ,
    source_token_account: ,
    program_source_token_account: ,
    program_destination_token_account: ,
    destination_token_account: ,
    source_mint: ,
    destination_mint: ,
    platform_fee_account: ,
    token_2022_program: ,
};

let cpi_ctx = CpiContext::new_with_signer(
    ctx.accounts.jup.to_account_info(),
    accounts,
    signer_seeds,
);

jupiter_cpi::cpi::shared_accounts_route(
    cpi_ctx,
    id,
    route_plan,
    in_amount,
    quoted_out_amount,
    slippage_bps,
    platform_fee_bps,
)?;

...', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/1-swap-api.md', 'sidebar_label: "V6 Swap API"
description: "Dive into the Jupiter Swap V6 API docs. Discover powerful swap capabilities, integration tips, and advanced features for DeFi applications."
title: "V6 Swap API" 

     How to Integrate Jupiter Swap [API Documentation] 
     

 :::info
If you have problems landing transactions, read  Landing Transactions on Solana .
::: 
 Jupiter APIs is the easiest way for developers to access liquidity on Solana. Simply pass in the desired pairs, amount, and slippage, and the API will return the serialized transactions needed to execute the swap, which can then be passed into the Solana blockchain with the required signatures. 
 :::info Risk Disclaimer
 Please use Jupiter''s Swap API at your own risk .  Jupiter''s Frontend UI  contains multiple safeguards and warnings when quoting. Jupiter is not liable for losses incurred by users on other platforms.
::: 
 V6 API Reference 
 All Jupiter swaps are using versioned transactions and address lookup tables. But not all wallets support Versioned Transactions yet, so if you detect a wallet that does not support versioned transactions, you will need to use the  asLegacyTransaction  parameter. 
 Learn more about the Jupiter API Documentation at the OpenAPI documentation. This documentation has a REST request list and a built in API Playground. Use the API Playground to try API calls now! 
 :::tip API Documentation
OpenAPI Documentation
::: 
 Guide for V6 Swap API (code example) 
 1. Install required libraries 
 Running this example requires a minimum of  NodeJS 16 . In your command line terminal, install the libraries. 
 npm i @solana/web3.js@1
npm i cross-fetch
npm i @project-serum/anchor
npm i bs58
 
 2. Import from libraries and setup connection 
 Next you can copy the following code snippets to a javascript file jupiter-api-example.js. And when you are ready to run the code, just type:  node jupiter-api-example.js 
 import { Connection, Keypair, VersionedTransaction } from ''@solana/web3.js'';
import fetch from ''cross-fetch'';
import { Wallet } from ''@project-serum/anchor'';
import bs58 from ''bs58'';

// It is recommended that you use your own RPC endpoint.
// This RPC endpoint is only for demonstration purposes so that this example will run.
const connection = new Connection(''https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/'');
 
 :::tip
Always make sure that you are using your own RPC endpoint. The RPC endpoint used by the connection object in the above example may not work anymore. For more information about RPC endpoints see the  official Solana Documentation  to learn more about their public RPC endpoints.
::: 
 3. Setup your wallet 
 You can paste in your private key for testing purposes but this is not recommended for production applications. 
 const wallet = new Wallet(Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || '''')));
 
 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 4. Get the route for a swap 
 Here, we are getting a quote to swap from SOL to USDC. 
 // Swapping SOL to USDC with input 0.1 SOL and 0.5% slippage
const quoteResponse = await (
  await fetch(''https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\
&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\
&amount=100000000\
&slippageBps=50''
  )
).json();
// console.log({ quoteResponse })
 
 5. Get the serialized transactions to perform the swap 
 Once we have the quote, we need to serialize the quote into a swap transaction that can be submitted on chain. 
 // get serialized transactions for the swap
const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      // user public key to be used for the swap
      userPublicKey: wallet.publicKey.toString(),
      // auto wrap and unwrap SOL. default is true
      wrapAndUnwrapSol: true,
      // Optional, use if you want to charge a fee.  feeBps must have been passed in /quote API.
      // feeAccount: "fee_account_public_key"
    })
  })
).json();
 
 6. Deserialize and sign the transaction 
 // deserialize the transaction
const swapTransactionBuf = Buffer.from(swapTransaction, ''base64'');
var transaction = VersionedTransaction.deserialize(swapTransactionBuf);
console.log(transaction);

// sign the transaction
transaction.sign([wallet.payer]);
 
 7. Execute the transaction 
 // get the latest block hash
const latestBlockHash = await connection.getLatestBlockhash();

// Execute the transaction
const rawTransaction = transaction.serialize()
const txid = await connection.sendRawTransaction(rawTransaction, {
  skipPreflight: true,
  maxRetries: 2
});
await connection.confirmTransaction({
 blockhash: latestBlockHash.blockhash,
 lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
 signature: txid
});
console.log(`https://solscan.io/tx/${txid}`);
 
 :::info Solana Network Congestion
Due to the network congestion on Solana, the  sendRawTransaction  method may not be able to help you to land your transaction. You should check out this  transactionSender  file to send transaction.
::: 
 
   
     
       Whole code snippet 
     
   
 import { Connection, Keypair, VersionedTransaction } from ''@solana/web3.js'';
import fetch from ''cross-fetch'';
import { Wallet } from ''@project-serum/anchor'';
import bs58 from ''bs58'';

// It is recommended that you use your own RPC endpoint.
// This RPC endpoint is only for demonstration purposes so that this example will run.
const connection = new Connection(''https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/'');

const wallet = new Wallet(Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || '''')));

// Swapping SOL to USDC with input 0.1 SOL and 0.5% slippage
const quoteResponse = await (
  await fetch(''https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\
&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\
&amount=100000000\
&slippageBps=50''
  )
).json();
// console.log({ quoteResponse })

// get serialized transactions for the swap
const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      // user public key to be used for the swap
      userPublicKey: wallet.publicKey.toString(),
      // auto wrap and unwrap SOL. default is true
      wrapAndUnwrapSol: true,
      // Optional, use if you want to charge a fee.  feeBps must have been passed in /quote API.
      // feeAccount: "fee_account_public_key"
    })
  })
).json();

// deserialize the transaction
const swapTransactionBuf = Buffer.from(swapTransaction, ''base64'');
var transaction = VersionedTransaction.deserialize(swapTransactionBuf);
console.log(transaction);

// sign the transaction
transaction.sign([wallet.payer]);

// Execute the transaction
const rawTransaction = transaction.serialize()
const txid = await connection.sendRawTransaction(rawTransaction, {
  skipPreflight: true,
  maxRetries: 2
});
await connection.confirmTransaction(txid);
console.log(`https://solscan.io/tx/${txid}`);
 
 
 Advanced error handling to disable certain AMM from the API 
 Sometimes an AMM will throw an error when swapping. To prevent getting a quote from the failed AMM, you can use the  excludeDexes  parameter when getting  /quote . 
 Example JS, with the help of  @mercurial-finance/optimist  package: 
 import { parseErrorForTransaction } from ''@mercurial-finance/optimist'';

// TX ID from last step if the transaction failed.
const transaction = connection.getTransaction(txid, {
  maxSupportedTransactionVersion: 0,
  commitment: ''confirmed''
});

const programIdToLabelHash = await (
  await fetch(''https://quote-api.jup.ag/v6/program-id-to-label'')
).json();
const { programIds } = parseErrorForTransaction(transaction);

let excludeDexes = new Set();
if (programIds) {
  for (let programId of programIds) {
    let foundLabel = programIdToLabelHash[programId];
    if(foundLabel) {
      excludeDexes.add(foundLabel);
    }
  }
}

// Request another quote with `excludeDexes`.
const { data } = await (
  await fetch(`https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112
&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v
&amount=100000000&excludeDexes=${Array.from(excludeDexes).join('','')}
&slippageBps=50`
  )
).json();
 
 Instructions Instead of Transaction 
 Sometimes you may prefer to compose using instructions instead of one transaction that is returned from the  /swap  endpoint. You can post to  /swap-instructions  instead, it takes the same parameters as the  /swap  endpoint. 
 const instructions = await (
  await fetch(''https://quote-api.jup.ag/v6/swap-instructions'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      userPublicKey: swapUserKeypair.publicKey.toBase58(),
    })
  })
).json();

if (instructions.error) {
  throw new Error("Failed to get swap instructions: " + instructions.error);
}

const {
  tokenLedgerInstruction, // If you are using `useTokenLedger = true`.
  computeBudgetInstructions, // The necessary instructions to setup the compute budget.
  setupInstructions, // Setup missing ATA for the users.
  swapInstruction: swapInstructionPayload, // The actual swap instruction.
  cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.
  addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.
} = instructions;

const deserializeInstruction = (instruction) => {
  return new TransactionInstruction({
    programId: new PublicKey(instruction.programId),
    keys: instruction.accounts.map((key) => ({
      pubkey: new PublicKey(key.pubkey),
      isSigner: key.isSigner,
      isWritable: key.isWritable,
    })),
    data: Buffer.from(instruction.data, "base64"),
  });
};

const getAddressLookupTableAccounts = async (
  keys: string[]
): Promise<AddressLookupTableAccount[]> => {
  const addressLookupTableAccountInfos =
    await connection.getMultipleAccountsInfo(
      keys.map((key) => new PublicKey(key))
    );

  return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
    const addressLookupTableAddress = keys[index];
    if (accountInfo) {
      const addressLookupTableAccount = new AddressLookupTableAccount({
        key: new PublicKey(addressLookupTableAddress),
        state: AddressLookupTableAccount.deserialize(accountInfo.data),
      });
      acc.push(addressLookupTableAccount);
    }

    return acc;
  }, new Array<AddressLookupTableAccount>());
};

const addressLookupTableAccounts: AddressLookupTableAccount[] = [];

addressLookupTableAccounts.push(
  ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))
);

const blockhash = (await connection.getLatestBlockhash()).blockhash;
const messageV0 = new TransactionMessage({
  payerKey: payerPublicKey,
  recentBlockhash: blockhash,
  instructions: [
    // uncomment if needed: ...setupInstructions.map(deserializeInstruction),
    deserializeInstruction(swapInstructionPayload),
    // uncomment if needed: deserializeInstruction(cleanupInstruction),
  ],
}).compileToV0Message(addressLookupTableAccounts);
const transaction = new VersionedTransaction(messageV0);
 
 Using  maxAccounts 
 Sometimes, if you are composing with Jupiter Swap instruction, you may want to spare some accounts (64 max in 1 Solana transaction)
for your own program instruction, you can use  maxAccounts . 
 // If you know that your instruction will take up 10 accounts, you
// can pass in 54 as `maxAccounts` when quoting.
const { data } = await (
  await fetch(''https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\
&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\
&amount=100000000\
&slippageBps=50\
&maxAccounts=54''
  )
).json();
const quoteResponse = data;
// console.log(quoteResponse)
 
 The  maxAccounts  is an estimation since it doesn''t consider account overlapping but it is a good start to control how many accounts
you want per transaction. 
 Using Token Ledger Instruction 
 Sometimes you may not know the exact input amount for the Jupiter swap until an instruction before the swap happens. 
 For example: 
 const instructions = await (
  await fetch(''https://quote-api.jup.ag/v6/swap-instructions'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      useTokenLedger: true,
  })
).json();

const {
  tokenLedgerInstruction: tokenLedgerPayload, // If you are using `useTokenLedger = true`.
  swapInstruction: swapInstructionPayload, // The actual swap instruction.
  addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.
} = instructions;

// A withdraw instruction that will increase the user input token account amount.
const withdrawInstruction = ...;

// Coupled with the tokenLedgerInstruction, the swap instruction will use the
// user increased amount of the input token account after the withdrawal as input amount.
const tokenLedgerInstruction = new TransactionInstruction({
  programId: new PublicKey(tokenLedgerPayload.programId),
  keys: tokenLedgerPayload.accounts.map((key) => ({
    pubkey: new PublicKey(key.pubkey),
      isSigner: key.isSigner,
      isWritable: key.isWritable,
    })),
  data: Buffer.from(tokenLedgerPayload.data, "base64"),
});

const swapInstruction = new TransactionInstruction({
  programId: new PublicKey(swapInstructionPayload.programId),
  keys: swapInstructionPayload.accounts.map((key) => ({
    pubkey: new PublicKey(key.pubkey),
      isSigner: key.isSigner,
      isWritable: key.isWritable,
    })),
  data: Buffer.from(swapInstructionPayload.data, "base64"),
});

const getAddressLookupTableAccounts = async (
  keys: string[]
): Promise<AddressLookupTableAccount[]> => {
  const addressLookupTableAccountInfos =
    await connection.getMultipleAccountsInfo(
      keys.map((key) => new PublicKey(key))
    );

  return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
    const addressLookupTableAddress = keys[index];
    if (accountInfo) {
      const addressLookupTableAccount = new AddressLookupTableAccount({
        key: new PublicKey(addressLookupTableAddress),
        state: AddressLookupTableAccount.deserialize(accountInfo.data),
      });
      acc.push(addressLookupTableAccount);
    }

    return acc;
  }, new Array<AddressLookupTableAccount>());
};

const addressLookupTableAccounts: AddressLookupTableAccount[] = [];

addressLookupTableAccounts.push(
  ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))
);

const messageV0 = new TransactionMessage({
  payerKey: payerPublicKey,
  recentBlockhash: blockhash,
  instructions: [tokenLedgerInstruction, withdrawInstruction, swapInstruction],
}).compileToV0Message(addressLookupTableAccounts);
const transaction = new VersionedTransaction(messageV0);
 
 This can be useful if you want to withdraw from Solend and immediately convert your withdrawal token into another token with Jupiter. 
 Setting Priority Fee for Your Transaction 
 If transactions are expiring without confirmation on-chain, this might mean that you have to pay additional fees to prioritize your transaction. To do so, you can set the  computeUnitPriceMicroLamports  parameter.  Refer to Landing Transactions guide for more tips . 
 const transaction = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      // user public key to be used for the swap
      userPublicKey: wallet.publicKey.toString(),
      dynamicComputeUnitLimit: true, // allow dynamic compute limit instead of max 1,400,000
      // custom priority fee
	    prioritizationFeeLamports: {
        priorityLevelWithMaxLamports: {
          maxLamports: 10000000,
          priorityLevel: "veryHigh" // If you want to land transaction fast, set this to use `veryHigh`. You will pay on average higher priority fee.
        }
      }
    })
  })
).json();
 
 Using Dynamic Slippage 
 To understand what Dynamic Slippage is, checkout our  Jupresearch post 
 Dynamic slippage is a slippage estimation and optimization mechanism during the /swap call, and is useful because: 
 
 Estimates slippage closer to the time of execution. 
 A set of heuristics that accounts for the type of token traded and user''s max slippage tolerance. 
 Safeguards the user while ensuring success rate. 
 
 The frontend sends a payload to the backend with an additional  dynamicSlippage  field with  maxBps  set as the user''s max slippage  (this is important to respect the user''s max, the jup.ag UI sets the default to 300bps (3%)) . 
 // get serialized transactions for the swap
const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      // user public key to be used for the swap
      userPublicKey: wallet.publicKey.toString(),
      // auto wrap and unwrap SOL. default is true
      wrapAndUnwrapSol: true,
      // jup.ag frontend default max for user
      dynamicSlippage: { "maxBps": 300 },
      // feeAccount is optional. Use if you want to charge a fee.  feeBps must have been passed in /quote API.
      // feeAccount: "fee_account_public_key"
    })
  })
).json();
 
 The backend returns a response with a serialized transaction that is already using the final optimized slippage and a  dynamicSlippageReport  for visibility/error catching. 
 {
    "swapTransaction": "// serialized transaction",
    "lastValidBlockHeight": 266691690,
    "prioritizationFeeLamports": 384,
    "computeUnitLimit": 107468,
    "prioritizationType": {
        "computeBudget": {
            "microLamports": 3577,
            "estimatedMicroLamports": 3577
        }
    },
    "dynamicSlippageReport": {
        // the final optimized slippage bps used in the serialized transaction
        "slippageBps": 12,
        // the incurred out amount observed from simulating the transaction
        "otherAmount": 8759842,
        // the simulated incurred slippage during optimization
        // negative integer refers to the loss in bps while positive refers to the gain
        "simulatedIncurredSlippageBps": -8,
        // an amplification ratio we use to add a buffer to the estimated slippage
        "amplificationRatio": "1.5"
    },
    "simulationError": null
}
 
 Examples 
 For more example scripts please visit the  jupiter-quote-api-node public Git repository . The repository has some further scripts and instructions for you to explore! 
 
 Javascript/Typescript:  https://github.com/jup-ag/jupiter-quote-api-node 
 Rust:  https://github.com/jup-ag/jupiter-api-rust-example 
 
 Having issues? Head to the  Troubleshooting  section for some help.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/4-price-api.md', 'sidebar_label: (Deprecated) Price API V1
description: Get real-time on-chain prices for any token with Jupiter Price API. Supports up to 100 tokens per call. Easy integration for developers.
title: "(Deprecated) Price API: Get On-Chain Price For Any Token" 

      (Deprecated) Jupiter Price API v1: Unlock Real-Time On-Chain Pricing for Any Token 
     

 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 :::warning
This endpoint is no longer maintained. Use  Pricing API V2  instead.
::: 
 Utilizing the powerful Jupiter Price API makes getting precise and real-time pricing for all SPL tokens simple. With the ability to fetch prices for up to 100 tokens, you''ll never need another price API again! 
 The Jupiter Price API comes with the option to specify another token as the base unit see "vsToken". 
 :::info
We support fetching the prices for up to 100 tokens in one call right now to manage performance. If you have a use case that is not supported yet, let us know in  #developer-support  in our discord:  discord.gg/jup 
::: 
 Usage 
 Jupiter Price API will always return  the unit buy price for the token  specified with the  ids  parameter. This price is based on the best pricing data available across all DEXes queried. Please remember the addresses and token tickers are  case-sensitive . 
 For example, the most basic call will provide the unit price for the token based on the  buy amount of USDC .  
 # Unit price of 1 SOL based on the buy amount of USDC
https://price.jup.ag/v6/price?ids=SOL

{
  "data": {
    "SOL": {
      "id": "So11111111111111111111111111111111111111112",
      "mintSymbol": "SOL",
      "vsToken": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "vsTokenSymbol": "USDC",
      "price": 30.389174403
    }
  },
  "timeTaken": 0.0003002400007972028
}
 
 If you include a  vsToken , it will change the buy token. For example, this call will return the unit price for  1 JUP, based on the buy amount of Bonk . Simply put, the  vsToken  argument tells you how much of the  vsToken  (Bonk in this case) you will need to buy the target token (JUP). So for every one JUP we want to buy, we will need 44,580 Bonk. 
 # Unit price of 1 JUP based on the buy amount of Bonk
https://price.jup.ag/v6/price?ids=JUP&vsToken=Bonk

{
    "data": {
        "JUP": {
            "id": "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN",
            "mintSymbol": "JUP",
            "vsToken": "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
            "vsTokenSymbol": "Bonk",
            "price": 44580.353494
        }
    },
    "timeTaken": 0.0002948529999997618
}
 
 Both the  ids  and  vsToken  can also be specified using input mints. 
 # Specifying both id and vsToken with mint addresses
https://price.jup.ag/v6/price?ids=7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs&vsToken=So11111111111111111111111111111111111111112

{
  "data": {
    "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs": {
      "id": "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
      "mintSymbol": "ETH",
      "vsToken": "So11111111111111111111111111111111111111112",
      "vsTokenSymbol": "SOL",
      "price": 43.28938739
    }
  },
  "timeTaken": 0.039186676000099396
}
 
 Try it out! 
 Try the API calls by making simple GET request via your browser or one of the terminal commands below: 
 
   Click to play videos 
   
     
    Your browser does not support the video tag.
   
   
     
    Your browser does not support the video tag.
   
 
 
   
     
       GET 
       https://price.jup.ag/v6/price 
     
   
 curl -X ''GET'' ''https://price.jup.ag/v6/price?ids=SOL''
 
 Parameters: 
 
 ids (required, string) : Supports symbol or address of a token. You can also pass in an array of ids to with  ,  as separator.
 
 Address mode are case-sensitive
 
 mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So 
 mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So , So11111111111111111111111111111111111111112 
 
 
 Symbol mode are case-sensitive
 
 SOL ,  BTC ,  mSOL 
 
 
 
 
 vsToken (string) :     Supports symbol or address of a token.
 
 Defaults to  USDC 
 Symbol mode are case-sensitive
 
 SOL ,  BTC ,  mSOL 
 
 
 Address mode are case-sensitive
 
 EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v 
 
 
 
 
 
 Typings 
 
 id ( string )  - Address of a token 
 mintSymbol ( string )  - Symbol of id token 
 vsToken ( string )  - Address of vs token 
 vsTokenSymbol ( string )  - Symbol of vs token 
 price ( number )  - Default to 1 unit of the token worth in USDC if vsToken is not specified 
 timeTaken ( number )  - API internal compute response time 
 
 Response 
 
     
       •  
       
       200: OK 
        Success Response
       
     
 {
  "data": {
    "SOL": {
      "id": "So11111111111111111111111111111111111111112",
      "mintSymbol": "SOL",
      "vsToken": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "vsTokenSymbol": "USDC",
      "price": 165.827567017
    }
  },
  "timeTaken": 0.0004649519978556782
}
 
 :::tip
You will get an empty response if the token is not found or there is an error in the params!
::: 
 
   
   •  default   Error Response 
 {
  "data": {},
  "timeTaken": 0.00007273000665009022
}
 
 
 
 
   
     
       GET 
       https://price.jup.ag/v6/price?ids=SOL&vsToken=mSOL 
     
   
 curl -X ''GET'' ''https://price.jup.ag/v6/price?ids=SOL&vsToken=mSOL''
 
 Response 
 
     
       •  
       
       200: OK 
        Success Response
       
     
 
{
    "data": {
        "SOL": {
            "id": "So11111111111111111111111111111111111111112",
            "mintSymbol": "SOL",
            "vsToken": "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
            "vsTokenSymbol": "mSOL",
            "price": 0.839028001
        }
    },
    "timeTaken": 0.00020902999676764011
}

 
 
 
 Rate Limits:  This endpoint is rate limited to  600 requests/min . 
 HTTP Status Codes 
 Code Error Message 
 400  Amount lesser or equals to 0   No routes found for trading pairs 
 404 Symbol or address not found for either input or vsToken 
 409 Duplicate symbol found for  input  or  vsToken .   The server will respond an error structure which contains the conflict addresses. User will have to use address mode instead.  { "error": "Duplicated symbol found for PERP, use one of the address instead", "addresses": [ "D68NB5JkzvyNCZAvi6EGtEcGvSoRNPanU9heYTAUFFRa", "9BsnSWDPfbusseZfnXyZ3un14CyPMZYvsKjWY3Y8Gbqn", "EBQ6gWBQNxA2zB4twR5GWP6CkeAhqZZZeDgeP7BTtdM3"  ]}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/10-troubleshooting.md', 'sidebar_label: "Troubleshooting"
description: Master Jupiter Swap API with quick fixes for common issues like timeouts and errors. Boost your API skills now!
title: Troubleshooting Tips 

     Jupiter Swap API Troubleshooting Tips 
     

 Swap Execution 
 Common transaction error: 
 
 Program log: Custom program error: 0x1771 
 
 
 Program Jupiter Aggregator v6 consumed 67018 of 200000 compute units 
 
 
 Program returned error: custom program error: 0x1771 
 
 0x1771  occurs when the slippage tolerance is exceeded, so when the final out amount is less than the minimum out amount. 
 Wrap and Unwrap SOL 
 You can refer to the documentation here: https://solanacookbook.com/references/token.html#how-to-manage-wrapped-sol. For the Jupiter API, there is also a  wrapAndUnwrapSol  parameter that you can use as well. 
 Transaction Confirmation Timeout 
 From time to time, you may see an error message like  Transaction was not confirmed in 60.00 seconds. , this means that your transaction expires without being confirmed. Each block on Solana has a fixed compute unit allocation. Each account can only take up certain compute units in the block. So, if you are swapping through a very hot pair, that means that many people will compete with you for those limited compute units. You will have to outbid others to get your transaction in. This usually happens if you are consistently being outbid by others to get your transaction in. 
 To learn how to mitigate this problem, you should read this article about Solana transaction here:
https://jstarry.notion.site/Transaction-confirmation-d5b8f4e09b9c4a70a1f263f82307d7ce 
 The Jupiter API cannot fix this for you but we do have a few things that can help you: 
 
 prioritizationFeeLamports  on  /swap : You can set this to  auto  which will call the  getRecentPrioritizationFees  RPC and get 2x of 75 percentile of all the writable accounts involved in your transaction. This is usually enough to outbid everyone but sometimes during high congestion, it may not be enough. If that is not enough, you can also do  {"autoMultiplier": 2} , which will 2x of the auto fees. In order to protect user from setting a very high fee, the fee is always capped at 0.005 SOL. 
 
 const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // quoteResponse from /quote api
      quoteResponse,
      // user public key to be used for the swap
      userPublicKey: wallet.publicKey.toString(),
      // auto wrap and unwrap SOL. default is true
      dynamicComputeUnitLimit: true,
      prioritizationFeeLamports: "auto",
      // prioritizationFeeLamports: {
      //   autoMultiplier: 2,
      // },
    })
  })
).json();
 
 
 If the  prioritizationFeeLamports  doesn''t work, you can always set your own fee by using the  /swap-instructions  endpoint. 
 dynamicComputeUnitLimit  on  /swap : By default, the Jupiter API assumes that each swap will take up 1.4m compute units. By setting this to  true  it will adjust the compute unit to be dynamic. Jupiter runs a simulation to estimate the compute units the swap will take then we add an extra 40% margin. By having lower compute units used we can set a higher priority fee. This will help to get a transaction through since now you are bidding with a higher priority fee. 
 maxRetries  on  sendRawTransaction : This can be useful to retry sending your transaction and increase the chance of your transaction landing. 
 You can check out how we send transaction on https://jup.ag  here . 
 Also, the Solana documentation has some  very good tips . 
 
 const txid = await connection.sendRawTransaction(rawTransaction, {
  skipPreflight: true,
  maxRetries: 2
});
 
 Blockhash is Invalid/Not Found 
 This can happen because of the decentralized nature of the chain. My local chain can be faster than your chain but they will eventually sync up. If you run into this problem, we suggest using  processed  commitment when submitting the transaction and use  confirmed  commitment to confirm your transaction. Setting  skipPreflight  to  true  can be very helpful too when submitting the transaction. This will mean that you will skip transaction simulation entirely. 
 If this problem persists, you can always set your own blockhash before submitting the transaction. You can check out a very helpful article  here . 
 const txid = await connection.sendRawTransaction(rawTransaction, {
  maxRetries: 2,
  skipPreflight: true, // If you set this to true, you can skip the next one.
  preflightCommitment: ''processed''
});', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/11-landing-transactions.md', 'sidebar_label: "Landing Transactions"
description: Optimize Transactions Landing Rate on Solana
title: Landing Transactions On Solana 
 At Jupiter, our primary objective is to provide the best developer experience and with the most competitive pricing for every swap. 
 Optimising transaction landing success rate can be challenging, especially during periods of network congestion when many users are competing to have their transactions processed. 
 Several common factors can affect the success of your transactions, including insufficient priority fees, inadequate slippage settings, and more. 
 TLDR 
 We can read more detailed explanation on how to land Jupiter swap transactions with below but here is the TLDR if you just want to skip all the details below. 
 When you are getting a quote from the API: 
 const quoteResponse = await (
  await fetch(''https://quote-api.jup.ag/v6/quote\
&inputMint=So11111111111111111111111111111111111111112\
&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\
&amount=100000000\
&restrictIntermediateTokens=true''
  )
).json();
 
 
 restrictIntermediateTokens : Make sure that you set this to  true , if your route is routed through random intermediate tokens, it will fail more frequently. With this, we make sure that your route is only routed through highly liquid intermediate tokens to give you the best price and more stable route. 
 
 When you are getting a transaction from the API: 
 const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey.toString(),
      dynamicComputeUnitLimit: true, // Set this to true to get the best optimized CU usage.
      dynamicSlippage: { // This will set an optimized slippage to ensure high success rate
        maxBps: 300 // Make sure to set a reasonable cap here to prevent MEV
      },
	    prioritizationFeeLamports: {
        priorityLevelWithMaxLamports: {
          maxLamports: 10000000,
          priorityLevel: "veryHigh" // If you want to land transaction fast, set this to use `veryHigh`. You will pay on average higher priority fee.
        }
      }
    })
  })
).json();
 
 When you are submitting the transaction, make sure that you are using one of the native Solana RPC: 
 
 Helius : https://www.helius.dev/ 
 Triton : https://triton.one/ 
 
 Yes, RPC matters. Use one of the above. 
 Bonus point, you can also submit your Jupiter transactions to the Jupiter transaction endpoint: 
 fetch(`https://worker.jup.ag/send-transaction`, {
  method: ''POST'',
  headers: {
    Accept: ''application/json'',
    ''Content-Type'': ''application/json'',
  },
  body: JSON.stringify(transactionPayload),
});
 
 Do note that this endpoint only works with Jupiter transactions. 
 Lastly, make sure that you submit your transaction using the  transactionSender . 
 On a High Level 
 You want to optimise your transaction landing rates by: 
 
 Setting competitive priority fees 
 Managing slippage effectively 
 Setting the optimal amount of compute units 
 Broadcasting transactions efficiently 
 
 Jupiter Swap API helps you improve transaction success with dynamic slippage and priority fees built directly into our API. 
 
 Priority Fees 
 What is priority fees? 
 Priority Fees  are optional fees, priced in  micro-lamports  per  Compute Unit (CU) , that you can add to your transaction on top of the base transaction fee (5,000 lamports / 0.000005 SOL) to get prioritised in the leader queue. By paying an additional fee, you improve the chances of landing your transactions more quickly. 
 Transactions submitted to the blockchain are prioritised based on a fee-bidding process. The higher the priority fee, the higher your transaction will be placed in the execution queue. 
 It’s important to note that overpaying for priority fees can be detrimental in the long run. If users continuously outbid each other to submit transactions, the overall fees required to process transactions across the network will increase over time. 
 Calculating the optimal priority fee—one that maximises your success rate without overpaying—can be increasingly challenging. 
 How are priority fees calculated? 
 priority fees = computeBudget * computeUnitPrice (CUP) 
 When adding priority fees, consider whether the transaction involves writing to any accounts, and adjust the  Compute Unit Price (CUP)  accordingly. 
 How Jupiter estimates priority fees? 
 Priority fees are estimated on the backend. We use Triton’s  getRecentPrioritizationFees  to obtain an estimate of the priority fees paid for the past 20 slots. Based on these recent priority fees, we can provide a better estimate for the amount of priority fee to be paid by categorising them into percentiles (medium, high, very high). 
 More info on trition, https://docs.triton.one/chains/solana/improved-priority-fees-api 
 An example of how Jupiter estimates priority fees 
 const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey.toString(),
      prioritizationFeeLamports: {
        priorityLevelWithMaxLamports: {
          maxLamports: 4000000,
          global: false,
          priorityLevel: "veryHigh"
        }
      }
    })
  })
).json();
 
 
 
 maxLamports : Maximum cap of fee per transaction 
 
 
 global : A boolean to decide whether to use a  global fee estimation  or a  local one  based on specific accounts 
 
 If global is  true , the query considers fees across the entire network. Otherwise, it focuses on fees relevant to the  writable accounts  involved in the instruction. 
 
 Terminologies 
 Global Priority Fee The priority fee estimation across the entire blockchain 
 Local Fee Market The priority fee estimation when editing a writable account (hot account) 
 
 
 
 priorityLevel : Provides an estimate of micro-lamports at each percentile over the past 20 slots, grouped by percentiles: 
 
 medium_PERCENTILE_BPS - 25% 
 High_PERCENTILE_BPS - 50% 
 very_high__PERCENTILE_BPS - 75% 
 
 The percentile determines the  “aggressiveness”  of the transaction’s fee estimation. It tells the function to analyse fee trends from the most recent transactions, focusing on either the 25th, 50th, or 75th percentile of fees observed across recent slots. This percentile helps balance speed and cost: 
 
 Lower percentile transactions may experience delays if congestion increases. 
 Higher percentile transactions have better chances of confirmation but incur higher fees 
 
 
 
 :::info
 priorityLevel  is only available with Jupiter official API and Trition. Self-hosted binary that are not using Trition will not be able to use  priorityLevel .
::: 
 Using Helius Priority Fee API 
 Alternatively, you can use Helius''s  getPriorityFeeEstimate  RPC method which provides fee recommendations based on both global and local fee markets. The API analyzes fee data of the past 150 blocks by default to suggest optimal priority fees. 
 const response = await fetch(HELIUS_URL, {
  method: ''POST'',
  headers: { ''Content-Type'': ''application/json'' },
  body: JSON.stringify({
    jsonrpc: ''2.0'',
    id: ''1'',
    method: ''getPriorityFeeEstimate'',
    params: [{
      transaction: serializedTransaction, // Base58 encoded transaction
      options: {
        recommended: true // Defaults to medium(50th percentile)
      }
    }]
  })
});
 
 The API returns priority fee estimates in micro-lamports per compute unit. You can also provide account keys instead of a serialized transaction to get fee estimates. 
 For detailed implementation and advanced options, see the  Helius Priority Fee API documentation . 
 
 Dynamic Slippage 
 Slippage is an inherent part of trading on DEXes. It is the difference between the quoted amount (expected amount) of the swap and the actual amount a user receives when the trade is executed. 
 Manually adjusting & resubmitting your transaction is a painstaking process. There is no standard slippage to set. Too much, and you may get MEV''ed; too little, and your transaction may fail and won''t land. 
 When slippage is not set properly, this can directly affect the success rate of your transaction. 
 Dynamic Slippage features a real-time slippage optimisation mechanism, providing an dynamic calculation based for different token pair & their respective volatility to get the optimal amount of slippage for your transaction, minimising the need to manually tweak your slippage value & help you land more transactions. 
 How does dynamic slippage work? 
 The frontend sends a payload to the backend with an additional  dynamicSlippage  field with  minBps  &  maxBps  set as the user''s max slippage. The current  maxBps  default is 300bps. 
 const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey.toString(),
      dynamicSlippage: {"minBps": 50, "maxBps": 300},
    })
  })
).json();
 
 The backend returns a response with a serialised transaction that is already using the final optimised slippage and a  dynamicSlippageReport  for visibility/error catching. 
 {
    "swapTransaction": "// serialized transaction",
    "lastValidBlockHeight": 266691690,
    "prioritizationFeeLamports": 384,
    "computeUnitLimit": 107468,
    "prioritizationType": {
        "computeBudget": {
            "microLamports": 3577,
            "estimatedMicroLamports": 3577
        }
    },
    "dynamicSlippageReport": {
        // the final optimized slippage bps used in the serialized transaction
        "slippageBps": 12,
        // the incurred out amount observed from simulating the transaction
        "otherAmount": 8759842,
        // the simulated incurred slippage during optimization
        // negative integer refers to the loss in bps while positive refers to the gain
        "simulatedIncurredSlippageBps": -8,
        // an amplification ratio we use to add a buffer to the estimated slippage
        "amplificationRatio": "1.5"
    },
    "simulationError": null
}
 
 Dynamic CU Estimation 
 const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey.toString(),
      dynamicComputeUnitLimit: true
    })
  })
).json();
 
 dynamicComputeUnitLimit - when  true  allows the transaction to utilise a dynamic compute unit limit rather than the standard maximum limit, which is set to 1,400,000 compute units. 
 By setting this parameter to  true , you enable the transaction to use the best CU limit based on transaction simulation. 
 
 Transaction Broadcasting 
 Transaction broadcasting is the process of submitting a signed transaction to the network so that validators can verify, process, and include it in a block. 
 
 After you’ve built and signed your transaction, the signed transaction is serialized into a binary format and submitted to a Solana RPC node, where it is propagated across the network. 
 The RPC node will verify and relay the transaction to the leader validator responsible for producing the next block. 
 
 Stake-weighted Quality of Service 
 Stake-Weighted Quality of Service (SWQoS)  is an implemented feature that, when enabled, allows leaders (block producers) to identify and prioritise transactions proxied through a staked validator as an additional Sybil resistance mechanism. 
 The more stake the validator holds, the better the chances of getting their transactions included in blocks. 
 Validators with higher stakes are granted more favourable access to submit transactions, ensuring they receive a larger share of block space. This mechanism helps maintain network security and mitigate Sybil attacks by preventing low-stake validators from spamming the network. 
 Current RPC providers that provides SWQoS are Helius and Triton. 
 SWQoS & Priority Fees 
 Both mechanisms are used to improve network performance, but they work differently. 
 
 SWQoS ensures that staked validators have better access to the network, reducing the likelihood of transactions being delayed or dropped due to network congestion. 
 SWQoS guarantees that transactions sent from staked validators have a prioritised pathway to reach the leader. 
 Priority fees impact how transactions are ordered and processed once they are within the leader’s queue. 
 Priority fees prioritize transactions based on the fees paid to the leader, ensuring quicker execution for users willing to pay more. 
 
 :::info
This is why it is important to submit your transactions to Solana native RPC providers like Helius and Triton. They have staked connections that can help you to land your transactions better. 
 
 Helius : https://www.helius.dev/ 
 Triton : https://triton.one/
::: 
 
 
 What is Jito? 
 Jito Labs  is a leading MEV infrastructure company building high-performance systems to scale Solana and maximise validator rewards. 
 Jito Tips on Solana are part of a mechanism that enables searchers—such as high-frequency traders or MEV participants—to prioritise their transactions by offering tips to validators. These tips incentivise validators to include specific transaction bundles during the block production process, helping users land critical transactions in competitive scenarios. 
 Leveraging Jito Tips can significantly improve your chances of landing transactions in time-sensitive environments, such as arbitrage trades or automated DeFi operations. This system provides a faster, more reliable way to execute critical transactions, giving participants an edge by minimising latency and enhancing the predictability of transaction inclusion. 
 At Jupiter, we provide users with the option of sending their transactions via Jito tips to help you land transactions much faster. 
 Jito also allows users to bundle transactions, ensuring they land on the blockchain exactly as intended, which mitigates risks such as front-running and sandwich attacks. This mechanism helps protect both users and decentralised applications (dApps) that rely on time-sensitive transactions. 
 Jito achieves this through features like low-latency transaction streaming, which ensures fast execution, and atomic transaction bundles, which allow multiple related transactions to execute together or not at all. This bundling process provides “revert protection,” meaning that if any part of a bundled sequence fails, the entire bundle is reverted, reducing exposure to harmful MEV strategies. 
 Jupiter also includes MEV protection on our frontend, sending your transaction directly to the Jito validator. 
 More info on Jito tip & MEV protection: https://docs.jito.wtf/. 
 To automatically include Jito tips in your Jupiter swap transaction: 
 const { swapTransaction } = await (
  await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: wallet.publicKey.toString(),
      prioritizationFeeLamports: {
        jitoTipLamports: 1000000
      }
    })
  })
).json();
 
 Please make sure that you are only submitting your transactions to Jito endpoints if you have Jito tips attached. If not, it will not work.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/2-payments-api.md', 'sidebar_label: Payments API
description: Convert any token to USDC with Jupiter Payments API. A comprehensive guide for seamless crypto transactions.
title: "Payments API: Convert Any Token to USDC" 

     Jupiter Payments API Guide: Seamless Token Conversion to USDC 
     

 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 Jupiter''s Payments API supports your payments use case. Utilize Jupiter + SolanaPay to pay for anything with any SPL token. With the Jupiter Payments API, you can specify an exact output token amount. The API doesn''t just support output token to USDC, but to any SPL token! 
 Use Case 
 Payments or interaction with a protocol can require an exact amount of token B. Users might not have token A or prefer to hold other tokens long term. The Jupiter API allow building a swap transaction to receive an exact amount of token A for a maximum in amount of token B. 
 A Practical Example using the API 
 Bob is selling a delicious latte for 5 USDC. Alice wants to buy Bob''s latte. The problem is, Alice only holds mSOL. Luckily, Bob can use the Jupiter Payments API to let Alice swap for exactly 5 USDC then transfer 5 USDC to his payment wallet. 
 First, we need to show Alice how much mSOL she will have to spend for the latte. To do this we use the  GET /quote  endpoint. 
 1. Get Quote 
 Retrieve a quote for swapping a specific amount of tokens. 
 
   Click to play video 
   
     
    Your browser does not support the video tag.
   
 
 
   
     
       GET 
       https://quote-api.jup.ag/v6/quote 
     
   
 curl -s ''https://quote-api.jup.ag/v6/quote?inputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=5000000&swapMode=ExactOut&slippageBps=50'' | jq ''.inAmount, .otherAmountThreshold''
 
 Parameters: 
 
 inputMint : The mint address of the input token (required). 
 outputMint : The mint address of the output token (required). 
 amount : The amount to swap, factoring in the token decimals (required). 
 slippageBps : Slippage tolerance in basis points (default 50 unless  autoSlippage  is set to true). 
 swapMode : Can be  ExactIn  or  ExactOut  (default  ExactIn ). 
 dexes : List of DEXes to include (optional). 
 excludeDexes : List of DEXes to exclude (optional). 
 restrictIntermediateTokens : Restrict to a top token set for stable liquidity (optional). 
 onlyDirectRoutes : Limit to single hop routes only (optional, default false). 
 asLegacyTransaction : Use legacy transactions (optional, default false). 
 platformFeeBps : Fee to charge in BPS (optional). 
 maxAccounts : Max accounts to be used for the quote (optional). 
 autoSlippage : Enable smart slippage (optional, default false). 
 maxAutoSlippageBps : Max slippage BPS for smart slippage (optional). 
 autoSlippageCollisionUsdValue : Custom USD value for calculating slippage impact (optional). 
 
 Response : 
 
     
       •  
       
       200: OK 
        Success Response
       
     
 {
    "inputMint": "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
    "inAmount": "23698263",
    "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    "outAmount": "5000000",
    "otherAmountThreshold": "23816755",
    "swapMode": "ExactOut",
    "slippageBps": 50,
    "platformFee": null,
    "priceImpactPct": "0",
    "routePlan": [
        {
            "swapInfo": {
                "ammKey": "8EzbUfvcRT1Q6RL462ekGkgqbxsPmwC5FMLQZhSPMjJ3",
                "label": "Raydium CLMM",
                "inputMint": "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
                "outputMint": "So11111111111111111111111111111111111111112",
                "inAmount": "23698263",
                "outAmount": "28158132",
                "feeAmount": "1992",
                "feeMint": "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"
            },
            "percent": 100
        },
        {
            "swapInfo": {
                "ammKey": "CSP4RmB6kBHkKGkyTnzt9zYYXDA8SbZ5Do5WfZcjqjE4",
                "label": "Whirlpool",
                "inputMint": "So11111111111111111111111111111111111111112",
                "outputMint": "hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux",
                "inAmount": "28158132",
                "outAmount": "100994175",
                "feeAmount": "1",
                "feeMint": "So11111111111111111111111111111111111111112"
            },
            "percent": 100
        },
        {
            "swapInfo": {
                "ammKey": "5LnAsMfjG32kdUauAzEuzANT6YmM3TSRpL1rWsCUDKus",
                "label": "Whirlpool",
                "inputMint": "hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux",
                "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
                "inAmount": "100994175",
                "outAmount": "5000000",
                "feeAmount": "131292",
                "feeMint": "hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux"
            },
            "percent": 100
        }
    ],
    "contextSlot": 267155237,
    "timeTaken": 0.010184745
}
 
 
 
   •  default   Error Response 
 {
    "errorCode": "string",
    "error": "string"
}
 
 
 
 :::info
Currently, only Orca Whirlpool, Raydium CLMM, and Raydium CPMM support ExactOut mode. All token pairs may not be available in this mode. To see more price options use ExactIn mode.
::: 
 Then Bob creates the transaction with the  POST /swap  endpoint, and adds a 5 USDC token transfer from Alice to his payment wallet using the  destinationTokenAccount  argument, which Alice will verify, sign and send. 
 2. Post Swap 
 Returns a transaction that you can use from the quote you get from  GET /quote . 
 Try it live in the playground: 
 POST https://quote-api.jup.ag/v6/swap 
 :::info
In the example below, we assume the associated token account exists on  destinationTokenAccount .
::: 
 import { PublicKey, Connection, Keypair, VersionedTransaction, VersionedMessage, TransactionMessage } from ''@solana/web3.js'';
import { getAssociatedTokenAddress, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from ''@solana/spl-token'';
import fetch from ''node-fetch'';

// Replace with actual valid base58 public keys
const USDC_MINT = new PublicKey(''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'');  // USDC mint address
const bobWalletPublicKey = new PublicKey(''BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9'');  // Bob''s wallet address

// Establish a connection to the Solana cluster
const connection = new Connection(''https://api.mainnet-beta.solana.com'');

// Replace these with actual valid base58 public keys
const feeAccount = new PublicKey(''ReplaceWithActualValidBase58Key'');  // Replace with actual fee account public key
const trackingAccount = new PublicKey(''ReplaceWithActualValidBase58Key'');  // Replace with actual tracking account public key

// Ensure these are valid base58 strings
console.log("USDC_MINT:", USDC_MINT.toBase58());
console.log("bobWalletPublicKey:", bobWalletPublicKey.toBase58());
console.log("feeAccount:", feeAccount.toBase58());
console.log("trackingAccount:", trackingAccount.toBase58());

// Get the associated token account for Bob''s wallet
async function getBobUSDCTokenAccount(bobWalletPublicKey) {
  const bobUSDCTokenAccount = await getAssociatedTokenAddress(
    USDC_MINT,
    bobWalletPublicKey,
    true,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID
  );
  return bobUSDCTokenAccount;
}

// Step 1: Fetch swap info
async function fetchSwapInfo() {
  const response = await fetch(''https://quote-api.jup.ag/v6/quote?inputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=5000000&swapMode=ExactOut&slippageBps=50'');
  const data = await response.json();
  return {
    inAmount: data.inAmount,
    otherAmountThreshold: data.otherAmountThreshold,
    quoteResponse: data
  };
}

// Step 2: Fetch the swap transaction
async function fetchSwapTransaction(swapUserKeypair, bobUSDCTokenAccount, swapInfo) {
  const requestBody = {
    userPublicKey: swapUserKeypair.publicKey.toBase58(),
    wrapAndUnwrapSol: true,
    useSharedAccounts: true,
    feeAccount: feeAccount.toBase58(),  // Use actual key
    trackingAccount: trackingAccount.toBase58(),  // Use actual key
    prioritizationFeeLamports: 0,  // No prioritization fee in this case
    asLegacyTransaction: false,
    useTokenLedger: false,
    destinationTokenAccount: bobUSDCTokenAccount.toBase58(),
    dynamicComputeUnitLimit: true,
    skipUserAccountsRpcCalls: true,
    quoteResponse: swapInfo.quoteResponse
  };

  const response = await fetch(''https://quote-api.jup.ag/v6/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json'',
    },
    body: JSON.stringify(requestBody),
  });

  const { swapTransaction, lastValidBlockHeight } = await response.json();
  return { swapTransaction, lastValidBlockHeight };
}

// Step 3: Send the transaction to the Solana blockchain
async function sendTransaction(swapTransaction, swapUserKeypair, lastValidBlockHeight) {
  const transaction = VersionedTransaction.deserialize(Buffer.from(swapTransaction, ''base64''));

  // Get the recent blockhash
  // Using ''finalized'' commitment to ensure the blockhash is final and secure
  // You may experiment with ''processed'' or ''confirmed'' for fetching blockhash to increase speed
  // Reference: https://solana.com/docs/oldrpc/http/getlatestblockhash
  const bhInfo = await connection.getLatestBlockhashAndContext({ commitment: "finalized" });
  transaction.recentBlockhash = bhInfo.value.blockhash;
  transaction.feePayer = swapUserKeypair.publicKey;

  // Sign the transaction with the swap user''s keypair
  transaction.sign([swapUserKeypair]);

  // Simulate the transaction to ensure it will succeed
  // Using ''finalized'' commitment for the simulation to match the security level of the actual send
  // You may experiment with ''confirmed'' or ''processed'' to simulate faster, but keep in mind the risks
  // Reference: https://solana.com/docs/oldcore/transactions#commitment
  const simulation = await connection.simulateTransaction(transaction, { commitment: "finalized" });
  if (simulation.value.err) {
    throw new Error(`Simulation failed: ${simulation.value.err.toString()}`);
  }

  // Send the transaction
  try {
    const signature = await connection.sendTransaction(transaction, {
      // NOTE: Adjusting maxRetries to a lower value for trading, as 20 retries can be too much
      // Experiment with different maxRetries values based on your tolerance for slippage and speed
      // Reference: https://solana.com/docs/oldcore/transactions#retrying-transactions
      maxRetries: 5,
      skipPreflight: true,
      preflightCommitment: "finalized",
    });

    // Confirm the transaction
    // Using ''finalized'' commitment to ensure the transaction is fully confirmed
    // Reference: https://solana.com/docs/oldcore/transactions#confirmation
    const confirmation = await connection.confirmTransaction({
      signature,
      blockhash: bhInfo.value.blockhash,
      lastValidBlockHeight: bhInfo.value.lastValidBlockHeight,
    }, "finalized");

    if (confirmation.value.err) {
      throw new Error(`Transaction not confirmed: ${confirmation.value.err.toString()}`);
    }

    console.log("Confirmed: ", signature);
  } catch (error) {
    console.error("Failed: ", error);
    throw error;
  }
}

// Example usage
(async () => {
  try {
    // Generate keypairs for swap user and Bob''s wallet, replace with actual keypairs for real usage
    const swapUserKeypair = Keypair.generate();

    // Ensure the bobUSDCTokenAccount is correct
    const bobUSDCTokenAccount = await getBobUSDCTokenAccount(bobWalletPublicKey);

    // Step 1: Fetch swap info
    const swapInfo = await fetchSwapInfo();

    // Step 2: Fetch the swap transactions
    const { swapTransaction, lastValidBlockHeight } = await fetchSwapTransaction(swapUserKeypair, bobUSDCTokenAccount, swapInfo);

    // Step 3: Send the transaction to the blockchain
    await sendTransaction(swapTransaction, swapUserKeypair, lastValidBlockHeight);
  } catch (error) {
    console.error(''Error:'', error);
  }
})();
 
 :::tip
If you want to add your own fees, check out: Adding Your Own Fees
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/8-c-sharp-example.md', 'sidebar_label: Game Dev (C#)
description: Integrate Jupiter swaps and payments into your C# games with easy-to-use APIs. Enhance development and enjoy cross-platform support.
title: Game Development (C#) 

     Jupiter Swap in C# - Elevate Your Game Development 
     

 :::info
Jupiter is fully supported within the Solana.Unity-SDK. The core  library  is independent of Unity and can be incorporated into Unreal Engine using the UnrealCLR library or in a C# backend.
::: 
 Using the Solana.Unity-SDK, game developers can effortlessly incorporate Jupiter swaps into their games and achieve cross-platform compatibility without the need to modify a single line of code. 
 Within the SDK, the Jupiter Payments API is also available, enabling you to utilize Jupiter + SolanaPay for facilitating user payments with any SPL token, allowing pricing in USDC or other tokens. 
 Documentation 
 For detailed documentation, please visit:  Solana Unity SDK Jupiter Documentation 
 Demos 
 
 Explore this demo video showcasing an in-game swap powered by the Jupiter integration:  Watch Demo Video 
 Access a live demo here:  Live Demo', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/9-self-hosted.md', 'sidebar_label: "Self-hosted V6 Swap API"
description: Unlock the potential of Self Hosted Jupiter Swap API for tailored trading solutions and independence from public API limits.
title: "Self-hosted V6 Swap API" 

     Self Hosted Jupiter Swap API - Personalized Infrastructure 
     

 Jupiter provides the ability for advanced users can run a self-hosted Jupiter Swap API. You can download the  jupiter-swap-api here . 
 Mission-critical use cases, like liquidations and oracles, can deploy their own API servers relying on their own RPC nodes to entirely decouple their systems from Jupiter infrastructure. 
 Integrators load is no longer restricted by the public API rate limits. 
 Prerequisites 
 A dedicated or shared Solana RPC node:  optional  but recommended with the  Yellowstone gRPC plugin  access. 
 The following RPC providers can provide a RPC node with the geyser plugin: 
 
 Triton 
 Helius  Contact Helius on  Discord 
 Shyft  Contact Shyft on  Discord 
 Solana Tracker 
 
 Usage 
 To start the API server: 
 RUST_LOG=info ./jupiter-swap-api --rpc-url <RPC-URL> --yellowstone-grpc-endpoint <GRPC-ENDPOINT> --yellowstone-grpc-x-token <X-TOKEN> 
 For instance, if you used Triton and your RPC url is https://supersolnode.jup/91842103123091841, the arguments would be  --rpc-url https://supersolnode.jup/91842103123091841 --yellowstone-grpc-endpoint https://supersolnode.jup --yellowstone-grpc-x-token 91842103123091841 
 It is also possible to run the API in poll mode (heavy for nodes and it is not recommended). It will periodically poll the Solana RPC node for accounts rather than listening with the Yellowstone gRPC endpoint: 
 RUST_LOG=info ./jupiter-swap-api --rpc-url <RPC-URL> 
 For others options, use  --help : 
 ./jupiter-swap-api --help 
 Once the API server is ready, it will open a HTTP server at  0.0.0.0:8080 . 
 The jupiter-swap-api is identical to the public Jupiter Swap API so all the documentation applies  Swap API , replacing the api URL  https://quote-api.jup.ag/v6  with  http://127.0.0.1:8080 . 
 Market Cache 
 The Jupiter self hosted Swap API relies on the market cache https://cache.jup.ag/markets?v=3 maintained by the Jupiter team, as a snapshot of all the relevant markets after liquidity filtering. 
 To pick up those new markets the api has to be restarted. The cache is updated every 30 minutes. 
 This is the only reliance on Jupiter infrastructure. 
 Adding New Markets (Without Restart) 
 To pick up new markets without restart, you can set  --enable-add-market  when starting the Jupiter self hosted Swap API. This way, you will see a new endpoint at  /add-market . To add a new market without restarting the API, you can post to this endpoint. For example, let''s say you have a new market on Raydium AMM, you will have to post the following payload to this endpoint: 
 {
  "address": "EzvDheLRnPjWy3S29MZYEi5qzcaR1WR5RNS8YhUA5WG5",
  "owner": "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
  "params": { // Optional
    "serumAsks":"Ac8Hoi4LBbJfG4pCEUu2sS3jkmNrZBv6tbdmEnxAkRsK",
    "serumBids":"CF1NyAZjWqi8t9WZ7pSiqCiTSr3taZ94EW44AjyZRsnY",
    "serumCoinVaultAccount":"65LDE8k8WqhgrZy6NDsVQxGuUq3r8fT8bJunt5WPAZAk",
    "serumEventQueue":"1Xpk12GqjPLS8bkL8XVRHc6nrnunqcJhDha9jUq6Ymc",
    "serumPcVaultAccount":"AKATaDtSNPc5HemQCJzhph7o76Q1ndRHyKwai5C4wFkR",
    "serumVaultSigner":"7xookfS7px2FxR4JzpB3bT9nS3hUAENE4KsGaqkM6AoQ"
  },
  "addressLookupTableAddress":"5tVPTN4afHxuyS8CNCNrnU7WZJuYeq5e2FvxUdCMQG7F" // Optional
}
 
 To derive the params, you can look up the  Serum documentation . 
 MacOS 
 On MacOS you will see this error message: 
 “jupiter-swap-api” can’t be opened because Apple cannot check it for malicious software. 
 Go to System Settings and click on "Open Anyway": 
 
 Advanced 
 If a set of AMMs is never needed for routing, they can be removed before starting the api to reduce load. 
 Create a market-cache excluding the program you want to remove, Openbook for this example: 
 curl "https://cache.jup.ag/markets?v=3" -o market-cache.json
jq ''map(select(.owner != "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"))'' market-cache.json > market-cache-no-openbook.json
 
 Then: 
 RUST_LOG=info ./jupiter-swap-api --market-cache market-cache-no-openbook.json ... 
 This will start the API server without Openbook as part of routing. You can also remove individual market as well. 
 Paid Hosted APIs 
 We are working with some Solana RPC partners in the ecosystem as well so that you can get a paid hosted API ran by them. 
 
 QuickNode: https://marketplace.quicknode.com/add-on/metis-jupiter-v6-swap-api 
 Reach out to Triton:  Triton', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/6-flash-fill.md', 'sidebar_label: Flash Fill
description: Learn to integrate Jupiter Swap using Flash-Fill for optimal crypto transactions. Discover unmatched efficiency!
title: Jupiter Swap via Flash-Fill 

     Jupiter Swap Flash Fill Documentation: Full Explanation 
     

 Use Flash Fill to integrate your program with Jupiter Swap. This allows you to avoid the limitations of Cross Program Invocation (CPI) via the "Flash-Fill" approach. Flash-Fill is one of two approaches to integrate Jupiter swap with your protocol. The other approach is Cross Program Invocation CPI. 
 The Jupiter team engineered "flash-fill" to allow developers and integrators to utilize the full potential of Jupiter swap with their programs. 
 :::note CPI is recommended
As of January 2025, Jupiter Swap via CPI is recommended for most users.
::: 
 :::info Why Flash-Fill?
To achieve the best prices and highest returns on swaps, Jupiter divides and routes an order across multiple DEXes in a single transaction, minimizing price impact by prioritizing the lowest-cost routes. Solana transactions are limited to 1232 bytes of storage. By using lookup tables, Jupiter can include more accounts (32 bytes per account) in one transaction. However, the CPI method cannot use lookup tables to reduce the size of each account, so CPI calls to swap via Jupiter typically fail. 
 Flash-filling allows the use of Versioned Transaction in combination with  Address Lookup Tables , thus, reducing the "size" of each account - something we can''t do via the CPI approach. 
 Note: when using Jupiter''s API, you can set maxAccounts to reduce the number of accounts. 
::: 
 Example 
 Here we show an  example transaction  on how to utilize Jupiter Swap via Flash Fill. We use Flash Fill to swap from any tokens to SOL even if the user doesn''t have enough SOL. You can even allow a third-party payer if the user doesn''t have any SOL at all. 
 :::danger
A  note of caution:  Unlike a typical flash loan, the repayment is in a different mint from the loan. As such, there is no easy way to ensure that the repayment amount is appropriate. Take extra measures to minimize the surface area for exploits. For example, making the instruction permissioned to trusted admins or utilizing a price oracle etc+. 
 The exact implementation is protocol specific making the scope beyond this guide.
::: 
 How does this work? 
 For a Flash Fill to work, the transaction will be composed of these instructions: 
 
 Borrow enough SOL for opening the wSOL account from this program. 
 Create the wSOL account for the borrower. 
 Swap X token to wSOL. 
 Close the wSOL account and send it to the borrower. 
 Repay the SOL for opening the wSOL account back to this program. 
 
 Code Repo 
 Here is the GitHub repo:  https://github.com/jup-ag/sol-swap-flash-fill . You should check out the  program code  and the  client code . 
 Here is the  transaction on chain  on how this works.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/3-adding-fees.md', 'sidebar_label: Adding Fees
description: Enhance your platform revenue by adding customizable fees to Jupiter swap using the Jupiter API. Learn how to implement it effortlessly!
title: Adding Your Own Fee To Jupiter Swap 

     Add Fees to Jupiter API: Enhance Your Platform Revenue Seamlessly 
     

 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 
 :::warning No need to use referral program
As of January 2025, you do not need to use the Referral program to add fees to your Jupiter Swap. 
 You can simply pass in  any  token account to the  feeAccount  parameter in  /swap  endpoint to indicate which mint and token account to send the fees to. (You still need to add  platformFeeBps  in  /quote ) 
 
 For Exact In, both input or output mint of the swap can be used to take fees. 
 For Exact Out, only the input mint can be used to take fees. 
 It does not support Token2022.
::: 
 
 The Referral Program is an open source program by Jupiter to provide referral fees for integrators who are integrating Jupiter Swap and Jupiter Limit Order. You can check out the code  here  to gain a better understanding of how it works. 
 By default, there are no protocol fees on Jupiter. Integrators have the option to introduce a platform fee on swaps. The platform fee is provided in basis points, e.g.  20 bps  for  0.2%  of the token input or output. If a platform fee is set by an integrator, Jupiter  will take 2.5%  of the platform fee charged by the integrators. It doesn''t support Token2022 tokens. 
 Usage 
 Jupiter API 
 1. Obtain a referral account 
 Go to the  referral dashboard  to create your referral account. After creating your referral account, remember to find your  Referral Key  on the page. This is your referral account public key. You''ll need this to gather platform fees. 
 2. Set your referral fee 
 Setting your referral fee with the Jupiter API is simple. You just add in the  platformFeeBps  parameter to the  GET /quote  endpoint: 
 
   
     
       GET 
       https://quote-api.jup.ag/v6/quote 
     
   
 Parameters in use in the below code example: 
 
 inputMint : The mint address of the input token. 
 outputMint : The mint address of the output token. 
 amount : The amount of input tokens to be swapped. 
 slippage : The maximum allowable slippage for the swap. 
 platformFeeBps : Basis points of the fee to be added. 
 
 curl -G "https://quote-api.jup.ag/v6/quote" \
     --data-urlencode "inputMint=So11111111111111111111111111111111111111112" \
     --data-urlencode "outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" \
     --data-urlencode "amount=100000000" \
     --data-urlencode "slippageBps=50" \
     --data-urlencode "platformFeeBps=20"
 
 
 // Function to swap SOL to USDC with input 0.1 SOL and 0.5% slippage
async function getQuote() {
  try {
    // Create a new URL object for the quote API endpoint
    const url = new URL("https://quote-api.jup.ag/v6/quote");

    // Append query parameters to the URL
    // inputMint: The mint address of the input token (SOL)
    url.searchParams.append(
      "inputMint",
      "So11111111111111111111111111111111111111112"
    );

    // outputMint: The mint address of the output token (USDC)
    url.searchParams.append(
      "outputMint",
      "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    );

    // amount: The amount of input tokens to be swapped (0.1 SOL in lamports, where 1 SOL = 1,000,000,000 lamports)
    url.searchParams.append("amount", 100000000);

    // slippageBps: The maximum allowable slippage for the swap (0.5% expressed in basis points)
    url.searchParams.append("slippageBps", 50);

    // platformFeeBps: The platform fee to be added (20 basis points)
    url.searchParams.append("platformFeeBps", 20);

    // Perform the fetch request to the constructed URL
    const response = await fetch(url.toString());

    // Check if the response is not OK (status code is not in the range 200-299)
    if (!response.ok) {
      // Throw an error with the status text from the response
      throw new Error(`Error fetching quote: ${response.statusText}`);
    }

    // Parse the response body as JSON
    const quoteResponse = await response.json();

    // Log the parsed response to the console
    console.log({ quoteResponse });
  } catch (error) {
    // Catch any errors that occur during the fetch request or JSON parsing
    // Log the error to the console
    console.error("Failed to get quote:", error);
  }
}

// Call the function to get the quote
getQuote();
 
 3. Set your fee token account 
 On the  POST /swap  endpoint, remember to add your  feeAccount  parameter. 
 
   
     
       POST 
       https://station.jup.ag/v6/swap 
     
   
 Parameters in use in the below code example: 
 
 quoteResponse : The response object from the  /quote  API. 
 userPublicKey : The public key of the user initiating the swap. 
 wrapAndUnwrapSol : Auto wrap and unwrap SOL. Default is true. 
 feeAccount : The fee account associated with the swap. 
 platformFeeBps : Basis points of the fee to be added. 
 
 # Example being constructed in code below
curl -X POST "https://quote-api.jup.ag/v6/swap" \
     -H "Content-Type: application/json" \
     -d ''{
           "quoteResponse": { /* The quote response from the /quote API */ },
           "userPublicKey": "YourUserPublicKey",
           "wrapAndUnwrapSol": true,
           "feeAccount": "YourFeeAccountPublicKey"
         }''
 
 
 // Function to find the fee account and get serialized transactions for the swap
async function getFeeAccountAndSwapTransaction(
  referralAccountPubkey,
  mint,
  quoteResponse,
  wallet
) {
  try {
    // Find the fee account program address synchronously
    // Parameters:
    // - Buffer.from("referral_ata"): A buffer containing the string "referral_ata"
    // - referralAccountPubkey.toBuffer(): The buffer representation of the referral account public key
    // - mint.toBuffer(): The buffer representation of the token mint
    // - new PublicKey("REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3"): The public key of the Referral Program
    const [feeAccount] = await PublicKey.findProgramAddressSync(
      [
        Buffer.from("referral_ata"),
        referralAccountPubkey.toBuffer(),
        mint.toBuffer(),
      ],
      new PublicKey("REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3")
    );

    // Construct the request body for the swap API
    const requestBody = {
      quoteResponse, // The quote response from the /quote API
      userPublicKey: wallet.publicKey.toString(), // The user''s public key
      wrapAndUnwrapSol: true, // Auto wrap and unwrap SOL (default is true)
      feeAccount, // The fee account obtained from findProgramAddressSync
    };

    // Perform the fetch request to the swap API
    const response = await fetch("https://quote-api.jup.ag/v6/swap", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody), // Convert the request body to a JSON string
    });

    // Check if the response is not OK (status code is not in the range 200-299)
    if (!response.ok) {
      // Throw an error with the status text from the response
      throw new Error(`Error performing swap: ${response.statusText}`);
    }

    // Parse the response body as JSON to get the swap transaction
    const { swapTransaction } = await response.json();

    // Log the swap transaction to the console
    console.log({ swapTransaction });

    return swapTransaction; // Return the swap transaction
  } catch (error) {
    // Catch any errors that occur during the fetch request or JSON parsing
    // Log the error to the console
    console.error("Failed to get fee account and swap transaction:", error);
  }
}

// Example usage of the function
// Assuming you have defined referralAccountPubkey, mint, quoteResponse, and wallet elsewhere
getFeeAccountAndSwapTransaction(
  referralAccountPubkey,
  mint,
  quoteResponse,
  wallet
);
 
 :::note
The fee token account, it can either be the input mint or the output mint on the swap for ExactIn. For ExactOut, the fee is being taken as the same mint as the input mint. Also, make sure that the fee token account has been created. You can create the fee token account on the referral dashboard. It doesn''t support Token2022 tokens.
::: 
 Referral Javascript SDK 
 You can check out the Referral Javascript SDK  here . For a list of methods that you can use, check out the source code  here . 
 There are also examples on how to use the SDK  here . 
 :::note
The Jupiter Swap''s project account for the Referral Program is  45ruCyfdRkWpRNGEqWzjCiXRHkZs8WXCLQ67Pnpye7Hp .
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/7-token-list/2-partner-tags.md', 'sidebar_label: "API Standard for Partners"
description: "Learn to integrate your tokens with Jupiter Station''s Partner API. Streamline token tagging for accurate trading. Visit for more details!"
slug: "/token-api-standard"
title: API Standard for Partners 

     Jupiter Partner API Standards: An Overview 
     

 API Standard for Partners 
 How to get your protocol''s tokens tagged 
 We can ingest your list of tokens and get them tagged automatically, to help your users to trade the right tokens. For example, we have Sanctum''s LSTs, pump.fun tokens, clone protocol, and birdeye trending tokens. Read more on the  main API page 
 We need: 
 
 A url  endpoint 
 That points to a simple  .csv file with a mint address per row  -- click on link to see sample. 
 That we can poll at a set interval (tell us how often you expect updates to happen) 
 
 The endpoint should be public, with our IP whitelisted for rate limits where necessary. 
 Tell us if you have a preferred word or acronym for your tag, one that''s short and mobile friendly. 
 That''s it!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/7-token-list/1-token-list-api.md', 'sidebar_label: "Ecosystem Token List API"
description: "Consolidated data for tokens, markets, and ecosystem partners. Perfect for developers."
title: "Ecosystem Master Token List" 

     Jupiter Token List API: Your Crypto Data Gateway | Jupiter Station 
     

 :::warning
The current version of Token API will be sunsetted/deprecated, as we are currently working on improvements for it over the next few weeks.
::: 
 API Endpoints 
 
   
     
       GET tokens by tag 
       https://tokens.jup.ag/tokens?tags=verified 
     
   
 Convenience Tags 
 For most people, these 2 tags are all you need. All tokens would either be verified or unknown. 
 Parameter Description 
 verified Tokens that we display as verified on jup.ag. Today, this is a superset consisting of tokens tagged “community” and “lst”. You can use this setting to automatically receive jupiter’s settings when we update our allowlist. 
 unknown Untagged tokens that we display a warning on jup.ag. 
 
 Other Tags Available 
 Parameter Description 
 community Tokens that are verified by the Jupiter community. To get a community tag for your project, go to https://catdetlist.jup.ag 
 strict Tokens that were validated previously in the strict-list repo. This repo will be deprecated, please use the community site to get a community tag going forward. 
 lst Sanctum’s list from their repo which we automatically pull: https://github.com/igneous-labs/sanctum-lst-list/blob/master/sanctum-lst-list.toml 
 birdeye-trending Top 100 trending tokens from birdeye: https://birdeye.so/find-gems?chain=solana 
 clone Tokens from Clone protocol, from their repo: https://raw.githubusercontent.com/Clone-Protocol/token-list/main/token_mints.csv 
 pump Tokens that graduated from pump, from their API 
 
 Usage: You can pass in a single tag or multiple:

- Single tag: https://tokens.jup.ag/tokens?tags=verified
- Multiple tags: https://tokens.jup.ag/tokens?tags=lst,community
 
 
 
   
     
       GET token by mint 
       https://tokens.jup.ag/token/So11111111111111111111111111111111111111112 
     
   
 Parameter Description 
 mint_address Pass the mint address of the token you want like this https://tokens.jup.ag/token/So11111111111111111111111111111111111111112 
 
 We only support filtering for 1 token at a time right now. 
 Example response: 
 {"address":"jupSoLaHXQiZZTSfEWMTRRgpnyFm8f6sZdosWBjx93v","name":"Jupiter Staked SOL","symbol":"JupSOL","decimals":9,"logoURI":"https://static.jup.ag/jupSOL/icon.png","tags":["community","strict","lst"],"daily_volume":2228947.6686637774,"freeze_authority":null,"mint_authority":"EMjuABxELpYWYEwjkKmQKBNCwdaFAy4QYAs6W9bDQDNw"},
 
 
 
   
     
       GET tradable tokens only 
       https://tokens.jup.ag/tokens_with_markets 
     
   
 Get all tradable tokens that meet jup.ag’s routing and liquidity threshold. This is a large response, please consider fetching tokens by tags instead 
 
 Usage notes: 
 
 There is a rate limit of 30 requests per minute. Please pass a referrer / origin in your request header 
 Enhanced metadata: We added daily volume, freeze authority and mint authority for your convenience. More fields will be available over time such as coingecko id. 
 If you see a token.jup.ag (without the s, the new one is tokens.jup.ag) in your codebase, that''s our deprecated old API. 
 
 Resources 
 
 Background and History 
 Introducing the Ecosystem Token API and standard', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/10-legal/2-terms-of-use.md', 'Terms of Use 
 
 Jupiter, https://jup.ag, a website-hosted user interface (the  "Interface" ) made available by Block Raccoon S.A. 
 The Interface is a visual representation of Jupiter protocol (the  "Protocol" ) which comprises open source software deployed in a permissionless manner by Block Raccoon S.A. The Interface provides an interface which allows users to view and administer their interactions with the Protocol. 
 These Terms of Use and any terms and conditions incorporated herein by reference (collectively, the  "Terms" ) govern your access to and use of the Interface. You must read the Terms carefully 
 To make these Terms easier to read: 
 Block Raccoon S.A. is referred to as "Jupiter", "we", "us", "our" or "the Company".
"You", "your" and "user(s)" refers to anybody who accesses or uses, in any way, the Interface. If you are accessing or using the Interface on behalf of a company (such as your employer) or other legal entity, you represent and warrant that you have the authority to bind that entity to these Terms and, in that case, "you", "your" or "user(s)" will refer to that entity.
By accessing, browsing, or otherwise using the Interface, or by acknowledging agreement to the Terms on the Interface, you agree that you have read, understood, and accepted all of the Terms and our Privacy Policy (the "Privacy Policy"), which is incorporated by reference into the Terms. 
 IMPORTANT NOTE REGARDING ARBITRATION: WHEN YOU AGREE TO THESE TERMS BY USING OR ACCESSING THE INTERFACE, YOU ARE AGREEING TO RESOLVE ANY DISPUTE BETWEEN YOU AND JUPITER THROUGH BINDING, INDIVIDUAL ARBITRATION RATHER THAN IN COURT. AND YOU AGREE TO A CLASS ACTION WAIVER, BOTH OF WHICH IMPACT YOUR RIGHTS AS TO HOW DISPUTES ARE RESOLVED. 
 If you come up with any further questions, please, dont be shy and feel free to contact us at legal@jup.ag. 
 1. Eligibility​ 
 General. You may not use the Interface if you are otherwise barred from using the Interface under applicable law. 
 Legality. You are solely responsible for adhering to all laws and regulations applicable to you and your use or access to the Interface. Your use of the Interface is prohibited by and otherwise violate or facilitate the violation of any applicable laws or regulations, or contribute to or facilitate any illegal activity. 
 The Interface and each of the Company''s services does not constitute, and may not be used for the purposes of, an offer or solicitation to anyone in any jurisdiction in which such offer or solicitation is not authorised, or to any person to whom it is unlawful to make such an offer or solicitation. 
 By using or accessing the Interface, you represent to us that you are not subject to sanctions or otherwise designated on any list of prohibited or restricted parties or excluded or denied persons, including but not limited to the lists maintained by the United Nations Security Council, the European Union or its Member States, or any other government authority. 
 We make no representations or warranties that the information, products, or services provided through our Interface, are appropriate for access or use in other jurisdictions. You are not permitted to access or use our Interface in any jurisdiction or country if it would be contrary to the law or regulation of that jurisdiction or if it would subject us to the laws of, or any registration requirement with, such jurisdiction. We reserve the right to limit the availability of our Interface to any person, geographic area, or jurisdiction, at any time and at our sole and absolute discretion. 
 Prohibited Localities. Jupiter does not interact with digital wallets located in, established in, or a resident of the United States, the Republic of China, Singapore, Myanmar (Burma), Cote D''Ivoire (Ivory Coast), Cuba, Crimea and Sevastopol, Democratic Republic of Congo, Iran, Iraq, Libya, Mali, Nicaragua, Democratic People’s Republic of Korea (North Korea), Somalia, Sudan, Syria, Yemen, Zimbabwe or any other state, country or region that is subject to sanctions enforced by the United States, the United Kingdom or the European Union. You must not use any software or networking techniques, including use of a Virtual Private Network (VPN) to modify your internet protocol address or otherwise circumvent or attempt to circumvent this prohibition. 
 Non-Circumvention. You agree not to access the Interface using any technology for the purposes of circumventing these Terms. 
 2. Compliance Obligations​ 
 The Interface may not be available or appropriate for use in all jurisdictions. By accessing or using the Interface, you agree that you are solely and entirely responsible for compliance with all laws and regulations that may apply to you. You further agree that we have no obligation to inform you of any potential liabilities or violations of law or regulation that may arise in connection with your access and use of the Interface and that we are not liable in any respect for any failure by you to comply with any applicable laws or regulations. 
 3. Access to the Interface​ 
 We reserve the right to disable access to the Interface at any time in the event of any breach of the Terms, including without limitation, if we, in our sole discretion, believe that you, at any time, fail to satisfy the eligibility requirements set forth in the Terms. Further, we reserve the right to limit or restrict access to the Interface by any person or entity, or within any geographic area or legal jurisdiction, at any time and at our sole discretion. We will not be liable to you for any losses or damages you may suffer as a result of or in connection with the Interface being inaccessible to you at any time or for any reason. 
 The Interface and the Protocol may rely on or utilise a variety of external third party services or software, including without limitation oracles, decentralised cloud storage services, analytics tools, hence the Interface or the Protocol may be adversely affected by any number of risks related to these third party services/software. These may include technical interruptions, network congestion/failure, security vulnerabilities, cyberattacks, or malicious activity. Access to the Interface or the Protocol may become degraded or unavailable during times of significant volatility or volume. This could result in the inability to interact with third-party services for periods of time and may also lead to support response time delays. The Company cannot guarantee that the Interface or the Protocol will be available without interruption and neither does it guarantee that requests to interact with third-party services will be successful. You agree that you shall not hold the Company responsible for any losses which occur due to any of the foregoing. 
 4. Your Use of Interface​ 
 By using or accessing the Interface, you represent and warrant that you understand that there are inherent risks associated with virtual currency, and the underlying technologies including, without limitation, cryptography and blockchain, and you agree that Jupiter is not responsible for any losses or damages associated with these risks. You specifically acknowledge and agree that the Interface facilitates your interaction with decentralized networks and technology and, as such, we have no control over any blockchain or virtual currencies and cannot and do not ensure that any of your interactions will be confirmed on the relevant blockchain and do not have the ability to effectuate any cancellation or modification requests regarding any of your interactions. 
 Without limiting the foregoing, you specifically understand and hereby represent your acknowledgment of the following: 
 The pricing information data provided through the Interface does not represent an offer, a solicitation of an offer, or any advice regarding, or recommendation to enter into, a transaction with the Interface. 
 The Interface does not act as an agent for any of the users. 
 The Interface does not own or control any of the underlying software through which blockchain networks are formed, and therefore is not responsible for them and their operation. 
 You are solely responsible for reporting and paying any taxes applicable to your use of the Interface. 
 Although it is intended to provide accurate and timely information on the Interface, the Interface or relevant tools may not always be entirely accurate, complete, or current and may also include technical inaccuracies or typographical errors. Accordingly, you should verify all information before relying on it, and all decisions based on information contained on the Interface or relevant tools are your sole responsibility. 
 In order to allow other users to have a full and positive experience of using the Interface you agree that you will not use the Interface in a manner that: 
 Breaches the Terms; 
 Infringes on or violates any copyright, trademark, service mark, patent, right of publicity, right of privacy, or other proprietary or intellectual property rights under the law; 
 Seeks to interfere with or compromise the integrity, security, or proper functioning of any computer, server, network, personal device, or other information technology system, including, but not limited to, the deployment of viruses and denial of service attacks; 
 Attempts, in any manner, to obtain the private key, password, account, or other security information from any other user, including such information about the digital wallet; 
 Decompiles, reverse engineer, or otherwise attempt to obtain the source code or underlying ideas or information of or relating to the Interface; 
 Seeks to defraud us or any other person or entity, including, but not limited to, providing any false, inaccurate, or misleading information in order to unlawfully obtain the property of another; 
 Violates any applicable law, rule, or regulation concerning the integrity of trading markets, including, but not limited to, the manipulative tactics commonly known as spoofing and wash trading; 
 Violates any applicable law, rule, or regulation of the United States or another relevant jurisdiction, including, but not limited to, the restrictions and regulatory requirements imposed by U.S. law; 
 Disguises or interferes in any way with the IP address of the computer you are using to access or use the Interface or that otherwise prevents us from correctly identifying the IP address of the computer you are using to access the Interface; 
 Transmits, exchanges, or is otherwise supported by the direct or indirect proceeds of criminal or fraudulent activity; 
 Contributes to or facilitates any of the foregoing activities. 
 As it has been already stated, we only provide you with the relevant interface and software and neither has control over your interactions with the blockchain nor encourages you to perform any. Any interaction performed by you via the Interface remains your sole responsibility. 
 All information provided in connection with your access and use of the Interface is for informational purposes only and should not be construed as professional advice. You should not take, or refrain from taking, any action based on any information contained in the Interface or any other information that we make available at any time, including, without limitation, blog posts, articles, links to third-party content, news feeds, tutorials, tweets, and videos. Before you make any financial, legal, or other decisions involving the Interface, you should seek independent professional advice from an individual who is licensed and qualified in the area for which such advice would be appropriate. 
 The Terms are not intended to, and do not, create or impose any fiduciary duties on us. To the fullest extent permitted by law, you acknowledge and agree that we owe no fiduciary duties or liabilities to you or any other party and that to the extent any such duties or liabilities may exist at law or in equity, those duties and liabilities are hereby irrevocably disclaimed, waived, and eliminated. You further agree that the only duties and obligations that we owe you are those set forth expressly in the Terms. 
 You understand that smart contract protocols such as the Protocol simply comprise a set of autonomous blockchain-based smart contracts deployed on the relevant blockchain network, operated directly by users calling functions on it (which allows them to interact with other users in a multi-party peer-to-peer manner). There is no further control by or interaction with the original entity which had deployed the smart contract, which entity solely functions as a provider of technical tools for users, and is not offering any sort of securities product or regulated service nor does it hold any user assets on custody. Any rewards earned by user interactions arise solely out of their involvement in the protocol by taking on the risk of interacting with other users and the ecosystem. 
 5. Non-custodial nature of Interface and Protocol 
 The Interface and Protocol are non-custodial in nature, therefore neither holds or controls your digital assets. Any digital assets which you may acquire through the usage of the Interface or the Protocol will be held and administered solely by you through your selected electronic wallet, and we shall have no access to or responsibility in regard to such electronic wallet or digital asset held therein. It is solely your responsibility to select the wallet service provider to use, and your use of such electronic wallet will be subject to the governing terms of use or privacy policy of the provider of such wallet. We neither own nor control your selected electronic wallet service, the relevant blockchain network, or any other third party site, product, or service that you might access, visit, or use for the purpose of enabling you to utilise the Interface or the Protocol. We will not be liable for the acts or omissions of any such third parties, nor will we be liable for any damage that you may suffer as a result of your transactions or any other interaction with any such third parties. 
 We will not create any hosted wallet for you or otherwise custody digital assets on your behalf, and it is your sole responsibility to maintain the security of your selected electronic wallet. You hereby irrevocably waive, release and discharge all claims, whether known or unknown to you, against us, our affiliates and their respective shareholders, members, directors, officers, employees, agents and representatives related to your use of any wallet software, associated loss of digital assets, transaction failures, or any other defects that arise in the course of your use of your electronic wallet, including any losses that may obtain as a result of any failure of the Interface or the Protocol. 
 Neither the Company, the Interface nor the Protocol provides any digital asset exchange or portfolio/fund management services. If you choose to engage in transactions with other users via the Interface or the Protocol, then such decisions and transactions and any consequences flowing therefrom are your sole responsibility. In no event shall the Company, its affiliates or their respective directors or employees be responsible or liable to you or anyone else, directly or indirectly, for any damage or loss arising from or relating to any interaction or continued interaction with the Interface or the Protocol or in reliance on any information provided on the Interface (including, without limitation, directly or indirectly resulting from errors in, omissions of or alterations to any such information). 
 "Know Your Customer" and "Anti-Money Laundering" checks: We reserve the right to conduct "Know Your Customer" and "Anti-Money Laundering" checks on you if deemed necessary by us (at our sole discretion) or such checks become required under applicable laws in any jurisdiction. Upon our request, you shall immediately provide us with information and documents that we, in our sole discretion, deem necessary or appropriate to conduct "Know Your Customer" and "Anti-Money Laundering" checks. Such documents may include, but are not limited to, passports, driver''s licenses, utility bills, photographs of associated individuals, government identification cards or sworn statements before notaries or other equivalent professionals. Notwithstanding anything herein, we may, in its sole discretion, refuse to provide access to the Interface to you until such requested information is provided, or in the event that, based on information available to us, you are suspected of using the Interface or the Protocol in connection with any money laundering, terrorism financing, or any other illegal activity. In addition, we shall be entitled to use any possible efforts for preventing money laundering, terrorism financing or any other illegal activity, including without limitation monitoring of transactions which you perform, screening of your digital wallet addresses, performing analytics on the foregoing as well as any related transactions or digital wallet address, blocking of your access to the Interface or the Protocol, or providing your information to any regulatory authority. 
 6. Disclaimers​ 
 You understand and agree that the Interface enables access to an online, decentralized, and autonomous protocol and environment, and associated decentralized networks, that are not controlled by Jupiter. We do not have access to your private key and cannot initiate an interaction with your virtual currency or otherwise access your virtual currency. We are not responsible for any activities that you engage in when using your wallet, or the Interface. 
 Jupiter cannot and does not represent or guarantee that any of the information available through the Interface is accurate, reliable, current, complete or appropriate for your needs. The information displayed through the Interface including information about prices is provided by third parties and/or calculated for informational purposes. Your use of any third-party scripts, indicators, ideas, and other content is at your sole risk. 
 You expressly understand and agree that your use of the Interface is at your sole risk. We make and expressly disclaim all representations and warranties, express, implied or statutory, and with respect to the Interface and the code proprietary or open-source, we specifically do not represent and warrant and expressly disclaim any representation or warranty, express, implied or statutory, including without limitation, any representations or warranties of title, non-infringement, merchantability, usage, security, suitability or fitness for any particular purpose, or as to the workmanship or technical coding thereof, or the absence of any defects therein, whether latent or patent. We do not represent or warrant that the Interface, code, and any related information are accurate, complete, reliable, current, or error-free. The Interface is provided on an "as is" and "as available" basis, without warranties of any kind, either express or implied, including, without limitation, implied warranties of merchantability, fitness for a particular purpose, or non-infringement. 
 You acknowledge that no advice, information, or statement that we make should be treated as creating any warranty concerning the Interface. We do not endorse, guarantee, or assume responsibility for any advertisements, offers, or statements made by third parties concerning the Interface. You acknowledge that Jupiter is not responsible for transferring, safeguarding, or maintaining your private keys or any virtual currency associated therewith. If you lose, mishandle, or have stolen associated virtual currency private keys, you acknowledge that you may not be able to recover associated virtual currency and that Jupiter is not responsible for such loss. You acknowledge that Jupiter is not responsible for any loss, damage, or liability arising from your failure to comply with the terms hereunder. 
 By accessing and using the Interface, you represent that you understand (a) the Interface facilitates access to the Protocol, the use of which has many inherent risks, and (b) the cryptographic and blockchain-based systems have inherent risks to which you are exposed when using the Interface. You further represent that you have a working knowledge of the usage and intricacies of blockchain-based digital assets, including, without limitation, SPL token standard available on the Solana blockchain. You further understand that the markets for these blockchain-based digital assets are highly volatile due to factors that include, but are not limited to, adoption, speculation, technology, security, and regulation. You acknowledge that the cost and speed of transacting with blockchain-based systems, such as Solana, are variable and may increase or decrease, respectively, drastically at any time. You hereby acknowledge and agree that we are not responsible for any of these variables or risks associated with the Protocol and cannot be held liable for any resulting losses that you experience while accessing or using the Interface. Accordingly, you understand and agree to assume full responsibility for all of the risks of accessing and using the Interface to interact with the Protocol. 
 The Interface may contain references or links to third-party resources, including, but not limited to, information, materials, products, or services, that we do not own or control. In addition, third parties may offer promotions related to your access and use of the Interface. We do not endorse or assume any responsibility for any such resources or promotions. If you access any such resources or participate in any such promotions, you do so at your own risk, and you understand that the Terms do not apply to your dealings or relationships with any third parties. You expressly relieve us of any and all liability arising from your use of any such resources or participation in any such promotions. 
 7. Intellectual Proprietary Rights​ 
 We own all intellectual property and other rights in the Interface and its contents, including, but not limited to, software, text, images, trademarks, service marks, copyrights, patents, and designs. Unless expressly authorized by us, you may not copy, modify, adapt, rent, license, sell, publish, distribute, or otherwise permit any third party to access or use the Interface or any of its contents. Accessing or using the Interface does not constitute a grant to you of any proprietary intellectual property or other rights in the Interface or its contents. 
 You will retain ownership of all intellectual property and other rights in any information and materials you submit through the Interface. However, by uploading such information or materials, you grant us a worldwide, royalty-free, irrevocable license to use, copy, distribute, publish and send this data in any manner in accordance with applicable laws and regulations. 
 You may choose to submit comments, bug reports, ideas, or other feedback about the Interface, including, without limitation, about how to improve the Interface (collectively, "Feedback"). By submitting any Feedback, you agree that we are free to use such Feedback at our discretion and without additional compensation to you, and to disclose such Feedback to third parties (whether on a non-confidential basis or otherwise). If necessary under applicable law, then you hereby grant us a perpetual, irrevocable, non-exclusive, transferable, worldwide license under all rights necessary for us to incorporate and use your Feedback for any purpose. 
 If (i) you satisfy all of the eligibility requirements set forth in the Terms, and (ii) your access to and use of the Interface complies with the Terms, you hereby are granted a single, personal, limited license to access and use the Interface. This license is non-exclusive, non-transferable, and freely revocable by us at any time without notice or cause in our sole discretion. Use of the Interface for any purpose not expressly permitted by the Terms is strictly prohibited. 
 In the event that you utilise any intellectual property in any manner which infringes on the rights of any party (including by unauthorised incorporation of the same in any project, protocol, code or any digital token), the Company reserves the sole discretion to effectuate the takedown of any such project, protocol, code or any digital token (or underlying intellectual property) at any time, without notice, compensation or payment to you. In addition, and without prejudice to the Company''s other remedies under this Agreement, you shall indemnify the Company and its officers, directors, employees, contractors, agents, affiliates, and subsidiaries from and against all claims, damages, obligations, losses, liabilities, costs, and expenses arising from your aforesaid infringement of intellectual rights. 
 8. Indemnification​ 
 You agree to hold harmless, release, defend, and indemnify us and our officers, directors, employees, contractors, agents, affiliates, and subsidiaries from and against all claims, damages, obligations, losses, liabilities, costs, and expenses arising from (a) your access to and use of the Interface; (b) your violation of these Terms, the right of any third party, or any other applicable law, rule, or regulation; and (c) any other party’s access and use of the Interface with your assistance or using any device or account that you own or control. 
 9. Limitation of Liability​ 
 Under no circumstances shall we or any of our officers, directors, employees, contractors, agents, affiliates, or subsidiaries be liable to you for any indirect, punitive, incidental, special, consequential, or exemplary damages, including (but not limited to) damages for loss of profits, goodwill, use, data, or other intangible property, arising out of or relating to any access to or use of the Interface, nor will we be responsible for any damage, loss, or injury resulting from hacking, tampering, or other unauthorized access to or use of the Interface, or from any access to or use of any information obtained by any unauthorized access to or use of the Interface. We assume no liability or responsibility for any: (a) errors, mistakes, or inaccuracies of content; (b) personal injury or property damage, of any nature whatsoever, resulting from any access to or use of the Interface; (c) unauthorized access to or use of any secure server or database in our control or the use of any information or data stored therein; (d) interruption or cessation of function related to the Interface; (e) bugs, viruses, trojan horses, or the like that may be transmitted to or through the Interface; (f) errors or omissions in, or loss or damage incurred as a result of, the use of any content made available through the Interface; and (g) the defamatory, offensive, or illegal conduct of any third party. Under no circumstances shall we or any of our officers, directors, employees, contractors, agents, affiliates, or subsidiaries be liable to you for any claims, proceedings, liabilities, obligations, damages, losses, or costs in an amount exceeding the greater of (i) the amount you paid to us in exchange for access to and use of the Interface, or (ii) $100.00. This limitation of liability applies regardless of whether the alleged liability is based on contract, tort, negligence, strict liability, or any other basis, and even if we have been advised of the possibility of such liability. Some jurisdictions do not allow the exclusion of certain warranties or the limitation or exclusion of certain liabilities and damages. Accordingly, some of the disclaimers and limitations set forth in the Terms may not apply to you. This limitation of liability shall apply to the fullest extent permitted by law. 
 10. Arbitration and Class Action Waiver​ 
 Binding Arbitration. Except for disputes in which either party seeks to bring an individual action in small claims court or seeks injunctive or other equitable relief for the alleged unlawful use of copyrights, trademarks, trade names, logos, trade secrets or patents, you and the Jupiter: (a) waive the right to have any and all disputes or claims arising from these Terms, your use or access to the Interface or any other disputes with the Jupiter (collectively, "Disputes") resolved in a court; and (b) waive any right to a jury trial. Instead, you and the Jupiter agree to arbitrate Disputes that are not resolved informally (as described below) through binding arbitration (i.e. the referral of a Dispute to one or more persons charged with reviewing the Dispute and making a final and binding determination to resolve it) instead of having the Dispute decided by a judge or jury in court. 
 No Class Arbitrations, Class Actions or Representative Actions. You and Jupiter agree that any dispute is personal to you and Jupiter and that any such dispute will be resolved solely through individual arbitration and will not be brought as a class arbitration, class action, or any other type of representative proceeding. Neither party agrees to class arbitration or to an arbitration in which an individual attempts to resolve a dispute as a representative of another individual or group of individuals. Further, you and the Jupiter agree that a dispute cannot be brought as a class, or other types of representative action, whether within or outside of arbitration, or on behalf of any other individual or group of individuals. 
 Process. You and the Jupiter agree that each will notify the other, in writing, of any Dispute within thirty (30) days of when it arises so that the parties can attempt, in good faith, to resolve the Dispute informally. Notice to Jupiter shall be provided by sending an email to legal@jup.ag. Your notice must include (1) your name, postal address, and email address; (2) a description of the nature or basis of the Dispute; and (3) the specific action that you are seeking. If you and the Jupiter cannot resolve the Dispute within thirty (30) days of the Jupiter receiving the notice, either you or Jupiter may, as appropriate pursuant to this Section 10, commence an arbitration proceeding. You and Jupiter agree that any arbitration or claim must be commenced or filed within one (1) year after the Dispute arose; otherwise, you and the Jupiter agree that the claim is permanently barred (which means that you will no longer have the right to assert a claim regarding the Dispute). 
 Choice of Law. These Terms are governed by and will be construed under the laws of Panama, without regard to principles of conflict of laws, govern the Terms and any Dispute between you and us. Any Dispute under these Terms shall be finally settled by Binding Arbitration (as defined below). Any unresolved Dispute arising out of or in connection with these Terms shall be referred to and finally resolved by arbitration under the rules of the London Court of International Arbitration (LCIA), which rules are deemed to be incorporated by reference into this Section 10 to the extent they are consistent with it. Any dispute arising from or relating to the subject matter of these Terms shall be finally settled in London, United Kingdom, in English, in accordance with the LCIA Arbitration Rules. Unless we agree otherwise, the arbitrator may not consolidate your claims with those of any other party. Any judgment on the award rendered by the arbitrator may be entered in any court of competent jurisdiction, to the extent a court therein would be deemed to be a court of competent jurisdiction other than any court located in the United States of America. You further agree that the Interface shall be deemed to be based solely in Panama and that, although the Interface may be available in other jurisdictions, its availability does not give rise to general or specific personal jurisdiction in any forum outside Panama. 
 Authority of Arbitrator. As limited by these Terms and applicable arbitration rules, the arbitrator will have: (a) the exclusive authority and jurisdiction to make all procedural and substantive decisions regarding a Dispute; and (b) the authority to grant any remedy that would otherwise be available in court. The arbitrator may only conduct an individual arbitration and may not consolidate more than one individual s claims, preside over any type of class or representative proceeding or preside over any proceeding involving more than one individual. 
 11. Miscellaneous​ 
 Changes. We may amend any portion of these Terms at any time by posting the revised version of these Terms with an updated revision date. The changes will become effective and shall be deemed accepted by you, the first time you use or access the Interface after the initial posting of the revised Terms and shall apply on a going-forward basis with respect to your use of the Interface including any transactions initiated after the posting date. In the event that you do not agree with any such modification, your sole and exclusive remedy are to terminate your use of the Interface. 
 Entire Agreement. These Terms (and any additional terms, rules, and conditions of participation that may be posted on the website of Jupiter) including the Privacy Policy constitute the entire agreement with respect to the Interface and supersedes any prior agreements, oral or written. 
 Privacy Policy. The Privacy Policy describes the ways we collect, use, store and disclose your personal information. You agree to the collection, use, storage, and disclosure of your data in accordance with the Privacy Policy. 
 Severability. If any provision of these Terms shall be determined to be invalid or unenforceable under any rule, law, or regulation of any local, state, or federal government agency, such provision will be changed and interpreted to accomplish the objectives of the provision to the greatest extent possible under any applicable law and the validity or enforceability of any other provision of these Terms shall not be affected. If such construction is not possible, the invalid or unenforceable portion will be severed from these Terms but the rest of these Terms will remain in full force and effect. 
 Survival. Upon termination of these Terms for any reason, all rights and obligations of the parties that by their nature are continuing will survive such termination. 
 English language. Notwithstanding any other provision of these Terms, any translation of these Terms is provided for your convenience. The meanings of terms, conditions, and representations herein are subject to their definitions and interpretations in the English language. In the event of conflict or ambiguity between the English language version and translated versions of these terms, the English language version shall prevail. You acknowledge that you have read and understood the English language version of these Terms. 
 If you have any questions, claims, complaints, or suggestions, please, contact us at legal@jup.ag.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/10-legal/3-privacy-policy.md', 'Privacy Policy 
 
 Jupiter , accessible at: https://jup.ag, one of its main priorities is the privacy of participants who are visitors of https://jup.ag and its dApps  (the “Interface”) . Jupiter does it best to collect as minimum Personal Data as possible. This Privacy Policy document contains types of data that are collected, used, and recorded by Jupiter. 
 The Jupiter Interface backed by Block Raccoon S.A., a company incorporated in Panama, which is the controller for your Personal Data within the scope of this Privacy Policy. Jupiter decides “why” and “how” your Personal Data is processed in connection with the Interface. If you have additional questions or require more information about this Privacy Policy, do not hesitate to contact  privacy@jup.ag . 
 This Privacy Policy applies only to the Interface activities and is valid for participants who are visitors to the Interface with regards to the Personal Data that they share and/or which is collected within Jupiter Interface. This Privacy Policy is not applicable to any Personal Data collected offline or via channels other than the Interface. Please read this Privacy Policy carefully to understand our policies and practices regarding your data and how it will be treated by the Interface. 
 IF YOU DO NOT HAVE THE RIGHT, POWER AND AUTHORITY TO ACT ON BEHALF OF AND BIND THE BUSINESS, ORGANIZATION, OR OTHER ENTITY YOU REPRESENT, PLEASE DO NOT ACCESS OR OTHERWISE USE THE INTERFACE. IF YOU ARE INTERESTED IN HOW WE USE COOKIES AND YOU CAN CHANGE YOUR COOKIE CHOICE, PLEASE SEE SECTION 5 “COOKIES AND AUTOMATICALLY-COLLECTED DATA” 
 1. Changes to this Agreement​ 
 If our data processing practices change, we will update this Privacy Policy accordingly to let you know of them upfront and give you a possibility to either provide your consent, object to a particular processing, or undertake other action you are entitled to under the Regulation. Please keep track of any changes we may introduce to this Privacy Policy. Your continued access to and use of the Interface constitutes your awareness of all amendments made to this Privacy Policy as of the date of your accessing and use of the Interface. Therefore, we encourage you to review this Privacy Policy regularly as you shall be bound by it. If, for some reason, you are not satisfied with our personal data processing practices, your immediate recourse is to stop using the Interface. You do not have to inform us of this decision unless you intend to exercise some of the data protection rights stipulated by GDPR and defined below in this Privacy Policy. 
 2. Eligibility​ 
 Age. By accessing our using the Interface, you represent and warrant that you are at least eighteen (18) years of age. If you are under the age of eighteen (18), you may not, under any circumstances or for any reason, use the Interface. Please report to us any instances involving the use of the Interface by individuals under the age of 18, should they come to your knowledge. 
 3. Applicability​ 
 This Privacy Policy applies to all your interactions with us via the Interface and your interactions with us in connection therewith. 
 Below are the categories of our processors used on the Interface due to an internal data processing roadmap providing a brief grasp of our data processing activities with regard to each piece of the Personal Data we may collect through the Interface, as well as your place in every data processing event. It can be requested at  privacy@jup.ag . Below are the categories of our processors which can access and process your Personal Data through the Interface: 
 
 Technical maintenance vendors; 
 Project and team management vendors; 
 Communication vendors; 
 Analytics, statistics, performance, marketing vendors. 
 
 4. Data processing in connection with the Interface​ 
 Types of Data Collected 
 To the maximum extent possible, Jupiter tries to collect as minimum Personal Data from you as possible. Personal Data we collect: 
 
 IP address, MAC address, log files, domain server, data related to usage, performance, website security, traffic patterns, location information, browser and device information – only when you are using the Interface; 
 Wallet addresses (public blockchain addresses), transaction, and balance information (blockchain data) that is accessible when interacting with the Interface; We use public Blockchain addresses to identify a user’s journey through our product. We group and analyze these user journeys collectively in order to improve our product user experience. We do not use this data for any purpose at an individual user level. The legal basis for this processing is our legitimate interests, such as monitoring and improving the Interface, the proper protection of the Interface against risks, and partly the contract performance basis to provide you the Interface. Note that we are not responsible for your use of any of the blockchain and your data processed in these decentralized and permissionless networks; 
 Log Files. Jupiter follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and this kind of Personal Data may also be collected as a part of hosting services'' analytics. The data collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These kinds of data may be linked to data that is personally identifiable. The purpose of the data collection and processing is for analyzing trends, administering the website, tracking users'' movement on the website, and gathering demographic information; 
 
 Jupiter may also engage third-parties advertising platforms that are triggered only when their technical features (so-called “pixels”) are enabled through the Interface. The mentioned third-parties advertising platforms may collect Personal Data of Interface''s visitors only with the purpose to optimize their advertising possibilities through their platforms, target you with their advertisements, and possibly share your data with other advertising platforms and agencies for further use. Jupiter may engage with the mentioned Personal Data of Interfaces visitors. 
 In no event, are we going to ask you to share your private keys or wallet seed. Never trust anyone or any website that asks you to enter your private keys or wallet seed. 
 How and Why we use your Personal Data 
 We may use your Personal Data listed above only for: 
 
 Our internal and operational purposes, when: ensuring security, identifying irregular website behavior, preventing fraudulent activity, and improving security at all possible levels; 
 Assessing and improving the performance of the Interface; 
 Analyzing our website visitors’ actions to improve our Interface (section “Cookies and Automatically Collected Data”); 
 Analyzing the Interface behavior, including via: Google Analytics (please refer to Google''s Analytics Policy for more information); 
 Find and prevent fraud. 
 
 To clear any doubts, we may use Personal Data described above or any other Personal Data: 
 
 on the basis of contract performance or necessity to enter into a contract (where the Personal Data is required for us to perform our undertakings and obligations in accordance with a contract we are entering into when you use our services, or where we are at the negotiations phase); 
 on the basis of our or our processors’ legitimate interests to protect the Interface, prevent any malicious and harmful activities to the Interface, maintain our technical systems healthily and secure, improve services and products by using aggregate statistics; 
 to respond to legal requests of authorities, provide information upon court orders and judgments, or if we have a good-faith belief that such disclosure is necessary in order to comply with official investigations or legal proceedings initiated by governmental and/or law enforcement officials, or private parties, including but not limited to: in response to subpoenas, search warrants or court orders, and including other similar statutory obligations we or our processors are subjected to; 
 on the basis of your consent; and 
 on other legal bases set forth in the personal data protection laws. 
 
 Disclosure of Data 
 In continuation of legal bases for collecting and processing the Personal Data, We may disclose any Personal Data about you: 
 
 in connection with a merger, division, restructuring, or other association change; or 
 to our subsidiaries or affiliates (if any) only if necessary for operational purposes. If we must disclose any of your Personal Data in order to comply with official investigations or legal proceedings initiated by governmental and/or law enforcement officials, we may not be able to ensure that such recipients of your Personal Data will maintain the privacy or security of your Personal Data. 
 
 Data Retention Period 
 Jupiter maintains Personal Data exclusively within the time needed to follow prescribed herein legal purposes. When we no longer need Personal Data, the limitation period for storage of such Personal Data has expired, you have withdrawn your consent or objected to our or our processors’ legitimate interests, we securely delete or destroy it unless the statutory requirements we, our processors or other controllers are subjected to stipulate otherwise. Aggregated data, which cannot directly identify a device/browser (or individual) and is used for purposes of reporting and analysis, is maintained for as long as commercially necessary till you object to the processing of such data or withdraw your consent. 
 Sometimes legal requirements oblige us to retain certain data, for specific purposes, for an extended period of time. Reasons we might retain some data for longer periods of time include: 
 
 Security, fraud & abuse prevention; 
 Financial monitoring and record-keeping; 
 Complying with legal or regulatory requirements; 
 Ensuring the continuity of your interaction with the Interface. 
 
 Your Inquiries 
 You may contact us by email at the following email address:  privacy@jup.ag ; We use the data that you provide in an email to us, which you may give voluntarily, only in order to answer your question or to reply to your email in the best possible manner. 
 5. Cookies and Automatically Collected Data​ 
 As you navigate through and interact with our Interface, we may ask your consent to use cookies, which are small files placed on the hard drive/browser of your computer or mobile device, and web beacons, which are small electronic files located on pages of the Interface, to collect certain information about devices you use, browsing actions, and patterns. 
 The data automatically collected from cookies and web beacons may include information about your web browser (such as browser type and browser language) and details of your visits to the Interface, including traffic data, location data and logs, page views, length of visit, and website navigation paths as well as information about your device and internet connection, including your IP address and how you interact with the Interface. We collect this data in order to help us improve the Interface and interaction with it. 
 The information we collect automatically may also include statistical and performance information arising from your use of the Interface. This type of data will only be used by us in an aggregated and pseudonymized manner. 
 You can choose to disable cookies through your individual browser options. To get more detailed information about cookie management with specific web browsers, please find it on the browsers'' respective websites: 
 
 For Google Chrome browser please refer to these instructions: https://support.google.com/accounts/answer/32050?co=GENIE.Platform%3DDesktop&hl=en; 
 For Firefox browser please look up here: https://support.mozilla.org/en-US/kb/clear-cookies-and-site-data-firefox 
 For Safari browser please visit: https://support.apple.com/ru-ru/guide/safari/sfri11471/mac 
 For Internet Explorer browser please refer to: https://support.microsoft.com/en-us/windows/delete-and-manage-cookies-168dab11-0753-043d-7c16-ede5947fc64d 
 
 6. Your rights under GDPR​ 
 Under certain circumstances, you may have a number of privacy rights concerning the use, storage, and processing of your Personal Data (e.g., the right to delete your data). Here is a list of privacy rights: 
 
 right to be informed - we are publishing this Privacy Policy to keep you informed as to what we do with your Personal Data. You can ask us for Personal Data regarding you that we keep at any time. This information concerns, among other things, the data categories we process, for what purposes we process them, the origin of the data if we did not acquire them directly from you and, if applicable, the recipients to who we have sent your data. 
 right of access – You may ask us whether we process your Personal Data and you have the right to request a copy of the data we hold about you. 
 right of rectification – You have the right to correct inaccurate or incomplete data about you. 
 right to be forgotten – You can ask for the Personal Data that we hold about you to be erased from our system and we will comply with this request unless we have a legitimate reason, legal requirement, and other statutory basis not to do so. Even if we can delete (erase) the Personal Data subject to our active (ongoing) processing activities and cease its processing, we will nevertheless retain this particular Personal Data in our backup and archive storages to fulfill our statutory and other requirements. 
 right to restriction of processing – where certain conditions apply, you can ask us to ‘block’ the processing of your Personal Data. 
 right to data portability – You have the right to have the data we hold about you transferred to another organization and to receive Personal Data in a structured, commonly used format. Please apply to:  privacy@jup.ag  to find out whether we currently support the provision of the portable file containing Personal Data we process about you. 
 right to object - You can object to the processing of your data by applying to:  privacy@jup.ag  at any time for reasons that arise from your special situation provided the data processing is based on our legitimate interest or that of a third party, or where we carry out profiling, use machine learning or automated decision-making algorithms. In this case, we will no longer process your Personal Data. The latter does not apply if we are able to prove there are compelling, defensible reasons for the processing that outweigh your interests or we require your data to assert, exercise, or defend legal claims. 
 right to withdraw consent - withdraw the consent you gave us with regard to the processing of your Personal Data for certain purposes. 
 right to complain - we take your rights very seriously. However, if you are of the opinion that we have not dealt with your complaints adequately, you have the right to submit a complaint to the data privacy protection authorities responsible. You can send your complaints to the EEA supervisory authority of your country of residence. 
 
 Please email:  privacy@jup.ag  with any questions about exercising any of the above rights. If You wish to learn more about the GDPR and Your rights, the Information Commissioner’s Office website is a reliable source. 
 7. Privacy of children​ 
 Our Interface is not directed to collect any data from people under the age of 18. We do not knowingly allow anyone under 18 years old to submit any data to our Interface. If you believe your child may have provided us with their data, you can contact us using the information in this Policy and we will delete the data from our Interface. 
 8. Transfer of Personal Data​ 
 Transfers to third countries shall be made subject to appropriate safeguards, namely Standard Contractual Clauses adopted by the supervisory authority and approved by the Commission. Copy of the foregoing appropriate safeguards may be obtained by you upon a prior written request sent. We may instruct you on further steps to be taken with the purpose of obtaining such a copy, including your obligation to assume confidentiality commitments in connection with being disclosed the Jupiter proprietary and personal information of third parties as well as terms of their relationships with Jupiter. 
 Keep in mind that the use of the Interface based on public blockchains is intended to immutably record transactions across wide networks of computer systems. Many blockchains are open to forensic analysis which can lead to deanonymization and the unintentional revelation of Personal Data, in particular when blockchain data is combined with other data. Because blockchains are decentralized or third-party networks that are not controlled or operated by us, we are not able to erase, modify, or alter Personal Data from such networks. 
 9. Data Integrity & Security of Processing​ 
 We take data security very seriously. We work hard to protect the Personal Data you provide us from loss, misuse, or unauthorized access. We utilize a variety of safeguards such as encryption, digital and physical access controls, non-disclosure agreements, and other technical and organizational measures to protect the Personal Data submitted to us, both during transmission and once it is at rest. 
 Please note that no electronic transmission, storage, or processing of Personal Data can be entirely secure. We cannot guarantee that the security measures we have in place to safeguard Personal Data will never be defeated or fail, or that those measures will always be sufficient or effective. Therefore, although we are committed to protecting your privacy, we do not promise, and you should not expect that your Personal Data will always remain private or secure. 
 10. Supervisory authority oversight​ 
 If you are a data subject whose data we process, you may also have the right to lodge a complaint with a data protection regulator in one or more of the European Union member states. Here you can find a list of data protection authorities in Europe: ​​https://edpb.europa.eu/about-edpb/about-edpb/members_en', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/10-legal/1-sdk-api-license-agreement.md', 'Jupiter API & SDK License Agreement 
 IMPORTANT:  This Jupiter API & SDK License Agreement ("Agreement") is a legally binding contract between you, as Licensee ("You", "Your" or "Licensee") and Block Raccoon S.A., an entity incorporated in Panama ("Jupiter," "we" or "our") and applies to your use of the Jupiter API or SDK, as defined herein, available through https://portal.jup.ag (collectively the "Service"). The Service includes an Application Programming Interface ("API") and a Software Development Kit (“SDK”), which is further discussed and defined below. If you do not agree to be bound by the terms and conditions of this Agreement, please do not proceed with the use of Service, the API, or the SDK. 
 This Agreement becomes effective as of the date you first access, download, copy or otherwise use the API or SDK ("Effective Date"). This Agreement shall continue until terminated either by us or by you. Even after termination of this Agreement, certain provisions will survive, as discussed herein. This Agreement also incorporates Jupiter`s Terms of Service link and Privacy Policy link which terms shall also govern your use of the Service. In the event of any conflict between this Agreement and the Terms of Service or Privacy Policy, the provisions of this Agreement shall prevail. 
 YOU ARE ENTERING A LEGALLY BINDING CONTRACT: BY COPYING, DOWNLOADING, OR OTHERWISE USING THE JUPITER API OR SDK YOU ARE EXPRESSLY AGREEING TO BE BOUND BY ALL TERMS OF THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF THIS AGREEMENT, YOU ARE NOT AUTHORIZED TO COPY, DOWNLOAD, INSTALL OR OTHERWISE USE THE JUPITER API or SDK. 
 The API and SDK are protected by copyright laws and international copyright treaties, as well as other intellectual property laws and treaties. The API and SDK is licensed to you, and its use is subject to the terms of this Agreement. 
 1. Definitions​ 
 1.1  "Application Programming Interfaces"  or  "API"  or  “Jupiter API”  means the back-end smart routing algorithm which facilitates the user’s efficient swapping of digital assets at a variety of third party trading venues, which may include object code, software libraries, software tools, sample source code, published specifications and Documentation. Jupiter API shall include any future, updated or otherwise modified version(s) thereof furnished by Jupiter (in its sole discretion) to Licensee. 
 1.2  "Software Development Kit"  or  “SDK”  or  “Jupiter SDK”  means the ancillary tools and resources that allow the user to utilise or integrate the API. Jupiter SDK shall include any future, updated or otherwise modified version(s) thereof furnished by Jupiter (in its sole discretion) to Licensee. 
 1.3  "Documentation"  includes, but is not limited to programmer guides, manuals, materials, and information appropriate or necessary for use in connection with the API. 
 2. Grant of License​ 
 2.1 Subject to the terms of this Agreement, Jupiter hereby grants Licensee a limited, non-exclusive, fee-bearing, non-transferable, non-sublicensable licence to use the API or SDK during the term of this Agreement solely for the purpose of Licensee''s internal development efforts to develop products or services integrating the API and/or SDK in any manner (the  Licensee’s Product ). 
 2.2 Licensee shall have no right to distribute, license (whether or not through multiple tiers) or otherwise transfer the API or SDK to any third party. 
 2.3 In case of potential other API or SDK use that is not prescribed by this Agreement, please write to info@jup.ag to seek written consent. 
 2.4 Representations. Both Parties to this Agreement are duly organized and validly existing in good standing with all requisite power and authority to enter into this Agreement and conduct its business as is now being conducted. Neither Party is identified on, or engages in any transactions with anyone else listed on, any sanctions list maintained by the U.S. Department of the Treasury’s Office of Foreign Asset Control (“OFAC”) and have shared with each other a copy of their Articles of Incorporation and Significant Shareholder list. 
 2.5 By providing access to the API and the SDK, Jupiter is solely providing a back-end technical service to the Licensee which allows the Licensee to provide swap-related services to end users of the Licensee’s products or services. Jupiter is not a party to any agreement for swap-related services between the Licensee, its end users, any counterparty or trading venue where swaps are performed, nor any trustee, custodian, bailee, manager, administrator or service provider in respect of any digital asset or otherwise. 
 2.6 Independent Contractor Relationship. The relationship between the Parties is that of independent contractors. Nothing in this Agreement shall be construed to create anything like the relationship of an employer and employee, joint venture, partnership, or joint association. 
 3. Other Rights and Limitations​ 
 3.1 Copies. Licensee may copy the API or SDK only as necessary for the purpose of the licence hereunder. 
 3.2 Except as expressly authorised under this Agreement or by Jupiter in writing, the Licensee agrees it shall not (and shall not permit or authorise any other person to): 
 a. use the API or SDK in any manner that is not expressly authorised by this Agreement; 
 b. use the API or SDK or develop or use the Licensee''s Product (i) for any illegal, unauthorised or otherwise improper purposes or (ii) in any manner which would violate this Agreement or the Documentation, breach any laws, regulations, rules or orders (including those relating to virtual assets, intellectual property, data privacy, data transfer, international communications or the export of technical or personal data) or violate the rights of third parties (including rights of privacy or publicity); 
 c. remove any legal, copyright, trademark or other proprietary rights notices contained in or on materials it receives or is given access to pursuant to this Agreement, including the API, the SDK and the Documentation; 
 d. sell, lease, share, transfer or sublicense the API, SDK or any content obtained through the API, directly or indirectly, to any third party; 
 e. use the API or SDK in a manner that, as determined by Jupiter in its sole discretion, exceeds reasonable request volume, constitutes excessive or abusive usage, or otherwise fails to comply or is inconsistent with any part of the Documentation; 
 f. access the API or SDK for competitive analysis or disseminate performance information (including uptime, response time and/or benchmarks) relating to the API; 
 g. use the API in conjunction with, or combine content from the API with, content obtained through scraping or any other means outside the API; 
 h. (i) interfere with, disrupt, degrade, impair, overburden or compromise the integrity of the API, Jupiter''s systems or any networks connected to the API or Jupiter''s systems (including by probing, scanning or testing their vulnerability), (ii) disobey any requirements, procedures, policies or regulations of networks connected to the API or Jupiter''s systems, (iii) attempt to gain unauthorised access to the API, Jupiter''s systems or any information not permitted by this Agreement or circumvent any access or usage limits imposed by Jupiter or (iv) transmit through the Licensee''s Product or the use of the API or SDK any (A) content that is illegal, tortious, defamatory, vulgar, obscene, racist, ethnically insensitive, or invasive of another person''s privacy, (B) content that promotes illegal or harmful activity, or gambling or adult content, (C) viruses, worms, defects, Trojan horses, or any other malicious programs or code or items of a destructive nature or (D) materials that could harm minors in any way; 
 i. copy, adapt, reformat, reverse-engineer, disassemble, decompile, download, translate or otherwise modify or create derivative works of the API, the SDK or the Documentation, Jupiter''s website, or any of Jupiter''s other content, products or services, through automated or other means; 
 j. interfere with Jupiter''s business practices or the way in which it licenses or distributes the API or SDK; 
 k. make any representations, warranties or commitments (i) regarding the API or SDK or (ii) on behalf of Jupiter; or 
 l. take any action that would subject the API or SDK to any third-party terms, including without limitation any open source software licence terms. 
 3.3 Without prejudice of the generality of the foregoing, where the Licensee’s Product is competitive with the API or the Service, Jupiter shall have the right to access the Licensee’s Product, request the Licensee for information regarding the Licensee’s Product, and Jupiter shall be granted a non-exclusive, royalty-free, non-transferable, non-sublicensable licence to use the Licensee’s Product for any purpose. 
 3.4 Third Party Software. Licensee acknowledges that effective utilization of the API and SDK may require the use of a development tool, compiler and other software and technology of third parties (“Third Party Software”). Licensee is solely responsible for procuring such Third-Party Software and technology and the necessary licenses for the use thereof. Jupiter makes no representation or warranty concerning Third Party Software and shall have no obligation or liability with respect to Third Party Software. 
 3.5 No right is granted to Licensee to sublicense its rights hereunder. All rights not expressly granted are reserved by Jupiter and, except as expressly set forth herein, no license is granted by Jupiter under this Agreement directly, by implication, estoppel or otherwise, under any patent, copyright, trade secret or trademark or other intellectual property rights of Jupiter. Nothing herein shall be deemed to authorize Licensee to use Jupiter`s trademarks or trade names in Licensee''s advertising, marketing, promotional, sales or related materials. Jupiter reserves all rights not otherwise expressly granted in this Agreement. 
 3.6 No assertion by Licensee. Licensee agrees not to assert any patent rights related to the API/SDK or applications developed using the API/SDK against Jupiter, Jupiter''s participants, or other licensees of the API/SDK for making, using, selling, offering for sale, or importing any products or technology developed using the API/SDK. 
 3.7 Jupiter may from time to time provide updates or upgrades to the API or SDK. Any such updates and upgrades will be performed according to Jupiter''s then-current operational policies, which may include automatic updating or upgrading of API or SDK currently in use at that time. Where the Licensee fails to accept such updates or upgrades, Jupiter shall be entitled to withhold access to the API, SDK and/or Service, and the same shall not constitute any breach of the terms of this Agreement. 
 4. Intellectual Property and proprietary rights 
 4.1 As between Jupiter and Licensee, Jupiter and/or its licensors shall own and retain all proprietary rights, including all patent, copyright, trade secret, trademark and other intellectual property rights, in and to the API and SDK and any corrections, bug fixes, enhancements, updates, improvements, or modifications thereto and (to the extent such rights accrue to the Licensee), the Licensee hereby irrevocably transfers, conveys and assigns to Jupiter all of its right, title, and interest therein. 
 4.2 Jupiter shall have the exclusive right to apply for or register any patents, mask work rights, copyrights, and such other proprietary protections with respect thereto. 
 4.3 The Licensee acknowledges that the license granted under this Agreement does not provide Licensee with title or ownership to the API or SDK, but only a right of limited use under the terms and conditions of this Agreement. 
 4.4 The Parties acknowledge that Jupiter does not store, send, or receive digital assets. Digital assets exist only by virtue of the ownership record maintained on the relevant blockchain network. Any creation or transfer of title that might occur in respect of any digital asset occurs on the relevant blockchain network (on the relevant contractual terms applicable to such creation and/or transfer) and is performed by the Licensee’s Product, and Jupiter does not have any role or responsibility in such transactions. Jupiter cannot guarantee that the Licensee’s Product, or any party can effect the transfer of such title or right to any digital asset. Accordingly, Jupiter cannot provide any guarantee, warranty or assurance regarding the authenticity, uniqueness, originality, quality, marketability, legality or value of any digital assets utilised in connection with the API and the Services. 
 5. No Obligation to Support​ 
 5.1 Subject to payment of fees as described herein, Jupiter would issue to the Licensee certain unique API keys, tokens, passwords and/or other credentials (collectively,  "Keys" ), for accessing the API and/or SDK and managing the Licensee''s access to the API. The Licensee may only access the API with the Keys issued to the Licensee by Jupiter. The Licensee acknowledges that access to the API may not always be available. The Licensee may not sell, transfer, sublicense or otherwise disclose its Keys to any other party or use them for any other purpose other than that expressly permitted by Jupiter. The Licensee is responsible for maintaining the secrecy and security of the Keys. The Licensee is fully responsible for all activities that occur using the Keys, regardless of whether such activities are undertaken by the Licensee or a third party. The Licensee is responsible for maintaining up-to-date and accurate information (including a current email address and other required contact information) for the Licensee''s access to the API and SFK. Jupiter may discontinue the Licensee''s access to the API and SDK if such contact information is not up-to-date and/or the Licensee does not respond to communications directed to such coordinates. 
 5.2 Jupiter makes no guarantees with respect to the performance, availability or uptime of the API or the SDK. Jupiter may conduct maintenance on or stop providing any of the API or the SDK at any time with or without written notice to the Licensee. In addition, Jupiter may change the method of access to the API, SDK and Documentation at any time. 
 5.3 Jupiter does not guarantee any support for the API or SDK under this Agreement. Nothing herein shall be construed to require Jupiter to provide consultations, support services or updates, upgrades, bug fixes or modifications to the API or SDK. In the event of degradation or instability of Jupiter''s system or an emergency, Jupiter may, in its sole discretion, suspend access to the API and/or SDK. 
 5.4 Jupiter reserves the right to change the method of access to the API or SDK at any time to ensure the safety and security of its environment. In the event of degradation or instability of Jupiter`s systems or in an emergency, you acknowledge and agree that Jupiter may, in its sole and absolute discretion, temporarily suspend your access to the API or SDK in order to minimize threats to and protect the operational stability and security of the Jupiter system. 
 6. Fees & Payment​ 
 6.1 Jupiter shall charge a subscription fee for usage of the Jupiter API and/or SDK. This may be a fixed fee, infrastructure fee and/or a variable fee based on revenue earned by the Licensee in respect of the Licensee’s Product. 
 6.2 The details of the level of fees charged shall be notified to you via the API portal at https://portal.jup.ag. By accessing, downloading, copying or otherwise using the API or SDK, you shall be deemed to have consented to said fees. 
 6.3 The Fees may be reviewed by Jupiter at any time commencing from three (3) months after the Effective Date. Any updated fees shall be notified to you via the API portal and your continued usage of the API or SDK shall be deemed consent to such updated fees. 
 7. Licensee’s Obligations 
 7.1 The Licensee agrees to report to Jupiter any errors or difficulties discovered related to the API or SDK, and the characteristic conditions and symptoms of such errors and difficulties. 
 7.2 The Licensee shall perform such sanity testing, cybersecurity testing or other technical checks in respect of the API or SDK as may be reasonably requested by Licensor from time to time. 
 7.3 The Licensee shall ensure that the offering/provision of the Licensee''s Product complies with all applicable laws and regulations, including without limitation all consumer protection, Know Your Customer (KYC) or Anti-money Laundering (AML) due diligence laws, sanctions, anti-money laundering or terrorist financing laws, securities laws, payment provider laws, or virtual assets regulations. Without prejudice to the generality of the foregoing, the Licensee shall obtain and maintain in force (or as applicable procure the obtaining and maintenance in force of) all necessary licenses, permissions, authorisations, consents and permits which may be necessary or desirable for the offering/provision of the Licensee''s Product. 
 7.4 The Licensee acknowledges and agrees that all reporting, information gathering and other obligations under applicable Know Your Customer (KYC) or Anti-money Laundering (AML) due diligence laws, sanctions, anti-money laundering or terrorist financing laws, securities laws, payment provider laws, or virtual assets regulations with respect to the Licensee''s end-users are the responsibility of the Licensee; and Jupiter shall not be responsible or have any liability for any of the foregoing. The Licensee agrees to provide such information to Jupiter if reasonably requested by Jupiter. 
 7.5 Without prejudice to the foregoing, upon written request from Jupiter, the Licensee shall use all efforts to block any specific digital wallet or address from accessing the Licensee''s Product and/or the API integration. 
 7.6 The Licensee agrees to immediately notify Jupiter if (i) the Licensee becomes aware of any security event, including any cybersecurity breach, attack or economic exploit relating to the Licensee''s Product or (ii) the Licensee''s Product, API, SDK or the Service becomes subject to any legal or regulatory investigation or action. 
 7.7 The Licensee shall be responsible for all customer service for all its products and services (including the Licensee''s Product). 
 8. Confidentiality​ and Publicity 
 8.1 The API and SDK contains valuable proprietary information and trade secrets of Jupiter and its suppliers that remain the property of Jupiter. You shall protect the confidentiality of, and avoid disclosure and unauthorized use of, the API or SDK. 
 8.2 Without prejudice to the generality of the foregoing, you agree not to disparage Jupiter, any of its affiliates, or any of their directors, shareholders, employees, servants, contractors, or agents in any manner, or otherwise make any false, misleading or negative statements to any party about Jupiter or any of its affiliates, the Service (or any output of the Service), or any other product(s) or service(s) of Jupiter or any of its affiliates. 
 8.3 Jupiter may disclose and publicise the existence of the business relationship between Jupiter and you on its website and in promotional and marketing materials without requiring any further consent from you. 
 8.4 You shall ensure that the Licensee’s Product shall prominently display to end users of such product or service the message “Powered by Jupiter”. 
 9. No Warranty​ 
 9.1 The API, SDK, and Documentation are provided "AS-IS" without any warranty whatsoever. To the full extent allowed by law, the foregoing warranties and remedies are exclusive and are in lieu of all other warranties, terms, or conditions, express or implied, either in fact or by operation of law, statutory or otherwise, including warranties, terms, or conditions of merchantability, fitness for a particular purpose, satisfactory quality, correspondence with description, and non-infringement, all of which are expressly disclaimed. 
 9.2 No advice or information, whether oral or written, obtained by you from Jupiter or through or from the API/SDK shall create any warranty not expressly stated in this agreement. Jupiter does not warrant that the API, SDK and Documentation are suitable for Licensee''s use, that the API, SDK or Documentation are without defect or error, that operation will be uninterrupted, or that defects will be corrected. Further, Jupiter makes no warranty regarding the results of the use of the API, SDK, and Documentation. 
 10. Limitation of Liability​ 
 JUPITER WILL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR RELATING TO THE USE OR THE INABILITY TO USE THE API, SDK AND ITS USE OR THE INABILITY TO USE WITH ANY THIRD PARTY SOFTWARE, ITS CONTENT OR FUNCTIONALITY, INCLUDING BUT NOT LIMITED TO DAMAGES FOR LOSS OF BUSINESS PROFITS OR REVENUE; BUSINESS INTERRUPTION OR WORK STOPPAGE; COMPUTER FAILURE OR MALFUNCTION; LOSS OF BUSINESS INFORMATION, DATA OR DATA USE; LOSS OF GOODWILL; DAMAGES CAUSED BY OR RELATED TO ERRORS, OMISSIONS, INTERRUPTIONS, DEFECTS, DELAY IN OPERATION OR TRANSMISSION, COMPUTER VIRUS, FAILURE TO CONNECT, NETWORK CHARGES, AND ALL OTHER DIRECT, INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES EVEN IF JUPITER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THE ABOVE EXCLUSIONS OR LIMITATIONS MAY NOT APPLY TO YOU. NOTWITHSTANDING THE FOREGOING, JUPITER TOTAL LIABILITY TO LICENSEE FOR ALL LOSSES, DAMAGES, CAUSES OF ACTION, INCLUDING BUT NOT LIMITED TO THOSE BASED ON CONTRACT, TORT, OR OTHERWISE, ARISING OUT OF YOUR USE OF THE API/SDK AND/OR INTELLECTUAL PROPERTY ON THIS TECHNOLOGY PLATFORM OR API/SDK, OR ANY OTHER PROVISION OF THIS AGREEMENT, SHALL NOT EXCEED THE AMOUNT OF 100 USD. THE FOREGOING LIMITATIONS, EXCLUSIONS, AND DISCLAIMERS SHALL APPLY TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, EVEN IF ANY REMEDY FAILS ITS ESSENTIAL PURPOSE. 
 11. Indemnity​ 
 You agree to indemnify and hold harmless Jupiter and its contributors, subsidiaries, affiliates, officers, agents, Intellectual Property service providers, co-branders, customers, suppliers or other partners, and employees, from any loss, claim or demand, including reasonable attorneys'' fees, made by any third party due to or arising out of your negligence, error, omissions, or failure to perform relating to your use of the API/SDK, your connection to the API, or your violation of the Agreement. 
 12. Disclaimers 
 12.1 UNLESS SEPARATELY STATED IN A WRITTEN EXPRESS LIMITED WARRANTY, THE API AND SDK PROVIDED BY JUPITER IS PROVIDED “AS IS” AND ON AN “AS AVAILABLE” BASIS, WITHOUT WARRANTIES OF ANY KIND FROM JUPITER, EITHER EXPRESS OR IMPLIED. TO THE FULLEST EXTENT POSSIBLE PURSUANT TO APPLICABLE LAW, JUPITER DISCLAIMS ALL WARRANTIES EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY QUALITY OR WORKMANSHIP LIKE EFFORT, FITNESS FOR A PARTICULAR PURPOSE, RELIABILITY OR AVAILABILITY, ACCURACY, LACK OF VIRUSES, QUIET ENJOYMENT, NON- INFRINGEMENT OF THIRD-PARTY RIGHTS OR OTHER VIOLATIONS OF RIGHTS. SOME JURISDICTIONS DO NOT ALLOW EXCLUSIONS OR LIMITATIONS OF IMPLIED WARRANTIES, SO THE ABOVE EXCLUSIONS OR LIMITATIONS MAY NOT APPLY TO YOU. NO ADVICE OR INFORMATION, WHETHER ORAL OR WRITTEN, OBTAINED BY YOU FROM JUPITER OR ITS AFFILIATES SHALL BE DEEMED TO ALTER THIS DISCLAIMER BY JUPITER OF WARRANTY REGARDING THE API OR SDK OR THE AGREEMENT, OR TO CREATE ANY WARRANTY OF ANY SORT FROM JUPITER. 
 12.2 NEITHER JUPITER NOR THE API PROVIDES ANY DIGITAL ASSET EXCHANGE OR PORTFOLIO/FUND MANAGEMENT SERVICE. WHERE THE LICENSEE OR ANY END USER OF THE LICENSEE''S PRODUCT MAKES THE DECISION TO TRANSACT UTILISING THE API OR THE SERVICE, THEN SUCH DECISIONS AND TRANSACTIONS AND ANY CONSEQUENCES FLOWING THEREFROM ARE SUCH TRANSACTING PARTY''S SOLE RESPONSIBILITY. 
 12.3 THE API FUNCTIONS SOLELY AS A BACK-END SUPPORTING TECHNICAL SERVICE FOR A SMART ROUTING ALGORITHM FOR DIGITAL ASSET SWAPS ONLY; IN NO CIRCUMSTANCES SHALL JUPITER, THE API OR THE SDK BE CONSTRUED AS A DIGITAL ASSET EXCHANGE, BROKER, DEALER, FUND MANAGER, FINANCIAL INSTITUTION, EXCHANGE, CUSTODIAN, ROBO-ADVISOR, INTERMEDIARY, OR CREDITOR. 
 12.4 THE API DOES NOT FACILITATE OR ARRANGE DIGITAL ASSET TRANSACTIONS BETWEEN COUNTERPARTIES, INCLUDING WITH RESPECT TO ANY TRANSACTIONS THAT OCCUR IN CONNECTION WITH ANY DECENTRALISED EXCHANGE, LIQUIDITY POOL OR OTHER CENTRALISED OR DECENTALISED FINANCE PRODUCT / FACILITY, WHICH TRANSACTIONS OCCUR ON SUCH PLATFORM, PROTOCOL AND/OR THE RELEVANT BLOCKCHAIN NETWORK. JUPITER IS NOT A COUNTERPARTY TO ANY DIGITAL ASSET TRANSACTION FACILITATED BY THE API OR THE LICENSEE''S PRODUCT. 
 12.5 There may be various vulnerabilities, failures or abnormal behaviour of software relating to digital assets (e.g., token contract, wallet, smart contract), or relating to the relevant blockchain network, and Jupiter cannot be responsible for any losses in connection with the same, including without limitation any losses in connection with (i) user error, such as forgotten passwords or incorrectly construed smart contracts or other transactions, (ii) server failure or data loss, (iii) corrupted wallet files, or (iv) unauthorised access or activities by third parties, including but not limited to the use of viruses, phishing, brute-forcing or other means of attack against the API or SDK, the relevant blockchain network, or the Licensee''s or any end user''s digital wallet. 
 12.6 Jupiter disclaims any responsibility for any disclosure of information or any other practices of any third-party API provider. Jupiter expressly disclaims any warranty regarding whether your personal information is captured by any third-party API provider or the use to which such personal information may be put by such third-party API provider. 
 13. Term and Termination​ 
 13.1 The effective date of this Agreement is the start of use of the API or SDK by the Licensee. There shall be a minimum term of 30 days for usage of the API to be paid for in advance (or such other minimum term as notified to you via the API portal at https://portal.jup.ag). 
 13.2 This Agreement will terminate automatically if you fail to comply with any of the terms and conditions of this Agreement and you will be liable to Jupiter and its suppliers for damages or losses caused by your non-compliance. The waiver by Jupiter of a specific breach or default shall not constitute the waiver of any subsequent breach or default. 
 13.3 Either party shall have the right to terminate the Agreement, immediately or upon thirty (30) days written notice to legal@jup.ag. 
 13.4 Upon termination of this Agreement, Licensee will immediately cease using the API and the SDK, and Licensee agrees to destroy all adaptations or copies of the API, SDK, and Documentation or return them to Jupiter upon the termination of this License. 
 13.5 Jupiter shall have the right to review/audit your use of the API or SDK in conjunction with this Agreement, and you will provide reasonable assistance for this purpose. 
 13.6 The rights of Jupiter and your obligations contained in this Agreement survive any expiration or termination of this Agreement. 
 14. Applicable Law; Arbitration​ 
 14.1 Licensee and Jupiter agree to arbitrate any dispute arising from this Agreement, except for disputes in which either party seeks equitable and other relief for the alleged unlawful use of copyrights, trademarks, trade names, logos, trade secrets or patents. ARBITRATION PREVENTS LICENSEE FROM SUING IN COURT OR FROM HAVING A JURY TRIAL. 
 14.2 Licensee and Jupiter agree to notify each other in writing of any dispute within thirty (30) days of when it arises. Notice to Jupiter shall be sent to legal@jup.ag. 
 14.3 The Licensee and Jupiter shall cooperate in good faith to resolve any dispute, controversy or claim arising out of, relating to, or in connection with this Agreement, including with respect to the formation, applicability, breach, termination, validity or enforceability thereof (a “Dispute”) shall be settled in accordance with the laws of Panama. The parties undertake to carry out any award without delay and waive their right to any form of recourse insofar as such waiver can validly be made. Judgment upon the award may be entered by any court having jurisdiction thereof or having jurisdiction over the relevant party or its assets. Jupiter and the Licensee will each pay their respective attorneys’ fees and expenses. Any dispute arising out of or related to this Agreement is personal to the Licensee and Jupiter and will not be brought as a class arbitration, class action, or any other type of representative proceeding. There will be no class arbitration or arbitration in which a person attempts to resolve a dispute as a representative of another person or group of persons. Further, a dispute cannot be brought as a class or other type of representative action, whether within or outside of arbitration, or on behalf of any other person or group of persons. 
 14.4 Any dispute between the parties will be governed by this Agreement and the laws of Panama, without giving effect to any conflict of laws principles that may provide for the application of the law of another jurisdiction. Whether the dispute is heard in arbitration or in court, Licensee and Jupiter will not commence against the other a class action, class arbitration or representative action or proceeding. 
 15. Changes to this Agreement​ 
 We may amend any portion of this Agreement at any time by posting the revised version of this Agreement on https://portal.jup.ag with an updated revision date. The changes will become effective and shall be deemed accepted by you, the first time you use or access the SDK or API after the initial posting of the revised Agreement and shall apply on a going-forward basis with respect to your use of the SDK and/or API. In the event that you do not agree with any such modification, your sole and exclusive remedy is to terminate your use of the SDK and/or API. 
 16. Miscellaneous​ 
 16.1 Assignment. Licensee may not assign this Agreement or any interest or rights granted hereunder to any third party without the prior written consent of Jupiter. A change of control or reorganization of Licensee pursuant to a merger, sale of assets or stock shall be deemed to be an assignment under this Agreement. This Agreement shall terminate immediately upon the occurrence of any prohibited assignment. 
 16.2 Waiver. No failure by either party to exercise or enforce any of its rights under this Agreement will act as a waiver of such rights and no waiver of a breach in a particular situation shall be held to be a waiver of any other or subsequent breach. 
 16.3 Severability. If any provision of this Agreement is found invalid or unenforceable, that provision will be enforced to the maximum extent possible and the other provisions of this Agreement will remain in force. 
 16.4 Entire agreement. This Agreement represents the complete agreement concerning the API, SDK and oral amendments are void. If any provision of this Agreement is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. 
 16.5 Neither Party hereto shall be responsible for any failure to perform its obligations under this Agreement if such failure is caused by acts of God, war, strikes, revolutions, lack or failure of transportation facilities, laws or governmental regulations or other causes that are beyond the reasonable control of such Party. Obligations hereunder, however, shall in no event be excused but shall be suspended only until the cessation of any cause of such failure. 
 16.6 By installing, copying, or otherwise using this API or SDK, you acknowledge that you have read, understand and agree to be bound by the terms and conditions indicated above.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/6-projects-and-dexes/1-rust-integration.md', 'sidebar_label: "Rust Integration"
description: Learn to integrate your DEX with Jupiter using Rust. Simplify processes with our APIs and DEX SDK for better performance.
title: Rust Integration 

     Jupiter DEX Integration Guidelines: Enhance Your Crypto Exchange 
     

 
 Overview 
 Jupiter is one of the most widely integrated protocols, so a lot of work is involved in minimizing issues on new integrations and making each integration valuable to our users and partners. 
 Our top priority is securing the best prices and the best token selection for our users, so we will focus on DEXes that will bring the most benefits to them. 
 :::warning We do not charge fees for integration.
::: 
 Guidelines 
 Minimum DEX TVL of $500k 
 
 Given the amount of integration work involved, a DEX must have enough liquidity to be useful for trading and to attract volume. 
 Each market/pool must have a minimum liquidity of $500 to show up on Jupiter. You can keep up to date on how we list tokens  here 
 
 An API for listing/delisting pools on the DEX 
 
 This will allow us to automatically track new markets as you add them to your DEX. 
 
 Provide a Rust SDK 
 
 Your SDK should implement this interface:  DEX Integration . 
 We are soon migrating to a Rust SDK and so are asking all integrated DEXes to create a Rust SDK version or give access to the code for us to include. 
 
 Security Audit 
 
 If you''re not using Solana''s audited SPL token swap (https://github.com/solana-labs/solana-program-library/tree/master/token-swap), we ask that you get your code audited.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/6-projects-and-dexes/2-integration-guidelines.md', 'sidebar_label: "DEX Guidelines"
description: Learn how to integrate your DEX with Jupiter. Achieve superior trading performance and user satisfaction.
title: DEX Integration Guidelines 

     Jupiter DEX Integration Guidelines: Enhance Your Crypto Exchange 
     

 To facilitate integration of your DEX into the Jupiter Core Engine, you will need to provide a DEX SDK that works with the  Jupiter AMM Interface . 
 pub trait Amm {
    // Maybe trait was made too restrictive?
    fn from_keyed_account(keyed_account: &KeyedAccount, amm_context: &AmmContext) -> Result<Self>
    where
        Self: Sized;
    /// A human readable label of the underlying DEX
    fn label(&self) -> String;
    fn program_id(&self) -> Pubkey;
    /// The pool state or market state address
    fn key(&self) -> Pubkey;
    /// The mints that can be traded
    fn get_reserve_mints(&self) -> Vec<Pubkey>;
    /// The accounts necessary to produce a quote
    fn get_accounts_to_update(&self) -> Vec<Pubkey>;
    /// Picks necessary accounts to update it''s internal state
    /// Heavy deserialization and precomputation caching should be done in this function
    fn update(&mut self, account_map: &AccountMap) -> Result<()>;

    fn quote(&self, quote_params: &QuoteParams) -> Result<Quote>;

    /// Indicates which Swap has to be performed along with all the necessary account metas
    fn get_swap_and_account_metas(&self, swap_params: &SwapParams) -> Result<SwapAndAccountMetas>;

    /// Indicates if get_accounts_to_update might return a non constant vec
    fn has_dynamic_accounts(&self) -> bool {
        false
    }

    /// Indicates whether `update` needs to be called before `get_reserve_mints`
    fn requires_update_for_reserve_mints(&self) -> bool {
        false
    }

    // Indicates that whether ExactOut mode is supported
    fn supports_exact_out(&self) -> bool {
        false
    }

    fn get_user_setup(&self) -> Option<AmmUserSetup> {
        None
    }

    fn clone_amm(&self) -> Box<dyn Amm + Send + Sync>;

    /// It can only trade in one direction from its first mint to second mint, assuming it is a two mint AMM
    fn unidirectional(&self) -> bool {
        false
    }

    /// For testing purposes, provide a mapping of dependency programs to function
    fn program_dependencies(&self) -> Vec<(Pubkey, String)> {
        vec![]
    }

    fn get_accounts_len(&self) -> usize {
        32 // Default to a near whole legacy transaction to penalize no implementation
    }

    /// The identifier of the underlying liquidity
    ///
    /// Example:
    /// For RaydiumAmm uses Openbook market A this will return Some(A)
    /// For Openbook market A, it will also return Some(A)
    fn underlying_liquidities(&self) -> Option<HashSet<Pubkey>> {
        None
    }

    /// Provides a shortcut to establish if the AMM can be used for trading
    /// If the market is active at all
    fn is_active(&self) -> bool {
        true
    }
}
 
 get_accounts_to_update  provides the necessary accounts to fetch, they are batched and cached by the Jupiter Core Engine and delivered through  update  to the AMM instance, there might be multiple calls to  quote  using the same cache so  we do not allow any network calls  in the entire implementation. 
 You can refer to the implementation guide below for easier integration with Jupiter. 
 https://github.com/jup-ag/rust-amm-implementation 
 Notes: 
 
 We need to be able to fork your SDK. This is to ensure our users that we can guarantee maintenance, support for the SDK, and fix potential bugs related to integrated DEXs.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/9-legacy/1-apis/1-swap-api.md', 'sidebar_label: "Swap API"
description: "Discover the vintage Jupiter V4 Swap API [Legacy]. Dive into functionalities and uses of this earlier version for developers interested in past crypto technologies."
title: "V4 Swap API" 

     Jupiter V4 Swap API: Exploring Legacy Crypto Technology 
     

 :::tip
We recommend checking out our v6 API for more reliability, performance and better pricing.
::: 
 We offer an API and an SDK, but, we recommend that integrators use our API. The API offers several benefits: 
 
 Language/platform agnostic. 
 Avoids NPM SDK dependency issues. Different dependencies will require different versions of the same library making integrating/upgrading more difficult. 
 The SDK has a heavy initialization and computation load that is tricky to optimize on mobile or compute-limited devices. 
 Offload heavy RPC dependency to the API. 
 
 Using the API 
 Jupiter API is the easiest way for developers to access liquidity on Solana. Simply pass in the desired pairs, amount, and slippage, and the API will return the serialized transactions needed to execute the swap, which can then be passed into the Solana blockchain with the required signatures. 
 Try it out! 
 # Copy and paste this into your terminal!
curl -s ''https://quote-api.jup.ag/v4/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=10000&slippageBps=1'' | jq ''.data | .[0] | .outAmount''
 
 V4 API Reference 
 :::tip V4 uses Versioned Transactions and Address Lookup Tables
All Jupiter swaps are now only a single transaction. Not all wallets support Versioned Transactions yet, so if you detect a wallet that does not support versioned transactions you may request a legacy transaction instead from the API.
::: 
 :::info API Documentation
 Swagger 
::: 
 Guide 
 1. Install the libraries 
 To run this example requires a minimum of  NodeJS 16 . In your command line terminal, install the libraries. 
 npm i @solana/web3.js@1
npm i cross-fetch
npm i bs58
 
 2. Import from libraries and setup connection 
 Next you can copy the following code snippets to a javascript file jupiter-api-example.js. And when you are ready to run the code, just type:  node jupiter-api-example.js 
 import { Connection, Keypair, VersionedTransaction } from ''@solana/web3.js'';
import fetch from ''cross-fetch'';
import bs58 from ''bs58'';

// It is recommended that you use your own RPC endpoint.
// This RPC endpoint is only for demonstration purposes so that this example will run.
const connection = new Connection(''https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/'');
 
 :::tip
Always make sure that you are using your own RPC endpoint. The RPC endpoint used by the connection object in the above example may not work anymore.
::: 
 3. Setup your wallet 
 In this example, you can paste in your private key for testing purposes but this is not recommended for production applications. 
 const keypair = Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ''''));
 
 4. Retrieve the route map 
 You can retrieve the route map to find out what tokens are listed on Jupiter and what swaps are possible with a particular token. The route map only returns the token mint addresses and not the token metadata. 
 // retrieve indexed routed map
const indexedRouteMap = await (await fetch(''https://quote-api.jup.ag/v4/indexed-route-map'')).json();
const getMint = (index) => indexedRouteMap["mintKeys"][index];
const getIndex = (mint) => indexedRouteMap["mintKeys"].indexOf(mint);

// generate route map by replacing indexes with mint addresses
var generatedRouteMap = {};
Object.keys(indexedRouteMap[''indexedRouteMap'']).forEach((key, index) => {
  generatedRouteMap[getMint(key)] = indexedRouteMap["indexedRouteMap"][key].map((index) => getMint(index))
});

// list all possible input tokens by mint Address
const allInputMints = Object.keys(generatedRouteMap);

// list tokens can swap by mint address for SOL
const swappableOutputForSol = generatedRouteMap[''So11111111111111111111111111111111111111112''];
// console.log({ allInputMints, swappableOutputForSol })
 
 
   
     
       GET 
       https://quote-api.jup.ag/v4/indexed-route-map 
     
   
 Retrieve an indexed route map for the possible token pairs you can swap between. 
 See Swagger for more details: https://quote-api.jup.ag/v4/docs/oldstatic/index.html 
   
 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

  .get {
    border: 1px solid #1976F2;
    background-color: #1976F2 !important;
  }

  .post {
    border: 1px solid #018847;
    background-color: #018847 !important;
  }

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 5. Get the routes for a swap 
 In this example, we try swapping SOL to USDC. 
 // swapping SOL to USDC with input 0.1 SOL and 0.5% slippage
const { data } = await (
  await fetch(''https://quote-api.jup.ag/v4/quote?inputMint=So11111111111111111111111111111111111111112\
&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\
&amount=100000000\
&slippageBps=50''
  )
).json();
const routes = data;
// console.log(routes)
 
 
   
     
       GET 
       https://quote-api.jup.ag/v4/quote 
     
   
 Get the top 3 swap routes for a token trade pair sorted by largest output token amount 
 See Swagger for more details: https://quote-api.jup.ag/v4/docs/oldstatic/index.html 
 Request Parameters 
 Parameter Type Required Description 
 inputMint Yes input token mint address 
 outputMint Yes 
 amount Integer Yes The API takes in  amount   in integer and you have to factor in the decimals for each token by looking up the decimals for that token. For example, USDC has 6 decimals and 1 USDC is 1000000 in integer when passing it in into the API. 
 swapMode No ( ExactIn  or  ExactOut )  Defaults to  ExactIn .   ExactOut  is for supporting use cases where you need an exact token amount, like payments. In this case the slippage is on the input token 
 slippageBps Integer No The slippage % in BPS.  If the output token amount exceeds the slippage then the swap transaction will halt. 
 feeBps Integer No If you want to charge the user a fee, you can specify the fee in BPS.  Fee % is taken out of the output token. 
 onlyDirectRoutes Integer No Default is false.  Direct Routes limits Jupiter routing to single hop routes only. 
 userPublicKey No Public key of the user (only pass in if you want deposit and fee being returned, might slow down query) 
 asLegacyTransaction Boolean No Only return routes that can be done in a single legacy transaction. (Routes might be limited) 
 
   
 :::tip Platform Fee
If you''d like to charge a fee, pass in feeBps as a parameter in the quote.
::: 
 :::tip Amount
The API takes in amount in integer and you have to factor in the decimals for each token by looking up the decimals for that token. For example, USDC has 6 decimals and 1 USDC is 1000000 in integer when passing it in into the API.
::: 
 6. Get the serialized transactions to perform the swap 
 // get serialized transactions for the swap
const transactions = await (
  await fetch(''https://quote-api.jup.ag/v4/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // route from /quote api
      route: routes[0],
      // user public key to be used for the swap
      userPublicKey: keypair.publicKey.toString(),
      // auto wrap and unwrap SOL. default is true
      wrapUnwrapSOL: true,
      // feeAccount is optional. Use if you want to charge a fee.  feeBps must have been passed in /quote API.
      // This is the ATA account for the output token where the fee will be sent to. If you are swapping from SOL->USDC then this would be the USDC ATA you want to collect the fee.
      // feeAccount: "fee_account_public_key"
    })
  })
).json();

const { swapTransaction } = transactions;
 
 
   
     
       POST 
       https://quote-api.jup.ag/v4/swap 
     
   
 Get the serialized swap transactions for the swap route provided. 
 See Swagger for more details: https://quote-api.jup.ag/v4/docs/oldstatic/index.html 
 Request Parameters 
 Parameter Type Required Description 
 route Route Yes Route object returned from Quote API. See Swaggar for definition 
 userPublicKey Yes public key of the user 
 wrapUnwrapSOL Boolean No if true, will automatically wrap/unwrap SOL.  If false it will use wSOL token account. Defaults to true. 
 feeAccount No The fee token account for the output token (only pass in if you set a feeBps) 
 asLegacyTransaction Boolean No Request a legacy transaction rather than the default versioned transaction, needs to be paired with a quote using   asLegacyTransaction   otherwise the transaction might be too large 
 destinationWallet No Public key of the wallet that will receive the output of the swap. This assumes the associated token account exists, and currently adds a token transfer instruction. 
 
   
 7. Deserialize and sign the transaction 
 // deserialize the transaction
const swapTransactionBuf = Buffer.from(swapTransaction, ''base64'');
var transaction = VersionedTransaction.deserialize(swapTransactionBuf);
console.log(transaction);

// sign the transaction
transaction.sign([keypair]);
 
 8. Execute the transaction 
 // Execute the transaction
const rawTransaction = transaction.serialize()
const txid = await connection.sendRawTransaction(rawTransaction, {
  skipPreflight: true,
  maxRetries: 2
});
await connection.confirmTransaction(txid);
console.log(`https://solscan.io/tx/${txid}`);
 
 Arbitrage Bot Using the API 
 Use the API to build your own arbitrage bot. 
 Jupiter API Arbitrage Example checks whether there is an opportunity for USDC => SOL and SOL => USDC, it submits two transactions that do not always promise profit and might incur losses, use it at your own risk. 
 API Arbs Example (Using V1 API) 
 Clone, Build and Run 
 First, fetch the latest version of the example code: 
 $ git clone https://github.com/jup-ag/api-arbs-example.git
$ cd api-arbs-example
 
 Next, follow the steps in the git repository''s  README .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/9-legacy/1-apis/2-payments-api.md', 'sidebar_label: Payments API
description: Discover Jupiter''s Legacy V4 Payments API for seamless SPL to USDC conversions.
title: V4 Payments API 

     Jupiter V4 Payments API Documentation [Legacy] | Jupiter Station 
     

 Payments API: Convert any token to USDC 
 Jupiter supports the payments use case. You can use Jupiter + SolanaPay to pay for anything with any SPL token. With this technique you can specify an exact output token amount. 
 Use Case 
 Payments or interaction with a protocol can require an exact amount of token B. Users might not have token A or prefer to hold other tokens long term. The Jupiter API allows for building a swap transaction to receive an exact amount of token A for a maximum in amount of token B. 
 A Practical Example using the API 
 Bob is selling a delicious latte for 5 USDC, Alice only holds mSOL but Bob can use the Jupiter API to let Alice swap for exactly 5 USDC then transfer 5 USDC to his payment wallet. 
 First, we need to show Alice how much mSOL will he have to spend for the latte. 
 curl -s ''https://quote-api.jup.ag/v4/quote?inputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=5000000&swapMode=ExactOut&slippageBps=1'' | jq ''.data | .[0] | .inAmount, .otherAmountThreshold''
 
 Parameters: 
 
 The input mint is mSOL and the output mint is USDC. 
 swapMode  is  ExactOut , as opposed to the default  ExactIn . 
 we want to receive amount=5000000, 5 USDC. 
 
 Response: 
 
 inAmount  is the quoted estimated amount of mSOL required to receive 5 USDC. 
 otherAmountThreshold  is the maximum in amount, the quote above with the slippage tolerance. 
 
 :::info
Currently, only Orca Whirlpool, Raydium CPAMM, and Raydium CLAMM support ExactOut mode. All tokens may not be available in this mode.
::: 
 Then Bob creates the transaction with the  /swap  endpoint, and adds a 5 USDC token transfer from Alice to his payment wallet using the  destinationWallet  argument, which Alice will verify, sign and send. 
 :::info
In the example bellow, we assume the associated token account exists on  destinationWallet .
::: 
 import { Token, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from ''@solana/spl-token''; // version 0.1.x
import { PublicKey } from ''@solana/web3.js'';

const USDC_MINT = new PublicKey(''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'');
const paymentAmount = 5_000_000; // 5 USDC
const merchantWallet = new PublicKey(''BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9'');

// get serialized transactions for the swap
const transactions = await (
  await fetch(''https://quote-api.jup.ag/v4/swap'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      // route from /quote api
      route: routes[0],
      userPublicKey: wallet.publicKey.toString(),
    })
  })
).json();

const { swapTransaction } = transactions;

const userDestinationTokenAccount = Token.getAssociatedTokenAddress(
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  USDC_MINT,
  wallet.publicKey,
);
const merchantTokenAccount = Token.getAssociatedTokenAddress(
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  USDC_MINT,
  merchantWallet,
  // @ts-ignore
  true,
);

// deserialize the transaction
const swapTransactionBuf = Buffer.from(swapTransaction, ''base64'');
var transaction = VersionedTransaction.deserialize(swapTransactionBuf);
console.log(transaction);

// get address lookup table accounts
const addressLookupTableAccounts = await Promise.all(
  transaction.message.addressTableLookups.map(async (lookup) => {
    return new AddressLookupTableAccount({
      key: lookup.accountKey,
      state: AddressLookupTableAccount.deserialize(await connection.getAccountInfo(lookup.accountKey).then((res) => res.data)),
    });
  });
);
// console.log(addressLookupTableAccounts)

// decompile transaction message and add transfer instruction
var message = TransactionMessage.decompile(transaction.message,{addressLookupTableAccounts: addressLookupTableAccounts});
message.instructions.push(
  Token.createTransferInstruction(
    TOKEN_PROGRAM_ID,
    userDestinationTokenAccount,
    merchantTokenAccount,
    wallet.publicKey,
    [],
    paymentAmount,
  ),
);

// compile the message and update the transaction
transaction.message = message.compileToV0Message(addressLookupTableAccounts);

// ...Send to Alice to sign then send the transaction
 
 :::tip
If you want to add your own fees, check out:  Adding Your Own Fees 
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/9-legacy/1-apis/3-adding-fees.md', 'sidebar_label: Adding Fees
description: Legacy documentation for adding fees in Jupiter Swap V4 API.
title: V4 Referral Program 

     Jupiter API V4 Referral Program [Legacy] 
     

 
 There are no protocol fees on Jupiter, but integrators can introduce a platform fee on swaps. The platform fee is provided in basis points, e.g.  20 bps  for  0.2%  of the token output. 
 :::info Zero Fees
Jupiter doesn''t take any fees.
::: 
 Usage 
 Jupiter API 
 With the Jupiter API, you can just add in the  feeBps  parameter to the Quote API: 
 5. Get the routes for a swap 
 Jupiter SDK 
 import { Jupiter, getPlatformFeeAccounts, TOKEN_LIST_URL } from ''@jup-ag/core'';
import { Connection } from ''@solana/web3.js'';

const SOLANA_RPC_ENDPOINT = "https://solana-api.projectserum.com";

const connection = new Connection(SOLANA_RPC_ENDPOINT);

const platformFeeAndAccounts = {
  feeBps: 50,
  feeAccounts: await getPlatformFeeAccounts(
    connection,
    new PublicKey(''BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9'') // The platform fee account owner
  ) // map of mint to token account pubkey
};

const jupiter = Jupiter.load({
  ..., // Other arguments, refer to @jup-ag/core documentation
  platformFeeAndAccounts
});
 
 You will need to create the token fee accounts to collect the platform fee. The platform fee is collected in the output mint in  ExactIn  mode and in the input mint in  ExactOut  mode. 
 We have created a tool to help you create the token accounts and also to consolidate fee tokens into a desired token. e.g. convert  $DUST  into  $SOL  or  $USDC . 
 https://github.com/jup-ag/jupiter-cli', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/index.md', 'sidebar_position: 1
title: Welcome
description: "Unlock superior trading with Jupiter Documentation. Integrate APIs for swaps, payments, and more effortlessly. Explore robust tools now!" 

     Jupiter APIs and Documentation 
     

 Welcome Catdet-veloper! 
 
 Build World Class Swap Experiences Now! 
 Jupiter''s goal is simple: Help you provide world class experiences for your users. We aim to do this with as little work as possible on your end, regardless of use case or need. 
 Jupiter offers a wide range of tools to make your life easy. Some of these tools include: 
 
 Swaps: One of the Fastest Swap APIs on Solana. Simply put in your desired pairs, amount, and slippage and receive your serialized transaction from the API to execute your swap. 
 Payments API: Quickly swap any token to USDC. Using this, you can specify an exact output token amount in any token (not just USDC). 
 Limit Orders: Place limit orders quickly and easily with Jupiter Limit Orders.  
 DCA: DCA into any SPL token with Jupiter''s DCA program. Integrating into your use case is fast and simple! 
 
 For DEXes looking to integrate with Jupiter products, check out these resources: 
 
 Jupiter Terminal: Jupiter Terminal provides an easy way to integrate an open-source and easy-to-use terminal in your app. 
 
 For projects who wants to make your token visible on the Strict list, see: 
 
 Get your Token onto Jupiter: 
 
 Learn how to use Jupiter products with our in-depth  User guides. 
 For technical questions or partnership requests, please reach out to us in our discord: https://discord.gg/jup.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/5-wallet-list.md', 'sidebar_label: "Wallet List"
description: Explore Jupiter compatible wallets such as Phantom, Glow, and Backpack for premium security features.
title: Compatible Wallets Supported by Jupiter 

     What Wallets are Compatible With Jupiter? Full List 
     

 Wallets supported on Jupiter 
 TLDR: 
Only wallets that are aligned with the  Wallet Standard  will be supported going forward. You will still be able to access wallets that were previously supported on our  legacy site . 
 
 Why is my wallet not supported? 
 We are sorry if your go-to wallet is not supported. We recommend migrating to other wallet that are aligned with the  Wallet Standard , such as Phantom, Glow, Backpack, OKX and more. 
 Wallets that do not conform to the latest standard have always been difficult for us to support. The challenges include: 
 
 Not supporting Versioned Transaction, which severely impacts the routing experience and prevents us from getting you the best quote 
 Unpatched security 
 Abandoned development 
 Unnecessary impact on user experience from large bundle sizes of unused wallets 
 
 
 More resources 
 
 What is Wallet Standard
 
 https://docs.phantom.app/developer-powertools/wallet-standard 
 
 
 Developer Guides
 
 https://github.com/solana-labs/wallet-standard', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/2-displaying-jup-stats.md', 'sidebar_label: Jupiter Stats
description: Learn to fetch key stats such as tickers, swap pairs, and more. Examples included
title: Fetch Jupiter Stats 

     Fetch Jupiter Stats: Tickers, Swap Pairs, and More 
     

 :::warning
These endpoints are no longer maintained.
::: 
 
 
 Last 24 hrs: https://stats.jup.ag/info/day 
 
 
 Last week: https://stats.jup.ag/info/week 
 
 
 Last month: https://stats.jup.ag/info/month', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/3-links-and-contract-addresses.md', 'sidebar_label: "Links and Contract Addresses"
description: "Access Jupiter API links and contract addresses for streamlined SDK integration and effective connectivity."
title: Helpful Links and Contract Addresses 

     Jupiter API Links and Contract Addresses | Jupiter Station 
     

 Contracts 
 
 Jupiter Swap:  JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 
 Jupiter Limit Order:  jupoNjAxXgZ4rjzxzPMP4oxduvQsQtZzyknqvzYNrNu 
 Jupiter DCA:  DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M 
 
 SDKs & APIs 
 
 Jupiter API
 
 v6 API uses JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 with versioned transactions & address lookup tables so all swap routes take just 1 transaction. Also, no intermediate token accounts and open order accounts are needed anymore. 
 v4 API  uses JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB with versioned transactions & address lookup tables so all swap routes take just 1 transaction. 
 v3 API  uses JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB which uses legacy transactions so some swap routes can take up to 3 transactions. 
 
 
 Jupiter Core Library  NPM 
 
 4.x.x uses JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB with versioned transactions & address lookup tables. 
 3.x.x uses JUP4Fb2cqiRUcaTHdrPC8h2gNsA2ETXiPDD33WcGuJB 
 2.x.x uses JUP3c2Uh3WA4Ng34tw6kPd2G4C5BB21Xo36Je1s32Ph 
 1.x.x uses JUP2jxvXaqu7NQY1GmNF4m1vodw12LVXYxbFL2uJvfo 
 
 
 Jupiter React-Hook  NPM 
 
 Github Repo 
 
 https://github.com/jup-ag', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/6-audits.md', 'sidebar_label: "Audits"
description: Smart Contracts Security Audits by top tier security firm in the ecosystem.
title: Smart Contracts Security Audits 
 Swap 
 
 Offside Labs  (v6) 
 Sec3  (v4) 
 
 Limit Order 
 
 Offside Labs 
 
 DAO 
 
 Offside Labs 
 
 Perpetuals 
 
 Offside Labs 
 OtterSec 
 Sec3 
 
 Lock 
 
 OtterSec', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/4-builder-tips.md', 'sidebar_label: "Builder Tips"
description: Learn key tips for using Jupiter to develop on Solana. Boost DApp efficiency and security effortlessly.
title: General Building Tips 

     General Tips For Building on Solana With Jupiter | Jupiter Station 
     

 New to building on Solana? 
 This is a good resource: https://solanacookbook.com 
 Private Key, beware of compromising your wallet. 
 A wallet Private Key is the most important strings of text, that allows anyone to restore/access your wallet, make sure you never commit your  Private Key  into your version control ( Git, etc. ), or expose them anywhere. 
 The safer way would be the use of  .env  file in your projects, and adding a  .gitignore  entry. Managing secrets can feel like extra work, but it is necessary to keep your wallets safe. 
 Our example repos are all equipped with  .env  support by default, if you want to configure it yourself:  dotenv ,  react-native-dotenv . 
 Careful! Before executing this function block! 
 Swaps are irreversible! Make sure you are certain with your code, and be extra careful if you happen to run intervals, or any code without human supervision.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/1-composing-with-versioned-transaction.md', 'sidebar_label: "Versioned Transactions"
description: Explore Versioned Transactions with Jupiter’s V4 API for streamlined swaps and more functions on Solana.
title: Composing With Versioned Transactions 

     Versioned Transactions on Jupiter: A Full Guide 
     

 
 Jupiter''s V4 API improves composability by utilizing Solana''s Versioned Transactions and Address Lookup Tables so all Jupiter routes can be done in a single transaction. 
 For anyone developing on Solana, one of the biggest hurdles in composing protocols has been dealing with the transaction size limit of 1232 bytes. Given that each account takes 32 bytes and each signature takes 64 bytes, it is easy to hit the transaction size limit frequently. For Jupiter, this meant that we were limited to two-hop swaps and used up all the transaction size just to fit the two swaps into a single transaction. 
 
 Summary of constraints that affect composability 
 
 transaction size  is limited to 1232 bytes.   
 compute budget  is defaulted to 200k compute units with a max of 1.4M compute units. If you exceed the compute budget, your transaction will be halted.  Most programs have designed their compute budget to take up 200k which you can use to estimate your compute budget. However, many programs do not have an upper bound on their compute budget and it''s possible for them to exceed the limit.  Jupiter transactions request the full 1.4M to accommodate some of these programs as best as possible. 
 cross-program invocations  are limited to 4 levels 
 stack usage  can not exceed 4k  
 BPF call depth  can not exceed 64 
 
Get more details from the  Solana runtime .
 
 By utilizing Versioned Transactions with Address Lookup Tables, all Jupiter swaps can now be done in a single transaction with approximately 50% of the transaction size freed for anyone to add their own instructions. 
 What are Versioned Transactions? 
 Versioned Transactions  are the new transaction format that allows for additional functionality in the Solana runtime, including  Address Lookup Tables .  Address Lookup Tables let you store the account addresses in on-chain tables instead of being stored directly in the transaction which will free up space for other instructions. 
 :::info You do not need to use Address Lookup Tables to compose with Jupiter.
We automatically construct the transactions to use the correct Jupiter lookup tables for you.  However, using your own on-chain lookup tables will allow you to fit more instructions into the transaction.
::: 
 1. Get the Jupiter swap transaction from the API. 
 You can refer to the example code in Using the API for retrieving a Jupiter swap transaction. 
 // Some more imports you will need
import { TransactionMessage, VersionedMessage, TransactionInstruction, sendAndConfirmRawTransaction, SystemProgram, AddressLookupTableAccount } from ''@solana/web3.js'';
import { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from ''@solana/spl-token'';

// public key to use for this example
const referralWalletPublicKey = new PublicKey("referral_wallet_public_key")
 
 2. Deserialize the transaction 
 // deserialize the transaction
const swapTransactionFromJupiterAPI = swapTransaction
const swapTransactionBuf = Buffer.from(swapTransactionFromJupiterAPI, ''base64'')
var transaction = VersionedTransaction.deserialize(swapTransactionBuf)
// console.log(transaction)
 
 3. Construct the referral fee transfer instruction 
 // construct the transfer instruction
const transferInstruction = SystemProgram.transfer({
    fromPubkey: wallet.publicKey,
    toPubkey: referralWalletPublicKey,
    lamports: 1000,
  }),
 
 4. Fetch the Address Lookup Table accounts 
 This will be needed to decompile and compile the transaction message. 
 // get address lookup table accounts
const addressLookupTableAccounts = await Promise.all(
  transaction.message.addressTableLookups.map(async (lookup) => {
    return new AddressLookupTableAccount({
      key: lookup.accountKey,
      state: AddressLookupTableAccount.deserialize(await connection.getAccountInfo(lookup.accountKey).then((res) => res.data)),
    })
  }))
// console.log(addressLookupTableAccounts)
 
 5. Decompile the transaction message and add the transfer instruction 
 // decompile transaction message and add transfer instruction
var message = TransactionMessage.decompile(transaction.message,{addressLookupTableAccounts: addressLookupTableAccounts})
message.instructions.push(transferInstruction)
 
 6. Compile the new message and update the transaction 
 // compile the message and update the transaction
transaction.message = message.compileToV0Message(addressLookupTableAccounts)
 
 7. Sign and send the transaction 
 // sign the transaction
transaction.sign([wallet.payer])

// Execute the transaction
const rawTransaction = transaction.serialize()
const txid = await sendAndConfirmRawTransaction(connection, Buffer.from(rawTransaction), {
  skipPreflight: true,
  commitment: ''confirmed'',
  maxRetries: 2
})
console.log(`https://solscan.io/tx/${txid}`)
 
 Using your own Address Lookup Tables 
 If you''d like to use your own address lookup tables, you just need to append your tables to the address lookup table accounts 
 // ...
addressLookupTableAccounts.push(yourAddressLookupTableAccounts)
// ...
 
 :::tip Resources for creating and using Address Lookup Tables 
 
 Github docs on versioned transactions 
 Github docs on address lookup tables 
 Phantom''s guide for sending a versioned transaction 
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/4-dca/3-lock-dca-campaign.md', 'title: DCA CPI Integration
sidebar_label: "DCA CPI Integration"
description: "Master Jupiter''s DCA CPI integration with our detailed guide, example code, and strategic use cases." 

     Jupiter DCA CPI: Enhanced Integration Techniques for Developers 
     

 This section contains examples of composing Jupiter''s DCA program in your program via Cross Program Invocation (CPI). 
 Our aim is to simplify the process for our partners to integrate Jupiter''s DCA for customized incentive programs. 
 Use Cases 
 The use cases for DCA are limitless. Feel free to use the following example as an inspiration to introduce your own functionalities. 
 Our example code allows you to have your own customized frontend + program that incentivizes users to DCA into your token in order to receive additional airdrops from you. 
 Open Sourced Code 
 
 anchor program + scripts - https://github.com/jup-ag/dca-cpi-example 
 frontend - https://github.com/TeamRaccoons/locked-dca ( see example ) 
 
 The open-sourced example allows you to airdrop additional tokens to users who DCA into your token. 
 Setting up (Program) 
 
 Fork and clone https://github.com/jup-ag/dca-cpi-example 
 Adjust the parameters
 
 AIRDROP_BPS 
 
 
 Generate a new program ID and  modify the program code 
 Deploy the program to Solana 
 
 Setting up (Airdrop Script) 
 
 Replace with your deployed program ID  here 
 Set env var  ADMIN_PRIVATE_KEY  - this is the account you will use to execute airdrops (it should contain sufficient tokens to airdrop + SOL to perform transactions) 
 Run the airdrop script  cd app && npm i && npm run airdrop   code 
 
 Setting up (Frontend) 
 
 Fork and clone https://github.com/TeamRaccoons/locked-dca 
 Replace the program ID  here 
 Craft new plans for the campaigns - Plans are hardcoded on the Frontend, and enforce on the contract level. 
 
 export const SECONDS_IN_MINUTE = 60; // 1 minute
export const SECONDS_IN_DAY = 86400; // 1 day
export const LOCKING_PLAN: ILockingPlan[] = [
  {
    name: `5 minutes`,
    incetivesPct: 0,
    cycleSecondsApart: SECONDS_IN_MINUTE, // executed per minute
    numberOfTrade: 5,
  },
  {
    name: `60 days`,
    incetivesPct: 20,
    cycleSecondsApart: SECONDS_IN_DAY,
    numberOfTrade: 60, // executed daily
  },
  {
    name: `90 days`,
    incetivesPct: 30,
    cycleSecondsApart: SECONDS_IN_DAY,
    numberOfTrade: 90, // executed daily
  },
];
 
 
 Here''s how it works 
 A user creates a DCA via your frontend and program. This creates an escrow account that integrates with Jupiter''s DCA program. 
 Once the DCA is completed (all orders are executed), the user will then be able to claim the tokens that they bought. Once they claim their tokens, the airdrop script will airdrop additional tokens from your admin account to them. 
 User flow 
 
 User create a DCA order via your deployed UI. 
 DCA completes within the preset duration. 
 User will be able to navigate to the site and close their escrow and receive the output token from the executed DCA orders. 
 Once the order and escrow has been closed, partners and integrators will automatically airdrop rewards or incentives directly into user''s wallet  (With the provided script running in a infinite loop in the background) 
 
 
 Scaffold Skeleton UI for Lock DCA: 
 
 Visit the Scaffold Skeleton UI 
 Access the Repository on GitHub 
 
 
 DCA Program: 
 
 Explore the DCA Program on GitHub 
 
 
 Airdrop Script: 
 
 Check out the Airdrop Script on GitHub', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/4-dca/1-integration.md', 'sidebar_label: Integrate DCA
description: Master Jupiter DCA Integration for efficient DCA orders on Solana. Get setup tips and SDK details.
title: Integrating Jupiter DCA 

     Jupiter DCA Integration: Seamless Solana Orders 
     

 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 Jupiter Dollar Cost Average (DCA) provides users with the quickest and easiest way to place DCA orders on Solana! DCA allows users to receive tokens directly in their wallet as each order is filled! 
 This page will serve as a general guide on integrating DCA into your use case. whether you are building a bot for yourself or looking to integrate with existing (d)apps, Jupiter''s DCA program will work regardless of programming language used. If you are trying to build a DCA bot in Typescript / Javascript, look at  DCA SDK . 
 Address 
 DCA Program (mainnet-beta):  DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M 
 Big Picture 
 There are 2 key instructions that can be executed 
 
 Creating a DCA 
 Cancelling (and receiving excess tokens) an existing DCA 
 
 Instructions 
 1. Setting up a DCA 
 A DCA Account is a Program Derived Address (PDA) account. In order to start dollar cost averaging, you will need to construct and send a Transaction containing an Instruction to open this DCA account.  (if you are not familiar with constructing a transaction on Solana, take a look at using  DCA SDK . This guide provides more thorough code examples) . 
 Each DCA account has unique parameters. If you want to have different parameters, you can create any number of DCA accounts. 
 Instruction 
 pub fn open_dca_v2(
    ctx: Context<OpenDcaOnBehalf>,
    application_idx: u64,
    in_amount: u64,
    in_amount_per_cycle: u64,
    cycle_frequency: i64,
    min_out_amount: Option<u64>,
    max_out_amount: Option<u64>,
    start_at: Option<i64>,
) -> Result<()> {
 
 Arguments needed (in this order): 
 Arguments Type Description 
 applicationIdx u64 A unix timestamp in seconds 
 inAmount u64 Total input mint amount to sell. For e.g. if you are trying to buy SOL using 100 USDC every day over 10 days,  inAmount  should be  100 _ 10 _ (10^6)  - USDC has 6 decimals 
 inAmountPerCycle u64 Input mint amount to sell each time. _For e.g. if you are trying to buy SOL using 100 USDC every day over 10 days,  inAmountPerCycle  should be  100 _ (10^6) * 
 cycleFrequency i64 The number of seconds between each periodic buys. For e.g. if you are trying to DCA on a daily basis,  cycleFrequency  should be 60 _ 60 _ 24 = 86,400 
 minOutAmount Option<u64> This is an optional field. Following the examples above, let''s say you only want to buy SOL if SOL is below SOL-USDC $20, that means for each cycle, with every 100 USDC, you want to receive a minimum of  100 / 20 = 5 SOL . You can then pass  5 * LAMPORTS_PER_SOL  as argument here. This ensures that you receive > 5 SOL for each order. 
 maxOutAmount Option<u64> This is just the inverse scenario of  minOutAmount . While  maxOutAmount  is a little counter intuitive, it can be used by advanced traders / investors who believe an asset is at risk of further decline in prices if it goes beyond a certain threshold. Say in the case of output mint being a stablecoin, if the stablecoin drops to $0.5, you will get more buying into it, but that may not necessary be a good thing since the risk of a stablecoin going to $0 is very real if it could depeg to $0.5. This is where  maxOutAmount  could be useful. 
 startAt i64 Unix timestamp in seconds of when you would like DCA to start. Pass  0  if you want to start immediately or pass a future time as a unix timestamp in seconds 
 
 Context Accounts needed: 
 Accounts Description isSigner? isWritable? 
 dca You will need to derive a DCA PDA here. The 4 buffers used to generate the PDA are seed -> ''dca'', user public key, input token public key, output token public key and a uid (use a unix timestamp). See  code example  below false true 
 user This is the user''s pubkey. Needs to be a signer of the transaction. true false 
 payer This is the payer''s pubkey. Needs to be a signer of the transaction. Pays for the rent to open token accounts needed as well as user''s DCA (PDA) account. This can be the same as user. true true 
 inputMint Token to sell false false 
 outputMint Token to buy false false 
 userAta User''s token account holding the token to sell. Does not necessarily need to be a associated token account. Will transfer inputMint tokens from this account to DCA PDA''s inputMint ATA false true 
 inAta The associated token account''s address of DCA PDA for inputMint. Example:  getAssociatedTokenAddressSync(inputMint, dcaPubKey, true)  from  @solana/spl-token  library false true 
 outAta The associated token account''s address of DCA PDA for outputMint. Example:  getAssociatedTokenAddressSync(outputMint, dcaPubKey, true)  from  @solana/spl-token  library false true 
 systemProgram The usual  new PublicKey("11111111111111111111111111111111") false false 
 tokenProgram new PublicKey(''TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'');  DCA has not been tested to work with Token 2022 yet false false 
 associatedTokenProgram new PublicKey(''ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL''); false false 
 eventAuthority new PublicKey(''Cspp27eGUDMXxPEdhmEXFVRn6Lt1L7xJyALF3nmnWoBj'')  This is DCA Program''s event authority for Anchor  0.28.0 ''s event CPI feature. false false 
 program The DCA program itself  new PublicKey(''DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M'') false false 
 
 Getting a DCA PDA 
 const [dca] = await PublicKey.findProgramAddressSync(
  [
    Buffer.from("dca"),
    userPubKey.toBuffer(),
    inTokenPubKey.toBuffer(),
    outTokenPubKey.toBuffer(),
    new BN(parseInt((Date.now() / 1000).toString())).toArrayLike(
      Buffer,
      "le",
      8
    ),
  ],
  new PublicKey("DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M")
);
 
 Phew! That''s all that is necessary to construct the instruction. Next, you will need to sign and send the transaction! 
 Here''s what a successful transaction to create a  DCA account looks like . 
 2. Cancelling a DCA 
 If you decide to stop your DCA program, you can close the DCA account. Closing the DCA account also returns any leftover tokens to the owner of the DCA account. 
 Similar to opening a DCA account, you will need to send a transaction containing an instruction to  close_dca . 
 Closing a DCA is relatively simple. There are no arguments needed. The accounts necessary are 
 Accounts needed: 
 Accounts Description isSigner? isWritable? 
 user This is the user''s account that owns the DCA Account. This account will also be the signer and payer of the transaction true true 
 dca The DCA account you want to close false true 
 inputMint Token to sell false false 
 outputMint Token to buy false false 
 inAta The associated token account''s address of DCA PDA for inputMint. Example:  getAssociatedTokenAddressSync(inputMint, dcaPubKey, true)  from  @solana/spl-token  library false true 
 outAta The associated token account''s address of DCA PDA for outputMint. Example:  getAssociatedTokenAddressSync(outputMint, dcaPubKey, true)  from  @solana/spl-token  library false true 
 userInAta User''s token account for input_mint. If not initialized, will initialize. false true 
 userOutAta User''s token account for output_mint. If not initialized, will initialize. false true 
 systemProgram The usual  new PublicKey("11111111111111111111111111111111") false false 
 tokenProgram new PublicKey(''TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'');  DCA has not been tested to work with Token 2022 yet false false 
 associatedTokenProgram new PublicKey(''ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL''); false false 
 eventAuthority new PublicKey(''Cspp27eGUDMXxPEdhmEXFVRn6Lt1L7xJyALF3nmnWoBj'')  This is DCA Program''s event authority for Anchor  0.28.0 ''s event CPI feature. false false 
 program The DCA program itself  new PublicKey(''DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M'') false false', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/4-dca/2-dca-sdk.md', 'sidebar_label: DCA with SDK
description: Integrate Dollar Cost Averaging (DCA) in JS/TS with Jupiter. Streamline trading with our guide and practical code examples.
title: Integrating DCA (JS/TS) 

     Integrating Jupiter DCA With Javascript and Typescript 
     

 
 Following code is tested to work with 
 
 NodeJS v20
@jup-ag/dca-sdk@2.3.5
 
 To ease integration, you may want to use Jupiter''s  DCA SDK 
 The following example is for a NodeJS environment. This example can be adapted to work in a frontend browser application. The only difference is in how you sign and send a transaction. 
 Code example and description as comments in-line: 
 
 Create a project directory and install dependencies: 
 
 mkdir dca-bot
cd dca-bot
npm init -y
npm i @solana/web3.js@1 @jup-ag/dca-sdk@2.3.5 dotenv
 
 
 Create a Typescript file with the following: 
 
 import { CloseDCAParams, DCA, Network, type CreateDCAParamsV2, type DepositParams, type WithdrawParams } from ''@jup-ag/dca-sdk'';
import { Connection, Keypair, PublicKey, sendAndConfirmTransaction } from ''@solana/web3.js'';

const connection = new Connection(''https://api.mainnet-beta.solana.com'');

const dca = new DCA(connection, Network.MAINNET);
const user = Keypair.fromSecretKey(new Uint8Array(JSON.parse(process.env.USER_PRIVATE_KEY))); // create a .env file and include your wallet private key as an array

const USDC = new PublicKey(''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'');
const BONK = new PublicKey(''DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263'');

async function createDCA() {
  const params: CreateDCAParamsV2 = {
    payer: user.publickey, // could have a different account pay for the tx (make sure this account is also a signer when sending the tx)
    user: user.publicKey,
    inAmount: BigInt(5_000_000), // buy a total of 5 USDC over 5 days
    inAmountPerCycle: BigInt(1_000_000), // buy using 1 USDC each day
    cycleSecondsApart: BigInt(86400), // 1 day between each order -> 60 * 60 * 24
    inputMint: USDC, // sell
    outputMint: BONK, // buy
    minOutAmountPerCycle: null,  // effectively allows for a max price. refer to Integration doc
    maxOutAmountPerCycle: null, // effectively allows for a min price. refer to Integration doc
    startAt: null, // unix timestamp in seconds
    userInTokenAccount, // optional: if the inputMint token is not in an Associated Token Account but some other token account, pass in the PublicKey of the token account, otherwise, leave it undefined
  };

  const { tx, dcaPubKey } = await dca.createDcaV2(params);
  const txid = await sendAndConfirmTransaction(connection, tx, [user]);

  console.log(''Create DCA: '', { txid });

  return dcaPubKey;
}

// this is for withdrawing from program ATA
async function withdraw(dcaPubKey) {
  // it''s possible to withdraw in-tokens only or out-tokens only or both in and out tokens together. See WithdrawParams for more details
  const params: WithdrawParams = {
    user: user.publicKey,
    dca: dcaPubKey,
    inputMint: USDC,
    withdrawInAmount: BigInt(1_000_000),
  };

  const { tx } = await dca.withdraw(params);

  const txid = await sendAndConfirmTransaction(connection, tx, [user]);

  console.log(''Withdraw: '', { txid });
}

async function closeDCA(dcaPubKey) {
  const params: CloseDCAParams = {
    user: user.publicKey,
    dca: dcaPubKey,
  };

  const { tx } = await dca.closeDCA(params);

  const txid = await sendAndConfirmTransaction(connection, tx, [user]);

  console.log(''Close DCA: '', { txid });
}

async function main() {
  const dcaPubKey = await createDCA();
  console.log(''DCA Pub Key: '', { dcaPubKey });

  const dcaAccount = await dca.fetchDCA(dcaPubKey);
  console.log(''DCA Account Data: '', { dcaAccount });

  const dcaAccounts = await dca.getCurrentByUser(user.publicKey);
  console.log({ dcaAccounts });

  await dca.getBalancesByAccount(dcaPubKey);

  await withdraw(dcaPubKey);

  await closeDCA(dcaPubKey);
}

main();', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/3-limit-order/2-limit-order-api.md', 'sidebar_label: Limit Order v2 API
description: Limit Order v2 API reference list
title: Limit Order v2 API
slug: ./limit-order-api 
 Create limit order 
 Sends a POST request to the Jupiter Limit Order API to get the unsigned transactions needed to create an order. 
 
   
     
       POST 
       https://api.jup.ag/limit/v2/createOrder 
     
   
 Parameters in use in the below code example: 
 
 inputMint : The mint address of the input token (required). 
 outputMint : The mint address of the output token (required). 
 maker : The wallet address of the user who wants to create an order (required). 
 payer : The wallet address of who is paying to open an order (usually  maker ) (required). 
 makingAmount : Amount of input mint to sell (required). 
 takingAmount : Amount of output mint to buy (required). 
 expiredAt : Unix time in seconds that determines when an order should automatically close. 
 feeBps : Amount of fee that the  referral  collects. (Requires  referral ). 
 computeUnitPrice : Used to determine a transaction''s prioritization fee. Defaults to  auto . 
 referral : The public key where fees get sent to (Requires  feeBps ). 
 inputTokenProgram : Defaults to  TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA 
 outputTokenProgram : Defaults to  TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA 
 wrapAndUnwrapSol : Defaults to  true , if either input or output mints are raw SOL 
 
 Create limit order request body and response 
   type CreateOrder = {
    inputMint: string;
    outputMint: string;
    maker: string;
    payer: string;
    params: {
      makingAmount: string;
      takingAmount: string;
      // In unix seconds (e.g. Date.now()/1_000)
      expiredAt?: string | undefined;
      
      // Requires `referral`
      feeBps?: string | undefined;
    };
    computeUnitPrice: string | "auto";
    referral?: string | undefined;
  
    // Default: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
    inputTokenProgram?: string | undefined;
    outputTokenProgram?: string | undefined;
    
    // Default: true
    // Determines if SOL needs to be wrapped and unwrapped
    wrapAndUnwrapSol?: boolean | undefined;
  };
  
  type CreateOrderResponse = {
    order: string;
    tx: string;
  };
 
 Example response 
 {
  "order": "EWxFUCUAzvo2siM9gYVPWkaouvCfemwnwkfdVw2ib7JH",
  "tx": "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAJDgljyvLecNltZyLKJwcNk/0wjQipK4AUImvf2FZSxHIzDYJ0JdiFdLKUD0/uyu862mvKMrRGcmeB0hacZldr91rI1D6IwBADhxzCinLz0WuLrIJDCWIg/AajAnWXFcf8wi6Dlq1U1ClYCNsR8Xj0JlqSi9FGU0GP64HMzvBB8o/7Pc01wNmmSKitJONFP3gmdGbtde+pcSLhy7GOlMkI03UDBkZv5SEXMv/srbpyw5vnvIzlu8X3EmssQ5s6QAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZBpuIV/6rgYT7aH9jRhjANdrEOdwa6ztVmKDwAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpCsNKlsFmcVpgwSM+yiWKDfMLHshY4HRcc2oSYmZjSyIQiYnNzGGPBnZ0rGd+KZqtsSj+INnM2CjlCMnxv5sw68b6evO+2606PWXzaqvJdDGxu+TC0vbg5HymAgNFL11hkn9sh+xDEAWX2S7IDh4PwuUsi7/8dQ+DB2YEV+4zsuGS8LiUcikk5FUuAM3vpZjsAmrMZL3FPOcH2v4SeX3/fwQFAAUCoAMCAAUACQNd9AgAAAAAAAYGAAEABwgJAQEKDwAAAgMECwoMBwkJCAYNCiKFbkqvcJ/1n9vKKe2gGX+OAOH1BQAAAACA8PoCAAAAAAAAAA=="
}
 
 
 Cancel limit order 
 Sends a POST request to the Jupiter Limit Order API to get the unsigned transactions needed to cancel order(s). 
 
   
     
       POST 
       https://api.jup.ag/limit/v2/cancelOrders 
     
   
 Parameters in use in the below code example: 
 
 maker : The wallet address of the user associated to the order(s) that are being cancelled (required)`. 
 computeUnitPrice : Used to determine a transaction''s prioritization fee. Defaults to  auto . 
 orders : The public keys for orders that are intended to be cancelled. If not specified, this will generate the transaction(s) to close all orders associated to the  maker . 
 
 Cancel order(s) request body and response 
 type CancelOrders = {
  maker: string;

  // "auto" sets the priority fee based on network congestion
  // and it will be capped at 500,000
  computeUnitPrice: string | "auto";

  // Specific order account public keys to cancel/close
  orders?: string[] | undefined;
};

type CancelOrdersResponse = {
  txs: string[];
};
 
 :::warning
If no orders are specified, the API would return the unsigned transactions to cancel ALL open orders, batched in groups of 5 orders.
::: 
 Example response 
 {
  "txs": [
    "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAFCAljyvLecNltZyLKJwcNk/0wjQipK4AUImvf2FZSxHIzhJKWtj2HSC7RNPJa8OnDC9WWH6trCbp1C6qA4BUMaQ0ye0cXKemx6Yc1OP5dEP1Nac45/1jWuZvS7iawRDbqZgMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAACsNKlsFmcVpgwSM+yiWKDfMLHshY4HRcc2oSYmZjSyIGm4hX/quBhPtof2NGGMA12sQ53BrrO1WYoPAAAAAAAQbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpkn9sh+xDEAWX2S7IDh4PwuUsi7/8dQ+DB2YEV+4zsuG+7bRt16L/qXhIqNGmwpgUHcNL0fQRKYOGfN2TfXujaQMDAAUCoIwAAAMACQMIQAkAAAAAAAQJAAABAgQFBgcECF+B7fAIMd+EAA==",
    "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAFCAljyvLecNltZyLKJwcNk/0wjQipK4AUImvf2FZSxHIzhJKWtj2HSC7RNPJa8OnDC9WWH6trCbp1C6qA4BUMaQ0ye0cXKemx6Yc1OP5dEP1Nac45/1jWuZvS7iawRDbqZgMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAACsNKlsFmcVpgwSM+yiWKDfMLHshY4HRcc2oSYmZjSyIGm4hX/quBhPtof2NGGMA12sQ53BrrO1WYoPAAAAAAAQbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpkn9sh+xDEAWX2S7IDh4PwuUsi7/8dQ+DB2YEV+4zsuEWFbUelyswY5BEVZJ4BDbpIlxW2qs0WTxU97RD4F2/iQMDAAUCoIwAAAMACQNaTggAAAAAAAQJAAABAgQFBgcECF+B7fAIMd+EAA=="
  ]
}
 
 
 View open orders 
 This proxies the  getProgramAccounts  RPC method and returns all order (accounts) associated to the specified wallet. 
 
   
     
       GET 
       https://api.jup.ag/limit/v2/openOrders 
     
   
 Parameters in use in the below code example: 
 
 wallet : The wallet address to filter open orders by (required). 
 inputMint : The mint address of the input token. 
 outputMint : The mint address of the output token. 
 
 Example response 
 [
  {
    "account": {
      "borrowMakingAmount": "0",
      "createdAt": "2024-10-22T11:49:27.000Z",
      "expiredAt": null,
      "makingAmount": "50000000",
      "oriMakingAmount": "50000000",
      "oriTakingAmount": "100000000",
      "takingAmount": "100000000",
      "uniqueId": "3697202764802760127",
      "updatedAt": "1729597767",
      "feeAccount": "APWoLnZc8g8iXLA8qLdHJ4w42ybRrq2Vm8UGQhH7TJ3r",
      "inputMint": "So11111111111111111111111111111111111111112",
      "inputMintReserve": "4Q4Qv1KT1qrpHPydQcoPVoCD9FuCCPPbD211CTW43RVF",
      "inputTokenProgram": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      "maker": "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
      "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "outputTokenProgram": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      "feeBps": 10,
      "bump": 255
    },
    "publicKey": "9vWTg8y4UvrLM49rqvJ2mtmpxicPytNs7FD78352g9Kr"
  }
]
 
 
 View order history 
 Returns a list of all orders and the trades that filled them. The paginated response returns 10 orders at a time and indicates if there are more orders via  hasMoreData  boolean and the current page via  page  in the response. 
 
   
     
       GET 
       https://api.jup.ag/limit/v2/orderHistory 
     
   
 Parameters in use in the below code example: 
 
 wallet : The wallet address to filter open orders by (required). 
 page : Results are paginated in groups of 10, starting from page 1. 
 
 Example response 
 {
  "orders": [
    {
      "userPubkey": "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
      "orderKey": "E7EtgGdsdhSkkzAsSLxqWsG5Edc3n4FUL2SXWwPeN3hQ",
      "inputMint": "So11111111111111111111111111111111111111112",
      "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "makingAmount": "0.05",
      "takingAmount": "100",
      "remainingMakingAmount": "0.05",
      "remainingTakingAmount": "100",
      "expiredAt": null,
      "createdAt": "2024-10-22T07:48:06Z",
      "updatedAt": "2024-10-22T07:53:02Z",
      "status": "Cancelled",
      "openTx": "4c1vMT1NBs5jNqanjenshNq8LXsLV68KY4mbiizDuRn9rFGEjU8g8cerUTrsmzhu4aYebtp6NyuQgqwUSNpsexYw",
      "closeTx": "4engV35gYcKSDDM57hB4n6ZT3pLKshWSMckNh2tdHrbyKcJm6DUfBAFzufCei8sKWLHDc43dTLejHmkxvKseDW7a",
      "programVersion": "j1o2qRpjcyUwEvwtcfhEQefh773ZgjxcVRry7LDqg5X",
      "trades": []
    },
    {
      "userPubkey": "jdocuPgEAjMfihABsPgKEvYtsmMzjUHeq9LX4Hvs7f3",
      "orderKey": "8xZdAtCMNXXy7ijUfxFhNTzJBdUrC4DgmBWCwviJrgPG",
      "inputMint": "So11111111111111111111111111111111111111112",
      "outputMint": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      "makingAmount": "0.05",
      "takingAmount": "100",
      "remainingMakingAmount": "0.05",
      "remainingTakingAmount": "100",
      "expiredAt": null,
      "createdAt": "2024-10-22T07:48:05Z",
      "updatedAt": "2024-10-22T07:53:02Z",
      "status": "Cancelled",
      "openTx": "Pm98oGGxVwaBN5TaoadVArmr6eHRuWpjYUzws5PERbvmufHfAFevaisi17XXmfTSoMW2LUdn9RYmPknzp2ft8kM",
      "closeTx": "4engV35gYcKSDDM57hB4n6ZT3pLKshWSMckNh2tdHrbyKcJm6DUfBAFzufCei8sKWLHDc43dTLejHmkxvKseDW7a",
      "programVersion": "j1o2qRpjcyUwEvwtcfhEQefh773ZgjxcVRry7LDqg5X",
      "trades": []
    },
  ],
  "hasMoreData": false,
  "page": 1
}', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/docs_versioned_docs/version-old/3-limit-order/1-limit-order.md', 'sidebar_label: Integrate Limit Order v2
description: Master Jupiter Limit Order integration for efficient Limit Orders on Solana.
title: Integrating Jupiter Limit Order v2
slug: ./limit-order 
 Jupiter Limit Order v2 (LO) provides users with the simplest way to place limit orders on Solana and receive tokens directly in your wallet when the order is filled. 
 This page will serve as a general guide on integrating LO into your use case. whether you are building a bot for yourself or looking to integrate with existing (d)apps, Jupiter''s LO program will work regardless of programming language used. 
 Learn more about the mechanics of Jupiter''s LO  here 
 Start using Limit Order APIs:  here 
 
 Program Address 
 LO v2 Program (mainnet-beta): j1o2qRpjcyUwEvwtcfhEQefh773ZgjxcVRry7LDqg5X 
 
 Create Limit Order API Walkthrough 
 This guide will show you how to create limit orders using Jupiter APIs. It also applies to canceling orders. 
 Install Required Libraries 
 We recommend using NodeJS >= 18 for the native  fetch  API 
 npm install @solana/web3.js bs58 dotenv
 
 We recommend  NodeJS >= 18  for native  fetch  support. 
 You can use any of these package managers: 
 
 bun  —  bun automatically reads  .env  files 
 npm 
 pnpm 
 yarn 
 
 Import Libraries and Set Up RPC Connection 
 import {
  Connection,
  Keypair,
  SendOptions,
  VersionedTransaction,
} from "@solana/web3.js";
import bs58 from "bs58";

const RPC_URL = process.env.RPC_URL;
if (!RPC_URL) throw "missing RPC_URL env var";

const RPC_CONNECTION = new Connection(RPC_URL);
 
 For TypeScript, these are the request body and response types that can be used. 
 type CreateOrder = {
  inputMint: string;
  outputMint: string;
  maker: string;
  payer: string;
  params: {
    makingAmount: string;
    takingAmount: string;
    expiredAt?: string;
    feeBps?: string;
  };
  computeUnitPrice: string | "auto";
  referral?: string;
  inputTokenProgram?: string;
  outputTokenProgram?: string;
  wrapAndUnwrapSol?: boolean;
};

type CreateOrderResponse = {
  order: string;
  tx: string;
};
 
 Set Up Your Wallet 
 Set up your wallet by decoding the private key from a base-58 string.
Do  not  use private keys directly in production. 
 const WALLET_PRIV_KEY = process.env.WALLET_PRIV_KEY;
if (!WALLET_PRIV_KEY) throw "missing WALLET_PRIV_KEY";

const wallet = Keypair.fromSecretKey(bs58.decode(WALLET_PRIV_KEY));
 
 Get the serialized transactions to create the limit order 
 Here we will do the following: 
 
 Create the request body, 
 Submit it to the API server, 
 Deserialize the transaction from the response, and 
 Sign and submit the transaction on chain
Do note that steps 2-4 are asynchronous and may reject. It is recommended to wrap this section in a  try-catch  block and handle the errors accordingly. 
 
 Creating the request body 
 In this example, we are creating a limit order to buy 100 USDC for 0.05 SOL with no expiry and using  auto  for the  computeUnitPrice . For advanced users, you may specify a numerical  computeUnitPrice . 
 const createOrderBody: CreateOrder = {
  maker: wallet.publicKey.toBase58(),
  payer: wallet.publicKey.toBase58(),
  inputMint: "So11111111111111111111111111111111111111112",
  outputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  params: {
    makingAmount: "50000000", // 0.05 SOL
    takingAmount: "100000000", // 100 USDC
  },

  // "auto" sets the priority fee based on network congestion
  // and it will be capped at 500,000
  computeUnitPrice: "auto",
};
 
 Send request to API server 
 Ensure that the method of the request is  POST  and that the body of the request is a stringified  CreateOrder  type. 
 const fetchOpts: RequestInit<RequestInitCfProperties> = {
  method: "POST",
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json",
  },
  body: JSON.stringify(createOrderBody),
};

const response = await fetch(
  "https://api.jup.ag/limit/v2/createOrder",
  fetchOpts
);
 
 Sign and submit the transaction on chain 
 Sending the transaction on chain does NOT mean that the transaction is successful. We recommend using the hash returned from  RPC_CONNECTION.sendRawTransaction()  and: 
 
 Check if the hash appears on an explorer, or 
 Use  RPC_CONNECTION.confirmTransaction() 
 
 Note that transactions may not appear on chain for some time. We recommend retrying (repeat the entire flow) only if the transaction has landed on chain but has failed (likely due to an invalid input), or if the transaction does not appear on chain after ~2 minutes*. 
 // Deserialise base64 tx response
const { order, tx } = await response.json<CreateOrderResponse>();
const txBuff = Buffer.from(tx, "base64");
const vtx = VersionedTransaction.deserialize(txBuff);

// Sign with wallet
vtx.sign([wallet]);
const rpcSendOpts: SendOptions = { skipPreflight: true };
const hash = await RPC_CONNECTION.sendRawTransaction(
  vtx.serialize(),
  rpcSendOpts
);', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-01-24-bonk-update.md', 'slug: bonk-update
title: "$BONK Update" 
 As per the  original announcement , we have been hosting a discussion on this topic in  #bonk , and we had a wide range of opinions around both the proposed plan and how to best execute it. 
 We would like to give a big thanks to everyone, including the BONK community, users, and the BONK core contributors for coming together to discuss this very tricky situation, and especially for everyone’s understanding of this dilemma we found ourselves in. 
 
 After a week of intense debate, 3 things became pretty clear: 
 
 Views are very divided, one of which is the perspective of burning everything or not retrieving the tokens at all, since it was already misplaced, with the other one to distribute them 100% immediately. It is clear that compromise will be needed. 
 ​​It was important for us to ensure that the tokens would be distributed where it was intended while also reaching an agreement that would be acceptable to the BONK core contributors and community to avoid a holy war, which would have benefitted no one. 
 Lastly, it became clear from the discussion that we cannot take custodianship of this at any cost, so the best thing to do would be to allow the core contributors to claim the tokens, with the understanding that the tokens will be distributed accordingly 
 
 We believe that a good course of action will be to proceed with the Jupiter program upgrade to allow the BONK core contributors to claim the tokens and facilitate the staggered distribution as per the original plan. This obviously requires tradeoffs from all sides, but this was a reasonable outcome for the majority of folks in the channel. 
 Lastly, we are extremely gratified by the chance to be of service to our users, as well as the opportunity to interact with the bonk contributors and community to work through this together. Great times lie ahead for the ecosystem. Let''s grow it to new heights together!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-01-13-bonk-retrieval-and-distribution-plan.md', 'slug: bonk-retrieval-and-distribution-plan
title: "$BONK Retrieval And Re-Distribution Plan" 
 At Jupiter, we are big fans of the BONK community and we deeply appreciate the energy it has brought to the Solana ecosystem.  We have also been strongly supportive of the community, including  burning the BONK fees  we collected from limit orders placed on our platform. 
 Late last week, we discovered that BONK tokens were airdropped to Openbook open order accounts rather than to the user accounts they were intended for. Since most traders use Openbook via Jupiter, a large portion of these tokens  (10T $BONK)  were airdropped to open order accounts managed by the Jupiter program. The full list of open order accounts and the respective accounts those were created for can be found  here . 
 
 Upon investigation, we realized that we would be able to potentially help the original targeted recipients retrieve the tokens by performing an upgrade to our program. We then reached out to the BONK core contributors to perform a full post technical post mortem and discussed what is the best plan forward. 
 Given the large amount of tokens at stake and the current phase of the market and ecosystem development, it appears that re-distributing all the tokens all at once might have the detrimental effect of causing a crash that might be hard to recover from, which will benefit no one, including the original targeted recipients and the Solana ecosystem. 
 As such, along with the BONK early contributors, we would like to propose a plan to help the original recipients claim the tokens in a way that would have the least impact in the market and give the BONK ecosystem to further build up liquidity and trust in the market. 
 It is important to note that Jupiter is not a current custodian for the tokens and has nothing to gain from this plan - we are here both to help the targeted recipients get their $BONK and also the project to maintain the great energy and momentum. 
 While it is of course not ideal that the tokens were uncovered so late in the launch cycle, we believe that if we put on a united front, this will end up being a net positive for all the key stakeholders - including the targeted recipients, BONK community, n the Solana ecosystem. 
 This post will outline the timeline of events, the full technical details of what happened, and an assessment of the current market and proposed plan. 
 Timeline Of Events 
 
 Dec 25th 2022 - BONK  Airdrop  to OpenBook Open Order Accounts 
 Jan 6th - Jupiter discovers  $BONK tokens sent to Jupiter-managed OO accounts. We initiate an investigation to see how many token was sent, to which accounts, and to see if these tokens are retrievable. 
 Jan 6th - Jupiter contacts the BONK core contributors to discuss how best to distribute the token airdrop to the original recipients. 
 Jan 7th -  Joint tweet  by BONK and Jupiter to make the community aware of the situation. 
 Jan 12th - Release of the proposed plan to redistribute to the intended recipients moving forward. 
 
 Technical Details 
 
 The query the BONK core contributors used to build their list of wallets executing transactions with the OpenBook Program inadvertently pulled in the open orders accounts used to hold the order information for trading on a market on OpenBook. 
 When a user trades on OpenBook with Jupiter, Jupiter creates and uses a Programmed Derived Address  (PDA)  to create the open orders account needed to execute the trade. Using a PDA allows the Jupiter program to sign for the address without needing a private key which allows the program to manage these accounts so users don''t have to, greatly simplifying the user experience while not having any security or custody implications. 
 When $BONK was airdropped to these Jupiter open orders account, it created an Associated Token Account  (ATA)  for these Jupiter PDAs to store the token. 
 In order to access the $BONK held in these ATAs, we will need to update the Jupiter program to allow the tokens to be claimed as only the program can manage these accounts. The latest Jupiter program  (V4)  has an update authority held by us. 
 We maintain update authority on our latest programs in order to regularly add new DEX integrations, fix issues, and work on new features. This also allows us to correct the 10T airdrop and deliver it to the intended recipients. 
 
 Market Assessment and Proposed Plan 
 As mentioned, given the large amount of tokens at stake and the early stage of the market/ecosystem - a plan to distribute all the tokens at once could have the effect of creating a major crash even before the tokens are retrieved and released - benefitting no one and potentially stopping the nascent BONK project. As such, along with the BONK early contributors, we would like to propose a plan to redistribute to the intended recipients of the original airdrop that mitigates potential market fears while giving the BONK community time to build further confidence in the token and the project. 
 The plan is as follows: 
 
 We will work on retrieving the tokens sent to the OpenBook open order accounts 
 Set up monthly releases over 12 months because a staggered release will release tokens in a manner that is absorbable by the market, and we believe that the community and ecosystem will continue to mature in the meantime 
 The first release will be performed next week to give us enough time to set everything up and for the market and community to digest the news 
 Additional incentives will also be provided for these recipients, as long as they continue doing a minimum number of trades that route through OpenBook. 
 
 Besides  (3)  which will also help to spur ongoing usage of OpenBook, the BONK contributors will also be aiming to assist software development of the project, which aligns with the original intent of sparking OpenBook development. 
 
 Next Steps 
 We would like to get feedback on this plan from both the targeted recipients and the BONK community. We have opened up a dedicated channel called #bonk in  our discord , so feel free to chime in there! 
 After the plan is finalized, we will proceed to retrieve the tokens on behalf of the users and set up a site to allow recipients to claim tokens as they are released monthly. 
 Of course, it would have been ideal if all tokens would''ve been received simultaneously, but it is now a chance for us as a community to come together and come out stronger from this.  After the many blows suffered by the crypto community (in particular Solana), $BONK has brought much excitement to the market, and we appreciate the chance to play our part in helping this along. 
 We would love to see everyone involved in this to work together to keep the great energy going, and create a long term sustained effort towards creating more great tokens and communities for the Solana ecosystem, helping it get to new heights too!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-12-15-jup-pie-cats/index.md', 'slug: jup-pie-cats
title: "Jup Pie Cats" 
 Over the last week, as everyone in the world was hunting me for JUP updates, I must confess to being very inspired by this video instead. 
 
 I mean, check this out - the level of care he takes to get the cat ready is exquisite. The cat is now well-fed, very clean, and at peace. And that’s a cat ready to tackle the incredibly messy world ahead with all kinds of possibilities and adversities. And that’s the amount of care we aspire to get Jupiter to as we ready for JUP. 
 As much as we would love to just launch JUP and get back to building world-class tech, we also want to make sure all the key things that are important to us - the token distribution, the ethos, making sure no one is left behind - are clearly decided, communicated, and clarified, because things are really quite different after the genesis moment. 
 Some of these are pretty controversial topics, but that’s the whole point of me highlighting them now. I hope to have these discussions as early as possible so we start JUP with as much common understanding and alignment as possible across every part of the stack. I will be on Discord and Reddit as much as possible over the next few days to debate, discuss and clarify anything. 
 Because, as I have said from day one, this is not just my journey, this is ours. 
 JUP 
 Since cats have small brains and did not go to MIT or Jane Street, we cannot process super complicated token plans and confusing power dynamics. 
 So instead, here’s a pie with cats: 
 
 Tokenomics reflect the ethos of a project, and our key ethos is as simple as it gets - For a project like Jupiter, there needs to be an equal weight between a focused entity able to constantly recruit world-class talent, build product, and execute strategy, and a wider community able to fact-check, counterweight, and help to course-correct. 
 As such, the 10B JUP will be 50% managed by the team, 50% distributed to the community. Perfectly balanced, as all cats should be. 
 
 We believe this balance will be extremely important to the long-term success of Jupiter. The community needs to trust the team and give room for maneuver, while the team needs to trust the community and invite everyone to be genuine stakeholders. Without this understanding, it will just be endless angst on both sides, the root cause of the classic “devs do something” phenomenon. 
 The major change from the green paper is that there is no more token sale. Instead, the 20% will now be divided between 10% for liquidity provision, and 10% for community contributors and grants. 
 For the team managed component, only the 10% of liquidity provision will be used in the first year. The 20% for the current team will start vesting after a year for 2 years. The remaining 20% will be the strategic reserve, used for future team members, future strategic investors, and for past Mercurial stakeholders. 
 The last component will be locked for at least a year, with a minimum of six months'' notice given to the community before any liquidity event can happen. Each of these pools will be held in separate muti-sigs for easy trackability by the public. 
 For the community component, we expect 40% to be broken up over 4 rounds of “growing the pie” airdrops. We are very excited about the availability of 10% for community contributors and grants - this allocation, likely given to the DAO to administer, should give a lot of incentive for the community to participate in initiatives to grow Jupiter, vet projects for the Solana ecosystem, and drive the decentralized meta - all of which are our main objectives. 
 I’ll share more thoughts and a proposed roadmap on how the DAO can incrementally grow in terms of scope, participants, responsibilities to become what I hope can become the most productive DAO in the history of crypto not just for Jupiter but for advancing the whole crypto ecosystem forward. 
 It will take time, years, but based on what I’m seeing so far, I’m actually incredibly bullish our DAO can get there. Slowly and incrementally for sure, but we will. One reason why I’m so bullish on this is because of the unique, positive, expansive vibes of the Jupiter and Solana community. Will elaborate more next time. 
 Now that there is no more presale, the launch will be very simple. 15-20% will be circulating initially. 10% is from the first airdrop and 5% for liquidity provision, which will either be mostly or entirely on-chain. We are also leaving open the possibility of having up to 5% more liquidity be available at launch. Details for claiming and the mechanism for liquidity provision will be shared over the next couple of weeks. 
 We would like the launch to happen in Jan, and currently coordinating with a range of partners to make it happen. 
 The Decentralized Meta 
 At Jupiter, we want to be a leading force in driving the decentralized meta forward - aka a world where everyone not just buys crypto, but actually uses crypto in their daily life as well. 
 As the best trading venue in crypto  (and since the first thing everyone does is trade) , Jupiter is the ideal spear tip for leading the charge, and we will need plenty of  PIE : 
 
 Products that r better than centralized versions 
 Incentives to attract masses to try the meta 
 Ecosystem of awesome projects on Solana 
 
 Given the massive amount of PIE needed to convert the masses to the decentralized meta, I would like to align on the key ethos and ideas we need over the next few years in order to help the space generate enough PIE to make it happen. 
 Ethos 1: Grow The Meta 
 Over the last few interviews, I have always been clear about using Jupiter and JUP as a core leverage point for driving the decentralized meta. 
 https://x.com/0xMert_/status/1733348900113711610?s=20
https://x.com/goodgamepodxyz/status/1732424198759600136?s=20 
 When people start to use Jupiter for whatever reason, they don’t just use Jupiter, they take a step into the increasingly unlimited potential of decentralized technologies - a world that’s so utterly different from the ones they are used to. 
 One thing that has been disappointing for me is engaging in conversations over the past 2 weeks where there were many airdrop recipients who had been extremely against starting the second growth airdrop purely for the reasons of being afraid that their own bags will be diluted - to the point of labeling new users as “airdrop farmers”, and calling themselves “loyal users”. 
 Protectionism sure starts early, but let’s not play into it. Careful and strategic emissions are of course crucial, that’s why we are fostering a tight culture of communicating strategy and getting feedback for every major phase, and why the interplay between the community and team is going to be crucial. 
 But to fight for your own bags exclusively so early in the game and to draw a line between users so early without consideration of the “grow the pie” ethos we need to set as well as the broader strategic vision is honestly not cool. 
 Also, it is my view that the max possible gains for the next couple of years will not be to focus on JUP utility, but rather brainstorming how to leverage JUP for maximum growth of Jupiter, Solana, and the decentralized meta - for the possible space is far, far bigger than we can imagine. 
 On that note, BONK is a really good example of what can happen when we take an expansive view of the universe, vs a constructive narrow perspective, for the universe strongly favors positive growth. 
 We will accept growing the meta strategically and pragmatically as one of our responsibilities - and JUP is one crucial leverage point we can use. 
 Ethos 2: Build A Secure Team 
 A cat that can hunt on its own is always going to be far more secure than a cat that needs to be fed constantly. 
 We would like Jupiter to be a world-class team that has strong revenues and hence operationally independent from the need to constantly fundraise for the sake of salaries and opex. That will set us up to be able to make the long-term decisions and build the amazing products that match up with our intentions to be a positive force for decades. 
 The core swap aggregation, which is a crucial part of Solana liquidity infrastructure, has always been and will always be completely free, much like Google’s search. In a DeFi first, we released the binary for free unrestricted usage 2 weeks ago, and will be taking more unprecedented steps next year to make it even more of a community resource. 
 Jupiter charges fees for limit orders, DCA, and perps and will keep these fees as team revenue. All fees will of course be tracked on-chain and fully visible on dashboards we will be publishing. Any investments made by team members have to be clearly reflected to avoid any semblance of conflicts of interest, particularly when it comes to Jupiter Start projects. I will personally refrain from making investments this year. 
 Due to the capped AUM for JLP, liquidity for perps can be rather limited at times, making it difficult to place positions. In addition, demand for JLP is extremely high, so the pool fills up extremely fast, in the matter of minutes every time we raise. 
 As a result, though, users are often unable to place positions and face rather high fees when placing positions. While we are working very hard to improve the system and increase the cap, being responsible and increasing the cap incrementally remains our top priority. 
 Thankfully, there are a range of excellent perp protocols on Solana, including  @zetamarkets ,  @DriftProtocol ,  @mangomarkets , and many more upcoming ones like  @FlashTrade_  - all of whom are our good friends, and we will do our best to encourage growth of the overall perp markets in Solana, not just our own, starting with an Educate program for Zeta next week. 
 In fact, after discovering the potential of on-chain perps on Jupiter, users are experimenting with various protocols, and learning what we have always known - Solana is by far the best place in crypto for on-chain perps, bar none. This will also get much better as liquidity on-chain increases exponentially over time. 
 Ethos 3: Help The Solana and Crypto Ecosystem 
 We do not see ourselves as a platform/product/protocol per se, but rather as a full-stack ecosystem push to help the Solana and crypto ecosystem win. 
 We will do so in 3 main ways: 
 
 Help make Solana the most used blockchain 
 Provide full array of world-class trading products 
 Help new projects win via Jupiter Start 
 
 We believe Solana is the best blockchain for onboarding the next billion users. And when we draw people to using Jup, they also end up using everything else on Solana. 
 And when we have a full set of powerful trading products that work as well as their centralized counterparts, they have no reason to go back to CEXes. 
 And when there is a critical mass of use cases and fun stuff you can do on-chain, there will be increasingly fewer reasons to pull your capital out. 
 Lastly, we can move the entire crypto space forward by being a shining example of what decentralized products, ethos and communities can do, hopefully playing a part in moving past the bad examples set by the last generation of fallen kings. 
 If not us, then who? 
 No Cats Left Behind 
 Over the past 5 weeks, we have spent enormous effort on making sure that everyone involved so far will be part of the journey at the very beginning. There are 3 main groups: Mercurial Stakeholders, Jupiter Users and Community Contributors. 
 
 Mercurial Stakeholders
For those who are unaware, Jupiter is a new project started when we were working on Mercurial  (which transited to Meteora on Feb 23) . Here are a couple of posts summarizing the background: 
 
 https://twitter.com/0x__fp/status/1721491581872586992
https://twitter.com/_ilmoi/status/1730789327456678330 
 Last week, after many rounds of public and private discourse, we finalized the 5% JUP position for Mercurial stakeholders (as of Feb 2023), which will come from the strategic reserve managed by the team. We also communicated the decision accordingly both to early Mercurial investors as well as in the Meteora discord. 
 https://meteoraag.medium.com/update-for-mercurial-stakeholders-as-of-feb-2023-2bf091627e52
https://discord.com/channels/841152225564950528/981108341482868736/1183160599073529926 
 https://discord.com/channels/841152225564950528/854683268519559189/1183176837019484230 
 NGL, it was extremely gratifying to connect with and get the approval of community members who have been part of the journey since very early on. Afterall, this has been one heck of a journey and these are absolute OG legends like  @durdenwannabe ,  @PigFahy ,  @0xSoju  and  @adidogceo  who have been with us through the entire cycle! 
 Besides the JUP position, Mercurial stakeholders will also be the starting holders of  @MeteoraAG , which after 2 years of absolutely relentless hard work (led by the incredible  @hellochow ,  @sudoku_defi ) and many other super talented team members is gaining great traction in terms of product, community, and DAO formation. 
 https://x.com/MeteoraAG/status/1730784233885474869?s=20
https://x.com/MeteoraAG/status/1735538511736889434?s=20
https://x.com/adidogCEO/status/1733658028509917215?s=20 
 I aim to write a full blog post about the founding history of Jupiter next week, and the various twists and turns leading to where we are currently. A podcast with  @SolanaLegend  focused on this historical period will  be released next week as well. 
 I deeply thank everyone who had been involved from day one, and particularly, the critical voices that have been instrumental in guiding us towards the final arrangement. Even if the criticisms have been extremely hard to swallow and felt very unfair at times, I doubt that I would have got it right if not for those voices. 
 Lastly, if you are a Mercurial stakeholder as of Feb 23, and you are not sure how to participate in the coming events, please reach out, we will spare no effort in making sure you are all caught up. 
 
 10K Community Airdrops Review Requests
The other thing we have been spending a ton of time on is the 10 thousand community airdrop review submissions, and we are finally almost done, thanks to the ungodly effort put in by  @9yointern . 
 
 AFAIK, we were the first project to openly debate the airdrop mechanism, to openly explain the criteria used, and also the first to open up a mechanism to allow people to protest the criteria. This is of course actually tremendously time-consuming and tiring, but we think it is an important process because we want to make sure we really tried our best to take into account every single point of view as well as do our best to address every complaint that came in. 
 The final allocations will be released tomorrow by   and there will be no more changes afterward. One thing here - do not harass our intern any further, regardless of your unhappiness. 
 She’s the most patient, anon-loving, SQL-churning, pepe-aware intern in the world, and everyone needs to appreciate the immense effort she put into it. We are normally pretty chill, but any mean messages will result in your airdrop being zeroed. Some things just cross the line, especially if someone super nice is trying her goddamn best. 
 Another major area of concern were also those with compromised accounts. There is no way to solve this totally elegantly, but what we will do for now is to not allow claiming on those wallets at the onset, and will likely have some kind of social media identification process and allowing claiming if there isn''t any double claims. 
 
 Community Contributors
Finally, next week there will be a site for anyone who has contributed meaningfully to Jupiter prior to Nov 2nd to connect their Twitter, Discord, and associated wallet address. 
 
 Similarly, this part will take likely take 2-3 weeks to finish reviewing, and will be a tremendous use of effort on our end. But yet, as I mentioned in one of the recent podcasts - it is important for me because I would really like to recognize everyone who took the extra effort to help Jupiter out, even when we were just a product with absolutely no indications of rewards whatsoever. 
 It means a fuck ton to us, and I will try my best to make sure you are recognized in one way or another.🩷 
 JUP FOR JUP 
 At Breakpoint, I presented our  “Grow The Pie”  presentation and green paper. Ever since then, we have been flooded with an absolutely incredible level of feedback, and we are extremely grateful for the energy and enthusiasm that everyone have shown us. Of course, all the wens and airdrop demands can get pretty intense at times, but it''s all part of the job. 
 To all the airdrop recipients, we are very grateful to be able to provide a present, and it is gratifying to hear from some of you regarding how it could being a really big difference in your life. That’s exactly what we are here for! 
 Also, I understand some of you are very anxious to claim it and maybe liquidate it for more stable assets. Don’t worry, it will happen soon in Jan, and we will do our best to make the whole process as seamless as possible and even make it as easy as possible for you to sell it or easily set the price you want for your JUP. 
 My only request is this - I hope you keep at least a bit of genesis JUP from the airdrop, because regardless of anything, you were an important part of the early journey. It will mean a lot to us if everyone involved at the beginning kept at least a bit of JUP with them. That way, we can keep in touch as we go through the coming years together. 
 Tokens are fungible, memories are not.🐱', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-07-27-jup-v3-metis-routing-algo/index.md', 'slug: jup-v3-metis-routing-algo
title: "Jupiter v3: The Metis Routing Algo"
description: "Explore Jupiter Metis Routing V3 for enhanced DeFi trades on Solana. Enjoy reduced slippage, DCA integrations, and advanced features." 

     Jupiter Metis Routing: V3 Crypto Swaps on Solana 
     

 
 Today, we are excited to announce Jupiter v3, which introduces Metis, a novel routing algorithm that further enhances our industry leading aggregator. Metis significantly improves route discovery for all pairs, substantially reduces slippage for large trades, and offers vastly improved scalability in preparation for upcoming Solana upgrades and new DEXs. 
 In order to be able to support Metis to run on Solana’s hyper fast blocktimes, we have also made major improvements to our backend infrastructure. In addition, we also introduce the Dollar-Cost Averaging beta, the testing of a new contract that removes the need for users to have intermediate token accounts, integrations of Limit Orders into our routing, the Jupiter space station and several new features that’s based on user feedback. 
 The upgrade, coming only a few months after v2, embodies our efforts to push the boundaries of Solana to offer the most powerful yet simple experience in all of crypto, and build a genuine CEX replacement to help with the inevitable migration to come. 
 This is obviously a mega update so let’s dive right in! 
 Metis 
 Today, we introduce Metis, our new advanced routing algorithm, a heavily modified variant of the  Bellman-Ford algorithm  catered for the key requirements of offering best price routing at scale in a very dynamic operational space. 
 Key Features 
 Incremental Route Building 
 To find the best price, Metis streams the input tokens to incrementally build a route to split and merge at any stage. By generating the routes for each split iteratively one after another, we can also use the same DEX in different splits - allowing us to find routes with better prices with more complex trades. 
 
 Combine Route Generation and Quoting 
 To improve the efficiency of the algo, we combine route generation and quoting into a single step, allowing us to avoid generating and using bad routes, which besides improving the efficiency, also allows us to use a larger set of tokens as intermediaries. 
 Future Proofing 
 v2 runs fast when the total number of DEXs used is small since Solana limits us to use at most 4 DEXs in a swap  (due to the account lock limit of 64) . Future Solana upgrades will relax this limit and allow more DEXs to be used in a single transaction. In addition, we foresee the continued growth of the Solana DeFi ecosystem, which means there will be many more DEXs emerging. 
 With Metis, we are well equipped to be able to handle both these trends, since the algorithm is able to scale to include more DEXs in a route when account lock limits are increased, and can support more DEXs with only a modest increase in running time. 
 
 Infra Upgrade 
 In addition, determining the cost per hop for various amounts of splits is obviously a major challenge, since there are many potential outputs for different amounts, including for vastly different liquidity venues like CLOBs and CLAMMs, and getting quotes from lots of AMMs is slow, which limited the scalability of the system.  To resolve this, we embarked on a major infra upgrade to refresh quotes in parallel and in real time. 
 Performance Improvements 
 The system has undergone rigorous testing over the past few weeks in production. At the same time, we have been benchmarking the performance of the algorithm. On average, Metis quotes prices that are 5.22% better than our v2 engine, with the improvements increasing sharply based on the trade size. 
 
 Powering Liquidity On Solana 
 And of course, this kind of insanely powerful engine will be completely out of reach for the average user in most other platforms, given the high level of gas cost this will incur. On Solana, the cost to the user will remain small and miniscule. 
 In addition, an great routing engine is crucial for DeFi in so many ways - liquidations require single transactions for large amounts to be as efficient as possible, new DEXs need a fair chance to be leveraged for volume as the more established ones, and of course, we need to keep on pushing the limits of Solana, so more people understand how powerful shit can get! 
 
 DCA (Dollar-Cost Averaging) 
 Secondly, we are also delighted to introduce our DCA Beta, a non-custodial, on-chain dollar cost averaging solution to automate the purchase or sale of any token. 
 
 How it works 
 If you choose to use USDC 900 to buy SOL daily over 9 days, 900 USDC will be transferred from your wallet to the non-custodial program and executed over the next 9 days. 
 
 Your first order to sell 100 USDC for SOL will take place immediately at the best price available then. 
 Your second order to sell the next 100 USDC for SOL will take place approximately 24 hours after the initial order at the best price available then 
 Subsequently, 7 more orders will all take place approximately 24 hours after the previous order until the full DCA order has been executed. 
 
 Ease Of Use 
 As with all Jupiter systems, we aim to make very complex transactions as simple as possible. You will automatically receive purchased tokens in your wallet within the same transaction of each order and a link to the blockchain transaction will be visible to you on  jup.ag . 
 Also, during the last order of your DCA, any remaining tokens will be sent to you and all program related accounts opened for your DCA will be closed and the rent returned to you automatically. 
 Notes 
 
 To ensure best price execution, DCA keepers use Jupiter and also perform price checks against an external price data provider i.e. Birdeye. 
 To prevent people from querying and hijacking the order right before the order is about to be executed, orders have a + 2 ~ 30 second variability. 
 Note that there is a 0.1% keeper fee for DCA order executions, only taken upon successful completion. 
 You can read more about key details like fees and technical implementation here 
 For the Beta phase, we’re limited to trade only the Top 20 tokens, with a cap of $5,000 USD for each DCA order. We will progressively increase the number of support tokens and lift the order size limit as we move out of beta. 
 
 :::tip Beta phase!
DCA is still in beta! So please give us as much feedback as possible to help us help everyone accumulate as much SOL as possible! :D
::: 
 
 Limit Order Integration Into Jupiter 
 At Jupiter, we aim to build the easiest limit orders in DeFi. Over the last couple of months, we have been steadily improving Jupiter limit orders behind the scenes, particularly on vastly improving the efficiency of the path discovery and order execution. Now, we are happy to share that Jupiter Limit Order has been integrated into Jupiter. 
 Jupiter will now compare Jupiter LO orders with the quoting engine quote price to provide users with the best possible price. This feature is especially useful for large limit orders, as they can be split, quoted, and filled by multiple Jupiter swaps. This improves the fulfilment of orders at the best price from both ends. 
 For example, there is a 20k USDC - RLB sell order here, being matched directly with one of the Jupiter Limit Order. Since this is the best price possible in the whole market, anyone will be able to take this order with zero slippage if they want to buy RLB. 
 
 We will continue to make major improvements to the limit orders over the next few months - improving it in terms of functionality, order discovery and usability. We cannot wait to make the easiest limit orders in DeFi even better than ever! 
 
 
 Jupiter Space Station 
 Jupiter Space Station is a comprehensive resource for everything related to Jupiter, all in one place for easy access! 
 
 Our station includes: 
 
 Statistics about Jupiter 
 Guides to using Jupiter Products 
 Development docs 
 Integration guidelines 
 List of partners 
 
 Open Contribution 
 In addition, it is an open-source system that allows anyone to contribute. You can add your protocol to the partners page, create an ELI5 user guide, or report an error in the syntax. Contributing is easy - simply add a pull request to our GitHub repository and help us make Jupiter Station even better. 
 Here are some examples of how our friends and users have contributed so far: 
 
 An insightful  article  authored by SolanaFM on how to verify transactions using block explorer. 
 Sphere  adding  their protocol into the partners page. 
 Enhancing our homepage with more  content . 
 
 We will be constantly improving this page, in our quest to make this the all in one and most helpful resource for everyone. In particular, we will be adding a community section too, to share a lot more about how the community can contribute! 
 
 New Improved Features 
 Jupiter v3 also features a number of smaller but important improvements based on user and developer feedback. 
 Feedback Mechanism 
 We have a direct feedback channel on top of our Discord support. Whenever a transaction or swap fails, there will be a quick button that prompts a feedback form. This allows users to inform us of any issues they are facing. If you miss the toast message, you can find the feedback form on the bottom-right of the site. The feedback form goes directly to the team. If you require a prompt response, please reach out to us through our official Discord channel. 
 
 Fallback Mechanisms 
 Aggregator works with a dozen DEXs and AMMs, and sometimes, DEX/AMM errors can cause certain routes to fail, resulting in the swap failing to go through. To improve this, our fallback mechanism will exclude any affected DEX/AMM causing errors in our trading routes and immediately refetch a new quote. Traders can then execute the new route and perform the swap without any issues. We have extended this mechanism to both Ver. Txn and Legacy routes to ensure a seamless trading experience for all our users. 
 
 Expanded Market Selection 
 To optimise for a safer and more robust trading experience, we previously set a strict criteria for the pools and markets where we stimulate swaps between $250 worth of tokens, with no more than a 70% loss/price difference. In our latest update, we are also including tokens that have already had liquidity elsewhere, as well as markets with single-sided liquidity of $1,000 within 20% of market price. 
 Shared Intermediate Token Accounts 
 We are testing a new contract that will leverage shared intermediate token accounts. The need for manually opening up intermediate token accounts has been a pain point for users given the initial setup cost and high number of potential swap failures. The new shared account feature streamlines the integration process and brings cost-saving benefits to partners and users alike. 
 Summary 
 With v3, we carry on the 3 core Jupiter traditions: 
 
 Upholding the JUP Promise (Best price, Best selection, Best UX) 
 Pushing the limits and possibilities of Solana 
 Introducing super easy to use, yet powerful features for the user 
 
 Again, nothing will ever be perfect or done, so your feedback is super important to helping us improve - the good, bad and ugly. We will work with everyone to ensure that no matter what, Solana will be home to the very best swap experience in all of DeFi and beyond.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-11-02-green-paper/index.md', 'slug: green-paper
title: "Jupiter Green Paper" 
 
Slides presented at breakpoint 2023 can be viewed  here 
 Growing the Pie 
 In this paper, we share an overview of what Jupiter has built in the past year, our ethos and our strategic direction for the future. **This paper serves a consultative purpose. We want to invite you to engage in dialogue with us, and contribute to shaping the future of Jupiter and its role within the Solana ecosystem. ** 
 We will be also introducing for the first time  $JUP, Jupiter Start and Jupiter Labs . We hope that the details in here will serve as a catalyst for fruitful discussions. 
 Today, Jup.ag is the default destination for traders on Solana. We have the best aggregator in crypto and the most seamlessly integrated platform in Solana – powering a variety of trading activities, including but not limited to swaps, limit orders, dollar cost averaging strategies and more ... 
 
 2023: Building the Best Decentralised Trading Experience 
 In the depths of the bear market in November 2022, we decided to double down on Solana. The collapse of FTX underscored the urgent need for a trustless alternative to centralised exchanges (CEX). And we believe that Solana, with its high-performance capabilities and robust community, is the best blockchain for this endeavour. 
 Our commitment was met with prolific shipping throughout 2023, as we successfully launched an array of new routes, innovative products, and better developer infrastructure. For example: 
 
 Our routing improvements include the launch of Metis – a novel routing algorithm that was customised for Solana’s fast blocktimes.  We also launched instant staked SOL to SOL swaps that gives you the best price across all trade sizes. 
 Our product portfolio expanded to include Dollar Cost Averaging(DCA), Limit Orders and a Bridge tool. 
 Our developer tooling improved with 2 major API Upgrades, Jup for Payments & Games, and the Jupiter Terminal. 
 
 A full list of our products and product announcements can be found on our  documentation website  and  blog . 
 By the end of October 2023, we facilitated a cumulative trading volume of $35 billion, executed 102 million transactions, and were used by 955,000 unique wallets, solidifying our position as the most used trading platform. We account for the majority of retail flow, with approximately 80% of organic swap volume originating from Jupiter. 
 Feedback from our user community  has been overwhelmingly positive, with many highlighting that the superior pricing and exceptional user experience provided by Jupiter were surpassing those offered by traditional centralised exchanges. 
 Core Anchors for Excellence in Product Development & Ecosystem Enhancement 
 The progress and innovations at Jupiter can be attributed to three core anchors that guide every decision and strategy we undertake: 
 
 
 **The JUP Promise: Best Price, Best Token Selection, Best UX: **This deceivingly simple and straightforward promise is the driving force behind our obsessive efforts in product innovation. From enhancements in routing algorithms to the integration of new tools, they are all aimed at delivering an exceptional trading experience for both users and developers. 
 
 
 **Maximising the Potential of Solana’s Technical Capabilities: **Much like harnessing the full potential of a high-performance vehicle, we strive to make the most of Solana’s capacity for providing swift and efficient trading experiences. Jupiter has been at the forefront of adopting new Solana features such as lookup tables, priority fees, and token 2022 standards. 
 
 
 Improving the liquidity landscape in Solana:  We are committed to the rapid integration of new liquidity sources and innovative use cases, ensuring the continual growth and competitive edge of the Solana ecosystem. 
 
 
 These anchors have been instrumental in the development and launch of various products at Jupiter. A prime example is  Metis, our advanced routing algorithm , which is a heavily customised version of the Bellman-Ford algorithm designed to provide optimal price routing in Solana’s fast block-times. 
 It guided us to prioritise the integration of Sanctum,  facilitating instant staked SOL to SOL conversions at the most favorable rates , irrespective of the trade size. This helps to accelerate the adoption of liquid staking tokens (LSTs) within the ecosystem, and paves the way for new composable innovations. 
 Furthermore, we introduced the bridge tool, a tool that allows users to seamlessly compare and select the most efficient bridge for transferring tokens from other chains to Solana, so that we can help to bring more capital to Solana. 
 Most recently, during the  Jupiter Planetary Developer Week , we unveiled a plethora of new features, including the V6 Swap API, Jup for Payments, and the upgraded Jupiter Terminal V2. 
 Having provided an insight into our recent product developments, you might now be curious about our future plans and directions. 
 Help Solana Grow aka Grow the Pie! 
 Our vision for the future is intrinsically tied to the growth and prosperity of the Solana ecosystem. We are driven by the conviction that a flourishing Solana ecosystem translates to collective benefits for all stakeholders involved. In simple terms, when the pie grows, everyone gets more pie. 
 In alignment with this vision, we are excited to introduce The Jupiter Plan, a strategic framework encompassing three pivotal components: 
 
 
 $JUP Governance Token:  Our goal is to cultivate a robust community and DAO for Jupiter. We also aim to incentivize engagement and new capital flows into the Solana ecosystem, thereby fostering its growth and vibrancy. NOTE: $JUP is not live yet, please beware of fake tokens. 
 
 
 Jupiter Start : This is a year-long initiative designed to help great new projects win on Solana, with a focus on projects that contribute to the health of the Solana ecosystem, not short term pump and dumps. There will also be a commitment to transparency and public seeding, so that the community can invest in good projects early on without gatekeeping. 
 
 
 Jupiter Labs:  In collaboration with our community and the JUP DAO, we will launch cutting-edge decentralised finance (DeFi) projects specifically tailored for the Solana ecosystem. We have 2 new initiatives to introduce – a novel LP-to-trader perpetual exchange, and a xSOL leveraged stablecoin. 
 
 
 **$JUP: Unveiling our Governance Token ** 
 NOTE: $JUP is not live yet, please beware of fake tokens. 
 We are thrilled to formally announce the impending launch of the $JUP token, a milestone that our community has been keenly anticipating. Our approach to introducing the JUP token has been deliberate, and we believe that the conditions are now optimal for its launch, as several key pieces are falling into place: 
 
 Having a broad and engaged user base 
 Completion of major platform upgrades 
 Having a pipeline of ecosystem projects 
 Strong belief in the coming upswing of Solana 
 
 The primary objectives of launching the JUP token are to: 
 
 Energise the ecosystem by attracting new capital flows and users to Solana. We aim to attract new investments, users, and capital to Solana, contributing to its overall growth and vitality. 
 Generate momentum for new ecosystem tokens: The JUP token can help to catalyse the momentum for more new ecosystem tokens. 
 Build a Strong and Distributed JUP Community: We are focused on establishing a robust and broad community that is engaged and committed to supporting crucial initiatives in the long term. 
 
 JUP will be a Governance token. Initially, the token will be locked, and the DAO will decide the exact unlock date. JUP token holders will have the ability to vote on critical aspects of the token itself, such as the timing of initial liquidity provision, future emissions beyond the initial mint, and key ecosystem initiatives, including determining the projects that will be a part of Jupiter Start. 
 For the initial supply of tokens, the proposed allocation will be as follows: 
 
 40% Community Growth (4 rounds of airdrop distribution) 
 20% Locked Token Sale 
 40% Team & strategic reserve (vested) 
 
 There will be 3 parts to the launch phases; the Community Airdrop, the Growth Airdrop and the Locked Token Sale. 
 Initiating a 2 week consultation period for airdrop mechanics 
 Traditionally, the mechanics of airdrops are unilaterally determined by the team, with the community subsequently informed of the decision. This often leaves limited scope for discourse or community input. 
 In our quest to foster a more collaborative ecosystem, we are opting for an alternative approach, where the community plays an integral role in shaping the mechanics of the upcoming airdrop. This green paper does not lay out the specifics of the airdrop criteria. Instead, starting from today, we are initiating a two-week consultation period, during which we invite open dialogue and contributions from all community members. 
 We want to devise a plan that resonates with the values of the community, so that we can own this journey together and be proud shared owners of JUP. 
 Community Airdrop 
 For the first round of community distribution, we propose an airdrop for existing users and community members to reinvigorate the community and give everyone a stake in the JUP and Solana. Given that 955,000 users have used Jupiter before, this will be one of crypto''s biggest organic airdrops. As it has been a very challenging (and often painful) year, we suggest prioritising users who have been consistently part of Jupiter and Solana throughout the whole time, especially the most bearish times. 
 Growth Airdrop 
 In the Growth Airdrop phase, we will see the formation of the DAO that will help decide on the Token Launch. In addition, the second round of our community distribution has a growth-centric focus, with the primary objective of attracting new users and enhancing liquidity within the Solana ecosystem. 
 We will reward trading on Jupiter and Solana to incentivise users to trade more actively. Moreover, we are anticipating the emergence of a new wave of promising ecosystem tokens early next year, and we want to drive as much focus and attention to these tokens as possible. It is crucial that users who are incentivised to start trading on Solana again can appreciate the significant strides made by Solana in terms of ux and ecosystem growth. We look forward to experimenting with the community and ecosystem on this! 
 Locked Token Sale Phase 
 To reinvigorate the public sale market of Solana, we are initiating a Locked Token Sale (LTS) phase for 20% of tokens. In order to make it as egalitarian as possible, there will be no exclusivity in terms of whitelisting nor early access, providing an equitable opportunity for all. 
 Tokens acquired in this sale will be locked, but they will confer voting rights upon the holders. This includes the ability to vote on pivotal decisions such as determining the initial liquidity date of the token. Consequently, participants in the token sale will effectively become the inaugural members of the DAO, playing an integral role in shaping its direction. 
 Over the public LTS and 2 rounds of community distribution, our objective is to cultivate a DAO that is not only highly engaged but also eagerly invested in the success and prosperity of Solana. 
 This approach represents a deliberate shift away from prevailing narratives of retail investors being disadvantaged, insider dominance, high FDV & low float token launch games, and uncertainties surrounding token emissions in Solana. Instead, we are championing a model of transparency and equitable participation – our airdrops and token sales have no insiders and no centralised voting, a high float from the start, and diverse investors that include previous users and new users. 
 By granting the DAO the authority to determine subsequent community distributions and sanction future mints, we cement a system that guarantees full transparency of emissions. The role of the DAO will also be growth centric, collaborating not just on the current initiatives but also to grow new world class products in the future. 
 There is a very clear distribution of roles between the team and the DAO - The team manages products, protocols, and development, while the DAO manages one of the most crucial aspects - token distribution & future emissions. 
 The entire initial supply belongs to community participants through the token sale, airdrops, and growth incentives, while the team’s allocation will be vested over 2 years. The strategic allocation (for potential future investors and talent) can only be used by the team at least a year after token liquidity, and there will be at least 6 months notice before any tokens are released from this pool. 
 Our aim is to energise the Solana ecosystem by driving investment, users and capital to Solana, generate more momentum for new ecosystem tokens and build up a strong and focused Jupiter community to help improve Solana. 
 Together, we work towards a future where the victories of Solana translate to victories for all. Solana wins, everybody wins! 
 Jupiter Start 
 Jupiter Start is a year-long initiative that seeks to redefine the launchpad experience, placing a strong emphasis on the long-term success and sustainability of new projects within the Solana ecosystem. We believe that for a project to truly thrive, it requires more than just a successful token launch; it needs a robust community, ongoing momentum, and strong visibility from investors. 
 New projects are essential for invigorating new ecosystems, and this underscores the significance of launchpads. However, the current landscape of existing launchpads leaves much to be desired. Their predominant focus tends to be on short-term token price gains, often neglecting the long-term viability and sustainability of projects. This short-term approach is further compounded by the absence of an engaged and supportive community, which is integral for the flourishing of any project. 
 Most fundamentally, launchpads today seem more focused on pumping the value of their own platform token rather than genuinely supporting new projects and the crypto ecosystem, with unfair advantages given to insiders and the encouragement of FOMO and speculative behaviour that leads to tokens dumping quickly post-launch. 
 The crypto industry is at a point where the need for real-world use cases, trustworthiness, and long-term sustainable projects has become more apparent than ever. There is a strong desire among community members and investors to contribute to projects that show promise and innovation. After all, the beauty of crypto is the ability of anyone to be involved in the entire value creation as early as possible. At the same time, new and legitimate teams are in need of support in terms of users, community engagement, and financing to build momentum and bring their visions to life. 
 Also, crypto needs a lot more use cases and trust worthiness. Two of the most prominent criticisms of crypto have been that there are no real use cases for real world adoption and that the prevalence of scams and rugs erode trust among retail investors. 
 With one of the most highest level of active developer participation, technical platform suitable for mainstream adoption, and invaluable experience from the dangers of short-termism, we believe that Solana is the perfect place to usher in a new era for crypto - focused on new use cases and long term thinking that is so very much needed. 
 Jupiter Start will be made up of 3 core components, which will be incrementally launched over the next few months. 
 
 
 Jupiter Token Spark: This initiative is committed to demystifying new tokens, simplifying the complexities associated with token launch, and ensuring immediate tradability on Jupiter. We highlight exceptional projects, providing them with visibility within our community and DAO. 
 
 
 Jupiter Launchpad: We aim to address the current inadequacies of launchpad models, concentrating on fostering long-term alignment, nurturing an organic community, maintaining ecosystem health, and integrating delegation features. 
 
 
 Jupiter Public Seeding: Our initiative supports communities in investing in new projects through a public venture capital funding model. This enables communal participation in seeding teams from day one, while incorporating crucial mechanisms such as vested funding. 
 
 
 Jupiter is well positioned to do this for the following reasons: 
 
 jup.ag  is the go-to platform for the most active traders, making it an ideal place to showcase and introduce new projects. 
 In conjunction with the launch of JUP, we are cultivating a broad and varied community, alongside a decentralised autonomous organisation (DAO). This network is poised to actively engage with and participate in new ventures. 
 The JUP DAO can facilitate independent decision-making on project involvement, effectively mitigating potential conflicts of interest. Furthermore, our extensive collaborations across the entire ecosystem position us to significantly contribute to and encourage cooperative efforts. 
 
 The first component to be launched will be Jupiter Token Start, which will provide both a step by step guide to launching a token for immediate discovery and trading on Jupiter, as well as provide an avenue for the best projects to be discovered by the Jup.ag user base and JUP community, while offering potential investors and traders the chance to explore, interact and understand the new tokens. 
 These components set themselves apart from prior cryptocurrency initiatives with the following core values: 
 
 100% transparency of end to end processes 
 Commitment to long term health of the Solana ecosystem 
 Inclusive participation regardless of token ownership 
 No insider advantage or preferential treatment 
 Co-development with the broader ecosystem 
 Clean, productive alignment of interests 
 Support for genuine user and community building 
 
 We hope that Jupiter Start will illuminate Solana''s significant advancements, showcasing it as a leader in progress, productivity, and ethical practices within the cryptocurrency ecosystem. And we want to work side by side with the projects, community and the broader ecosystem to achieve this! 
 Jupiter Labs 
 Jupiter Labs  will debut top-tier DeFi protocols in partnership with Jupiter users, JUP DAO, and the Solana community. We aim to bolster Solana''s DeFi ecosystem by nurturing new projects, leaders, and tokens. Although these initiatives will originate within Jupiter, they are ultimately designed to launch and operate independently. 
 Jupiter Labs is initiating two innovative projects which are at different stages of development: 
 
 
 LP <> Trader Perpetuals : This is a novel LP-to-trader perpetual exchange on Solana that offers up to 100x leverage. By utilising pool liquidity and oracles, it ensures zero price impact, zero slippage, and deep liquidity. Oracles enable stable market operations during liquidations and stop-loss events, removing risks of position bankruptcy and LP pool fund loss. Users can open and close positions in one simple step, eliminating the need for additional accounts or deposits. With Jupiter Swap integration, any Solana token can be used to open positions. 
 
 
 xSOL Leveraged Stablecoin : We propose sUSD, a new stablecoin backed by SOL and uses leveraged LSTs as the primary yield mechanism with protocol level dynamic rebalancing for stability. Borrowers can mint sUSD using SOL as collateral through interest-free loans with returns from the staked leveraged SOL covering the borrowing costs while providing annualised returns of 7~20% to sUSD holders. We suggest several mechanisms to further enhance the stability and utility of sUSD, including USDC-sUSD pool and various sUSD redemption mechanisms. 
 
 
 These projects will be bootstrapped in conjunction with Jupiter users, the JUP DAO and the Solana ecosystem. Jupiter users will be granted priority access to test and benefit from incentives associated with these protocols and the JUP DAO will receive part of the protocol tokens. Crucially, we would invite knowledgeable members of the Solana ecosystem to be part of the process of community and protocol development early on, with community tokens allocated for this purpose. 
 In Summary 
 Crypto is in dire need of more users, an expansion of use cases, and an enhancement of trust. Solana is the perfect place for all 3 - It can be the most used, most useful and most trusted ecosystem. 
 Jupiter can help: 
 
 $JUP:  Driving an increase in on-chain users and activity. 
 Start:  Broadening the spectrum of use cases and bolstering retail trust. 
 Labs:  Introducing innovative and impactful DeFi protocols. 
 
 Together, let''s shape a future where we don’t need CEXes anymore, where crypto is useful, and where your mum is proud of you for working in crypto. 
 Woohoo, LFG!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2022-12-21-jupiter-muses-1.md', 'slug: jupiter-muses-1
title: "Jupiter Muses #1" 
 Hey everyone, here are some updated thoughts on the Solana landscape, Jupiter direction and community alignment based on my observations over the last few weeks since and from discussions from the last community call. 
 Solana Landscape 
 A few months ago, we tweeted that Solana is the most likely candidate to be a major trading hub in crypto, and our confidence in that has not changed. That said, it is important to recognize several key issues plaguing Solana right now. 
 
 
 For DeFi, these include lack of liquidity depth, decreased on-ramp / off-ramp options, shaky oracles and wrapped tokens. 
 Many retail investors still feel very burnt by recent events, and continue to be doubtful over the lack of clarity of FTX in Solana. 
 In addition, many developers are unhappy about perceived biases towards insiders and celebrities, and there are also others who have focused their efforts in search of opportunities elsewhere. 
 
 That said, we are still strong believers in Solana’s long term prospects, and believe that Solana is the chain most likely to onboard the next generation of mainstream users.  There are many reasons for this, and one of it is the existence of a unique core developer community that is unlikely to be matched anytime soon by other ecosystems  (except than ethereum) , as demonstrated by the amazing speed in which the replacement for Serum came about. 
 The combination of a very strong core developer community, existing retail userbase, enthusiasm by various industry players  (offchain resources, gaming)  and a proven, battle hardened technical platform makes it hard for new entrants to catch up. 
 On our end, we have been very active in pushing Solana forward. In the last month alone, we integrated 6 new protocols and upgrades in the last month alone. We are also the first to leverage on Solana’s transaction v2 upgrade, encouraging wallets to support this new standard. 
 Moving forward, we will look to help re-invigorate Solana by investing large amounts of effort in helping improve liquidity and price discovery, showcasing new projects to users and embarking on marketing efforts to help new users come onboard Solana. 
 In summary, Solana is weakened, but it is a chance for the existing ecosystem and foundation to reset a lot of the cultural flaws and for new entrants to establish a foothold. And we will work hard to help on every step of the way. 
 
 Jupiter Direction And Product 
 The main goal for Jupiter is to  advance the usage of decentralized liquidity and replace the need for anyone to use centralized liquidity platforms like FTX . We will do so by aggregating, building or integrating key services under a single, super easy to use system. 
 In the near term, we will be making big improvements to our existing system by launching full txn v2 support, making a push for composability, and revealing a new routing engine. 
 In the long term, we aim to expand the set of DeFi use cases on Solana, starting with limit orders that leverage on the full availability of liquidity on Solana. In addition, we want to scale the  JUP Promise  of  best price ,  best selection ,  best ux  across the entire crypto universe. 
 We have very exciting plans in 2023 for these, will be excited to share more soon! In addition, there were a few other topics that was discussed in the last call regarding product: 
 
 We fix a lot of issues for projects that we integrate since we are often the first to spot issues with their onchain program or sdk issues, or get shit from users when things do not work. 
 Possible protocol revenue comes from referral bonuses  (need to make this an industry standard) , optional fees  (tying to token plans) , positive slippage, new services with fees 
 Most of Solana users come through Jupiter in one way or another - how can we use that to help new projects and tokens get discovered?
Will be fun to continue this topics in following calls! 
 
 
 Community Building 
 The hardest thing about community building is that it is very easy to do the simple thing and hype things up but ruin the goal of building a genuine userbase, evangelists and developers who care about the project long term. 
 We started the JUP spirit discussion a few months ago, culminating in what I thought was an awesome representation towards what the community should look like -  most vocal, most long term, most critical . 
 Our community building program therefore needs to be focused on achieving this, vs creating short term hype, instant gratification or convenient promises. The crypto space suffers greatly from an over-emphasis on these 3, and it is imperative that we do not repeat these mistakes as we go about building the best community in crypto. 
 The other major topic that we discussed in the call was around the role of the community - the current consensus is that the community can focus on evangelizing and growth, while the team can focus on building great products that the space needs to wean off our dependence on centralized platforms. 
 In addition, here are a few other notes, some from the call, and some from the discussion afterward. 
 
 We believe in rewarding community members who actively participate in improving product, evangelizing Jupiter and trying out new untested products. 
 Community ownership needs to be focused on sustainable rewards for long term players or driving growth for a new product 
 Users, community, developers are all equally important to us, and we need to make sure all 3 groups are taken care of 
 
 Although we are not ready for a fully liquid token yet, we think we can continue these discussions to move the ball forward: 
 
 Brainstorm how we can be helpful for re-invigorating the Solana landscape 
 Agree on the key goal of any community programs we embark on, whether it is growth, ownership or long term alignment 
 Focus on quality vs quantity moving forward. Existing discord channels shall be archived, and new ones for quality contributions opened up 
 Discuss how we can allow the community to take on enhancement and autonomy for growth and evangelism, vs from team-driven marketing efforts 
 
 
 Summary 
 Even though Solana DeFi has taken quite a big hit this past 2 months - we have been shipping faster than ever before, and we are very confident of delivering great products and value for users in Solana and beyond in our quest to  help wean the space off the need to use centralized systems. 
 Lets buidl the  most long term ,  most constructive  and  most vocal community  in crypto, and achieve this goal together.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-11-01-jup-native-usdc-circle-wormhole/index.md', 'slug: jup-native-usdc-circle-wormhole
title: "Jupiter Bringing Native USDC to Solana, Powered by Wormhole and Circle''s CCTP" 
 We are excited to announce our plans to integrate Circle’s Cross-Chain Transfer Protocol  (CCTP)  to bring native USDC to Solana powered by Wormhole. CCTP is a permissionless on-chain utility that ensures secure USDC transfers between blockchains using a native burn-and-mint process. 
 Understanding CCTP­­ 
 Circle''s Cross-Chain Transfer Protocol (CCTP) is an on-chain utility designed by Circle. Its primary function is to enable the seamless transfer of USDC across various blockchains through a burn-and-mint mechanism. When users want to transfer USDC from one chain to another, CCTP burns USDC on the source chain and then mints a corresponding amount on the target chain. This process guarantees that the USDC''s total supply remains consistent, preserving its integrity across blockchains. 
 CCTP''s Role in Solana and Jupiter 
 The imminent integration of CCTP into Solana marks a pivotal moment for Jupiter. With this integration, Solana''s ecosystem stands to benefit from increased liquidity, reduced fragmentation from fewer wrapped USDC versions, and enhanced interoperability. By facilitating native USDC transfers within Jupiter, users are presented with the benefit of efficient, zero-slippage cross-chain transfers without ever departing from the Jupiter app interface. 
 Integrating Wormhole Connect in Jupiter 
 Wormhole has established itself as the industry standard for cross-chain messaging protocols, powering cross-chain applications. Currently, it connects over 30 leading blockchains. The Uniswap Foundation''s bridge assessment committee recently recognized it as the industry’s top bridging provider, following an extensive security and decentralization  report . By integrating  Wormhole Connect  into Jupiter, we offer users unparalleled access to liquidity across all major chains without the need to exit the Jupiter platform. This streamlined cross-chain capability not only elevates the user experience but also helps drive our product and community''s growth. 
 Ending notes 
 Being the most used dapp on Solana, we are excited to bring this liquidity to all users in the ecosystem. Once the Solana CCTP goes live, this will be available on our UI, where users will be able to connect their non-Solana wallets and transfer their USDC into Solana with zero slippage regardless of transaction size. 
 This advancement promises unmatched liquidity for all Solana enthusiasts, extending Solana''s unique features and advantages to other chains, heralding a new era of interconnectivity in the DeFi realm. 
 Stay tuned to our  Twitter  for real-time updates on the launch of this integration.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-11-30-jup-start/index.md', 'slug: jup-start
title: "Grow The Pie Update #2"
description: "Explore Jupiter''s Grow the Pie Update—igniting Solana with community projects, education, and new trading avenues" 

     Grow the Pie on Solana - Update #2 | Jupiter Station 
     

 Grow The Pie Update #2: Jupiter Start 
 At Breakpoint, we presented 3 major initiatives to grow the Solana Pie: $JUP, Jupiter Start, and Jupiter Labs. Today, after extensive discussions with the ecosystem, we are delighted to elaborate more about Jupiter Start. 
 For a long time, we have been wondering how we can encourage traction and awareness for great new projects while not accidentally promoting scams or being biased one way or the other. 
 It is crucial for ecosystems to strike the balance - new projects and tokens are literally the lifeblood of ecosystems, but hyping the wrong projects is probably the biggest breaker of trust for retail investors. 
 If we hit that balance though, we will be able to help good projects get more traction and awareness while making trading and investing more fun, trustworthy, and rewarding for users. 
 If we achieve that, we will also in essence be encouraging the safe, effective decentralized trading of new tokens, while helping the Solana ecosystem build more trust and connectivity. 
 Jupiter Start will be our year-long initiative to do so, banking on close collaboration with the community and ecosystem to help vet, debate, understand, and highlight great new projects. 
 The 5 aspects of Jupiter Start are: 
 
 Jup Community Introductions 
 Jup Prelisting 
 Jup Educate 
 Jup Launchpad 
 Jup Atlas 
 
 We will start piloting the first 3 as soon as next week, while the next 2 will be done next year, since they involve funds and will need to be more carefully designed. As with all pilots, we will be iterating and experimenting with the formats very frequently. 
 
 A. Jupiter Community Introductions 
 Jupiter Community Introductions are to let Jupiter community members and users learn more about new projects and tokens in the Solana ecosystem. 
 Each introduction will last about a week, in which the project will be featured on our Discord forum. Projects will share key information about their idea, tokenomics, and key details like origination transactions and distribution of ownership. 
 Our community members will be able to help vet, understand, and discuss these projects. If the responses are positive and no red flags are found, we can spread the word further by tweeting about it and probably featuring it on our homepage. 
 Community members that  prove  expertise and thoughtfulness over time to their peers will also be able to earn corresponding rewards and recognition. 
 To kick this off, our first set of community introductions will be
 @OvolsNFT  and  @MyroSOL ! 
 B. Jupiter Pre-Listing 
 Jupiter Pre-Listing aims to allow new tokens to be safely traded on Jupiter by users. 
 The  token will show up in the token selector earlier, and the users can set limit orders at the price they want, perform DCA, etc. 
 Given that these are new tokens and liquidity will be very thin at the start, there will be lots of UI reminders and prompts to make sure the user knows what they are doing. 
 To ensure that these are not scam tokens, projects must be sufficiently known by the ecosystem, or need to post in a pilot forum in our Discord with sufficient time for our community to vet. Things like credibility are subjective, and we will iterate along the way. Obviously, tokens with misleading names similar to prominent projects or persons, or overlapped with the strict list will not be approved. 
 If you have a new token coming up, and want to make trading on Jupiter as easy as possible the moment the token is launched, let us know today! 
 If you’re a member of the ecosystem with expertise in evaluating various aspects of an early project — token distributions, legitimacy, etc. — let us know! 
 Pre-listings are NOT an endorsement of the project by Jupiter, merely a way to encourage a vibrant trading ecosystem. DYOR is extremely critical when investing in new tokens, be careful! 
 C. Jupiter Educate 
 Jupiter Educate is to let qualified traders and users of Jupiter learn more about great projects in the Solana ecosystem. The project will be featured on our social media as well as a section on our site. Qualified users and traders will be able to earn points or tokens by reading materials and performing certain on-chain actions. 
 With this initiative, we aim to have a sustainable, ongoing engine to let users know about great new on-chain projects, while also providing awareness and qualified active users for exciting new projects. 
 This will be a highly selective and customized process, and we will poll our communities ahead of time, and only projects with clear community support and strong ecosystem support will be part of this. 
 Pending a community poll, our first Educate partner will be  @ZetaMarkets , an awesome perps exchange platform and a great friend of Jupiter! 
 D. Launchpad and Atlas 
 Launchpad and Atlas are 2 funding-related initiatives to be launched next year. Launchpad will help projects get community and their token launched, Atlas to allow the community to partake in VC-style seed funding for early-stage projects. Whenever funding is involved, it obviously becomes a lot more complicated, so we will be taking our time with these, while also applying some of the lessons. 
 Community-Driven Approach 
 As with all our key initiaitives, we are committed to doing these in conjuction with the community and doing it in a way that greatly enhances the trust of users in the Solana ecosystem. 
 If you fall into any of the following categories: 
 
 A user with strong interest in vetting projects and understanding tokenomics 
 A project looking to launch a new token or idea 
 A community leader looking to connect new projects with your community 
 
 Please get in touch with  @benliewxyz , and we will try our best to involve you! By the way, due to the extremely high demand from projects to be featured or supported for Jupiter Start, we apologize if we cannot accommodate all. 
 The most challenging thing about this whole endeavor is defining what ''good'' means and who gets to decide that. 
 As such, we are designing Jupiter Start in a way such that the team is not the only entity involved in the process – instead, the community will play a leading role in proposing, deciding, or vetoing these endeavors. 
 Let''s make Solana and crypto a better place for both good new projects and users - our moms will be very proud if that happens!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-08-18-jup-lst/index.md', 'slug: jup-lst-with-sanctum
title: "Jupiter LSTs Integration with Sanctum" 
 Unlocking The Potential Of LSTs With The Sanctum Integration 
 
 In order to maximize the adoption of LSTs  (Liquid Staking Tokens)  with users and protocols alike, we have integrated  Sanctum  into our routing system, allowing users to swap from xSOL-SOL with the best possible rates, regardless of trade amount. 
 This integration coincides with the formal launch of Sanctum and its reserve pool with over 200K SOL - meaning large amounts of xSOL can be immediately swapped for tokens like USDC via the pool and Jupiter. 
 Key Features of the Sanctum 
 
 
 Instant Unstaking:  Leveraging Sanctum’s SOL reserve pool, users can instant unstake LSTs. Unlike traditional LST-SOL pools that fragment liquidity, Sanctum services every staked pool with one SOL pool, enabling every stake pool token to be accessible across DeFi. 
 
 
 Improved Validators Experience:  Validators can easily launch stake-pools-of-one by tapping into Sanctum''s shared liquidity. This reduces concerns about sourcing liquidity and unlocks a substantial portion of staked SOL for use in Solana''s DeFi ecosystem. 
 
 
 Competitive Pricing:  Sanctum routing provides a pricing edge for smaller stake pool tokens and transactions, shifting away from heavy reliance on liquidity provision to AMMs. 
 
 
 Three Main Functions on Jupiter 
 
 SOL - xSOL:  Direct staking through Sanctum, allowing SOL deposits into stakepools, with users receiving corresponding LSTs. 
 xSOL - xSOL:  Support for LSTs trading, with partial support for various xSOL routes. 
 xSOL - SOL:  Integration with Sanctum enables instant unstaking and liquidity access for staked SOL. 
 
 Benefit To The Ecosystem 
 LSTs have always held great potential for use by both users and DeFi protocols as a valuable source of yield. However, they''ve been hindered from mass adoption due to the challenge of instantly liquidating large LST amounts. Liquidity in standard markets is insufficient for large traders or liquidators who need rapid liquidity exit. 
 With this launch and integration, many of these problems are mitigated. Liquidators can now efficiently liquidate both small and large xSOL positions, leveraging Jupiter’s liquidity routes that include the Sanctum SOL reserve pool and other integrated liquidity sources instantly, with optimal prices and minimized price impact and slippage. 
 This unlocks LST adoption, introducing more tradable assets to Solana that can significantly increase TVL, unlock 9B in staked DeFi capital, and most importantly, enable protocols to maximize their capital efficiency and yield without typical cooldown or liquidity constraints. This pivotal step is a game-changer, and we eagerly anticipate the innovative products to be built upon this foundation.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-09-18-dca-out-of-beta/index.md', 'slug: dca-official-launch
title: "Jupiter DCA Is Now Officially Launched!" 
 In an important step towards building the most powerful and usable set of spot trading features in DeFi, we are thrilled to announce that  Jupiter DCA is now officially launched!  After many rounds of rigorous testing and user feedback, we have incorporated a ton of improvements based on valuable suggestions and ideas from partners and users to increase platform stability and add more features. 
 
 Jupiter DCA Recap 
 2 months ago, we launched the beta version of Jupiter DCA - a non-custodial, on-chain dollar cost-averaging solution to automate the purchase or sale of any token. 
 When you set up a DCA order, your chosen tokens get moved from your wallet to a special account owned by the DCA program. Imagine it like putting your tokens in a vault. The first order happens right after you create your DCA, and then more orders come in at the times you pick. So, if you''re DCA-ing 1,000 $USDC into $SOL every day for 10 days, the first 100 $USDC -> $SOL order goes through when you start, and you''ll have 9 more daily orders to go. 
 Key use cases for DCA include: 
 
 Bear market accumulation 
 Bull market profit taking 
 Splitting up large orders 
 Exiting low liquidity tokens 
 
 To ensure the best price execution, DCA keepers use Jupiter and also perform price checks against an external price data provider i.e. Birdeye. In addition, to prevent people from querying and hijacking the order right before the order is about to be executed, orders have a + 2 ~ 30 seconds variability. 
 Upgrades From Beta 
 
 
 Advanced Pricing Strategy:  Introducing Min/Max parameters for users to define a precise, user-defined executable price range. This gives users more control over their investments and helps them avoid buying or selling at unfavorable prices. 
 
 
 Expanded Tradable Tokens:  Now offering access to over 600 tokens listed on the Jupiter Strict Token List, giving users a significant increase in token selection from the initial Top 20 tokens. 
 
 
 Any-to-Any Token Trading Pairs:  Enabling trading between any-to-any token pairs for more diverse trading options. 
 
 
 Metis Algorithm Implementation:  Leveraging the Metis algorithm for enhanced routing and improved pricing. 
 
 
 Increased Global Upper Limit:  We have increased the global upper limit for a single DCA order from $5,000 USD to $20,000 USD. This change offers users more flexibility for a wider range of use cases. 
 
 
 Enhanced Default Slippage Rate for Improved Order Fulfillment:  The default slippage rate has been adjusted to 10 basis points (bps) for an improved and better transaction fulfillment rate without disrupting the DCA flow. 
 
 
 Enhanced Safety Mechanism with additional checks and warnings:  Verifying scheduled date/time, token validation against the Jupiter Strict List, and issuing warnings for high price impact. Users can now see estimated price impacts for each cycle, and lower-cap tokens have more precise decimal market rates, with more warnings and banners to bolster the trading experience. 
 
 
 
 Advanced Pricing Strategy 
 
 
 
 One of the most eagerly requested additions from our users and partners is the introduction of a Min/Max parameter or Advanced Pricing Strategy, addressing the need for precise control. This feature is implemented at the contract level, empowering users to define a minimum price for selling and a maximum price for buying within their DCA orders, adding an extra layer of control for more precise order execution. This strategy ensures order execution within a user-defined price range. If the price falls outside the range during the execution, Jupiter will reattempt to fill your order at a later time till successful, while also enforcing our randomiser at a later time so your trade remains unpredictable. 
 
 The example above sets both the minimum and maximum prices for the DCA order to be executed. 
 
 Minimum price - $19 
 Maximum price - $20 
 
 So in this scenario, if the  SOL price is within $19-$20 , the DCA will execute the order, and if it  falls below  or  pump above  the range, Jupiter will retry at a later time to try to check with the price, and if it is within the user-defined range, Jupiter will attempt to execute the order while enforcing our randomiser so your trade remains unpredictable. 
 
 Expanded Tradable Token Selection 
 Additionally, we''ve significantly broadened our range of supported tokens, expanding from the  top 20 traded tokens on Jupiter''s list to encompass over 600 tokens . This expansion is backed by the community-verified  Jupiter Strict Token List . 
 
 Any-to-any token trading pairs & Metis Algorithm Implementation 
 In line with our extensive Metis-powered enhancements, DCA now effortlessly enables trading between any-to-any pairs with improved routing and pricing efficiency. 
 Metis, our powerful routing engine, dynamically operates on a vast scale. It optimizes routes by splitting and merging input and output tokens, ensuring the best prices for even more complex trades. This enhanced efficiency opens doors to a broader range of intermediary tokens while keeping costs minimal, just a fraction of a cent. 
 Minimum Frequency and Maximum Cycle Settings 
 Introducing settings that allow for a maximum duration of one year to meet specific trading needs. 
 We have a suggestive text that explains each min and max frequency for each iteration, this will make the frequency input feel more natural and it will always show the frequency error message if input falls out of bounds or when the wallet is not connected or no input value. 
 
 Minute → 2 - 1440 minutes (~ 1 day) 
 Hour → 2 - 168 hours (~1 week) 
 Day → 2 - 30 days (~1 month) 
 Week → 2 - 52 weeks (~1 year) 
 Month → 2 - 12 months (~1 year) 
 
 
 Join us! 
 These measures collectively strengthen the safety and effectiveness of Jupiter DCA, enhancing your experience while reducing potential risks. Your trust and feedback propel us forward, and we are committed to refining and expanding DCA''s capabilities. We are dedicated to providing a seamless and secure environment for your DCA journey. Join us on this exciting path and stay informed within our active community. https://discord.gg/jup', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2024-01-24-jupiter-LFG-launchpad-beta/index.md', 'slug: jupiter-lfg-launchpad
title: "Jupiter LFG Launchpad"
description: "Explore Jupiter LFG Launchpad for community-focused, decentralized token launches. Transparent and straightforward, it offers unique liquidity solutions." 

     Jupiter LFG Launchpad: Decentralized Token Launch Innovation | Space Station 
     

 Jupiter LFG Launchpad Beta! 
 Delighted to share our very beta LFG Launchpad, the first and only system whose goal is to infuse projects with love 💕 from a genuine Jupiter DAO and community, sets them up with long term success and protects their buyers from hype, fomo and rugs. 
 Unlike other launchpads, this launchpad will not have any complex  (and often fucked)  incentive mechanisms, or isolated price discovery systems - relying on the community, open market and ecosystem to do their things instead. 
 There will also be 2 tokens launching on LFG in Jupuary, of which we share more details below too. This is  VERY BETA , so we expect to uncover a lot more issues over these 2 weeks, including the JUP launch. 
 It is risky, but hey, if we don''t dogfood our own launchpad with our own JUP, how am I going to ask others to trust me with theirs right? So let''s see if we can make this work😆 
 Key Features: 
 
 Largest community rooting for you, maybe even becoming users! 
 Millions of airdrop recipients can claim at once 
 Launch pool that''s customizable for projects needs, locks team LP for days and mitigate bot advantage powered by the awesome  @MeteoraAG  DLMM 
 Highly intuitive tool to design the liquidity pool exactly the way you want* 
 Special network reporting and gas management panel to handle on-chain chaos 
 Full trading features but focused on the pre-ordering process 
 Integration with full network of bots so you can choose your fav bot to use it with 
 Full enterprise level RPC, Cloudflare and FE support 
 
 
 Key Goals: 
 
 LFG Price discovery: Everyone starts at once, no complicated isolated pool mechanisms. The open market should be where discovery happens 
 Immediate liquidity for paper recipients to dump, while there will be sufficient buy liquidity, preventing very erratic price swings. 
 Sufficient backstop buyer-regret liquidity for price to stabilise before liquidity can be withdrawn by team. This prevents a situation where the price dumps shortly but the team has all the stable liquidity. 
 Fully transparent on-chain market making, completely zero shennigans. 
 A focused UX for the user to buy/sell wo making a lot of possible mistakes around gas and trades 
 
 
 
 DAO Vote, Community Rallying and Technical Support 
 The DAO will vote for all projects to be launched, ensuring that this is a project the community can get behind. 
 After the DAO vote, the project will be fully and thoroughly introduced to the community via a few sharing sessions on Discord and Twitter as well as being featured on the Jupiter homepage for a few days. 
 This will ensure that the most active community members and users will get to know the project very, very well - increasing the chances not just of a one day buying, but a long term, highly synergistic relationship. 
 Removing all potential worries for projects by providing full operational, scaling, technical support and expertise. Our best in class user support will extend to you too. 
 References: 
 For more details on motivations and technical updates, you can refer to this draft jupresearch post. 
 https://jupresear.ch/t/jupiter-lfg-launchpad-beta/31 
 Custom Price Curve Modeling 
 Unlike other liquidity curves the point here is NOT price discovery or equilibrium, but rather liquidity bootstrapping and backstopping. Along with every project''s extremely different needs and context, a custom price curve tool is needed. 
 Enter The LFG Price Curve design, maths, paper and website is being developed by intern #2  @Village_Idiot , who is mid way through high school. 
 https://lfg-design.jup.ag 
 This tool here to help project teams design the price curves they want, which will then automatically tell them the amount raised at different price points, executes the mathematical translation into DLMM bins etc. 
 The important here is that there is no need to determine or set an initial price - you can just decide your initial price (which is important for determining bot advantage), your final price (important depending on your liquidity needs) and how steep you want the price to increase. 
 
 Graph y-axis does not start from 0 
 For example, in this configuration you can see here the starting price is low to incentivize early liquidity, but the curve steeps strongly upwards with only a small number of tokens available for early takers before a more gentle slope occurs. This incentivizes early aggressive price action while leaving most tokens for users. 
 Alternatively, less hyped project can certainly opt for a more gentle slope with a higher starting price, which will allow everyone to acquire the tokens gradually over time without much price advantage for early buyers. 
 While the current tooling only supports on single curve, we will be adding a lot more curves over the coming year, including S-shaped and U-shaped ones.  We look forward to experimenting with various configurations over this year, and I am sure best practises will start to show up over time! 
 The full research paper and post will be up soon. He writes like a 5th grader, so be kind. 
 First 2 Projects For LFG Beta: 
 We are trying out a lot of new things with this launchpad, and many, many things can go wrong. As such, we will host a lower stakes launch first, and then finally eat our own dog food with JUP. 
 
 A fun coin managed by our good friends  @OvolsNFT  will launch this week some help from me.  I will have zero financial stake in it, and Jupiter will have zero involvement in the memecoin. 
 
 With even more airdrop recipients than JUP, it will be a much lower stakes, fun, but similarly extremely technically challenging test for the launch pad. 
 
 Following week, on 31st of Jupuary, we will of course launch JUP. Yes, we are dogfooding our own launchpad ourselves with JUP. 
 
 Jupiter DAO 
 In both cases, both  @OvolsNFT  and  @Jupiterexchange  will provide 1% to LFG launchpad, of which the upcoming JUP DAO will receive 75% and the team 25%. 
 So that should be a nice early bonus to the DAO. The team will keep this first, and transfer to the DAO after it forms. 
 Moving forward, the Jupiter DAO will approve new projects to be on the launchpad. It has to be throughly responsible for making sure the projects are worthy of being promoted to all Jupiter users, and then doing what they can to make the project as successful as possible. 
 There will be no bullshit like insider arrangements, secret profit sharing and token gating. The above arrangement is a pure, simple and mutually beneficial approach to token launches. 
 Given that the Jupiter DAO will be the largest, most non-insider voting, most dynamic and open minded DAO in the history of DAOs, we are confident 
 The team will provide all required support to projects approved by the DAO, with the likely maximum of one project every 2 weeks to maintain a very high quality pipeline. 
 1st Feb: Ready For Projects 
 We hope this gives a nice overview of our LFG launchpad, and our road towards launching Jupiter. We look forward to your active participation in these 2 launches. 
 If all goes well, we will be able to start offering the launchpad to projects who would like to launch with Jupiter! 
 Otherwise.... Well, at least we mess up together as a community right? 🩷', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-02-10-jupiter-token-list-api/index.md', 'slug: jupiter-token-list-api
title: "Introducing the Jupiter Token List API" 
 Introducing the Jupiter Token List API – an open, collaborative and dynamic token list to make trading on Solana a more transparent and safer experience for users and developers. 
 
 Today, we are introducing the Jupiter Token List API. We are designing this token list to be open, collaborative, and dynamic, to build a safer and more transparent trading experience for users and developers. 
 A key part of our  JUP Promise (Best Price, Best Token Selection, Best UX)  is the idea that users should be able to trade any token they want on Jupiter while having the peace of mind that the token they are trading is the right one. 
 
 This is super challenging in DeFi when the only true identifier of a token is its mint address, versus the more commonly human-referenced metadata of a project, such as its symbol, name, and icon, that can be impersonated. With new projects being created every day, it is not only difficult for protocols to police but it also creates a burden for users to be extra careful with what they''re trading. 
 Having an up-to-date and trusted token list is crucial for both users and projects. Users depend heavily on the applications to display the right tokens. New projects want their tokens to be discoverable and tradable everywhere, whether they are famous or not. 
 In addition, a robust list should contain other types of data to give us the full picture of a token, including on-chain metadata from project creators, actual market liquidity, data from developers like Wormhole, SolanaFm, Birdeye, AllBridge, and community validation data. 
 With all these in mind, we would like to share how we addressed safety, openness, and the ability to trade any token while incorporating various sources of data into the token list. 
 Our Approach 
 
 Dynamic:  The full list updates automatically with new projects as long as there is sufficient liquidity. This makes it available for trading on Jupiter immediately. 
 Open:  We include market and partner data about a token so you can choose what you need. The full list will always contain all tokens available for trade to give open access to all projects. 
 Safety:  Only validated tokens are shown on the ''Strict'' list by default. 
 Collaborative:  We engage ecosystem partners to build a robust and comprehensive list with us by including their data. 
 Community Driven:  Our community drives the token-list validation process. 
 
 For example, take this USDCet token symbol. 
 {
    "address":"A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM",
    "chainId":101,
    "decimals":6,
    "name":"USD Coin (Portal from Ethereum)",
    "symbol":"USDCet",
    "logoURI":"https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM/logo.png",
    "extensions":{
        "coingeckoId":"usd-coin-wormhole-from-ethereum"
    },
    "tags":[
        "old-registry",
        "wormhole"
    ]
}
 
 You can see that this token has 2 tags – it is found in both the old Solana token registry and the list of bridged Wormhole tokens. 
 In following these 3 key principles of being collaborative, dynamic & open, we hope to build up a comprehensive solution for everyone in the ecosystem while taking care of the safety of users. 
 
 Token List API 
 The API has a  “strict”  option – which we use as the default on our UI. 
 The strict list only includes tokens from Solana’s original token list, Wormhole’s token list, and Jupiter’s community-validated tokens. It freezes important metadata (symbol, name, logo) on validation to stop projects from changing their metadata to impersonate another token. 
 Endpoints 
 Jupiter’s token lists are designed to be open. We include tags about its source so that developers can choose the tokens for their use case. For your convenience, we included the tokens we show in “strict” mode on our UI in a separate endpoint. 
 Strict:  https://token.jup.ag/strict 
 
 This returns only tokens that are tagged "old-registry", "community", or "wormhole" verified. No unknown and banned tokens are returned. 
 
 All:  https://token.jup.ag/all 
 
 This returns all tokens including unknown/ untagged tokens. 
 It does not include banned tokens by default. To bring up banned tokens, append this flag to the endpoint. (?includeBanned=true). 
 Our lists are designed for trading and so only lists tokens that satisfy our minimum liquidity requirements and are available for trading on Solana. 
 
 Metadata 
 Tags:  Each token can have 1 or more of the following: 
 
 Old-registry:  These are tokens added to the archived solana labs token list repo before July 2022. As this is the original token list in Solana, the tokens here are generally more recognised. 
 Community:  These are tokens attested by Jupiter''s communities, including newer and widely traded tokens created after the old-registry was archived like Bonk and Hades. 
 Wormhole:  These are bridged assets to Solana via wormhole, mostly from Ethereum. 
 No tags / Unknown ("tags:[ ]"):  These are tokens that are picked up automatically by Jupiter. 
 
 Extensions: 
 
 isBanned:  These tokens are flagged by our community, typically for trying to impersonate another project. 
 
 
 Jupiter App 
 Our UI uses the API and defaults to showing tokens from the “Strict” list. Users can toggle on the “All” list that includes unknown tokens. 
 
 Even if the token has not been immediately validated, it will still be surfaced via symbol and mint address search with additional prompts. 
 
 Community Validation for Strict Mode (BETA) 
 Our community drives the token vetting process. We are iterating on it together, with a focus on safety and openness. 
 To follow the conversation, see  our public Github Repo  and talk to us in  our discord . 
 Collaborate with us 
 The Jupiter Token API is still early and we want to work w everyone – users, community members, protocols, and data consumers to build a better one: 
 
 Ecosystem Partners:  If you have your own token data (e.g. Wormhole tokens, SolanaFM validated tokens) that we can incorporate, let us know. 
 Community:  Join our validation process and tell us what you want to see in the strict list! 
 Users:  Try out the 2 modes on the UI and give us feedback! 
 
 We are excited to improve on the  JUP Promise  – of the  best price, best UX, and best token discovery  – to our users and the ecosystem, letting users discover all tokens while helping them to stay safe. 
 The Jupiter Token API is our third API on top of the Price API and Swap API, joining a set of important lego pieces to unlock trading and liquidity on Solana. 
 A robust token list is fundamental to any DeFi trading landscape - let’s work together towards a safer, more dynamic, and open trading env on Solana!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2022-08-24-creating-jup-spirit.md', 'slug: creating-the-jup-spirit-together
title: "Creating The JUP Spirit Together 🦄🪐" 
 A strong community is at the heart of every good crypto protocol; especially for Jupiter, our community has been cheering us on, guiding development from day one, and filling in the team’s blindspots with talent and passion. 
 We wouldn’t have been the same without you. 
 
 Here are some examples of how the community has shaped Jupiter: 
 
 Helped make Jupiter one of the fastest growing Defi platforms ever by sharing their positive experiences on Twitter, Discords, private groups 
 Alerted the team to bugs and issues to make the product as good as it can be 
 Supported new users in navigating the platform with a lot of patience and empathy 
 Made art that we’ve used in our materials and it made Jupiter more lively 
 Translated Jupiter into 7 languages and wrote articles for their home communities 
 Created and ran AMAs, trivia, and other events in very creative and engaging ways 
 Moderating other users’ comments in discord with care and intuition 
 
 Thanks to everyone’s incredible help, we have made tremendous progress in the last 9 months, which includes crossing $22B in volume traded, being the most integrated protocol in Solana by most of the major projects, running Solana’s most consistent podcast, and growing a substantial organic community. 
 As we take the next step towards our  broader goal of bringing decentralized liquidity to everyone , we would like to invite the community to create a new manifesto and incentive system together. 
 The  JUP Promise  of best token selection, best price, and best experience for users and developers helped Jupiter to become one of the best products and top DEXes in Defi. 
 The  JUP Spirit  will help Jupiter build one of the most vocal, most long term oriented and most critical communities in crypto. 
 
 Drafting The JUP Spirit Together 🎨 
 To get things started, here’s a draft of the JUP Spirit, and the ethos we want to engender. It is a draft of how we envision the community coming together: 
 
 
 Be critical yet optimistic about product improvements:  It is very difficult to build a leading aggregator and maintain that lead. We need YOU to join the hustle. Tell us where we can do better, and be critical yet optimistic about improving the product with us. 
 
 
 Tell the world about Jupiter:  If a tree fell in the middle of the forest and no one saw it, did it fall? If Jup is the best Defi product in the world, but no one knows about it, is it still the best product in the world? We need a community committed to pushing us to be the best in the world, and telling the world about it! 
 
 
 Maintain a long-term mindset:  Short-termisms plague crypto. We are determined to build a community that is critical yet supportive through ups and downs, lefts and rights, #BUIDL-ing together for the long term. 
 
 
 How to help:  What impressed you so far about the Jupiter community? What other communities do you think have great ethos that moves the project forward? How would you change the draft we have above? 
 
 How do we manifest the JUP Spirit? 
 On one side is the community ethos; on the other side are the incentives that drive behaviour. We want to create a fun yet meaningful role and incentive system to reward and encourage contributors. 
 Currently, we award roles for Jupion (helpful contributors, winners of events), Jupassador (consistent help and repeated wins), and Jupioneer (the earliest users and contributors to Jupiter when we started and heroic contributors), while XP is awarded for participants of our events such as AMAs and Twitter spaces. 
 While our current system has worked very well in terms of bootstrapping the community, there are some issues we need to resolve: 
 
 Impactful contributions (helping us work through bugs, product feedback that gets incorporated, partnership wins, great tweets) are not rewarded 
 XP is disjointed from roles and it’s not clear what purpose it serves 
 Consistency in community contribution (support, artwork) is not recognised 
 
 We would like to evolve a new system alongside the JUP Spirit that will help us manifest a great community.  This system will also be the foundational groundwork before any decentralised token community is formed.  Not to worry, any existing roles and XP collected to date will be recorded and migrated to the new setup. 
 There are many areas that we will like to grow contributions in - developer innovation, art and memes, infographics, active product testers, creative and active evangelism, etc. 
 The community sees things that we do not see – they are in many other communities, try the product from a user’s perspective, and leverage Jupiter in ways we can only imagine. We want to tap on the fullness of their talents, skills, and intuition to help Jupiter to grow, by sharing more context and empowering people to act. 
 How to help:   Reading the draft of the JUP Spirit, what do you think is good and what is lacking in terms of our current setup? How do we encourage either valuable or long-term participation? 
 
 LFGGGG! 
 We will be running this conversation for the next 2 weeks — we hope to come away with renewed energy and a better sense of how to be helpful as a community and embody the JUP Spirit.  This conversation will be facilitated by our 2 newly minted lead mods - Timoon and LJQ, who will be sharing regular updates to keep the conversation going. 
 Please refer to the earlier questions in the “How to help” sections and share your thoughts, or just share anything you want! You are probably less boomer and more in touch than us, so you know best. 
 Here are the channels to participate in the Jup Spirit discussions. Feel free to cross-post! 
 
 Discord:  The easiest way to chat. Go to 🔆・jup-spirit category in our discord and join the conversation: discord.gg/jup 
 Email:  If you’re feeling shy and like it classic, you can email feedback@jup.ag 
 
 Top contributors will get first dibs on whatever roles are decided in the new system, as well as some awesome amazing Jupiter swag! 
 We need to build a strong community foundation ahead of any token-related work. The formation of the JUP Spirit is a crucial step for that foundation that will anchor our main goal of bringing decentralized liquidity to everyone.
Very, very, excited to work together to create the most active, robust and long-term communities in crypto together. 
 LFGGGGG!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-03-28-jup-v2-major-upgrade-to-routing-engine/index.md', 'slug: jup-v2-major-upgrade-to-routing-engine
title: "Jupiter v2 - A Major Upgrade to our Routing Engine!" 
 
 We are excited to announce Jupiter v2 - a major upgrade to our routing engine! Rewritten in Rust to tap on the speed of Solana, it now offers advanced routing across 20+ liquidity venues for better pricing on both large and small trades. 
 This engine was made possible by the introduction of major composability improvements in Solana last year, including Versioned Transactions, where more complex transactions such as multiple hops and split trades can be executed together within one atomic transaction. 
 Our quote and pricing API will similarly undergo major upgrades, allowing integrators to seamlessly adopt the new engine for better quoting and more accurate/deeper real-time price data. 
 
 In addition, there are a few other significant improvements, including: 
 1. Dynamic Priority Fees 
 Where the program determines the added transaction priority fee needed for a successful trade. The feature, when turned on, will run in the background, reducing the chances of failed transactions. 
 
 2. Safety Improvements 
 User safety and security are our top priority. By default, we show only community-validated tokens and added safeguards against trades where the price impact or price warning exceeds 15%. 
 
 3. New Design and Navigation 
 We will introduce a refreshed brand with an even better user experience at Jupiter. We are committed to collaborating closely with the community, sharing design ideas and gathering feedback throughout the process to make this happen! 
 
 We will be rolling out these enhancements incrementally and engaging the community along the way. Stay tuned for product updates and feature/design discussions in Discord. Your feedback and suggestions will help shape our products and features for v2! 
 With Jupiter v2, we progress towards building the most powerful trading engine in DeFi and a platform to replace the need to use CEXes. This is us keeping to the key JUP Promise of Best Price, Best Token Selection and Best UX! 
 Come give it a spin here:  v2.jup.ag', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-09-01-jupiter-limit-order-upgrade/index.md', 'slug: jup-limit-order-upgrade
title: "Limit Order Upgrade: Any-to-any token trading, 0% maker fee and more!" 
 
 Today, we’re introducing the key upgrades to Jupiter Limit Order, with features like  any-to-any tokens trading ,  fee removal  and  enhancements  that will elevate your trading experience and open up exciting new possibilities. 
 Let’s dive into more details: 
 Any-to-any Token Trading 
 Responding to user feedback and demands, we''re thrilled to unveil any-to-any token trading within Jupiter Limit Order. Unlike before, where it was restricted to specific base tokens like USDT, USDC, and SOL, this update leverages an upgraded Limit Order contract and Jupiter''s latest routing algorithm to empower trading of any token pairs. This expansion broadens the scope, providing users with even more trading options and opportunities. 
 
 TradingView Chart 
 Empowering your Jupiter Limit Order experience further, we''ve integrated our trading chart with TradingView, utilizing data from BirdEye. This integration offers a comprehensive TradingView chart within our platform, making it much easier to perform technical analysis and place limit orders with a few clicks through the interface. 
 
 It''s important to note that while this integration offers exceptional functionality, some low liquidity token pairs might face limitations due to insufficient historical data. 
 Keeper/Taker guideline 
 We are coming up with a comprehensive guidelines for users and developers interested in running their own keepers or takers, complete with example code. This initiative will empower more participants in the system to efficiently run and execute orders, potentially benefiting from order profit execution and positive slippage. 
 The taker code facilitates keepers in accessing, filtering, and sorting open orders on-chain based on price. Furthermore, keepers can gather quotes from the Jupiter Swap API to evaluate trade profitability. Notably, this integration also enables the merging of Jupiter Swap Instructions with Limit Order Instructions, streamlining execution. 
 This enhancement enables a broader group of keepers to participate in executing Jupiter Limit Orders, thus enhancing order execution and decentralization. 
 Check out GH Repo here 
 0% Fees for placing orders 
 Considering all these updates, we''re making a significant alteration to the fee structure: reducing  Jupiter Limit Order fees to 0% for placing orders . This strategic move aims to encourage heightened usage of Limit Order. This not only encourages order placement but also improves order matchability with swaps as active orders increase.  We are also working on a more streamlined referral fees structure for partners and integrators which we will be releasing more details in the upcoming developer-focused updates. 
 Your feedback is invaluable to us, and we''re dedicated to refining your trading experience on Jupiter. These enhancements mark the beginning of an exciting journey. Our unwavering commitment to delivering even more remarkable features in the future remains steadfast. We encourage you to continue sharing your suggestions and feedback; your insights greatly contribute to our progress. Connect with our active community on Discord. 
 Join our Discord community 
 Lastly, we''re excited to announce a series of trading campaigns, commencing with $SOL. As we align with the evolving ecosystem, we''re gearing up to roll out campaigns in collaboration with our partners. Stay tuned for more updates and let''s embrace the momentum together by placing those limit orders! 
 Trade now:  https://jup.ag/limit/USDC-SOL', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-06-29-jup-token2022-support.md', 'slug: jup-token2022-support
title: "Jupiter Token 2022 Support" 
 After rigorous testing over the past few weeks,  Token2022 is now officially supported by Jupiter !  Fluxbeam  has been integrated into our routing, and tokens like  $BERN  and  $MOON  can now be traded along with other tokens in the Solana universe. 
 Token2022 is a new token standard developed by Solana Labs that presents a superset of functionality provided by the standard  SPL Token Library  which includes transfer fees, interest bearing tokens, non-transferability, and immutability. 
 This enables new types of tokenomics to be developed. For example, $BERN leverages a 6.9% transfer fee to reward holders of $BERN and $BONK while Solarmoon leverages transfer fees to reduce supply and create deflationary tokenomics for $MOON. 
 With the large number of updates over SPL Token Program, we had to make significant upgrades to our backend, UI and aggregator program to handle both the standard token library and token2022 in one seamless UX. Most notably, we had to support transfer fees across the entire stack and update our crawler to recognize Token2022 tokens. 
 In addition, as Jupiter is deeply integrated across many major wallets and dapps — not all of whom support 2022 yet — it was important for us to break this work out into a separate token list API as not to affect existing partners. 
 It’s important to note that Token2022 is currently still undergoing development and auditing. In addition, as features like transfer fees make it more difficult for integrators to adopt, we recommend sticking to the standard token library unless there is a strong need for those specific features. 
 To understand more about the standard, you can refer to these resources: 
 
 https://spl.solana.com/token-2022 
 https://twitter.com/KEMOS4BE/status/1663960214637539329 
 https://twitter.com/heliuslabs/status/1671551473950531585 
 
 We are really excited to support Token 2022 standards and can''t wait to see the amazing things that projects cook up with these new possibilities. To a greater Solana platform!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2022-09-14-unveil-jup-spirit/index.md', 'slug: unveiling-the-jup-spirit
title: "Unveiling the JUP Spirit (🦄​ ,🪐​)" 
 We spent the last 2 weeks sharing an ethos for Jupiter’s community and debated how we can best rally and recognize what is important to us. You showed up with passion and ideas. And together, we thought really hard as a community about what matters to us. 
 The essence of why community is important is captured here: Without a community, we are just a website and code, much like how the body is just flesh and blood. The soul gives us life, and the community brings Jupiter alive. 
 
 
 The JUP Spirit 
 With that in mind, we are excited to unveil the JUP Spirit! It will be the guiding force behind our community as we work together to bring decentralized liquidity to everyone. 
 
 Most Vocal, Most Critical, Most Long Term 
 Yup. The JUP Spirit may be simple but it covers so much of what we care about. It captures the essence of being there for Jupiter in the most helpful and genuine way. This is also a massive improvement over the first draft, pointing to the importance of community in co-creating a vision with us. 
 Just like how the JUP Promise of Best Tokens, Best Price and Best UX helped us to create one of the top products in DeFi, the JUP Spirit of Most Vocal,
Most Critical and Most Long-Term is a rallying cry to create one of the most active and helpful communities around! 
 Most Vocal:  A vocal community does what they can to support and spread Jupiter far and wide. After all, what’s the point of building something great if no one knows about it? Yes, go forth and activate all of the viral dark arts you know. 
 Most Critical:  It is very difficult to build a leading aggregator and to stay ahead. The community is out there and we need all of your eyes and ears to help us be the very best. We hope you can give us feedback on all kinds of issues, large or small. 
 Most Long-Term:  So much of crypto is plagued by short-termisms – in tokenomics, product and more. We don’t like that. We want to build the most sustainable product and organic community that gives a shit regardless of whether the market is up or down, left or right. 
 
 Unleashing The Jup Spirit 
 Now that we spent a very productive 2 weeks discussing the JUP Spirit, we are focusing the next 2 weeks on working out how we can unleash the JUP Spirit in our community! 
 Here’s what you can look forward to: 
 1/ Discord Revamp:  To make it easier for you to participate, we will cut back on some channels that are no longer relevant and open some new ones. It’s day 1 again! 
 2/ New Experimental Activities:  We will pause our current set of events (quizzes, weekly winners) to make it easier for new community-led activities in line with the JUP Spirit to arise. 
 3/ Rework of Roles:  We will begin to rework roles and incentives to recognize and reward our people, starting with folks who are the most JUP Spirited. 
 4/ Updated Community Content:  We will refresh some content like FAQs and invite you to help. 
 To kick off this new period, a community call will be held  this Friday, 2pm UTC on our discord  to celebrate the very beginnings of our JUP Spirit bonfire!! It will be a chat with friends and not a 1-way speaking street, so we hope you come and participate actively. 
 Buckle up Jupinauts 
 Together, we hope to build a Jupiter that belongs to all of us. This is the start. 
 And yes, this is alpha and financial advice. 
 Let''s UNLEASH the JUP Spirit! (🦄​ ,🪐​) 
 
 P.S.: Shout out to these amazing people who contributed to the conversation! We are so, so happy to meet and hear from you. 
 THANK YOU   pixel, cryptoRon, Humprey1 | Jupiter, LJQZZZ, scot, Surime, thimerosa, binlxyz, Timoon_21, Bentley, tikijiu | Jupiter, Aremia Vincenzo, dendaMx0, freaky, MANHJUPI, Surime, Drswagoon, Morty | from Jupiter, yukaz, UP | Jupiter, Zhing Richard, !spice, silver | popbone, snow, tralava, bruda.sol, sadovnik, msNik,  clara, Stand, Loyal, Optimus prime, abuwazir, zeck, ushenry, smarty, poopo, lucha, Peterpan, hopper255, summertime, Poseidon, akashc8, Belami, jentelo', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2022-05-25-jupiter-the-liquidity-infrastructure-for-solana.md', 'slug: jupiter-the-liquidity-infrastructure-for-solana
title: "Jupiter: The Liquidity Infrastructure For Solana" 
 Over the last few months, Jupiter has become the key swap liquidity infrastructure for Solana growing to over $16B in trading volume, aggregating across 15 integrated DEXs and facilitating the liquidity flow of many key projects in the ecosystem. 
 What we''ve accomplished today has been the result of a successful collaboration between the team, the community, and the Solana ecosystem. Only through constant feedback and close collaboration with everyone, have we been able to continually work towards the JUP promise of providing the  best price ,  best token selection , and  best UX  in DeFi. 
 As crypto captures more markets like banking, gaming, and payments, we believe Solana will be one of the key hubs for all that activity, with the number of applications, users, and protocols set to explode in the years to come. 
 Jupiter will provide the single liquidity endpoint for all these stakeholders to connect effortlessly and the swap infra to allow the entire ecosystem to scale exponentially. But, unlocking this growth requires the collective efforts of not just the team, but, a larger body of the community, ecosystem, and users working together. 
 
 
 Why Solana? 
 We are committed to building the swap infrastructure for Solana because we see Solana as becoming one of the key trading hubs of crypto. It is also perfectly positioned to capture the next billion crypto users where usability, transaction costs, and scalability remain key barriers to entry for them. 
 Solana’s blazing speed and throughput are key enablers of innovation. Liquidity protocols that would be impossible on slower and less scalable blockchains, including full-fledged order book systems and rapidly updating oracle-based AMMs, can finally be brought to life on Solana. 
 Beyond that, Solana''s developer ecosystem is unique in crypto. Rooted by the goal to be the "useful" blockchain in people''s daily lives, the ecosystem is filled with some of the smartest, most helpful product-focused builders around building ever more unique, useful and innovative apps. 
 Additionally, Solana has also attracted major audiences in finance, gaming, NFT, and payments, enough to reach a tipping point of users, devs, and businesses building on top of it, as seen by the significant growth of dev users and wallet downloads. This will lead to the flywheel effect where more users → more assets → more liquidity in the whole Solana ecosystem, making swap infrastructure more critical for growth. 
 As with any trading hub, one critical aspect is the links to external platforms. With Solana, it’s well-poised on both centralized exchanges and decentralized cross-chain connections, and continues to be one of the top priorities for connections with all the emerging protocols and standards. 
 Last but not least, the Solana ecosystem is just plain fun. We have been in many crypto ecosystems in the past, and the Solana ecosystem strikes us as the most fun, pragmatic and focused on user experience vs ideologies. And that’s really important for us! 
 Of course, there are some critical technical issues to be addressed such as network slowdowns, txn size, and compute unit limits, but we are confident the problems will be resolved by the excellent team over at Solana labs, who have proven time and time again that they are one of the best technical and operational executing blockchains in crypto. 
 
 Jupiter Overview 
 Originally, Jupiter was a team experiment, where we built a standalone program to integrate Mercurial and Serum to provide more utility for stables like $UST & $PAI and help establish them as key stables in Solana. In doing so, we launched the first cross-protocol liquidity swap on Solana. 
 Encouraged by our own dogfooding and the highly receptive response from the community (and the geeks in us loved playing with all the various networks, and solving all the tricky problems, like txn size limits, and all that good stuff), we decided to start Jupiter as a standalone project, launching in November 2021. 
 Along the way, we developed the JUP Promise to anchor us to the value we want to deliver - best price, best token selection, and best UX for users and developers. Sticking to this promise, along with the relentless feedback and debugging help provided by our community of users and developers, has been crucial in helping us improve the platform and make significant progress on key objectives. 
 We''d like to take the chance to share what these objectives are, the main challenges we had to solve to get here, and some of the cool things we have in the works. :D 
 1: Build the best swap experience in DeFi 
 With everyone''s help, we''ve come a long way towards building one of the best aggregators in DeFi, with the goal of allowing anyone using Solana for the first time to have an amazing experience trading with the best price and best experience possible. 
 To have the most comprehensive liquidity coverage in Solana along with a seamless experience, there were a large number of technical challenges we had to solve, including fitting advanced swap routes within the transaction size limit of 1232 bytes and compute unit limits, and incorporating very different technical models like Serum’s orderbook mechanism, Lifinity’s rapidly updating oracle based pricing mechanism and Crema’s concentrated liquidity mechanism. 
 Over time, we have developed a very strong and flexible technical foundation (both on-chain and off-chain), as well as a solid process of working closely with other teams to overcome any initial technical challenges, sharing feedback and often working with them very early in their launch process to improve their platform and SDK, allowing us to roll out new integrations rapidly. 
 Now, we have the widest and most comprehensive liquidity coverage in Solana, having integrated over 15 DEXes into one seamless interface and SDK, including very technically different platforms like Serum, Orca, Lifinity, and Crema. 
 2: Be the swap infrastructure for Solana 
 To ensure the seamless and healthy flow of liquidity throughout the ecosystem, we work towards providing the most comprehensive and robust swap infrastructure possible for Solana for any user or project to reliably transact on. 
 We do so by providing a single liquidity endpoint where any users, dapp and protocol can seamlessly access all the available liquidity, achieving the best price and ux for their own projects, regardless of whatever platform or language they are using. This liquidity endpoint is accessible via 3 main mechanisms: A user facing website on jup.ag, a comprehensive and robust SDK and API, and onchain program instructions. 
 We have since built up an extremely diverse ecosystem of projects leveraging Jupiter for their swap needs, including top Solana projects like Mango, Tulip, Defi Land - ranging from native swaps in wallets to facilitating key DeFi use cases like vaults, liquidations, and payments. 
 3: Build one of the best communities in crypto 
 With over 50k community members across Twitter and Discord, we have built one of the best organic DeFi communities in Solana. Our community has been a cornerstone of Jupiter’s development and growth. This is true not just for product, but also in terms of evangelising, support, content contributions, and just plain vibe, making Jupiter a fun place to spend time connecting with others. 
 What makes our community so special is an amazing group of content creators and moderators who have created a lot of great content, spread a lot of great energy, answered questions, and also led a lot of events, including community AMAs, where we discuss various community members journey into crypto, international AMAs, etc. 
 Beyond that, our community has been essential at evangelising Jupiter to the other users and the ecosystem, with many of the most important integrations and partnerships have come because various members have spoken up and championed Jupiter in their respective communities, with Mango, DeFi Land, and Project Galaxy are just a few notable examples. 
 Ask-Me-Anything (AMA) has been a constant initiative for us to connect with key players in the ecosystem and vice versa, which eventually blossomed into some amazing partnerships. Not only that, it’s a really helpful platform for all of our community to learn more about DeFi protocols, NFTs, GameFi projects, and the Solana ecosystem in-depth. In the AMA series, we hosted some of the most talented guest speakers in Solana and garnered a wide range of audiences live on Twitter Spaces and Discord. 
 The series then continued on to morph into our very own podcast series - Exploring Solana with Jupiter - to reach a larger audience especially outside of Solana, for people to learn more about the community. 
 Our growing community of developers building on top of Jupiter have helped us be able to scale supporting the growing number of projects who all have different platforms and use cases they are building for. They’ve not only shared solutions that have worked but also code. 
 
 What''s next? 
 Despite the incredible progress we have made the past 6 months, the whole ecosystem is only at its infancy and there is still so much more work to do in order to help Solana scale. It is also because we are at this early stage, there is so much potential and opportunities waiting to be unleashed. 
 Jupiter will be kickstarting a new phase and we are planning on many exciting developments. On the product side, we are going to support interesting integrations like direct staking/ minting routes and a wider range of use cases such as Solana Pay, TWAP and streaming payments. As more liquidity sources and tokens come online, enabling routing between all of them and maintaining a scalable robust swap layer will be an ongoing investment in infrastructure building. 
 On the community end, we hope to nurture the next set of leaders who can eventually lead our teams, truly embodying the spirit of empowerment and service of the community. We have also seen much success with our AMAs series and we will increase our content marketing such as podcasts and opinion pieces, to educate and bring new users to Solana. 
 As we look beyond Solana, we see many opportunities to improve cross-chain migration of assets into and out of Solana with Jupiter well placed to add immense value in this area.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-10-23-jupiter-planetary-developer-week/index.md', 'slug: jup-planetary-dev-update
title: "Jupiter Planetary Developer Week" 
 
 Introduction 
 Calling all Jupiter Space Catdets, welcome to the Jupiter Planetary Developer Week! 
 We''ve been working really hard to bring you fantastic new features that will make it even easier for you to create amazing liquidity use cases on Solana. 
 This is a whole week dedicated to Solana developers, where we will unveil major improvements to our tools, just in time for the Breakpoint conference. 
 So, get ready to supercharge your  BUIDLing  journey with us! 
 Day 1 - V6 Quoting API Official Release 
 Today, we are happy to announce the official release of our v6 API! This is DeFi’s most powerful and comprehensive liquidity API and will power the development of sophisticated use cases and complex DeFi processes on Solana. 
 
 This announcement comes on the heels of 2 months of relentless stability and feature-level improvements, helped immensely by key early adopters, including  Solend ,  Mango ,  Drift ,  Birdeye ,  Hawksight ,  Sphere , and  Kamino  who not just helped to iron out a lot of the kinks for any new infrastructure service, but also guided us towards specific improvements to make it possible for them to use Jupiter for their use cases. 
 In this article, we will go through key upgrades made for v6 to make building liquidity use cases much more powerful and easier: 
 
 Upgrade to use the Metis Algo for higher liquidity to support key use cases 
 Using shared intermediate token accounts for integration simplification and cost savings 
 Token ledger for increased swap success rates 
 A brand new referral fees system 
 
 In addition, we will also show advanced usage patterns, examples of how our partners are using it. 
 This launch of the v6 API is part of a series of developer announcements we are rolling out to enhance the liquidity infrastructure landscape for Solana. Stay tuned! 
 Key features for V6 Quoting API 
 Metis Algo As Backbone For v6 Routing 
 Three months ago, we launched Metis on our homepage. It''s an innovative new algorithm with real time streaming and discovery, with the routing engine also completely rewritten in Rust. This heavily modified variant of the Bellman-Ford algorithm incorporates key features such as incremental route building, combined route generation and quoting, and it''s also future-proofed for much better scalability as we add more DEXes and tokens. 
 The previous version of the API utilized an older version of the algorithm that had significant limitations. Most notably, it did not provide efficient routing for large trades, which constrained its applicability for major use cases such as margin trading and liquidations. Moreover, it employed the former JavaScript engine, resulting in inconsistent API performance. 
 
 With the v6 API now using Metis, all partners can enjoy a far higher level of liquidity for key use cases. For example, Solend which is using it for margin trading, where the trading amount is often much larger and requires deeper liquidity. 
 On the backend, we are constantly upgrading the API and making incremental improvements to deliver an easier, smoother and more efficient liquidity infrastructure for our partners. 
 Shared Intermediate Token Accounts For Integration Simplification and Cost Savings 
 The idea of Shared Intermediate Token Accounts came about because there was an increasing number of intermediate token accounts to be created in order for a swap to be successful, which increased integration complexity and cost for users that needed to be addressed. 
 Previously: 
 
 
 Integrators needed to create every single intermediate token account before integrating and obtaining quote routes, to make sure that the swaps were executed without any disruption. Any token accounts that were missed out would lead to swap errors. 
 
 
 In Solana, an account rent fee is incurred for every Solana account to store data on the blockchain. With a large number of intermediate token accounts to be created per protocol, users incur a sizable amount of rent. 
 
 
 With the Shared Intermediate Token Accounts, Jupiter creates and maintains a set of Associated Token Account  (ATA)  contracts for intermediate token accounts. These shared accounts are global and shared among all protocols and partners integrated with Jupiter. Integrators now only need to ensure they have the final output token account to receive tokens for every swap. 
 On top of this, OpenBook Open Orders accounts are no longer required as well, because all orders accounts are also globally initialized and shared amongst integrators. 
 For instance, when swapping from Token A → Token B → Token C, instead of having to create accounts for Token B and Token C, integrators will only need to set up for the final out token  (Token C in this case) . Any intermediate tokens in between, regardless of the number of token hops, are automatically initialized and managed by Jupiter’s pre-established shared token accounts. 
 Creating individual token ATA accounts incurs account rent fees, which accumulate over time due to the growing number of intermediate tokens. With fewer intermediate token accounts required, users benefit from not having to incur account rent fees for maintaining their individual token ATA accounts with each protocol they swap on. 
 We also see a much simpler integration process for partners and integrators, as the need to create and manage numerous intermediate token ATA accounts via route maps is eliminated. 
 Integrators can also better compose swap instructions that fit within a single transaction size limit, as the number of accounts to pass through in each instruction is streamlined with these shared ATA accounts. 
 Token Ledger For Increased Swap Success Rates 
 It is very important to have a good swap success rate for a great experience for users as well as integrators. Token Ledger was developed because the common way of relying on simulation to facilitate swaps is not always reliable and can lead to swap failures especially during times of market volatility. A method that is based on actual amounts transacted, and combined into a single transaction is greatly needed, leading to the birth of The Token Ledger. 
 The Token Ledger is a collection of three instructions  (Set Token Ledger, Send Instruction, Swap Instruction)  that consolidate withdrawal and swap instructions into a single transaction. Integrators/partners can now effortlessly instruct a swap to be executed based on the actual sent amount, after taking into account fees and slippages. 
 Before the introduction of the Token Ledger, swap instructions relied on a simulation-driven approach to approximate the amount deducted from a user''s wallet to facilitate the swap. This estimation approach often ended up with discrepancies between the estimated and actual amounts, especially during periods of market volatility with high slippages, leading to swap failures. 
 Consider this scenario where a user intends to withdraw 1,000 USDC from Meteora’s USDC vault into wBTC. Note that users hold vUSDC LP tokens in Meteora vaults. 
 
 In the first instruction, the Token Ledger will verify and record the user’s initial USDC balance within their wallet. For the purpose of this example, let’s assume the initial balance is 100 USDC. 
 In the second instruction, an amount equivalent to 1,000 USDC in vUSDC is withdrawn from Meteora vaults into USDC, and we examine the user’s balance. Due to factors like slippage, the USDC balance is found to be 1090 USDC. 
 For the third instruction, subtracting the initial 100 USDC from the current 1090 USDC balance, it’s evident that the user has effectively withdrawn 990 USDC, which will then be utilized to swap for wBTC as the final output token. 
 
 Without the Token Ledger, the previous swap method relied on estimated amounts, which could fluctuate due to market volatility and performance variations, frequently resulting in suboptimal user experiences. 
 With the Token Ledger, integrators can issue swap instructions based on actual amounts that have taken into account slippage and related fees. This eliminates the need for simulation and significantly increases the success rate of swaps, all within a single transaction. 
 The Token Ledger caters to a wide range of use cases, which include but are not limited to: 
 
 Withdrawing assets from a protocol to any desired token, such as converting to USDC from a wBTC vault. 
 Supporting protocols that transition positions to a different token from their original position, as seen in Perpetuals. 
 Facilitating the exchange of NFTs for tokens other than SOL. 
 
 Read more about the Token Ledger:
https://station.jup.ag/docs/old/apis/swap-api#using-token-ledger-instruction 
 Referral Fees Program to Simplify Fee Collection 
 In our pursuit of making life easier for our partners, we''ve streamlined the process of charging referral fees with the new referral fees program. 
 In the past, setting up referral fees for our partners was not straightforward. Distributing referral fees to Referrer A and Jupiter required adding two more accounts to the instruction. It was also challenging to accommodate varying percentages of referral fees for different partners, needing to pass more accounts into the instruction to calculate these fees. 
 The motivation behind building the referral fees system was to automate the process of calculating all these fees, while providing a user-friendly interface to set up referral accounts and claim the referral fees collected. 
 Referral Fees System Features 
 
 Set up referral accounts with Jupiter via a simple interface requiring only a few clicks. 
 Only 1 single referral account is needed across the different Jupiter products. 
 Checking on the total fees collected across the token accounts with an easy button to claim them 
 
 The partner journey is now hyper easy - They head over to Jupiter, create a referral account, and then plug the referral account parameters into their integration. It''s that simple! 
 Give our dashboard a spin here: https://referral.jup.ag 
 Read here on how to add your platform fees to Jupiter Swap : https://station.jup.ag/docs/old/apis/adding-fees 
 More info on Jupiter Referral Program: https://station.jup.ag/docs/old/additional-topics/referral-program 
 
 Performing Advanced Swaps with Jupiter v6 
 Cross Program Invocation (CPI) & Flash-fill 
 The Cross Program Invocation (CPI) and Flash-fill are two approaches to integrate Jupiter swap with your protocol. In Jupiter v6 API, we have made CPI calls much easier to use by turning transaction payload into instructions for API users. 
 CPI Approach 
 To better understand how to swap via CPI, let us walk through an example of utilizing Jupiter Swap via CPI to swap from any tokens to SOL even if the user has insufficient SOL. 
 For CPI to work, the transaction will be composed of these instructions: 
 
 Borrow enough SOL from the program to open a wSOL account that the program owns. 
 Swap X token from the user to wSOL on Jupiter via CPI. 
 Close the wSOL account and send it to the program. 
 The program then transfers the SOL back to the user. 
 
 Read more here: https://station.jup.ag/docs/old/apis/cpi 
 The CPI approach is not without its limitations - because of Solana’s transaction limit of 1232 byte size, lookup tables cannot be used within a CPI call, swaps via CPI can fail at runtime since Jupiter routes may involve multiple DEXes in order to reduce price impact. Instead, we recommend taking the “flash-fil” approach to utilizing Jupiter Swap. 
 Flash-Fill Approach 
 The “Flash-fill” approach is a way to integrate your program with Jupiter swap without the limitations of CPI. Flash-filling allows the use of Versioned Transactions in combination with Address Lookup Tables to include more accounts per transaction while keeping within the 1232 bytes limit. 
 To understand the Flash-Fill approach, we will walk through the same example of utilizing Jupiter swap via Flash-Fill to swap from any token to SOL even if the user has insufficient SOL. Note that Flash-Fill can facilitate swaps from any token to any token, not limited to SOL. 
 For Flash Fill to work, the transaction will be composed of these instructions: 
 
 Borrow enough SOL from the program to open a wSOL account that the program owns. 
 Create the wSOL account for the borrower. 
 Swap X token to wSOL 
 Close the wSOL account and send it to the borrower. 
 Repay the SOL for opening the wSOL account back to this program. 
 
 This approach entirely bypasses the need for CPI calls, effectively sidestepping the constraints imposed by CPI. 
 To delve deeper into these two approaches, check out our documentation here: https://station.jup.ag/docs/old/apis/flash-fill 
 Partners Using v6 API 
 A big shout out to our key early adopters for running our v6 API and helping us improve our stability and features. Check out how they are using Jupiter to power their use cases. 
 
 Drift  leveraged swaps utilise the power of “flash loans” to allow traders to increase their spot buying or selling potential by up to 5x. These leveraged swaps are powered by Jupiter, to find the best price routes and get access to deep liquidity across Solana. 
 Solend  Margin Trading is an extension of their lending where it combines flash loans, swapping, and depositing the proceeds back into Solend all in a single transaction. The trading view features a swap UI powered by Jupiter. 
 Birdeye  is an on-chain trading data aggregation platform that utilize Jupiter Swap for all SPL tokens including the latest Token2022. With the latest v6 upgrade, it offers more improved speed that enhances trading experience on Birdeye. 
 Hawksight  integrated Jupiter v6 for their auto-swap deposits, making it super easy for users to maximise yield through auto-compounding and auto-rebalancing their LP positions efficiently. 
 Ultimate Wallet  integrated Jupiter into their native in-wallet swap. With the upgrade from v4 to v6, Token2022 is fully supported and the latest Metis algorithm expanded the price routes, enabling their users to swap over the widest range of tokens and access even better price quotes for their users. 
 Sphere  is a payments platform and API for digital currencies, where businesses can start accepting card, ACH, wire, stablecoins, and other digital currencies in a single universal checkout page. Jupiter provides the swap infrastructure for the built-in token swap. 
 Sollinked  is a social app designed for gated communities, offering a platform for newsletters or "paid" email inboxes that can be prioritized through incentives. Sollinked utilizes Jupiter to facilitate payments for emails and reservations using all SPL tokens. 
 
 Day 1 Ending Notes 
 Jupiter’s goal is to provide the best possible liquidity infrastructure for Solana. 
 With this major v6 upgrade, we are confident we have taken a major step in this direction. As always, we would love feedback and your thoughts on how we can improve, please join our feedback conversations on  Discord ! 
 
 
 
 Day 2 - Jupiter for Payments v2 
 Today, we are thrilled to dive into the world of Jupiter for payments, where we will introduce you to the upgraded ExactOut API. Join us as we delve into the improvements we have made to our ExactOut API, and how we have been facilitating online and offline payments in recent months. 
 A big shout out to  Sollinked ,  CandyPay ,  Sphere  and  Helio  for integrating Jupiter swap into their payment systems. These are super exciting times as we break down the barriers separating the world of crypto from traditional finance. 
 So, without further ado, let''s get started! 
 ExactOut v2 API to Power Payments 
 ExactOut is an important feature, particularly in supporting payment use cases within any ecosystem. Jupiter''s ExactOut API allows users to specify the precise amount of output tokens they require, with the input token amount being calculated accordingly. For instance, with ExactOut integrated, a protocol’s user can indicate they wish to receive exactly 100 USDC in exchange for SOL via Jupiter, instead of having to manually calculate and input the amount of SOL required to swap for an approximate amount of 100 USDC. 
 In the initial release of ExactOut v1, we could only support direct routes, limiting token selection and routing options that can be used. However, in Jupiter v6 API, our program has been updated to conduct on-chain calculations, thus enabling multi-hop routes for ExactOut v2. 
 This upgrade significantly broadens the range of supported routes from around 20 to over 400 trading pairs, enhancing route options and price selections. With 20 times more available price routes, aggregated across our partner platforms like Raydium and Orca, users can expect considerably better prices for their ExactOut swaps. 
 How ExactOut is used 
 ExactOut is particularly useful in scenarios involving the purchase of NFTs, allowing users to make payments with any tokens they possess. To illustrate, let''s consider a situation where an NFT Marketplace has integrated ExactOut on its platform. You wish to buy your favorite NFT which is priced at 40 SOL, but most of your liquid assets are in BONK. Without ExactOut, you would need to estimate the amount of BONK required to obtain 40 SOL and manually swap on an external platform to convert BONK into SOL. 
 The good news is that since the NFT Marketplace has integrated ExactOut into its interface, you can simply purchase the 40 SOL NFT and Jupiter swap would automatically calculate the most optimal amount of BONK required to purchase the 40 SOL NFT. This is achieved in a single click, eliminating the need to leave the site or perform additional calculations, while ensuring that you receive the best possible price through Jupiter.
This is extremely important to Solana as payments are a crucial part of bridging crypto with real-life applications, ultimately contributing to the mainstream adoption of the Solana ecosystem. 
 Read more about ExactOut here: https://station.jup.ag/docs/old//apis/payments-api 
 ExactOut Showcase #1 - Sollinked 
 Sollinked is a social app designed for gated communities, offering a platform for newsletters or "paid" email inboxes that can be prioritized through incentives. Sollinked utilizes Jupiter to facilitate payments for emails and reservations using all SPL tokens. 
 See how Sollinked users make payments with various SPL tokens to bump up their newsletters and emails, even though payments are primarily denominated in USDC. This is possible through the integration with Jupiter ExactOut. 
 
 
 ExactOut Showcase #2 - CandyPay Coffee 
 Candy Pay has integrated Jupiter to power built-in swap transactions to facilitate payments in SPL tokens. Users can now make purchases with any token they have in their wallets. 
 Check out this demo of a user buying a cup of coffee priced in USD with their SAMO tokens. How cool is that! 
 https://twitter.com/JupiterExchange/status/1638799925348794369 
 ExactOut Showcase # 3 - Helio 
 Helio, the leading payments app for Solana, powers sales for +3,000 creators & merchants who sell NFTs, digital content, e-commerce and more with the power of blockchain payments. Helio partnered with Jupiter to power seamless token swaps inside the Helio checkout flow. Buyers can spend SOL or any token, while merchants always receive USDC or their asset of choice. 
 "The future of commerce is based on lightning fast blockchain payments and one of the key advantages is that buyers can spend any token while merchants instantly receive their own currency of choice. Jupiter has abstracted the complexity of a DEX and given us a few simple lines of code to help us deliver on this promise"   CTO - Jim Walker 
 
 ExactOut Showcase # 4 - Sphere Pay 
 Sphere is an end-to-end payments API for digital currencies, offering on-ramp, multi-chain and fiat payments, to off-ramp in a single integration. 
 Sphere uses Jupiter to enable “universal settlement”, where customers can pay in whichever currency they want, and merchants will receive any currency of their choice — with Jupiter handling the ExactOut swap behind the scenes at the best possible rates. 
 Here is an example of how Sphere users can select to pay in any currency of their choice, with merchants receiving any currency they wish. Thanks to v6, these swaps are blazing fast, and shared ATAs and versioned transactions/lookup tables allow all of this to be bundled into a single transaction. 
 
 Ending Words 
 With Jupiter providing the essential infrastructure support for payments, we see Jupiter playing an important role in helping support the payment and fees infrastructure of Solana. 
 If you have any feedback and product improvements, do feel free to swing by and share them on our  Discord ! 
 
 
 Day 3 - Jupiter Terminal v2 
 Today we will be unveiling the brand new Jupiter Terminal V2! It is the smallest, fastest and easiest way to add Jupiter to your dApp with just a few lines of code! 
 
 A big shout out to  Meteora ,  MarginFi ,  FamousFoxFederation  and  Bonk  for being one of the early adopters of Terminal V2, seamlessly implementing swap functionality for their users without the need to navigate away from their pages. 
 In this update, we will go through key upgrades made for Terminal v2 to make implementing swap functionality for your dApp better, easier and just more fun: 
 
 Terminal v2 is now equipped with the latest v6 API, featuring Metis 
 Cross app state sharing with Jupiter Terminal 
 Unified Wallet Kit integration 
 Fee support for partners and integrators 
 Improved UX enhancements 
 
 Let’s dive in! 
 
 What’s new in Terminal V2 
 Terminal is a very popular way to integrate Jupiter into various platforms and applications, enabling protocols to seamlessly implement swap functionality for their users. It is also super easy to customize, from configuring input/output mint states, exact output mode, displaying tokens from Jupiter’s strict token list, all these are toggled on and off with just a few clicks to generate the code snippet. 
 Here are the details of what’s new in v2: 
 
 
 Jupiter Terminal v2 is upgraded to v6 API that is running Metis, bringing to you the most powerful price quote engine for the best prices and best token selection, with the best user experience. 
 
 
 We introduce cross app state sharing with Jupiter Terminal through the new syncProps() API function: 
 
 Starting with wallet Passthrough, syncProps() API will make sure your wallet states are always in sync, and Terminal can also callback to your dApp to request for wallet connection. 
 We are actively working on implementing cross-app state syncing for slippage, verTx, priority fees, as well as input mint and amount. 
 
 
 
 import { useWallet } from ''@solana/wallet-adapter-react''; // Or @jup-ag/wallet-adapter;

const passthroughWalletContextState = useWallet();
useEffect(() => {
  if (!window.Jupiter.syncProps) return;
  window.Jupiter.syncProps({ passthroughWalletContextState });
}, [passthroughWalletContextState.connected, props]);
 
 
 
 Terminal v2 is using the  Unified Wallet Kit  - an open-sourced wallet adapter, that incorporates wallet standards and passthrough wallet capabilities. It seamlessly interfaces with many well used wallets out there, to give the best wallet experience for your users. 
 
 
 Jupiter Terminal now offers fee support for partners and integrators. Partners can choose to enable platform fees on top of the swaps. To facilitate this, partners need to create token fee accounts to begin collecting platform fees. The Jupiter Referral Dashboard allows partners and integrators to monitor and claim these fees conveniently. 
 
 
 We have also enhanced the user experience by implementing additional error and warning messages to guide users. There is now a built-in RPC monitor that notifies users of any RPC abnormalities or degradation in the Solana network. 
 
 
 
 Terminal Showcase 
 Check out this mini showcase of how our partners have integrated Terminal to provide swap functionality for their users: 
 Terminal Showcase #1 
 Meteora ''s mission is to grow liquidity on Solana by building dynamic liquidity protocols - including stablecoin liquidity, LST liquidity and multi-token pools. Idle capital is dynamically distributed to various lending protocols to earn additional yield on top of swap fees and rewards. Meteora’s keeper - Hermes will continuously watch lending pool utilization rates and reserve levels, ready to withdraw the funds for safety.
Terminal v2 has been integrated on Meteora via the widget approach to let their users easily swap on-site for the required tokens to participate in liquidity provisioning. 
 
 Terminal Showcase #2 
 FamousFoxFederation , an NFT and gaming project, offers raffles and sweepstakes to participate in their NFT events. Users are able to both auction and trade their NFTs through raffle events, as well as stand a chance to win NFTs through the sweepstakes.
FamousFoxes has seamlessly integrated Jupiter Terminal into their raffle platform via the Modal approach to let their users stay on the site and effortlessly swap for the tokens required to buy the raffle tickets. 
 
 Terminal Showcase #3 
 MarginFi  is one of the leading lending/borrowing protocols in Solana. It offers users a comprehensive platform where they can seamlessly borrow, lend, and even stake SOL for LSTs – all within a unified environment.
MarginFi integrated Jupiter Terminal via the Integrated mode, rendering the swap as part of its dapp, on a dedicated page. Their users can stay on the site to also swap their tokens on top of participating margin trading. 
 
 Ending Words 
 Terminal v2 is like the magic wand for adding swap superpowers to your Solana dApp in the most hassle-free and elegant way. If you haven''t given it a spin yet, now''s the perfect time to unlock its awesomeness and inject some fun and additional functionality into your project! 
 https://terminal.jup.ag/ 
 
 
 Day 4 - Unified Wallet Kit 
 Today, we will be introducing the  Unified Wallet Kit , which was born out of our desire to help developers build more easily on Solana, fast tracking through all the challenges we faced in trying to support the majority of the wallets out there and building a great wallet UI/UX. 
 
 Unified Wallet Kit is an open-sourced, Swiss Army Knife wallet adapter, striving for the best wallet integration experience for developers, and best wallet experience for your users. 
 
 Along with  Terminal , it''s the fastest way to get started on Solana. 
 Let’s learn how. 
 Unified Wallet Kit to make BUIDLing Easier 
 To bootstrap a dApp with a wallet, we often find ourselves repeating the same setup, such as getting the various wallet adapters (both Solana Wallet Standard and custom wallets) installed, building notifications for wallet state (selected, connected, disconnected etc.), auto-reconnecting to the last connected wallet, adapting to a mobile-first responsive design, theming etc., over and over again. 
 This is our biggest motivation in building the Unified Wallet Kit - to have all these essential yet repetitive basic building blocks provided in a simple package that anyone can just plug and play. 
 Being one of the most used dApps on Solana, where we facilitate the majority of liquidity exchange in the ecosystem, we built our own world-class wallet adapter to support the majority of wallets for access to this liquidity. This wallet adapter includes all the important blocks mentioned above and more, to provide users with the best wallet experience. 
 Now, we want to give back to the developer community. We hope that by bringing our world class wallet adapter open-source, we will allow any developers to fast track and bootstrap their projects in no time! 
 Features of Unified Wallet Kit 
 
 
 Main ESM bundle at a compact 94KB (~20KB gzipped) 
 
 
 Built-in Wallet Standard, Mobile Wallet Adapter support 
 
 
 Abstracted wallet adapter, with a Bring Your Own Wallet (BYOW) approach where you can select the wallets your dapp wishes to support. This allows you to add custom and legacy wallets. 
 
 
 Mobile responsive 
 
 
 Smart notification system where you can either plug in your own notification system or use it by itself. This notification system does not interfere with your dapp. 
 
 
 Internationalization with language support for English, Chinese, Vietnamese, French, Japanese, Bahasa Indonesia and Russian 
 
 
 Theming - select from light, dark and Jupiter modes. More customisation to come. 
 
 
 Pluralization for i18n 
 
 
 New user onboarding 
 
 
 The Unified Wallet Kit will allow integrators to very quickly enable these features and let wallets connect to their dApps with only a few lines of code. It can’t get any easier than this. 
 
 Similarly with Terminal, the live playground is available at https://unified.jup.ag. Come swing by and check it out. 
 Quick Notes on Unified Wallet Kit 
 
 
 Unified Wallet ships with WalletStandard and Mobile Wallet Adapter by default as we echo the push for the Wallet Standard specification. However any additional wallets or custom implementations can still be added easily with the Bring Your Own Wallet (approach) so that it does not bloat your dapp. 
 
 
 We understand that different dapps have their own notification implementation, therefore the notification system is optional and can be plugged in with your existing notification system. 
 
 
 The Unified Wallet Kit is currently used on  Meteora , do give it a spin. 
 
 
 
 Ending Words 
 Jupiter is dedicated to help make BUIDLing easier for everyone. Developers should have zero friction building on Solana, we believe that having this great developer experience is important to help attract even more brilliant people to come build together and drive innovation. This is just the beginning, and we are excited to introduce more open-source projects in time to come. 
 Let’s keep moving forward together! 
 
 
 Day 5 - Jupiter Gaming Unity SDK 
 
 Today, we are excited to delve into the world of Jupiter for gaming, where we will look at how Jupiter has been facilitating in-game swaps and enabling gaming use cases through the integration with the  Solana.Unity-SDK , developed by the talented team at MagicBlock. This post is brought to you in collaboration with  MagicBlock . 
 Live Demo: https://magicblock-labs.github.io/Solana.Unity-SDK/ 
 
 In this post, we will learn about: 
 
 Why Solana is the major blockchain for on-chain games 
 Solana.Unity-SDK and its main features 
 Jupiter’s role in supporting gaming, use cases that the Jupiter x Solana Unity SDK powers, and a partner showcase 
 
 Before anything else, a big shout out to  Star Atlas ,  Guac , Genopets ,  DefiLand  and  FamousFoxes  for integrating Jupiter and enriching the gaming experience of their users, by providing a seamless and immersive swap experience. 
 Without further ado, let’s dive in. 
 Solana, the major blockchain for on-chain gaming 
 On-chain games are introducing a paradigm shift in the way players interact, own and experience new forms of entertainment. It’s no surprise Solana stands out as a major blockchain for on-chain gaming, thanks to its high throughput, low transaction fees, and robust ecosystem. Its ability to process thousands of transactions per second ensures that gamers experience minimal latency, creating a seamless and enjoyable gaming experience. 
 Furthermore, Solana’s vibrant community and extensive developer tools make it an attractive platform for game developers of all sorts, from those looking to infuse their game with on-chain assets to the ones pushing the boundaries with fully-on-chain games. 
 Solana is also designed to be interoperable with other blockchain networks. This means game developers can easily add Solana-based games to other blockchain platforms, allowing for seamless user experience. 
 As the gaming sector grows, Solana is poised to take the lead in on-chain gaming over all the other chains. 
 Solana Unity SDK and its main features 
 MagicBlock , the team behind the Solana Unity SDK, is an end-to-end infrastructure provider for on-chain gaming on Solana, empowering developers to create a new category of composable and permissionless gaming experiences. 
 The Solana Unity SDK simplifies the integration of Solana-based NFTs, tokens, and on-chain programs into Unity games, making it easier for game developers to create web3 games and experiences. 
 Some features of Solana.Unity-SDK: 
 
 Full JSON RPC API coverage 
 Transaction and message decoding/encoding from base64 and wire formats 
 Non-custodial Solana wallet setup in Unity, supporting Solana Wallet Adapter (Phantom, Backpack, Solflare...) and Web3auth (Social login) 
 TokenWallet object for sending and receiving SPL tokens and JIT provisioning of Associated Token Accounts 
 Additional capabilities include NFT support, compiling games to xNFTs (Backpack), native DEX operations (Orca, Jupiter), and websockets for custom events, along with Solana Mobile Stack support 
 
 With the Unity-SDK game developers can easily create seamless onboarding flows with wallets, social authentication and gasless API. Now, they can also provide a seamless trading experience with Jupiter swap! 
 Give the SDK a spin here: https://github.com/magicblock-labs/Solana.Unity-SDK 
 Jupiter x Solana.Unity-SDK Native Integration to Power Gaming 
 As the liquidity infrastructure of Solana, Jupiter provides the best rates and deep liquidity from across the ecosystem. This is important in gaming contexts where gamers trade in-game assets frequently, especially rare assets that are very valuable. The best prices and higher liquidity makes it much easier for the gamers to stay within the game to trade these assets, improving the overall gaming experience. 
 Jupiter is natively supported in the Solana.Unity-SDK and runs the v6 Quote API and ExactOut v2 API for the best swap prices. 
 The integration features: 
 
 Utility methods to easily retrieve tokens information, get swap quotes and perform swaps. Game developers can easily integrate Jupiter swaps in their games and compile cross platforms without changing a single line of code. 
 A native integration that ensures a smooth and uninterrupted game experience for the players where users can exchange assets from the game UI, without annoying popups or embedded iframes. 
 Furthermore, you can effortlessly combine Jupiter with other instructions through the SDK, such as Session Keys, which eliminates the need for manual transaction approvals and ensures uninterrupted gameplay. 
 
 This integration caters to a wide range of use cases, which include but are not limited to: 
 
 Marketplace purchases 
 In-game payment with any coin 
 Asset swaps 
 Gamified trading experiences 
 
 Ready to include Jupiter into your game? Check out the docs here: https://docs.magicblock.gg/SolanaUnitySDK/guides/jupiter 
 Showcase - DeFi Land 
 DeFi Land  is a multi-chain agriculture-simulation game created to gamify Decentralized Finance. While there are games that make use of the blockchain, DeFi Land takes DeFi as a whole and aggregates the various actions that can be taken on each DeFi platform and turns them into an interactive game that can be played. 
 Check out how Defi Land has integrated Jupiter to power their in-game Market, taking the entire experience of DeFi swaps to the next level. 
 
 DeFi Land is built with the Unity Engine 2021.2.1 and uses the IDexAggregator interface in the SDK to create their Market. 
 The interface provides convenient methods for performing swaps and accepting payment - while working seamlessly on any platform. Most notably, DeFi Land is also available as xNFT where players directly leverage Backpack to perform in-game swaps, powered by Jupiter. 
 Ending Words 
 Jupiter is Solana''s liquidity hub, offering the best prices and deep liquidity, strongly supporting diverse use cases and enhancing the gaming experience. We believe that Solana is the best place for web3 gaming, with amazing infrastructure support from teams like MagicBlock with their Solana Unity SDK, the perfect foundation for game development. 
 We can’t wait to see the brilliant game creations of the builders of Solana! 
 
 This marks the end of our inaugural Jupiter Planetary Developer Week. It was an amazing week of developer focused updates where we unveiled the spanking new v6 API with Metis for routing, Referral Fees System for easy fee management, ExactOut v2 for Payments, Terminal v2 for the easiest way to integrate Jupiter, Unified Wallet Kit for the best wallet integration experience and showcasing Jupiter for games. We are committed to making things easy for you to create awesome liquidity use cases. 
 All these just in time for the Breakpoint Conference happening next week! Thanks for following through all days of our massive update, we hope you had supercharged your BUILDling journey with us. 
 Come talk to us and join our upcoming talks at Breakpoint', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2022-12-31-jupiter-community-call-27-12-summary.md', 'slug: jupiter-community-call-27-12-summary
title: "Jupiter Community Call 27/12 Summary" 
 Dear Jupiter community - Happy NY eve, and looking forward to a super fun 2023! Despite of the macro headwinds, we are making awesome progress towards being the swap layer of Solana and helping  move crypto users away from ever having to need to use centralized exchanges like FTX ever again . 
 
 We also had a really fun community call on  Tuesday 27/12/22 ,  and here''s a quick summary: 
 Solana and Multi-chain 
 
 A pretty big deal is being made out of the fact that deGods and other projects are expanding outside of Solana. The main thing is, this is not really a big deal since even on Ethereum, even the most loyal and OG projects are multi-chain in all but name 
 That said, the timing is rather unfortunate - since the current narrative about Solana is overwhelmingly negative and this adds to the flood of negativity 
 From our point of view, we are heavily invested in Solana, and our long term perspective is not affected. We are committed to building the best decentralized finance trading tools on Solana, and these movements does not change our position one iota 
 
 Possible Jupiter Launchpad 
 
 The second thing we discussed in detail was Jupiter starting a community driven launchpad to help surface great new projects, which is very much needed in the ecosystem 
 It would also be an interesting complement to the Jupiter community, since the alignment between our users and the new projects will be very strong and relevant 
 The most important thing of course, is that the community is the one who will be driving the discussions, picking the projects and promoting it, rather than centralized parties where the incentives are extremely skewed. 
 
 Community Ownership Discussion 
 
 We are extremely committed to growing and involving the community more actively in 2023 
 It is important to both recognise past usage and contributions, while also incentizing a new generation of users and community members to be part of the long term effort to build up world class system, community and economics 
 It is obviously not a great time to launch a token, so it will not be wise or feasible to do so now, regardless of the initial hype it might generate - so we have to think of more creative ways of doing so beyond the standard airdrop model! 
 
 Ending thoughts:  Jupiter’s long term goal is to help remove the need for users to use centralized exchanges like FTX. To reach this goal requires us to get to a world class system, community and token - which is anything but easy. But we inch closer, every single day!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v2/2023-11-16-grow-the-pie-update-1/index.md', 'slug: grow-the-pie-1
title: "Grow The Pie Update #1"
description: "Explore the first community airdrop in Grow the Pie Update #1. Learn the allocation process and future plans on Jupiter." 

     Grow the Pie Update #1: Community Airdrop Details 
     

 Grow The Pie Update #1: Community Airdrop 
 Here’s the breakdown for the first round of the community airdrop, along with a detailed rationale about how we arrived at it. 
 We want to be as open as possible about explaining our thought processes, unique circumstances and data points we have gathered, and make sure that the airdrop is as understandable as possible, even the nuances of the discussion. 
 We take every part of the airdrop discussion very seriously, and we are immensely grateful for all the time and effort that everyone put in. Even if we cannot give everyone what they deserve or think is correct, I would like everyone who ever interacted with Jupiter to know that their usage/contribution was seriously considered. 
 An official airdrop allocation site will be up for everyone to check their stats and allocations.
That will conclude the current phase, moving us to the next phase of the JUP token launch. 
 BASICS: 
 
 
 There will be 10B JUP Tokens. 
 
 
 As mentioned in our Breakpoint talk, this airdrop is to engage users who used us in the past, and invite them to be closely involved with the next phase of the Jupiter journey. Which means, the  955K wallets  who interacted with Jupiter directly before  Nov 2nd  are eligible for consideration. There will be future rounds of airdrops for new users, so stay tuned for that. 
 
 
 This is obviously a massive number of wallets, and with 35B of volume, how to slice it up to make it meaningful was always going to be a challenge, but we are gonna try our best. 
 
 
 All users who interacted with Jupiter via our many amazing integrations for example Solincinerator, Solendprotocol and all the wallets will be included in the airdrop if the transaction was signed directly by the user and we have that data. 
 
 
 Also as mentioned, 40% will be allocated to the community over 4 rounds of airdrops. 10% will be allocated in this round, which will be 1B tokens. We expect to start one more round of growth oriented airdrop before token launch. 
 
 
 We have never announced or even hinted at any form of airdrop or even token until a couple of days pre-breakpoint. All growth has been purely organic. There was no massive increase in wallets in those few days, so there’s no reason to think that we were massively spammed. Therefore, de-duplication is not a particular area of concern for us, but will definitely be for future rounds. 
 
 
 All previously published dashboards and criteria were from 3rd parties. While certainly a good proxy, we are taking into account a much wider set of data points and nuances into consideration. So do wait for the official site to check both the volume, score and allocation. 
 
 
 First round allocations will be up to check but tokens will not be live yet. There are several phases to the token launch, which we covered in the breakpoint talk and we will share more later on. 
 
 
 PERSPECTIVES 
 There were many extremely different perspectives and proposals being floated over the last week, with 2 major directions, the first being a completely even distribution, and the other being a completely volume based distribution. There were also many great proposals that aimed to strike a balance, and we took inspiration from many of those. 
 DATA 
 Based on these feedback and ideas, we looked into the data in a lot of  detail, which you can see in the attached image. 
 
 
 Massive Power Law At Play
The most important data point here is the massive power law in terms of trading volume. 0.1% of wallets account for 60% of volume, while 0.2% account for 80% of volume. Even within the 0.2 tier, there are non-bot users that account for 240M of volume, far more than the average user in this elite tier. Conversely, the lower 70% accounts for much less than 1% of volume. 
 
 A linear (or even quadratic) proportion based on volume will not work for a good distribution, even for relatively power users with >100k or >1M of volume. We did not want to overcomplicate it with fancy maths too much  (base x logs) , so we opted for a reasonable tier method instead that will ensure that no one will get way too much or too little. 
 
 
 Bigger wallets were more active before 2022, while smaller wallets were more active after 2023.
A larger number of the bigger wallets turned out to have used it mostly before 2023, while smaller wallets were more active in 2023. This suggests that a multiplier for 2023 volume will have the effect of bumping up small wallets into higher tiers. 
 
 
 Stable/xSOL-SOL/Bot volume were more significant at the highest levels
One interesting observation was that stable/xSOL-SOL/bot volume was far higher at the highest levels. For example, the 2 wallets that did >500M in volume were purely arb traffic. While our share of user volume has greatly increased over time, arb bots consisted of a fairly large volume, especially early on in the cycle. 
 
 
 To be clear, there are many kinds of bots, and many of them play an important part in the liquidity ecosystem, so this is an observation to open up the conversation about whether to differentiate between these volumes. 
 There are many other interesting observations not covered above, but feel free to join our discord and chat more! 
 AIRDROP BREAKDOWN 
 With these in mind, we would like to present the airdrop breakdown for the first 10%. 
 
 Even distribution for all wallets  (2%) 
 Tiered score based distribution, with score based on  adjusted volume  (7%) 
 Community members on discord, twitter, developers  (1%) 
 
 We believe this breakdown will reward power users and contributors significantly more, while likely giving everyone else a reason to come back and engage. 
 Let me dive into each of these categories: 
 
 Even distribution between all wallets  (2% / 200M tokens) 
While not using volume as the major criteria was always going to be a non-starter, we also greatly appreciated the point that we should aim to be as inclusive as possible to maximise the community building potential here, and bring as many people back as possible regardless of volume. 
 
 As such, we are allocating 200M tokens, which means about 200 tokens for each account, which would be a nice welcome present if Jupiter does well. For those who have not tried out Jupiter or Solana for a long time, do come back and try us out again - lots have changed! 
 We are not de-duplicating here for reasons mentioned above. We have never announced an airdrop before, and neither did we see a huge influx of wallets at any point in time, so we think it''s more important to have everyone included, vs performing opaque methods of deduplicating. 
 
 Tiers Based On Adjusted Volume Score  (7% / 700M Tokens) 
The vast majority of tokens in this drop will be allocated towards a tier based scoring system, with adjusted volume being the main point of reference. 
 
 Here’s where we leave the simplistic into the much more nuanced landscape of allocating based on how much they engaged with the network, how much they used Jupiter in during the bear market, and the nature of the volume. 
 Based on the  NON-ADJUSTED  volume, we will be looking at approximately: 
 
 Tier 1: Top 2K users, 100,000 tokens each (est >1M trading vol) 
 Tier 2: Next 10K users, 20,000 tokens each (est > 100K trading vol) 
 Tier 3: Next 50K users, 3000 tokens each (est > 10K trading vol) 
 Tier 4: Next 150K users, 1000 tokens each (est >1K trading vol) 
 
 It is important to remember that we are using these volume numbers as a proxy, since the final tiering will be based on the top X users in the given tiers based on adjusted volume. 
 The adjustments will likely be the following: 
 
 multipliers for 2023 volume (likely counted 2X or 3X) 
 zeroing of arb volume (defined as samemint - samemint txns) 
 removing of known accounts (for example wormhole exploiter) 
 
 So, someone who traded mainly in 2022 but disappeared in 2023 will likely be dropped in tier, while someone active throughout 2023 will likely gain in tier. 
 One question that we are going to leave open will be whether to discount stable, xsol-sol and bot traffic. 
 The obvious flaw with this approach is simple - the tiers are pretty broad, tiering is kinda sorta unfair to those who just missed out on the past tier. For example, even in tier 1, you have a user who traded 240M in volume vs the average of 1M traded in that tier. 
 We opted for this approach because as mentioned in the earlier section, there are massive power laws at work and we want to design a system where we get meaningful amounts of tokens into large numbers of active users of Jupiter, yet have it be meaningful for everyone if they do well. 
 This approach ensures that anyone who used Jupiter actively, particularly in 2023, will likely see their activity reflected in the various tiers. 
 And since this is a community building activity, not an academic exercise to have the mathematically perfect distribution, and I personally don’t like things that are not understandable by everyone this is what we opted for in the end. 
 
 Community Contributors  (1% / 100M Tokens) 
Given that community contribution cannot be placed side by side with users, we have created a completely different allocation for discord contributors, Twitter supporters and developers. 
 
 There will be multiple tiers here to reflect the level of contribution these amazing folks have in helping us become the platform we are today. We will have a preliminary list up next week, and allow people to submit additional requests as well. 
 
 Wrapping Up The Community Airdrop Consultation 
 Hey all, wanted to share the main changes that we are making to the community airdrop after the last few days of very intense debates. We will also share important clarifications and explain some of the hotly debated decisions. 
 With this update, we are formally wrapping up the community airdrop consultation and will be focusing on getting the allocation checker website up and running asap. 
 This has been a long process for everyone, but we are seriously grateful for those who took the time and effort to chim in, and that we managed to talk to so many of you representing all various segments of Jupiter users. 
 Sorry that this update was a couple of days late - I wanted to make sure that anyone who is interested can understand the decisions and thought processes as much as possible. 
 
 Changes made from first proposal
After talking to everyone, I agree that we missed out on certain important aspects around OGs n consistency. As such, there will be 3 main changes we are making from the initial proposal: 
 
 
 Acknowledge OGs who used the protocol in the first few months 
 Add a consistency modifier, with preference to those who have used Jupiter sufficiently over the last couple of years vs one off usages. 
 2023 volume multiplier only applies to older users who stayed on 
 
 The exact details of these changes, as well as the end decisions on stables and bots will be shared on the interns wrap up the analysis of numbers and get the checker up and running. 
 
 Important Clarifications 
 
 
 Tiers are based on adjusted scores, not volumes
The volume we indicated in my last post is to explain the guidelines as to how the tiers are derived. 
 
 Therefore, there will NOT be a sharp volume based cutoff, but rather based on top 2000/10000/50000/150000 users based on the volume adjusted score. 
 
 The 1% community allocation is for all contributors
The 1% community allocation is to allow us to have high levels of discretion for various types and levels of contribution that go far beyond volume. This includes developers, Twitter contributors, Discord, etc. We will have an initial list but also allow everyone to provide submissions on their contributions. This is similarly retroactive, so only contributions made before nov 2 will be considered. 
 
 Folks with Discord roles will be allocated something simple, but this allocation is mostly focused on contribution, which we will put in serious time and effort into reviewing to do justice to everyone who helped us above and beyond in debugging, promoting, moderating, etc. 
 
 The coming website is an allocation checker site
The coming website is an allocation checker site. The token will go live later. We have a very clear token launch plan made up of 3 meows that we want to work closely with the community to execute. 
 
 
 Explainers on hotly debated decisions
We have to stand by certain hotly debated decisions, including the tiering system based on adjusted score, having an allocation for universal distribution, and the 2023 multipliers. 
 
 
 Bonuses for 2023 volume
Probably the hottest point of contentment was the 2023 multiplier, since it appeared to prioritize newer users rather than older users. The 2023 multiplier might seem arbitrary, so let me explain. Even though the price of SOL started tanking in 2022, 2023  (after the ftx fallout)  was when we really saw on-chain activity drop dramatically, and belief in Solana has completely tanked. 
 
 It is likely not a false statement to say that those continued to be active in 2023 is a big reason why Solana survived, and we want to acknowledge that. We continue to believe that a multiplier for 2023 volume is appropriate, but we will add in additional conditions to ensure that it applies only to old users who stayed on. 
 
 
 No de-duplication for the even distribution
The lack of de-duplicating here for the even distribution is a concern for some, but the reason here is that it is extremely hard to de-dup without making use of tedious and opaque machine learning approaches, that is at the end of the day, not foolproof. We will avoid that to make this airdrop as understandable as possible. Having a min number of transactions is not ideal as well, since that rules out a lot of users who used us via integrations and we want to be as inclusive as possible for this part of the allocation. We will likely add more rules for this in future rounds of airdrops, but not in this one. 
 
 
 Disproportionate allocation for power users
Many people have critiqued that power users will get a disproportionately large amount of the airdrop. However, this difference is actually much smaller compared to the difference in volume, which is closer to 1000x or even as large as 240,000x. So the extremes have actually been very much nerfed, while still making it meaningful per tier. It also encourages usage instead of farming via multiple wallets. 
 
 
 Disparity in same tier
Conversely, some users within the same tier have also commented why given their volume, they might get the same as someone who traded less. The difference in volume within a tier might seem big until you comprehend the massive power law at work, where a non-bot single whale can trade 240M, and 0.2% accounts for 80% of the volume even with bots excluded. 
 
 
 Just missing out on tiers
We understand that like airline mileage tiers, it sucks to just miss out on a tier, and we sincerely apologise for that, but this is the best we can do at the moment to prevent an overly top heavy distribution, while making it meaningful for people in each tier, and keeping the overall system relatively simple. 
 
 
 
 Reflections on the community consultation
As mentioned, this post formally ends the consultation period for the airdrop. 
 
 Next steps: 
 
 A site will be up soon with official criteria, scores and allocations. 
 There will also be a place for users to submit their pre-breakpoint community contributions 
 We will share some thoughts on this process of community consultation for airdrops, and how the process will be updated for the next few rounds. 
 
 Thanks again to everyone for being part of this process. We know it has been extremely tiring for everyone. For us, this retroactive airdrop is a once in a lifetime chance to work with all the amazing users who have been part of our journey, so we are deeply appreciate the change to engage with everyone.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/5-faq/2-returned-fund-for-unsuccessful-position.md', 'sidebar_label: "Returned Fund for Unsuccessful Position"
description: Learn how to locate returned fund for unsuccessful attempt to increase position 
 Returned fund for unsuccessful position 
 
 Go to the Transaction ID 
 
 
 
 Scroll down to  CreateIncreasePositionMarketRequest 
 
 
 
 Click on  Position Request  address 
 
 
 
 Click on the latest successful transaction 
 
 
 
 You could find your returned fund here: 
 
 For  SOL , check  SOL Balance Change  tab 
 
 For  ALL other token , check  Token Balance Change  tab 
 
 :::info
Note: Wallet service providers might not be fully parsing the transactions. If you still couldn’t locate your fund although it was shown that it’s returned on the explorers, please contact your wallet service provider accordingly.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/5-faq/3-returned-fund-after-position-is-closed.md', 'sidebar_label: "Returned Fund after Position is Closed"
description: Learn how to locate fund after position is closed 
 Returned fund after Position is closed 
 
 Under  Transaction History  on Jupiter Perpetual Trading, click on the transaction ID of the closed position. 
 
 
 
 You could find your returned fund here: 
 
 For  SOL-Long position , check  SOL Balance Change  tab 
 
 For  ALL other positions , check  Token Balance Change  tab 
 
 :::info
Note: Wallet service providers might not be fully parsing the transactions. If you still couldn’t locate your fund although it was shown that it’s returned on the explorers, please contact your wallet service provider accordingly.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/5-faq/1-faq.md', 'sidebar_label: "Frequently Asked Questions"
description: Frequently Asked Questions 
 FAQ - Frequently Asked Questions 
 1. I tried opening a position/adding collateral and it’s not successful. Where is my fund? 
 Fund will be returned to your wallet address in about 1-2 mins. There might be a delay for the fund to be returned when the network is congested. In that case, you can always close your expired request under the  Expired Orders  tab. 
 Check out this  link  on how to look up for your returned fund. 
 :::info
Wallet service providers might not be fully parsing the transactions, so, it is always a better idea to check on-chain. If you still couldn’t locate your fund although it was shown that it’s returned on the explorers, please contact your wallet service provider accordingly.
::: 
 2. I closed my position with profit and I have not received my fund. 
 You will receive the underlying asset for LONG-position, i.e. SOL for SOL-Long, ETH for ETH-Long, wBTC for wBTC-Long. 
 You will receive either USDC or USDT for all SHORT-positions. 
 Check out this  link  on how to check for fund from closed positions. 
 3. The price has reached my TP/SL price on the chart. Why is my TP/SL not triggered? 
 
 
 Missing Associated Token Accounts 
 We won''t be able to trigger a TP/SL if there is no active token account for the user. These are the associated token accounts (ATAs) needed for each position. 
 
 ETH Token Account for ETH-Long; 
 wBTC Token Account for wBTC-Long; 
 USDC and USDT Token Account for ALL Short positions. 
 
 
 
 Oracle Price Not Reached 
 There are two oracles that we are using for TP/SL, the Pyth Mainnet Oracles and the Pyth Pythnet oracles. For full detail, please refer  here . 
 Our chart data is using the  Pythnet oracles  and the positions uses the  Mainnet oracles . 
 
 
 If you are sure that you have an active ATA for the position and check the Mainnet oracle price and confirm that TP/SL is not triggered at the price it is supposed to, please open a  Perp-ticket . 
 4. Why is my liquidation price changing? 
 There is an hourly borrow fee on every position, the hourly borrow fee will change the liquidation price over time. 
 If you want to understand how the hourly borrow rate works, you can check it out  here . 
 5. I deposited 1 SOL (where 1 SOL = $100) for a 5x leveraged SOL-Long position, profited $50 (where 1 SOL = $110). Why did I get less amount? Why didn’t I get back 1.5 SOL? 
 Assuming zero fees, with $50 profit, you will be getting SOL in return with value of $150.
At the time of closing the position, 1 SOL = $110, 
 $150 / $110 = 1.3636
 
 You will be getting 1.3636 SOL where the value is equivalent to $150. 
 
 Here is another example, this is a SOL-Long position, the total amount the user should be getting is $3086.28 in SOL. 
 The value of SOL at the time is $189.28, hence  $3086.28 / $189.28 = 16.30 . The user will be receiving 16.30 SOL in return. 
 :::info
The  PNL  shown is the amount before fees. The exact amount is shown under  Deposit/Withdraw  tab.
::: 
 6. I have an existing SOL-Long position. I deposited 1 SOL to open a new SOL-Long position but I don’t see my new position. 
 Both positions will be combined into one position, where 
 
 Leverage of the combined position = Average of the leverage level of each position.
e.g. (1.2x + 1.4x) / 2 = 1.3x 
 Size = initial collateral * leverage level. 
 
 The TP/SL you have set earlier will remain the same after the positions are combined.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/6-referral-program.md', 'sidebar_label: "Referral Program"
description: Discover Jupiter Station''s Referral Program. Earn fees through seamless integrations with our robust tools and guides. Start now!
title: Jupiter Referral Program 

     Jupiter Referral Program | Earn More From Your dApps 
     

 The Referral Program is an open source program by Jupiter to provide referral fees for integrators who are integrating Jupiter Swap and Jupiter Limit Order. You can check out the code  here  to gain a better understanding of how it works. 
 Referral Dashboard 
 You can manage your Referral Account on  https://referral.jup.ag/  (currently only working for Jupiter related accounts). 
 Referral Javascript SDK 
 You can check out the Referral Javascript SDK  here . For a list of methods that you can use, check out the source code  here . 
 There are also examples on how to use the SDK  here . 
 Deriving the Fee Token Account 
 The  feeAccount  is a PDA based on the referral account you have created with the dashboard above. Here is an example code on how to derive it: 
 const [feeAccount] = await PublicKey.findProgramAddressSync(
  [
    Buffer.from("referral_ata"),
    referralAccountPubkey.toBuffer(), // your referral account public key
    mint.toBuffer(), // the token mint
  ],
  new PublicKey("REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3") // the Referral Program
);
 
 When passing in the fee token account, please make sure that the fee token account exists.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-how-referral-works.md', 'sidebar_label: "How Referral works"
description: Learn how to setup referral and get started on earning referral fees from Jupiter swap.
title: How Jupiter Referral Works
slug: /jupiter-swap/how-referral-works 
 Jupiter Referral program 
 The Jupiter Referral program allows you to earn fees by referring users to the platform. It uses URL parameters to track referrals:
https://jup.ag/?referrer=[ReferralKeyAddress]&feeBps=[FeesBps] 
 :::tip Important Notes 
 
 ExactIn swaps support both input and output tokens 
 ExactOut swaps only support input tokens 
 
 ::: 
 Getting Started: 
 Connect your wallet on Jupiter (jup.ag).
Click the ''Referral'' button at the bottom center of the page.
You''ll be redirected to your referral dashboard where you can create your referral account and set up supported fee accounts (currently SOL, USDC, and USDT). 
 
 Creating Your Referral Account: 
 Visit the Referral dashboard (https://referral.jup.ag/).
You''ll be prompted to create your referral account with a preferred name. 
 
 
 (Note your unique referral key (e.g., 7tme...w4hd)) 
 Setting Up Token Accounts: 
 Create token accounts for  SOL ,  USDC , and  USDT . These cover most use cases. 
 
 :::tip
Ensure you have enough SOL to pay for token account rental fees
::: 
 
 The referral mini-popup will highlight in orange any missing token accounts. 
 Generating Your Referral Link: 
 Once your account is set up, select your preferred fee tier (0.1%, 0.5%, or 1%). 
 
 Copy your personalized referral link. Share your link to start earning referral fees. 
 Example referral link: https://jup.ag/swap/SOL-USDC?referrer=7tme...w4hd&feeBps=50 
 By following these steps, you''ll be ready to participate in the Jupiter Referral program and start earning fees for every swap you refer.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/1-limit-order-api.md', 'sidebar_label: Limit Order API
description: Streamline trading with Jupiter Limit Order API on Solana. Access tutorials, SDK tools, and tips to boost your crypto strategies efficiently.
title: Build a Limit Order Bot With Javascript 

     Jupiter Limit Order API Documentation 
     

 
{`
  .api-method-box {
    border-radius: 8px;
    margin: 16px 0;
    display: inline;
    padding: 4px;
    font-weight: 700;
    margin-right: 8px;
    font-size: 12px;
    color: white
  }

.get {
  border: 1px solid #018847;
  background-color: #018847 !important;
}

.post {
  border: 1px solid #eaba0c;
  background-color: #eaba0c !important;
}

  .api-method-path {
    font-size: 14px;
    display: inline;
  }
`} 
 Jupiter Limit Order provides users with the simplest way to place limit orders on Solana and receive tokens directly in your wallet when the order is filled! 
 
 Query user open order, order history and trade history APIs 
 
   
     
       GET 
       https://jup.ag/api/limit/v1/ openOrders 
     
   
 Parameters 
 Query Type Required Description 
 wallet string No The wallet address 
 inputMint string No The contract address of the token used to place the limit order 
 outputMint string No The contract address of the token being bought 
 
 :::info
Due to the transaction size limit, it is best to provide a wallet address even if it is not required.
::: 
 Example Request 
 curl -X GET "https://jup.ag/api/limit/v1/openorders?wallet=TVeKgyTMp3DjwVFRYC9mYcRStRnbRsFExrZDFCKrXnT&inputMint=So11111111111111111111111111111111111111112&outputMint=WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk"
 
 Response 
   
     
       •  
       
       200: OK 
        Success Response
       
     
 [
    {
        "publicKey": "APCQFtJqMhv6MpXHEtwTBxuSzGTLcJz3XcQGKc1hNpc2",
        "account": {
            "maker": "TVeKgyTMp3DjwVFRYC9mYcRStRnbRsFExrZDFCKrXnT",
            "inputMint": "So11111111111111111111111111111111111111112",
            "outputMint": "WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk",
            "oriInAmount": "30000000",
            "oriOutAmount": "150000000000",
            "inAmount": "30000000",
            "outAmount": "150000000000",
            "expiredAt": null,
            "base": "314Ybz35QBeJ4DNRYbpBVM8DFhcDrchpmvTLQQhcLj23"
        }
    }
]
 
   
   
   •  default   Error Response 
 {​
  "message": "string",​
  "code": "string",​
  "issues": [​
    {​
      "message": "string"​
    }​
  ]​
​}
 
 
 
 
   
     
       GET 
       https://jup.ag/api/limit/v1/ orderHistory 
     
   
 Parameters 
 Query Type Required Description 
 wallet string Yes wallet address 
 cursor number No 
 skip number No 
 take number No 
 
 Example Request 
 curl -X GET "https://jup.ag/api/limit/v1/orderHistory?wallet=TVeKgyTMp3DjwVFRYC9mYcRStRnbRsFExrZDFCKrXnT"
 
 Response 
   
     
       •  
       
       200: OK 
        Success Response
       
     
 [
{
        "id": 38422148,
        "orderKey": "BBdAfjXB3kiu2Z6XZM6BAm5hei5awU3SwTT12btaQmgx",
        "maker": "TVeKgyTMp3DjwVFRYC9mYcRStRnbRsFExrZDFCKrXnT",
        "inputMint": "So11111111111111111111111111111111111111112",
        "outputMint": "WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk",
        "inAmount": "0",
        "oriInAmount": "30000000",
        "outAmount": "0",
        "oriOutAmount": "2715393334",
        "expiredAt": null,
        "state": "Completed",
        "createTxid": "5xbd6BhqCbfhrorEsrxSGs2wGzaJMycuqy6X11PTMrJtF2mMAoAo4e7vJgCzjWDKNRWMqrMyAL4u5aaWaEtnAFKW",
        "cancelTxid": null,
        "updatedAt": "2024-05-23T17:09:31.024Z",
        "createdAt": "2024-05-23T17:07:47.000Z"
    }
]
 
   
   
   •  default   Error Response 
 {​
  "message": "string",​
  "code": "string",​
  "issues": [​
    {​
      "message": "string"​
    }​
  ]​
​}
 
 
 
 
   
     
       GET 
       https://jup.ag/api/limit/v1/ tradeHistory 
     
   
 Parameters 
 Query Type Required Description 
 wallet string No Wallet Address 
 inputMint string No Contract address of the token being sold 
 outputMint string No Contract address of the token being bought 
 cursor number No 
 skip number No 
 take number No 
 
 Example Request 
 curl -X GET "https://jup.ag/api/limit/v1/tradeHistory?wallet=TVeKgyTMp3DjwVFRYC9mYcRStRnbRsFExrZDFCKrXnT"
 
 Response 
   
     
       •  
       
       200: OK 
        Success Response
       
     
 [
    {
        "id": 47520095,
        "inAmount": "30000000",
        "outAmount": "2715393334",
        "txid": "2csWeVyrqfCcjYHUhpYikEW7aspz7piThp1CjrXv3iCofwa4Kd9zhF5PrRuidH4pJ4U5ZCeA9edYgqZgHWhKYVpt",
        "updatedAt": "2024-05-23T17:09:29.999Z",
        "createdAt": "2024-05-23T17:09:23.000Z",
        "order": {
            "id": 38422148,
            "orderKey": "BBdAfjXB3kiu2Z6XZM6BAm5hei5awU3SwTT12btaQmgx",
            "inputMint": "So11111111111111111111111111111111111111112",
            "outputMint": "WENWENvqqNya429ubCdR81ZmD69brwQaaBYY6p3LCpk"
        }
    }
]
 
   
   
   •  default   Error Response 
 {​
  "message": "string",​
  "code": "string",​
  "issues": [​
    {​
      "message": "string"​
    }​
  ]​
​}
 
 
 
 Cancel order 
 
   
     
       POST 
       https://jup.ag/api/limit/v1/ cancelOrders 
     
   
 Parameters 
 Query Type Required Description 
 owner string No 
 feePayer string No 
 orders string list No List of orders being attempted to cancel 
 
 Body 
 {​
  "owner": "string",​
  "feePayer": "string",​
  "orders": [​
    "string"​
  ]​
​}
 
 Response 
   
     
       •  
       
       200: OK 
        Success Response
       
     
 { "tx": "string"​ }
 
   
   
   •  default   Error Response 
 {​
  "message": "string",​
  "code": "string",​
  "issues": [​
    {​
      "message": "string"​
    }​
  ]​
​}
 
 
 
 Create Limit Order (Code Example) 
 1. Install the libraries 
 Running this example requires a minimum of  NodeJS 16 . In your command line terminal, install the libraries. 
 npm i @solana/web3.js@1
npm i cross-fetch
npm i @project-serum/anchor
npm i bs58
 
 2. Import from libraries and setup connection 
 Next you can copy the following code snippets to a javascript file  jupiter-api-example.js . And when you are ready to run the code, just type:  node jupiter-api-example.js 
 import { Connection, Keypair, Transaction } from "@solana/web3.js";
import fetch from "cross-fetch";
import { Wallet } from "@project-serum/anchor";
import bs58 from "bs58";

// This RPC endpoint is only for demonstration purposes so it may not work.
const connection = new Connection(
  "https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/"
);
 
 :::info
Always make sure that you are using your own RPC endpoint. The RPC endpoint used by the connection object in the above example may not work anymore.
::: 
 3. Setup your wallet 
 In this example, you can paste in your private key for testing purposes but this is not recommended for production applications. 
 const wallet = new Wallet(
  Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || ""))
);
 
 4. Get the serialized transactions to perform the limit order 
 // Base key are used to generate a unique order id
const base = Keypair.generate();

// get serialized transactions
const { tx } = await (
  await fetch(''https://jup.ag/api/limit/v1/createOrder'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      owner: wallet.publicKey.toString(),
      inAmount: 100000, // 1000000 => 1 USDC if inputToken.address is USDC mint
      outAmount: 100000,
      inputMint: inputMint.toString(),
      outputMint: outputMint.toString(),
      expiredAt: null, // new Date().valueOf() / 1000,
      base: base.publicKey.toString(),
      // referralAccount and name are both optional.
      // Please provide both to get referral fees.
      // More details in the section below.
      // referralAccount: referralPublicKey,
      // referralName: "Referral Name"
    })
  })
).json();
 
 expiredAt  - Can be either null or Unix timestamp in seconds. 
 Execute transaction 
 5. Deserialize and sign the transaction 
 // deserialize the transaction
const transactionBuf = Buffer.from(tx, "base64");
var transaction = Transaction.deserialize(transactionBuf);

// sign the transaction using the required key
// for create order, wallet and base key are required.
transaction.sign([wallet.payer, base]);
 
 6. Execute the transaction 
 // get the latest block hash
const latestBlockHash = await connection.getLatestBlockhash();

// Execute the transaction
const rawTransaction = transaction.serialize();
const txid = await connection.sendRawTransaction(rawTransaction, {
  skipPreflight: true,
  maxRetries: 2,
});
await connection.confirmTransaction({
  blockhash: latestBlockHash.blockhash,
  lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
  signature: txid
});
console.log(`https://solscan.io/tx/${txid}`);
 
 
   
     
       Whole code snippet 
     
   
 import { Connection, Keypair, Transaction } from "@solana/web3.js";
import fetch from "cross-fetch";
import { Wallet } from "@project-serum/anchor";
import bs58 from "bs58";

// This RPC endpoint is only for demonstration purposes so it may not work.
const connection = new Connection(
  "https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/"
);

// Base key are used to generate a unique order id
const base = Keypair.generate();

// get serialized transaction
const { tx } = await (
  await fetch(''https://jup.ag/api/limit/v1/createOrder'', {
    method: ''POST'',
    headers: {
      ''Content-Type'': ''application/json''
    },
    body: JSON.stringify({
      owner: wallet.publicKey.toString(),
      inAmount: 100000, // 1000000 => 1 USDC if inputToken.address is USDC mint
      outAmount: 100000,
      inputMint: inputMint.toString(),
      outputMint: outputMint.toString(),
      expiredAt: null, // new Date().valueOf() / 1000,
      base: base.publicKey.toString(),
      // referralAccount and name are both optional.
      // Please provide both to get referral fees.
      // More details in the section below.
      // referralAccount: referralPublicKey,
      // referralName: "Referral Name"
    })
  })
).json();

// deserialize the transaction
const transactionBuf = Buffer.from(tx, "base64");
var transaction = Transaction.deserialize(transactionBuf);

// add priority fee
const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({
  microLamports: 1, // probably need to be higher for the transaction to be included on chain.
});
transaction.add(addPriorityFee);

// sign the transaction using the required key
// for create order, wallet and base key are required.
transaction.sign([wallet.payer, base]);

// Execute the transaction
const rawTransaction = transaction.serialize();
const txid = await connection.sendRawTransaction(rawTransaction, {
  skipPreflight: true,
  maxRetries: 2,
});
await connection.confirmTransaction(txid);
console.log(`https://solscan.io/tx/${txid}`);
 
 
 Deserialize, sign and execute the transaction from the response like  here . 
 :::info
Due to the transaction size limit, the maximum cancellation order in a batch is 10.
::: 
 :::info
The Jupiter Limit Order''s project account for the Referral Program is  45ruCyfdRkWpRNGEqWzjCiXRHkZs8WXCLQ67Pnpye7Hp .
::: 
 Referral 
 Check out the  referral program  for Limit Order.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/3-lst-stablecoin/1-litepaper.md', 'sidebar_label: "Litepaper"
title: LST Stablecoin Litepaper
description: LST Overview. 
 This litepaper introduces SUSD, a native Solana yield-bearing stablecoin protocol backed by SOL liquid staking tokens (LSTs) with dynamic leverage to supercharge yield for holders of SUSD. 
 
 Introduction 
 Current popular stablecoins such as USDC, USDT are plagued by multiple levels of custodian and regulatory risks. In addition, there are unfair levels of risks for holders of these fiat backed centralized stablecoins, granting centralized issuers full autonomy on investment decisions, risking fiat-deposits without distributing the yield generated to holders of these stablecoin - the actual risk bearers. 
 While other various decentralized stablecoins such as DAI by Maker generates yield from Real-World assets, introducing additional risk vectors, XYZ aims to solve these problems by introducing an overcollateralized fully decentralized stablecoin, SUSD, backed by SOL LSTs while channeling proof-of-stake yield back to the actual risk-bearers - individuals and organizations holding SUSD. 
 Use Cases / Benefits 
 
 Interest-free loans - Unlike typical lending protocols where borrowers are charged an interest, XYZ allows borrowers to act as minters of SUSD by using SOL as collateral. Yields generated from staked SOL covers the cost of the loan resulting in a perpetually interest-free loan while maintaining the upside of SOL. 
 Fully decentralized stablecoin native to Solana to power Solana’s DeFi ecosystem 
 Earn stablecoin yield 
 
 Leveraged Yield 
 POS yield is generated through LSTs and redirected to stablecoin holders and potentially protocol token holders. To further increase the yield, leverage on LST is achieved through recursively borrowing SOL by collateralizing SOL LSTs at various lending protocols. The level of leverage is dynamically adjusted according to the SOL lending rate and LST yield. In the event SOL lending rates spike, resulting in a net 0 additional yield, no leverage is used. The projected yield is 7% ~ 17% with an average yield of 10~12% in a healthy market condition. 
 Since SOL LSTs are effectively staked SOL, the price ratio of SOL LSTs to SOL remains relatively stable through various market conditions. This allows for low levels of liquidation risks. The primary risk factors are oracle attacks and potential exploits of the LST protocols used. This risk is managed and minimized through diversifying across various audited LST protocols with dynamic leverage enabling rapid but progressive deleveraging to preserve collateral used should a blackswan event occur. 
 Maintaining Peg 
 SUSD is backed by overcollateralized SOL, however, due to market forces, the value of SUSD can vary. Through various market conditions, there is a natural economic incentive for market makers to restore the value of SUSD back to 1 USD / SUSD. 
 When the value of SUSD is above USD 1, there are arbitrage opportunities by minting SUSD via SOL to be sold at market prices for a profit, this selling pressure restores the value of SUSD back to 1. 
 Conversely, when the value of SUSD is below USD 1, minters of SUSD have the incentive to repay their loans for cheap, since the loans are denominated in SUSD. Repayment of loans introduces buy pressure on SUSD in the open market which restores the peg of SUSD back to 1. (see additional mechanisms below for additional approaches to maintaining SUSD peg) 
 Liquidations 
 Minters of SUSD opens a loan position with an initial collateralization ratio of 130%. In the event, the value of the collateral drops below the minimum collateralization of 110%, a progressive liquidation event occurs, allowing anyone to participate in restoring the position back to a healthy ratio by repaying SUSD to improve the collateralization ratio while earning a portion of the position’s collateral as a fee. 
 Mechanics 
 SUSD is an overcollateralized stablecoin minted in a permissionless manner by depositing SOL. With the deposited SOL, the protocol converts it to SOL LSTs with leverage via lending protocols to maximize yield generated for holders of SUSD. 
 Minting SUSD 
 
 Users are allowed to mint up to an initial collateralization ratio of 130% while maintaining a minimum collateral ratio of 110% to prevent liquidation. 
 This effectively allows a user to take ~76.9% (100 / 1.3) loan. 
 For e.g. SOL price is $10 and the user uses 10 SOL as collateral, the total value of collateral is $100, the user can have a maximum loan of ~76.90 SUSD calculated as (10 SOL x $10) / 1.3. 
 In the event SOL price drops ~15% below $8.459 (76.9 * 1.1 / 10), the user’s collateral is at stake of liquidation to bring the loan ratio back above the minimum collateral ratio of 110%. 
 We propose the initial and minimum collateral ratio of 130% and 110% to eventually be decided by a DAO. This collateral ratio should be sufficiently high to maintain protocol stability and ensure sufficient collateral backing stablecoins minted in extreme market conditions. 
 A minimal minting fee (amount yet-to-be determined) is charged to cover the cost of converting SOL to leveraged SOL LST. 
 Protocol Leverage 
 
 The proposed protocol leverage is used to provide yield to stablecoin holders, and allow SUSD minters interest-free loans. This yield is derived from POS staking through LSTs, hence offering a reasonably stable and sustainable yield. We propose the use of leverage to increase yield further. 
 Leverage is achieved through lending protocols by collateralizing LST SOL to borrow SOL, which in turn is swapped to LST SOL, performed repeatedly until desired leverage factor is achieved. Effectively, this works as an interest rate arbitrage and remains profitable as long as the borrow rate is lower than the yield derived from LSTs. Liquidation risk is minimal since the price of collateral and the price of the debt token has a correlation factor of close to 1. 
 A dynamic leverage of 1 ~ 3x is used and adjusted according to liquidity available as well as borrow rate. The primary factor used to determine leverage is borrow rate. As the borrowing rate goes up, the yield goes down. Once borrow rate goes above PoS yield, leverage is no longer justified. Rather than deleveraging all at once, we take a progressive approach to deleveraging. 
 A proposed permissionless keeper design will perform the transactions to leverage or deleverage dynamically. The keeper is a simple infinite loop process that monitors the protocol SOL vault, performing leverage when excess SOL is within the vault and deleveraging as new requests for SOL redemptions are being made. 
 The Leverage Process 
 
 When a user deposits SOL to mint SUSD, the SOL is transferred to the protocol’s vault. 
 When a keeper script detects excess SOL in this vault, the keeper:
 
 Initiates a CPI call to either swap or stake the SOL in exchange for LST SOL 
 The LST SOL will then be deposited into lending vaults as collateral 
 A debt positioning, borrowing SOL will be opened 
 The SOL is then repeatedly swapped / staked for LST SOL and deposited as collateral to borrow more SOL to maximize collateral in LST SOL against a debt in SOL 
 
 
 
 The Cost of Leveraging 
 When SOL is converted to LST, the keeper should automatically look for routes to get the maximum amount of SOL either through swapping through dexes or directly staking it with a LST protocol. There should be no additional cost associated with leveraging 
 The Deleveraging process 
 
 
 Deleveraging has to occur whenever a user is attempting to withdraw SOL collateral or when a SUSD position needs to be liquidated or redeemed against. 
 After a request for SOL has been submitted on-chain, the keeper sees the request and withdraws LST SOL to be converted back to SOL recursively up to the desired amount. There are 2 primary ways to convert LST SOL to SOL - swapping or unstaking. The keeper will always prefer swapping if the rates are equal to the output amount through unstaking given the instant nature of swap. 
 
 The Cost of Deleveraging 
 Converting LST SOL to SOL via unstaking incurs a 0.1% fee. Since, we propose a maximum leverage of 3x, this fee has to be multiplied by 3 or 0.3%. This fee will be borne by users who mint SUSD. 
 Loan Repayment 
 
 Users can redeem their amount of SOL deposited (net minting fee) as long as their position stays above the minimum collateralization ratio. 
 In order to redeem more or their entire net SOL deposited, they would have to repay a portion or their entire SUSD loan position to improve their debt-to-collateralization ratio. When debt becomes 0, they would be able to redeem their entire net SOL deposited. 
 User Liquidation 
 XYZ protocol mints SUSD with an overcollateralization of SOL such that 1 SUSD is always backed by > $1.1 worth of SOL. In order to maintain the collateralization level, each user’s position will need to be within the minimum collateralization ratio of 110% as introduced above. Should a user’s position go below the minimum collateralization ratio, liquidators are entitled to perform liquidation by repaying SUSD on the user’s position until the position is brought back to 110% collateral ratio. Liquidators are awarded 1% additional SOL for liquidation. 
 
 Additional Mechanisms 
 Stablecoin Peg Redemptions 
 The core importance of maintaining a SUSD peg of $1 can be achieved through permissionless redemption. Separate to user-position liquidations, our proposed mechanism allows for anyone to perform a redemption of 1 SUSD against $1 worth of SOL. This creates an economic incentive for market makers to purchase SUSD from the open market when the price of SUSD goes below $1 to be redeemed against $1 worth of SOL. 
 Redemption is performed against users’ position. The user’s position with the highest debt-to-collateral ratio will first be redeemed against. Redemption creates a natural economic incentive to restore the peg of SUSD back to $1 through buy pressure on SUSD from the open market. 
 Stablecoin Peg via Protocol Token 
 While redemptions are an effective way to maintain the peg of SUSD, there are undesirable effects for SUSD minters who can be redeemed against even with a healthy debt-to-collateral ratio. To reduce the occurrence of redemption against users’ SOL and to minimize the impact on minter should this occur, we propose the introduction of a XYZ protocol token that can be redeemed against when the price of SUSD is within -5% of $1. (The -5% is arbitrary and can be voted on by the DAO.) This effectively allows market makers to purchase SUSD from the open market for < $1 and redeem $1 worth of the XYZ protocol token. 
 In addition to the buy pressure on SUSD by market makers, this 5% tolerance also creates a time buffer for minters to repay their debt at a lower than face value given that their debt is denominated in SUSD without losing collateral. This would further increase buy pressure on SUSD to restore the peg. 
 In order to achieve this, the protocol token will need to be value accruing or deflationary. This can be achieved through directing a portion of the yield generated from leveraging LST to XYZ protocol token holders or through a burning mechanism. 
 It is important to highlight that the proposal of redemption against XYZ protocol token should not be mistakenly associated with the idea of having SUSD backed by the protocol token. SUSD is ultimately backed by minters’ SOL. The redemption of SOL will still occur if SUSD depegs below $0.95 (-5% threshold) and the protocol will always be overcollateralized with > $1.1 worth of SOL for every SUSD minted. The protocol token is only used to improve the capital efficiency of the protocol by allowing minters to maintain a higher debt-to-collateral ratio with lower risks of redemption prior to liquidation while also effectively maintaining the peg of SUSD through natural economic incentives.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-jupiter-start/5-atlas.md', 'sidebar_label: "Atlas"
description: "Atlas"
title: "Jupiter Start: Atlas" 
 (soon)', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-jupiter-start/3-pre-listing.md', 'sidebar_label: "Pre-Listing"
description: "Pre-Listing is to facilitate seamless availability of new token on Jupiter"
title: "Jupiter Start: Pre-Listing" 
 Jupiter Start: Pre-Listing is designed to facilitate the seamless availability of a new token on Jupiter and other integrated platforms. 
 To participate, projects should meet the following requirements: 
 
 
 Introduce themselves in the  Jupiter Start: Community Introduction  and gain attestation from community members. 
 
 
 Specify the exact start time for liquidity to be added to the on-chain markets  (this information will remain confidential) . 
 
 
 Specify the pools and markets from which Jupiter needs to crawl  (this information will remain confidential) . 
 
 
 Add the new token to the  Jupiter Token List . 
 
 
 Participating in this program offers several benefits for users: 
 
 
 Safety: Ensuring that the token is verified and preventing scams or duplicates. 
 
 
 Advanced trading: Enabling the new token to be traded on Jupiter''s Limit Order and DCA platforms. 
 
 
 For projects, the benefits include: 
 
 
 Liquid token: The token becomes more liquid for potential buyers or sellers immediately after launch. 
 
 
 Visibility: The token will be available in the token selector and selectable by users before liquidity starts to flow. We will also promote it and direct traffic on our main swap site with a banner. 
 
 
 Tokens will be marked with a  New  tag to have more visibility 
 
 
 :::info
Do get in touch with us through Discord or Twitter/X if you want to coordinate the launch with us.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-jupiter-start/1-community-intro.md', 'sidebar_label: "Community Intro"
description: "Community Intro is the first step of Jupiter Start - with a introduction to Jupiter community and users"
title: "Jupiter Start: Community Intro" 
 Jupiter Start: Community Introduction  is to let Jupiter community members and users to learn more about new projects and tokens in the Solana ecosystem. 
 Each introduction and discussion will last about a week, in which the project will be featured on our discord forum. 
 
 
 We will help create a forum post for you to start posting information in when we commence the Jupiter Start: Intro 
 
 
 Ideally you have writing or graphics to share about your project’s idea, tokenomics and even more details things like proof of burn. 
 
 
 Our community members will then start asking questions and we will need you to start engaging our community. 
 
 
 Lastly, when introduction and discussion is done, and if the responses from the community are good and positive, we will tweet about it from Jupiter’s Twitter/X and share a few key highlights and start directing people to check out the post in which we feature your project. 
 
 
 Jupiter Discord:  https://discord.gg/jup 
 Channel: #👋🏻・project-introduction', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-jupiter-start/4-launchpad.md', 'sidebar_label: "Launchpad"
description: "Launchpad"
title: "Jupiter Start: Launchpad" 
 (soon)', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-jupiter-start/2-educate.md', 'sidebar_label: "Educate"
description: "Educate is to allow Jupiter traders and users to learn more about great projects in Solana"
title: "Jupiter Start: Educate" 
 Jupiter Start: Educate is a program designed to allow Jupiter qualified traders and users to learn more about great projects in the Solana Ecosystem. 
 Each education campaign is expected to run for at least one week. During this time, the featured project will be showcased on our main site ( jup.ag ) as well as our social media platforms  ( Twitter  &  Discord ) . 
 To participate, projects should meet the following requirements: 
 
 
 Introduce themselves in the  Jupiter Start: Community Introduction  and obtain attestation from community members. 
 
 
 Provide write-ups for the Educate page. 
 
 
 Specify 2-3 on-chain tasks/actions for users to complete. These tasks need to be trackable and verifiable. 
 
 
 Specify the duration of the education campaign. 
 
 
 Specify the exact dates for the campaign. 
 
 
 Specify the allocation of tokens/points for distribution during the campaign. 
 
 
 On the Jupiter side, we will provide: 
 
 
 A list of qualified traders/users based on certain criteria. 
 
 
 Banners featuring the project on our main site ( jup.ag ) and social media platforms (Twitter & Discord). 
 
 
 Co-marketing efforts to spread the word.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/1-transferring-from-cex.md', 'Transferring from CEXs to Solana 
 
 Welcome to our comprehensive guide on bridging into Solana from major centralized exchanges (CEXs). If you''re eager to explore the thriving ecosystem of Solana but are currently navigating your way from centralized platforms, you''re in the right place. 
 In this guide, we''ll walk you through step-by-step instructions and insights on bridging your assets seamlessly from popular CEXs to Solana, empowering you to tap into the exciting opportunities this blockchain network offers. 
 Step-by-Step Guide for Bridging into Solana from Binance 
 Step 1: Setting Up a Solana Wallet 
 1.1 Download a Solana Wallet: Download a compatible Solana wallet like Phantom or Sollet. 
 1.2 Create a New Wallet: Follow the wallet''s instructions to create a new wallet. 
 1.3 Secure Your Wallet: Write down the seed phrase and store it securely. Never share it with anyone. 
 1.4 Note Your Solana Address: Your Solana wallet address is required to receive funds. Copy it for later use. 
 Step 2: Preparing Your Binance Account 
 2.1 Log into Binance: Open Binance and log into your account. 
 2.2 Ensure You Have the Assets: Ensure you have the cryptocurrency you want to bridge in your Binance account. 
 Step 3: Initiating the Transfer from Binance 
 3.1 Go to ''Wallet'' and Select ''Fiat and Spot'': Navigate to your wallet overview. 
 3.2 Find Your Cryptocurrency: Search for the asset you want to bridge (e.g., USDT, ETH). 
 3.3 Select ''Withdraw'': Click on the ''Withdraw'' button next to your chosen asset. 
 Step 4: Transferring to Solana 
 4.1 Enter Your Solana Wallet Address: Paste your Solana wallet address in the ''Recipient’s SOL Address'' field. 
 4.2 Choose the Network: Select the Solana network (SOL) for the transfer. 
 4.3 Enter the Amount: Input the amount of the cryptocurrency you wish to transfer. 
 4.4 Double-Check Details: Ensure all details are correct. Verify the address and network. 
 4.5 Confirm the Withdrawal: Click on ''Withdraw'' to initiate the transfer. 
 Step 5: Confirming the Transaction 
 5.1 Await Confirmation: Wait for Binance to process the transaction. This may take a few minutes. 
 5.2 Check Your Solana Wallet: Log into your Solana wallet to confirm that the funds have arrived. 
 Step 6: Final Steps 
 6.1 Transaction History: You can view the transaction history in both your Binance account and your Solana wallet. 
 6.2 Use Your Funds: Once the transfer is complete, you can use your funds on the Solana network. 
 Important Notes: 
 Fees: Be aware of withdrawal fees and network fees.
Minimum Transfer Amount: Check for any minimum amount requirements for transfers on Binance. 
 Security: Always double-check addresses and transaction details to avoid errors. 
 Troubleshooting: 
 Delayed Transaction: If the transaction is taking longer than expected, check the transaction status on Binance and in your Solana wallet. 
 Incorrect Address: If you entered an incorrect address, unfortunately, the transaction cannot be reversed. Always double-check before confirming. 
 :::note
This guide provides a general overview and may vary slightly depending on the specific cryptocurrency you are transferring and updates to the Binance or Solana wallet interfaces. Always refer to the latest guidelines provided by Binance and your Solana wallet.
::: 
 Step-by-Step Guide for Bridging into Solana from Coinbase 
 Step 1: Setting Up a Solana Wallet 
 1.1 Download a Solana Wallet: Choose and download a Solana-compatible wallet like Phantom or Solflare. 
 1.2 Create a New Wallet: Follow the instructions provided by the wallet to create a new wallet. 
 1.3 Secure Your Wallet: Safely store your seed phrase or private key. 
 1.4 Note Your Solana Address: Copy your Solana wallet address for later use. 
 Step 2: Preparing Your Coinbase Account 
 2.1 Log into Coinbase: Access your Coinbase account. 
 2.2 Check Your Assets: Ensure you have the assets you want to bridge in your Coinbase account. 
 Step 3: Initiating the Transfer from Coinbase 
 3.1 Navigate to ''Portfolio'': Go to your ''Portfolio'' page on Coinbase. 
 3.2 Select the Asset to Transfer: Find the cryptocurrency you wish to bridge. 
 3.3 Choose ''Send/Receive'': Click on ''Send/Receive'' at the top right of the screen. 
 Step 4: Transferring to Solana 
 4.1 Enter Transfer Details: In the ''Send'' tab, input the amount you wish to transfer. 
 4.2 Input Your Solana Wallet Address: Paste your Solana wallet address in the ''To'' field. 
 4.3 Select the Network: Choose the appropriate network for the transfer (this step may vary based on the asset you''re transferring). 
 4.4 Review and Confirm: Double-check all details, including the address and network. 
 Step 5: Confirming the Transaction 
 5.1 Complete Security Checks: Follow any additional security steps required by Coinbase. 
 5.2 Wait for the Transfer: The transaction will be processed. Timing can vary. 
 Step 6: Receiving in Solana Wallet 
 6.1 Check Your Solana Wallet: Log into your Solana wallet to confirm the receipt of funds. 
 6.2 View Transaction History: Your transaction history can be viewed in both your Coinbase account and Solana wallet. 
 Important Notes: 
 Network Selection: Make sure to select the correct network compatible with Solana. 
 Fees: Be aware of any transaction fees. 
 Minimum and Maximum Limits: Check any limits on the amount you can transfer. 
 Troubleshooting: 
 Transaction Delays: Some delays are normal. Check the transaction status in both Coinbase and your Solana wallet. 
 Wrong Address Input: Transactions to a wrong address cannot be reversed. Always double-check before confirming. 
 Security Tips: 
 Verify Addresses: Always verify the correctness of the wallet address. 
 Be Cautious of Phishing: Be aware of phishing attempts and only use official websites and applications. 
 :::note
Please note that the specific steps may vary depending on the type of cryptocurrency you are transferring and any updates to the Coinbase or Solana wallet interfaces. Always refer to the most recent guidelines provided by Coinbase and your chosen Solana wallet.
::: 
 Step-by-Step Guide for Bridging into Solana from Bybit 
 Step 1: Setting Up a Solana Wallet 
 1.1 Download a Solana Wallet: Select and download a Solana-compatible wallet, such as Phantom or Sollet. 
 1.2 Create Your Wallet: Follow the provided instructions to create a new wallet. 
 1.3 Secure Your Wallet: Safeguard your seed phrase or private key. 
 1.4 Copy Your Solana Address: Note down your Solana wallet address for later use. 
 Step 2: Preparing Your Bybit Account 
 2.1 Log into Bybit: Access your Bybit account. 
 2.2 Check Your Holdings: Make sure you have the assets you wish to bridge in your Bybit account. 
 Step 3: Initiating the Transfer from Bybit 
 3.1 Access the ''Assets'' Section: Navigate to the ''Assets'' section in Bybit. 
 3.2 Locate the Asset to Transfer: Find and select the cryptocurrency you want to bridge. 
 3.3 Click on ''Withdraw'': Initiate the withdrawal process for the chosen asset. 
 Step 4: Transferring to Solana 
 4.1 Enter Transfer Details: In the withdrawal section, enter the amount you want to transfer. 
 4.2 Input Your Solana Wallet Address: Paste your Solana wallet address in the designated field. 
 4.3 Choose the Correct Network: Select the appropriate network that is compatible with Solana transfers. 
 4.4 Confirm the Details: Double-check all entered information, especially the wallet address and network. 
 Step 5: Confirming the Transaction 
 5.1 Complete Security Verifications: Follow Bybit’s security procedures for withdrawal. 
 5.2 Await the Transfer: The transaction will now process, which may take some time. 
 Step 6: Receiving in Your Solana Wallet 
 6.1 Check Your Solana Wallet: Open your Solana wallet to confirm the arrival of funds. 
 6.2 Transaction History: Review the transaction history in both your Bybit account and Solana wallet. 
 Important Notes: 
 Network Selection: Ensure the selected network is compatible with Solana. 
 Transaction Fees: Be aware of transaction fees that may apply. 
 Transfer Limits: Check if there are any minimum or maximum transfer limits. 
 Troubleshooting: 
 Delayed Transactions: If the transaction is delayed, verify the status in both Bybit and your Solana wallet. 
 Incorrect Address: If you send to an incorrect address, the transaction is usually irreversible. Always verify the address before confirming the transfer. 
 Security Tips: 
 Double-Check Addresses: Ensure the accuracy of the wallet address before transferring. 
 Beware of Scams: Stay alert to phishing scams and use official websites and apps. 
 :::note
This guide provides an overview based on the typical process of transferring assets from Bybit to Solana. The specific steps may slightly vary depending on the cryptocurrency you are transferring and any updates to the Bybit platform or the Solana wallet interfaces. Always refer to the latest instructions provided by Bybit and your chosen Solana wallet.
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-limit-order-with-sdk.md', 'sidebar_label: "Limit Order with SDK"
description: Master limit order creation on Solana with Jupiter SDK. Streamline trades and optimize with referral perks.
title: Creating a Limit Order with the SDK 

     Jupiter Limit Order SDK Documentation 
     

 Program Address 
 jupoNjAxXgZ4rjzxzPMP4oxduvQsQtZzyknqvzYNrNu 
 Installation 
 Our published package can be found here at  NPM . 
 yarn add @jup-ag/limit-order-sdk
 
 Usage 
 1. Import the needed libraries 
 import { LimitOrderProvider } from "@jup-ag/limit-order-sdk";
 
 2. Load limit order instance with connection 
 // This RPC endpoint is only for demonstration purposes so it may not work.
const SOLANA_RPC_ENDPOINT =
  "https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/";
const connection = new Connection($SOLANA_RPC_ENDPOINT);

const limitOrder = new LimitOrderProvider(
  connection,
  // referralPubKey and referralName are both optional.
  // Please provide both to get referral fees.
  // More details in the section below.
  // referralPubKey,
  // referralName
);
 
 :::info
Always make sure that you are using your own RPC endpoint. The RPC endpoint used by the connection object in the above example may not work anymore.
::: 
 Create limit order 
 // Base key are used to generate a unique order id
const base = Keypair.generate();

const { tx, orderPubKey } = await limitOrder.createOrder({
  owner: owner.publicKey,
  inAmount: new BN(100000), // 1000000 => 1 USDC if inputToken.address is USDC mint
  outAmount: new BN(100000),
  inputMint: new PublicKey(inputToken.address),
  outputMint: new PublicKey(outputToken.address),
  expiredAt: null, // new BN(new Date().valueOf() / 1000)
  base: base.publicKey,
});

await sendAndConfirmTransaction(connection, tx, [owner, base]);
 
 expiredAt  - Can be either null or Unix timestamp in seconds. 
 Query user order and history 
 import { ownerFilter } from "@jup-ag/limit-order-sdk";
import { OrderHistoryItem, TradeHistoryItem } from "@jup-ag/limit-order-sdk";

const openOrder = await limitOrder.getOrders([ownerFilter(owner.publicKey)]);

const orderHistory: OrderHistoryItem[] = await limitOrder.getOrderHistory({
  wallet: owner.publicKey.toBase58(),
  take: 20, // optional, default is 20, maximum is 100
  // lastCursor: order.id // optional, for pagination
});

const orderHistoryCount: number = await limitOrder.getOrderHistoryCount({
  wallet: owner.publicKey.toBase58(),
});

const tradeHistory: TradeHistoryItem[] = await limitOrder.getTradeHistory({
  wallet: owner.publicKey.toBase58(),
  take: 20, // optional, default is 20, maximum is 100
  // lastCursor: order.id // optional, for pagination
});

const tradeHistoryCount: number = await limitOrder.getTradeHistoryCount({
  wallet: owner.publicKey.toBase58(),
});
 
 Cancel order 
 const tx = await limitOrder.cancelOrder({
  owner: owner.publicKey,
  orderPubKey: order.publicKey,
});

await sendAndConfirmTransaction(connection, tx, [owner]);
 
 Batch cancel order 
 const tx = await limitOrder.batchCancelOrder({
  owner: owner.publicKey,
  ordersPubKey: batchOrdersPubKey,
});

await sendAndConfirmTransaction(connection, tx, [owner]);
 
 :::info
Due to the transaction size limit, the maximum allowed cancellation order per transaction in a batch is 10.
::: 
 Referral 
 Check out the  referral program  for Limit Order.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/legacy/6-migrating-api-sdk.md', 'Migrating the API or SDK 
 Migrating the API 
 From v3 to v4 
 
 You do not have to support Versioned Transactions to migrate to v4.  You can set the  parameterasLegacyTransaction=true  to have the api return a legacy swap transaction. 
 V3 used Legacy transactions. V4 has migrated to use Versioned Transactions with Address Lookup Tables. 
 With  VersionedTransaction  and Address Lookup Tables, all Jupiter swaps are done in a single transaction, so they no longer need to handle sending multiple transactions sequentially. 
 Use  VersionedTransaction.deserialize   to deserialize the transaction object in order to insert your own instructions in the transaction. 
 V4 swagger: https://quote-api.jup.ag/v4/docs/static/index.html 
 
 From v1 to v3 
 
 Remove token ledger 
 Change  slippage  to  slippageBps 
 Route now return  slippageBps 
 V1 swagger : https://quote-api.jup.ag/docs/static/index.html 
 V3 swagger: https://quote-api.jup.ag/v3/docs/static/index.html 
 
 Migrating the SDK 
 From v2 to v3 
 
 slippageBps  instead of  slippage 
 
 slippageBps  = Math.ceil(slippage*100) 
 
 
 Remove the need of token ledger 
 Example: https://github.com/jup-ag/jupiter-core-example/commit/1f6967e46736b52ba9b4d7a85f91d2628e3d0e26 
 
 From v1 to v2 
 
 jupiter.computeRoutes ,  inputAmount  changed to  amount  and the typing is changed from number to JSBI. (https://github.com/GoogleChromeLabs/jsbi)
 
 The result of  computeRoutes  also return JSBI like  inAmount  and  outAmount . 
 
 
 outAmountWithSlippage  changed to  otherAmountThreshold 
 Example: https://github.com/jup-ag/jupiter-nextjs-example/commit/ff91a085f129d34cf83b14b1fda62ef370d7f1a9', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/legacy/8-customise-market-cache.md', 'sidebar_label: "Custom Markets Cache"
description: Adding your own custom markets to Jupiter 
 Adding Your Own Custom Markets to Jupiter 
 Jupiter is periodically caching active and liquid markets at https://cache.jup.ag/markets?v=3.  Markets must have a minimum amount of liquidity. If your market does not meet the requirements for automatic listing you can still amend your own markets cache and use the SDK. 
 It is designed to reduce network requests and optimise load speed, as a result some constant values might be added to the bare  AccountInfo  corresponding to a pool. 
 The market cache is an  Array<AccountInfo<string[]> & {pubkey: string, params?: any}> .
 params  are specific to each AMM and the expected fields can be found in the constructor of  @node_modules/@jup-ag/core/dist/lib/<ProtocolAmm> . 
 For instance, this is the entry for a Raydium market: 
 {
  "data": [
    "AQAAAAAAAAD+AAAAAAAAAAcAAAAAAAAAAwAAAAAAAAAJAAAAAAAAAAYAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAEBCDwAAAAAAAAAAAAAAAABAS0wAAAAAAEBCDwAAAAAAQEIPAAAAAAABAAAAAAAAAADKmjsAAAAAAMqaOwAAAAAFAAAAAAAAABAnAAAAAAAAGQAAAAAAAAAQJwAAAAAAAAwAAAAAAAAAZAAAAAAAAAAZAAAAAAAAABAnAAAAAAAAU2uDHCcEAAChuDUAAAAAADmuvwEAAAAAq9TxQpsiAADFFAdiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMB1nhl6uUoAAAAAAAAAAADfr39PAwAAAAAAAAAAAAAArDHzAQAAAABBW/oLAwAAAAAAAAAAAAAAmugQ0aF7QwAAAAAAAAAAAEcKgd3SLwAA3Xy2Hyf6BFXiVI0V7b38LKWNOLajCnUbYYOnX91NiUwMczxA1Fr+2j9aF8wBJjCEmuTh0xq062Nzcx3tNyja3dwEZG7buv4QDNTvUo5Vfo/pDJf0bfq5oy5DuhgJg15Axvp6877brTo9ZfNqq8l0MbG75MLS9uDkfKYCA0UvXWEHcev5yxUY3bPt1CDdT5xDeoUmBXWzVdqyEcbk9hVnQlDvrexxF14vgiHVZykh2ka5nLLm5UBv6JAeyM3tcTpxEyubQ9DttKnfkeOdSTtFMlZ2lJ++nHZAJGv9t5rPQjqFDy1uAqR6+CTQmradxC1wyyjL+iSft+5XudJWwSdi73NZ/XQWidKldBI0uRDuuB7WxPCA6PLR9p+K2esVyOgYtdClj/EROg6VrxA3OAsmZINCgjfUo+5a0nYEO6GCrzaLuHUvBJims1CBun4bNygcZuuxfCAL0wPQiauGhKmyTfflDIK2/QOR3b6OxK/pJgfYBmbwDOqRg/8vhAc+E4W1YJXC4cTcAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
    "base64"
  ],
  "executable": false,
  "lamports": 6124800,
  "owner": "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",
  "rentEpoch": 329,
  "pubkey": "5y2QYKY8gQCcmG6jy4fc7wFg8L5SW7bkyvMH3jUTqBdy",
  "params": {
    "serumBids": "F7G6Uvk6pRT3PnhZLm5YGA4GGTWHE8AfrdTVqyPc9fuC",
    "serumAsks": "83tUsZUQeXDZR7uhtWHin2epPdjMNPtdyxCNgcFyhaFS",
    "serumEventQueue": "5SVX8MeCrxVjWazeD5oeWjYBurHvygpma4NyTi9hmGws",
    "serumCoinVaultAccount": "9CgWdLCkkVY1Mi95c8p3oKvCM7Fu3JQG9EBmRPvgBfoX",
    "serumPcVaultAccount": "4mTDtiiSvjeqEYJcQVfDgbKBVJNpwjSyTc58q7GdB8Vo",
    "serumVaultSigner": "2c7BqzhwBCb86DprTKte7UfK6F4Xwu4B1uX7YsWZ4c7G"
  }
}
 
 It can be crafted using the  RaydiumAmm  constructor along with the  RaydiumAmm.decodeSerumMarketKeysString  static method.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/legacy/3-jupiter-legacy-transaction.md', 'sidebar_label: "Legacy Txns"
description: "About Jupiter Legacy Transactions" 
 About Jupiter Legacy Transaction 
 The latest v6 API will only return one swapTransaction when  asLegacyTransaction=true  is supplied to enable legacy transactions. So you no longer need to do a setup or cleanup transaction. 
 Due to transaction size limits, only certain amms can be swapped through together. 
 Swap Success / Failure 
 :::info  Jupiter Swap Success/Failure Stat 
::: 
 
 The typical  swap success rate for Jupiter is 93.7%  excluding failures due to slippage. 
 One of the most prominent errors is the UI not limiting the input amount properly resulting in trying to swap with more tokens than the user has available.
 
 The errors for this is  {"Custom":1}  from Token Program and  {"Custom":40}  from Raydium AMM. 
 
 
 {"Custom":6000}  is slippage rate failure. 
 You may see lower swap success rate if...
 
 You use the SDK and are not limiting the intermediate tokens to the most liquid tokens.  By default, the SDK will use all tokens as intermediary tokens. 
 Your trade sizes are very small, < 1 USD. 
 In this case the swap route will route through the long tail of token markets which are not very durable and can disappear as another swap takes it. 
 But this is generally not a real-world swap.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/legacy/2-how-does-jupiter-work.md', 'How Does Jupiter Work? 
 Under the Hood 
 The price for a token can change quickly at any point in time. So the best priced trade is not always on one DEX and may involve a combination of trades across many DEXes.
Here are some key features for how Jupiter discovers the best priced trades. 
 Smart Routing 
 Jupiter directly connects all DEX markets and AMM pools together no matter the provider and will find all direct and multi-hop routes between any two tokens on Solana. 
 Multi-hop Routes 
 
 Not only does Jupiter compare the prices between markets on different DEXes but often the best priced routes are not direct markets. Instead, Jupiter may find the best price by routing through an intermediary token, e.g.  USDC-mSOL-SOL  instead of  USDC-SOL . This may be due to price inefficiencies and/or volatility in the various markets that Jupiter routes through. 
 Trade Splitting 
 Jupiter will split your trade into smaller trade sizes. For example, if you want to make a 100 USDC-SOL trade, it may distribute your trade into a 30 USDC-SOL trade on Raydium and a 70 USDC-SOL trade on Orca. The % distribution of the trades is dynamically determined to give you the best price. Trade splitting helps get better prices for large size trades and trades with tokens where there is shallow liquidity spread out across a number of DEXes. 
 
 Other Key Features of Jupiter 
 Automatically lists new tokens 
 The number of new tokens being added is increasing at an ever faster pace. Jupiter automatically lists any tokens as long as their have  reached enough liquidity . This means you can be assured that you''ll be able to trade new tokens as they launch on Solana. 
 Automatically lists new markets 
 The number of markets and liquidity pools that are launching is also increasing. Jupiter automatically picks up any market or pool for any of the DEXes it currently aggregates. This ensures that Jupiter always has the latest liquidity for any token that is listed as soon as it is available. 
 Swap in single transaction 
 Jupiter has worked to optimize its swap aggregation so that it all fits with the transaction limits so that swapping can be done in one transaction. This is important to handle cases where the price for the token you are buying has changed and no longer fits your slippage limit. If Jupiter cannot make the trade with your slippage limit, it will rollback the transaction and return an error. 
 The basic flow 
 
 User enters in the  tokens they want to trade . 
 User enters in the  amount of tokens  they want to trade for. 
 Jupiter  calculates out all the possible routes  for the token trade. 
 Jupiter  fetches the quotes  for each of those routes and returns the amount of tokens you will receive per route. This includes all fees. 
 Jupiter  ranks each route  by most tokens you will receive. 
 User can select any route but the first route offers the most tokens. 
 User clicks to trigger a swap. 
 User approves the Jupiter transactions from their wallet 
 Jupiter executes the trade.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/legacy/7-example-react-hook.md', 'sidebar_label: "Example: React Hook"
description: Integrate Jupiter into your React App. 
 Integrate Jupiter into your React App 
 Use the React-Hook if you''d like to embed Jupiter into your own React UI. 
 Pre-requisites 
 Setup your  Wallet Adapter  for your frontend application. 
 Installation 
 Open your terminal, navigate to your project directory, and run the command below. 
 npm i @jup-ag/core @jup-ag/react-hook jsbi
 
 Meanwhile, our published package can be found here  NPM . 
 Usage 
 import { TOKEN_LIST_URL } from "@jup-ag/core";
import { JupiterProvider, useJupiter } from "@jup-ag/react-hook";
 
 Create a React component 
 React 
 import React, { useEffect, useState } from "react";

const JupiterApp = () => {
  return (
    <>
      <div style={{ fontWeight: ''600'', fontSize: 16, marginTop: 24 }}>
        Hook example
      </div>
      <div>Number of tokens:</Text>
      <div>Number of input tokens</Text>
      <div>Possible number of routes:</Text>
      <div>
        Best quote:
      </div>
    </>
  )
}

export default JupiterApp;
 
 React Native 
 import React, { useEffect, useState } from "react";
import { Text } from "react-native";

const JupiterApp = () => {
  return (
    <>
      <Text style={{ fontWeight: ''600'', fontSize: 16, marginTop: 24 }}>
        Hook example
      </Text>
      <Text>Number of tokens:</Text>
      <Text>Number of input tokens</Text>
      <Text>Possible number of routes:</Text>
      <Text>
        Best quote:
      </Text>
    </>
  )
}
export default JupiterApp;
 
 Fetch the list of tokens 
 
 Declare the interface. 
 
 export interface Token {
  chainId: number; // 101,
  address: string; // ''EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'',
  symbol: string; // ''USDC'',
  name: string; // ''Wrapped USDC'',
  decimals: number; // 6,
  logoURI: string; // ''https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/BXXkv6z8ykpG1yuvUDPgh732wzVHB69RnB9YgSYh3itW/logo.png'',
  tags: string[]; // [ ''stablecoin'' ]
}
 
 
 Fetch token list from Jupiter API. 
 
 import { TOKEN_LIST_URL } from "@jup-ag/core";

const JupiterApp = () => {
  const [tokens, setTokens] = useState<Token[]>([])
  useEffect(() => {
    // Fetch token list from Jupiter API
    fetch(TOKEN_LIST_URL[ENV])
      .then(response => response.json())
      .then(result => setTokens(result))
  }, [])
  // ...
}

export default JupiterApp;
 
 
 Then, it''s time to look for which token you would like to swap, from the  tokens  array.  In this case, we will swap from  USDC  to  USDT . 
 
 import { TOKEN_LIST_URL } from "@jup-ag/core";

const JupiterApp = () => {
  const [tokens, setTokens] = useState<Token[]>([])
  console.log(tokens) // Look for tokens

  const [inputMint] = useState<PublicKey>(new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"))
  const [outputMint] = useState<PublicKey>(new PublicKey("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"))
  // ...
}
 
 Attach useJupiter hooks 
 import { TOKEN_LIST_URL } from "@jup-ag/core";

const JupiterApp = () => {
  const [tokens, setTokens] = useState<Token[]>([])
  const [inputMint] = useState<PublicKey>(new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"))
  const [outputMint] = useState<PublicKey>(new PublicKey("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"))

  useEffect(() => {
      // Fetch token list from Jupiter API
      fetch(TOKEN_LIST_URL[ENV])
        .then(response => response.json())
        .then(result => setTokens(result))
    }, [])

  // Attach Jupiter hook
  const jupiter = useJupiter({
    amount: JSBI.BigInt(1 * (10 ** 6)), // raw input amount of tokens
    inputMint,
    outputMint,
    slippage: 1, // 1% slippage
    debounceTime: 250, // debounce ms time before refresh
  })

  // ...
}

export default JupiterApp;
 
 :::info How do you calculate the amount to pass in?
Every token have their own decimals place, in our example, both USDC and USDT pairs have their decimals place at  6 .
Assuming in the UI, user entered a value of  1 USDC , we can derive the amount to pass into Jupiter to be  1  multiplied by ( 10  exponent of  6 ) 
 const inputAmount = 1; // UI input
const inputTokenInfo = tokens.find(item => item.address === "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v") // Token info
const amount = JSBI.BigInt(inputAmount * (10 ** inputTokenInfo.decimals)) // Amount to send to Jupiter
 
 ::: 
 Display the result 
 Tab 
 Performing a swap 
 Once you have acquired all the meaningful information from the Jupiter instance, it is time we perform a swap with the exchange() function. 
 :::warning
You would need a  wallet  and  connection  instance to perform a swap, the easiest way to interface with your wallet (Phantom, Sollet, Solflare...) would be the use of  @solana/wallet-adapter-react library , visit the  documentation  for more info.
::: 
 Tab 
 :::info For advanced developers, custom wallet instance can be used as long as it fulfils the interface requirement of: 
 SignerWalletAdapter from ''@solana/wallet-adapter-base/lib/signer.d.ts''
 
 Alternatively, 
 interface CustomWallet {
    publicKey: PublicKey
    sendTransaction(transaction: Transaction, connection: Connection, options?: SendTransactionOptions): Promise<TransactionSignature>;
    signTransaction(transaction: Transaction): Promise<Transaction>;
    signAllTransactions(transaction: Transaction[]): Promise<Transaction[]>;
}
 
 ::: 
 Example 
 If you need more help, pay a visit to  Example (React, Next.js)  or, just fork and start there.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/legacy/4-integrate-jupiter-next-js.md', 'description: Integrate Jupiter into your NextJS App. 
 Integrate Jupiter with NextJS 
 Use the API in your own NextJS UI. 
 NextJS example using Jupiter API 
 https://github.com/jup-ag/jupiter-api-nextjs-example 
 Clone, Build and Run 
 First, fetch the latest version of the example code: 
 $ git clone https://github.com/jup-ag/jupiter-api-nextjs-example.git
$ cd jupiter-api-nextjs-example
 
 Next, follow the steps in the git repository''s  README . 
 Example Demo : https://jupiter-api-nextjs-example.vercel.app/', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/JUP/4-Get-Started.md', 'sidebar_label: ''Get Started''
description: ''Read this to learn how to get started today!'' 
 Important J.U.P Components 
 Regular Events: Attend regular events including AMAs, weekly Uplinks calls, and monthly LFG votes. 
 
 AMAs: Part of the Launchpad process. Help the Core Working Group interview projects seeking to launch with Jupiter. 
 Townhalls: The working group holds regular townhalls to check in with the DAO 
 Uplink calls: Every Wednesday on Zoom at 3:30 PM UTC Kash hosts a weekly overview of Jupiter’s ongoings. 
 Voting Sessions: These last for 3 days and happen during the first week of the month for LFG votes, or intermittently for proposals. 
 
 The LFG Launchpad Process: To launch with Jupiter a project must go through a 4 step process 
 
 Projects make an intro post on the Jupiter research forum 
 They are selected by the CWG to be announced to the community, and are given a Discord channel. 
 These projects are given opportunities to speak to the DAO including multiple AMAs 
 
 During the first week of every month the vote occurs and 2 are chosen. Taking part in the monthly launchpad vote is how you obtain your DAO rewards. 
 How to Vote: 
 
 Head to Vote.Jup.ag 
 Stake your JUP
Votes take place regularly, be involved in  Discord  &  Twitter  to stay in the know.
You get rewards no matter who you vote for, only participation matters 
 
 Work Groups: 
 Work Groups are task-forces of ecosystem leaders that work with the DAO to grow the ecosystem 
 
 Core Working Group: Made up of C2, Slorg, Kemo, and Durden. Responsible for kickstarting and providing the activation energy to processes which support and further the DAO & The Jupiter ecosystem. 
 Uplink Working Group: Led by Kash, the media arm of Jupiter. 
 Catdet Working Group: Led by Julian. Seeks to empower members of the DAO. 
 
 Getting Involved: There are many ways you can start participating 
 
 Vote! 
 Attend regular events 
 Engage in the LFG process 
 Contribute your ideas and feedback in Discord and on the Jup Research Forum 
 
 Gain Roles in Discord: 
 Cadets are an active contributor of the Jupiter community who helps to grow the culture
Cat-of-Cultures are exceptional Catdets who have contributed significant time and energy', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/JUP/index.md', 'sidebar_position: 1 
 Jupiter United Planet (J.U.P), the home of the Jupiter Space Catdets 
 The best DeFi product can only be as good as the DAO that drives it. It has been one of our longest and strongest missions to create a well-functioning DeFi DAO, one that rewards contribution and success and forms the backbone of Solana DeFi and bring forth the Decentralized Meta. 
 With Jupiter and $JUP, we have the opportunity to bring that dream to life, through J.U.P. 
 Learn more about $JUP''s genesis story, the J.U.P DAO and the Defi 2.0 mission in the links in this section.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/JUP/3-socials.md', 'sidebar_label: ''Social Links''
description: Community related links. 
 Social Links 
 
 Blog 
 Twitter  @JupiterExchange 
 Discord 
 Snapshot of JUP Stakers & Voters , Courtesy of  Allium Labs .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/JUP/2-Understand-Jupiter.md', 'sidebar_label: ''Jupiter, $JUP and J.U.P''
description: ''All about Jupiter, $JUP and the J.U.P. DAO'' 
 Jupiter: Defi 2.0 
 Jupiter started as an aggregator, but we have evolved far beyond that into a full stack ecosystem play: 
 
 Full array of spot products (swaps, limit orders, dca) 
 One of the top perp platforms in defi 
 Solana gateway 
 Our fledging  LFG launchpad 
 (Hint hint) 
 
 Learn about Jupiter, $JUP and J.U.P 
 
 
 Stats: Jupuary 2024 : Jupiter directs 80% of organic volume and 65% of all volume on Solana.We are the most used trading platform in defi, most used service in Solana, one of the top perp platforms in defi. 
 
 
 JUP: The Genesis Post : $JUP is an incredibly valuable resource that will be used courageously and strategically to grow Jupiter and the meta. Learn about Defi 2.0, our 50/50 tokenomics, and our annual Jupuary plan. 
 
 
 $JUP Minting and Accountability : Industry leading token accountability and transparency 
 
 
 LFG Launchpad Design : Try out our LFG price curve modelling tool 
 
 
 Reddit AMA : Collection of your top questions about our product and strategy. 
 
 
 Interviews & Media : And the cats go meoww! 
 
 
 Recap our LFG platform and $JUP journey: 
 
 2 Nov 2023: Solana Breakpoint "Grow the Pie" presentation 
 16 Nov 2023: Community Airdrop consultation part 1 
 21 Nov 2023: Wrapping up the Community Airdrop Consultation 
 15 Dec 2023: JUP, PIE, CATS 
 19 Dec 2023: Jupiter Strategy explained with discord screenshots 
 2 Jan 2024: Jupuary Kickoff 
 23 Jan 2024: Announcing LFG Launchpad Beta 
 28 Jan 2024: Good Cats review 
 29 Jan 2024: LFG test launch reflections 
 31 Jan 2024: Pre-JUP reflections', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/1-swap.md', 'sidebar_label: "How to Swap"
description: Learn token swapping on Jupiter with top tips, slippage settings, and easy dApp navigation.
title: How to Swap Tokens on Jupiter
slug: /jupiter-swap/swap 

     How to Swap Tokens on Jupiter: Step By Step 
     

 
 :::tip Jupiter charges no fees
There are no protocol fees on Jupiter. The only fees are transaction fees and DEX/AMM fees which are factored in to the swap calculations. If you see more SOL deducted than what you expect, it is probably due to deposits for creating  Associated Token Accounts .
::: 
 Basic Swap User Flow 
 
 First, navigate to the  Jupiter Website .  Double check  that the URL in your search bar is correct: https://jup.ag/ 
 Next, connect your wallet by clicking the  Connect Wallet  button at the top right corner of the site. 
 Select the tokens that you want to swap from and into with the token selectors. 
 Enter the input amount of the selected token that you want to swap from. 
 Review the swap route and output token amounts. Checkout the full list of supported DEXes for routing  here . 
 Configure additional parameters to help with your trade, including: Priority Fees, Slippage Settings, and Swap Settings. 
 After you have confirmed all the parameters and inputs, click on the ''Swap'' button, and you will be prompted with a confirmation from your wallet. If you ''Confirm'', your swap will be sent to the blockchain, to be finalized. 
 A notification toast will appear in the lower left corner that will inform you of the current status of your transaction. 
 You can view your swap history at the bottom of the page or click on the wallet at the top right corner. 
 
 Let''s go through Jupiter Settings in greater detail below. 
 
 Jupiter Settings 
 
 
 Jupiter Swap:   Jupiter Swap  tab  (the current tab you are in)  where you can instantly spot swap for any supported SPL token. 
 Jupiter Limit Order:   Jupiter Limit Order  tab where you can place limit orders at a specific price and receive tokens directly in their wallet if the order is triggered and filled. 
 Global Priority Fee:   Transaction Priority Fees  is a Solana feature that allows users to bid for priority for their transactions in the leader''s queue. 
 Jupiter Global Settings:  Select your default settings like language, Solana explorer and RPC endpoint. 
 Connect Wallet:  Connect to your preferred wallet to interact with Jupiter. 
 Refresh Quote:  Refresh quote button to update the latest quote for the configured asset swap in the terminal. 
 Slippage Settings:  Slippage settings configure your acceptable threshold for price change between when you submit a transaction and it executes. 
 Swap Settings:  These settings will directly impact the routing and pricing of the swaps being performed. Typically, default settings works for beginners. 
 
 Global Settings 
 :::tip The RPC Endpoint Selector now displays active end-point latency
Due to network traffic loads RPC endpoints can get overloaded, which can lead to latency issues that will directly impact your trade executions. Reviewing the RPC latency and selecting the lowest latency option is a best practice to ensure the fastest trade execution.
:::
 
 
 Language:  Pick your preferred language from English, Chinese, Vietnamese, Japanese, Indonesian, and Korean. 
 Preferred Explorer:  Pick your preferred explorer from Solscan, SolanaFM, Solana Beach, Solana Explorer, XRAY, and OKLink. 
 RPC Endpoint:  Pick your preferred public RPC endpoint from Triton RPC, Helius RPC, or use your own custom RPC endpoint. 
 
 Transaction Priority Fees 
 :::info Transaction Priority Fees
Trades submitted to the blockchain are assigned a priority based on the fee bidding process. The higher the priority fee, the higher your transactions will be in the execution queue. During times of congestion, increasing your priority fee can help. Use with caution and remember to re-adjust the fee selection afterwards.
:::
 
 
 Transaction Broadcasting Selector:  Select your transaction broadcasting option. Choose from submitting to RPCs with priority fee, sending your transaction directly to Jito Validators via a bundle, or an Mixed, which fires both and see which lands first. 
 Priority Level:  Specify the Priority Level, in increasing priority: Fast, Turbo, Ultra for the transactions you are executing. 
 Fee Mode:  Pick your preferred Fee Mode. Either specify a Max Cap for your fee or an Exact Fee for your transactions. 
 
 Slippage Settings 
 ::::info Slippage Settings 
 Utilizing the Slippage Setting to ensure your transactions are executed is a common practice. The slippage setting is important to prevent users from getting poor swap rates on transactions if the asset price falls below the specified slippage rate. 
 :::danger 
 This is an advanced setting and should be used with caution. 
 ::: 
 :::: 
 
 
 Mode:  Select the slippage mode you want to utilize. Dynamic mode optimises slippage between success rate, and sandwich protection through a series of simulations. Auto slippage will utilize Jupiters internal slippage calculations for the best setting. Fixed will adhere to your specified slippage amount. 
 Slippage:  Enter the maximum acceptable slippage rate for your swaps. 
 
 Swap Settings 
 
 
 Direct Route Only:  Using Direct Route Only ensures that the transaction will only be submitted to a single pool. This will limit a lot of intermediate tokens and filter out a lot of other viable routes that use intermediary tokens. 
 Use wSOL:  Using  Wrapped SOL (wSOL)  makes using Jupiter faster and more convenient for traders who trade frequently with SOL, since it avoids having to wrap/unwrap SOL. 
 Versioned Transaction:  Enabling  Versioned Transaction  improves composability so Jupiter will be able to fit in more routes and get even better pricing all in a single transaction. 
 
 
 Jupiter Swap 
 
 
 Input Token Wallet Balance:  Jupiter detects the input token balance in your wallet. 
 Half/ Max Amount:  Shortcut buttons to quickly input  Half  or  Max  of the balance amount. 
 Input Token / Token to Sell:  Token selector to select token to sell or swap from. 
 Input Token / Token to Sell Amount:  Specify the amount of input token to sell or to swap from. 
 Input token & Output Token Switch:  This button switches the input and output token. 
 Output Token Wallet Balance:  Jupiter detects the output token balance in your wallet. 
 Output Token / Token to Buy:  Token selector to select token to buy or swap to. 
 Output Token / Token to Buy Amount:  Jupiter computes this quoted output amount from the swap configuration and current on-chain price rates of the assets involved in the route.  (This includes swap fees from all DEXs and AMMs along the route.) 
 Order Routing:  Order routing shows the markets being routed through and each hop along the path. This can sometimes involve Multi-hop and Split trades to achieve the best results. 
 Action - Swap:  Once you have confirmed all the parameters, LFG! 
 
 Order Routings 
 :::info Order Routing
Clicking on the area marked number 9 from the Swap terminal above will show you the exact order routing path for the quoted transaction. You can also see the split trades and all market hops along the route.
:::
 
 
 Swap Details / Price Info 
 
 
 Exchange Rate for the Selected Tokens:  This is the current exchange rate, based on the on-chain prices for the selected input and output tokens, along with a comparison against Coingecko Price API. 
 Price Impact:  Price Impact is influenced by the available liquidity to settle the trade. The larger the trade the larger the price impact on the selected assets. 
 Minimum Received:  Minimum received takes into account the slippage setting and market liquidity to compute the minimum amount that the user will receive even with maximum price fluctuations during a successful swap. 
 Max Transaction Fee  This is the maximum fee you will pay to execute the quoted transaction. This takes into account your selected fee settings. 
 Deposit:  If you are transacting assets you have not owned before, Solana may require a small deposit amount to create the ATA account in your wallet to hold that asset. This will only occur with assets you have not owned previously.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-01-24-bonk-update.md', 'slug: bonk-update
title: "$BONK Update" 
 As per the  original announcement , we have been hosting a discussion on this topic in  #bonk , and we had a wide range of opinions around both the proposed plan and how to best execute it. 
 We would like to give a big thanks to everyone, including the BONK community, users, and the BONK core contributors for coming together to discuss this very tricky situation, and especially for everyone’s understanding of this dilemma we found ourselves in. 
 
 After a week of intense debate, 3 things became pretty clear: 
 
 Views are very divided, one of which is the perspective of burning everything or not retrieving the tokens at all, since it was already misplaced, with the other one to distribute them 100% immediately. It is clear that compromise will be needed. 
 ​​It was important for us to ensure that the tokens would be distributed where it was intended while also reaching an agreement that would be acceptable to the BONK core contributors and community to avoid a holy war, which would have benefitted no one. 
 Lastly, it became clear from the discussion that we cannot take custodianship of this at any cost, so the best thing to do would be to allow the core contributors to claim the tokens, with the understanding that the tokens will be distributed accordingly 
 
 We believe that a good course of action will be to proceed with the Jupiter program upgrade to allow the BONK core contributors to claim the tokens and facilitate the staggered distribution as per the original plan. This obviously requires tradeoffs from all sides, but this was a reasonable outcome for the majority of folks in the channel. 
 Lastly, we are extremely gratified by the chance to be of service to our users, as well as the opportunity to interact with the bonk contributors and community to work through this together. Great times lie ahead for the ecosystem. Let''s grow it to new heights together!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-01-13-bonk-retrieval-and-distribution-plan.md', 'slug: bonk-retrieval-and-distribution-plan
title: "$BONK Retrieval And Re-Distribution Plan" 
 At Jupiter, we are big fans of the BONK community and we deeply appreciate the energy it has brought to the Solana ecosystem.  We have also been strongly supportive of the community, including  burning the BONK fees  we collected from limit orders placed on our platform. 
 Late last week, we discovered that BONK tokens were airdropped to Openbook open order accounts rather than to the user accounts they were intended for. Since most traders use Openbook via Jupiter, a large portion of these tokens  (10T $BONK)  were airdropped to open order accounts managed by the Jupiter program. The full list of open order accounts and the respective accounts those were created for can be found  here . 
 
 Upon investigation, we realized that we would be able to potentially help the original targeted recipients retrieve the tokens by performing an upgrade to our program. We then reached out to the BONK core contributors to perform a full post technical post mortem and discussed what is the best plan forward. 
 Given the large amount of tokens at stake and the current phase of the market and ecosystem development, it appears that re-distributing all the tokens all at once might have the detrimental effect of causing a crash that might be hard to recover from, which will benefit no one, including the original targeted recipients and the Solana ecosystem. 
 As such, along with the BONK early contributors, we would like to propose a plan to help the original recipients claim the tokens in a way that would have the least impact in the market and give the BONK ecosystem to further build up liquidity and trust in the market. 
 It is important to note that Jupiter is not a current custodian for the tokens and has nothing to gain from this plan - we are here both to help the targeted recipients get their $BONK and also the project to maintain the great energy and momentum. 
 While it is of course not ideal that the tokens were uncovered so late in the launch cycle, we believe that if we put on a united front, this will end up being a net positive for all the key stakeholders - including the targeted recipients, BONK community, n the Solana ecosystem. 
 This post will outline the timeline of events, the full technical details of what happened, and an assessment of the current market and proposed plan. 
 Timeline Of Events 
 
 Dec 25th 2022 - BONK  Airdrop  to OpenBook Open Order Accounts 
 Jan 6th - Jupiter discovers  $BONK tokens sent to Jupiter-managed OO accounts. We initiate an investigation to see how many token was sent, to which accounts, and to see if these tokens are retrievable. 
 Jan 6th - Jupiter contacts the BONK core contributors to discuss how best to distribute the token airdrop to the original recipients. 
 Jan 7th -  Joint tweet  by BONK and Jupiter to make the community aware of the situation. 
 Jan 12th - Release of the proposed plan to redistribute to the intended recipients moving forward. 
 
 Technical Details 
 
 The query the BONK core contributors used to build their list of wallets executing transactions with the OpenBook Program inadvertently pulled in the open orders accounts used to hold the order information for trading on a market on OpenBook. 
 When a user trades on OpenBook with Jupiter, Jupiter creates and uses a Programmed Derived Address  (PDA)  to create the open orders account needed to execute the trade. Using a PDA allows the Jupiter program to sign for the address without needing a private key which allows the program to manage these accounts so users don''t have to, greatly simplifying the user experience while not having any security or custody implications. 
 When $BONK was airdropped to these Jupiter open orders account, it created an Associated Token Account  (ATA)  for these Jupiter PDAs to store the token. 
 In order to access the $BONK held in these ATAs, we will need to update the Jupiter program to allow the tokens to be claimed as only the program can manage these accounts. The latest Jupiter program  (V4)  has an update authority held by us. 
 We maintain update authority on our latest programs in order to regularly add new DEX integrations, fix issues, and work on new features. This also allows us to correct the 10T airdrop and deliver it to the intended recipients. 
 
 Market Assessment and Proposed Plan 
 As mentioned, given the large amount of tokens at stake and the early stage of the market/ecosystem - a plan to distribute all the tokens at once could have the effect of creating a major crash even before the tokens are retrieved and released - benefitting no one and potentially stopping the nascent BONK project. As such, along with the BONK early contributors, we would like to propose a plan to redistribute to the intended recipients of the original airdrop that mitigates potential market fears while giving the BONK community time to build further confidence in the token and the project. 
 The plan is as follows: 
 
 We will work on retrieving the tokens sent to the OpenBook open order accounts 
 Set up monthly releases over 12 months because a staggered release will release tokens in a manner that is absorbable by the market, and we believe that the community and ecosystem will continue to mature in the meantime 
 The first release will be performed next week to give us enough time to set everything up and for the market and community to digest the news 
 Additional incentives will also be provided for these recipients, as long as they continue doing a minimum number of trades that route through OpenBook. 
 
 Besides  (3)  which will also help to spur ongoing usage of OpenBook, the BONK contributors will also be aiming to assist software development of the project, which aligns with the original intent of sparking OpenBook development. 
 
 Next Steps 
 We would like to get feedback on this plan from both the targeted recipients and the BONK community. We have opened up a dedicated channel called #bonk in  our discord , so feel free to chime in there! 
 After the plan is finalized, we will proceed to retrieve the tokens on behalf of the users and set up a site to allow recipients to claim tokens as they are released monthly. 
 Of course, it would have been ideal if all tokens would''ve been received simultaneously, but it is now a chance for us as a community to come together and come out stronger from this.  After the many blows suffered by the crypto community (in particular Solana), $BONK has brought much excitement to the market, and we appreciate the chance to play our part in helping this along. 
 We would love to see everyone involved in this to work together to keep the great energy going, and create a long term sustained effort towards creating more great tokens and communities for the Solana ecosystem, helping it get to new heights too!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-12-15-jup-pie-cats/index.md', 'slug: jup-pie-cats
title: "Jup Pie Cats" 
 Over the last week, as everyone in the world was hunting me for JUP updates, I must confess to being very inspired by this video instead. 
 
 I mean, check this out - the level of care he takes to get the cat ready is exquisite. The cat is now well-fed, very clean, and at peace. And that’s a cat ready to tackle the incredibly messy world ahead with all kinds of possibilities and adversities. And that’s the amount of care we aspire to get Jupiter to as we ready for JUP. 
 As much as we would love to just launch JUP and get back to building world-class tech, we also want to make sure all the key things that are important to us - the token distribution, the ethos, making sure no one is left behind - are clearly decided, communicated, and clarified, because things are really quite different after the genesis moment. 
 Some of these are pretty controversial topics, but that’s the whole point of me highlighting them now. I hope to have these discussions as early as possible so we start JUP with as much common understanding and alignment as possible across every part of the stack. I will be on Discord and Reddit as much as possible over the next few days to debate, discuss and clarify anything. 
 Because, as I have said from day one, this is not just my journey, this is ours. 
 JUP 
 Since cats have small brains and did not go to MIT or Jane Street, we cannot process super complicated token plans and confusing power dynamics. 
 So instead, here’s a pie with cats: 
 
 Tokenomics reflect the ethos of a project, and our key ethos is as simple as it gets - For a project like Jupiter, there needs to be an equal weight between a focused entity able to constantly recruit world-class talent, build product, and execute strategy, and a wider community able to fact-check, counterweight, and help to course-correct. 
 As such, the 10B JUP will be 50% managed by the team, 50% distributed to the community. Perfectly balanced, as all cats should be. 
 
 We believe this balance will be extremely important to the long-term success of Jupiter. The community needs to trust the team and give room for maneuver, while the team needs to trust the community and invite everyone to be genuine stakeholders. Without this understanding, it will just be endless angst on both sides, the root cause of the classic “devs do something” phenomenon. 
 The major change from the green paper is that there is no more token sale. Instead, the 20% will now be divided between 10% for liquidity provision, and 10% for community contributors and grants. 
 For the team managed component, only the 10% of liquidity provision will be used in the first year. The 20% for the current team will start vesting after a year for 2 years. The remaining 20% will be the strategic reserve, used for future team members, future strategic investors, and for past Mercurial stakeholders. 
 The last component will be locked for at least a year, with a minimum of six months'' notice given to the community before any liquidity event can happen. Each of these pools will be held in separate muti-sigs for easy trackability by the public. 
 For the community component, we expect 40% to be broken up over 4 rounds of “growing the pie” airdrops. We are very excited about the availability of 10% for community contributors and grants - this allocation, likely given to the DAO to administer, should give a lot of incentive for the community to participate in initiatives to grow Jupiter, vet projects for the Solana ecosystem, and drive the decentralized meta - all of which are our main objectives. 
 I’ll share more thoughts and a proposed roadmap on how the DAO can incrementally grow in terms of scope, participants, responsibilities to become what I hope can become the most productive DAO in the history of crypto not just for Jupiter but for advancing the whole crypto ecosystem forward. 
 It will take time, years, but based on what I’m seeing so far, I’m actually incredibly bullish our DAO can get there. Slowly and incrementally for sure, but we will. One reason why I’m so bullish on this is because of the unique, positive, expansive vibes of the Jupiter and Solana community. Will elaborate more next time. 
 Now that there is no more presale, the launch will be very simple. 15-20% will be circulating initially. 10% is from the first airdrop and 5% for liquidity provision, which will either be mostly or entirely on-chain. We are also leaving open the possibility of having up to 5% more liquidity be available at launch. Details for claiming and the mechanism for liquidity provision will be shared over the next couple of weeks. 
 We would like the launch to happen in Jan, and currently coordinating with a range of partners to make it happen. 
 The Decentralized Meta 
 At Jupiter, we want to be a leading force in driving the decentralized meta forward - aka a world where everyone not just buys crypto, but actually uses crypto in their daily life as well. 
 As the best trading venue in crypto  (and since the first thing everyone does is trade) , Jupiter is the ideal spear tip for leading the charge, and we will need plenty of  PIE : 
 
 Products that r better than centralized versions 
 Incentives to attract masses to try the meta 
 Ecosystem of awesome projects on Solana 
 
 Given the massive amount of PIE needed to convert the masses to the decentralized meta, I would like to align on the key ethos and ideas we need over the next few years in order to help the space generate enough PIE to make it happen. 
 Ethos 1: Grow The Meta 
 Over the last few interviews, I have always been clear about using Jupiter and JUP as a core leverage point for driving the decentralized meta. 
 https://x.com/0xMert_/status/1733348900113711610?s=20
https://x.com/goodgamepodxyz/status/1732424198759600136?s=20 
 When people start to use Jupiter for whatever reason, they don’t just use Jupiter, they take a step into the increasingly unlimited potential of decentralized technologies - a world that’s so utterly different from the ones they are used to. 
 One thing that has been disappointing for me is engaging in conversations over the past 2 weeks where there were many airdrop recipients who had been extremely against starting the second growth airdrop purely for the reasons of being afraid that their own bags will be diluted - to the point of labeling new users as “airdrop farmers”, and calling themselves “loyal users”. 
 Protectionism sure starts early, but let’s not play into it. Careful and strategic emissions are of course crucial, that’s why we are fostering a tight culture of communicating strategy and getting feedback for every major phase, and why the interplay between the community and team is going to be crucial. 
 But to fight for your own bags exclusively so early in the game and to draw a line between users so early without consideration of the “grow the pie” ethos we need to set as well as the broader strategic vision is honestly not cool. 
 Also, it is my view that the max possible gains for the next couple of years will not be to focus on JUP utility, but rather brainstorming how to leverage JUP for maximum growth of Jupiter, Solana, and the decentralized meta - for the possible space is far, far bigger than we can imagine. 
 On that note, BONK is a really good example of what can happen when we take an expansive view of the universe, vs a constructive narrow perspective, for the universe strongly favors positive growth. 
 We will accept growing the meta strategically and pragmatically as one of our responsibilities - and JUP is one crucial leverage point we can use. 
 Ethos 2: Build A Secure Team 
 A cat that can hunt on its own is always going to be far more secure than a cat that needs to be fed constantly. 
 We would like Jupiter to be a world-class team that has strong revenues and hence operationally independent from the need to constantly fundraise for the sake of salaries and opex. That will set us up to be able to make the long-term decisions and build the amazing products that match up with our intentions to be a positive force for decades. 
 The core swap aggregation, which is a crucial part of Solana liquidity infrastructure, has always been and will always be completely free, much like Google’s search. In a DeFi first, we released the binary for free unrestricted usage 2 weeks ago, and will be taking more unprecedented steps next year to make it even more of a community resource. 
 Jupiter charges fees for limit orders, DCA, and perps and will keep these fees as team revenue. All fees will of course be tracked on-chain and fully visible on dashboards we will be publishing. Any investments made by team members have to be clearly reflected to avoid any semblance of conflicts of interest, particularly when it comes to Jupiter Start projects. I will personally refrain from making investments this year. 
 Due to the capped AUM for JLP, liquidity for perps can be rather limited at times, making it difficult to place positions. In addition, demand for JLP is extremely high, so the pool fills up extremely fast, in the matter of minutes every time we raise. 
 As a result, though, users are often unable to place positions and face rather high fees when placing positions. While we are working very hard to improve the system and increase the cap, being responsible and increasing the cap incrementally remains our top priority. 
 Thankfully, there are a range of excellent perp protocols on Solana, including  @zetamarkets ,  @DriftProtocol ,  @mangomarkets , and many more upcoming ones like  @FlashTrade_  - all of whom are our good friends, and we will do our best to encourage growth of the overall perp markets in Solana, not just our own, starting with an Educate program for Zeta next week. 
 In fact, after discovering the potential of on-chain perps on Jupiter, users are experimenting with various protocols, and learning what we have always known - Solana is by far the best place in crypto for on-chain perps, bar none. This will also get much better as liquidity on-chain increases exponentially over time. 
 Ethos 3: Help The Solana and Crypto Ecosystem 
 We do not see ourselves as a platform/product/protocol per se, but rather as a full-stack ecosystem push to help the Solana and crypto ecosystem win. 
 We will do so in 3 main ways: 
 
 Help make Solana the most used blockchain 
 Provide full array of world-class trading products 
 Help new projects win via Jupiter Start 
 
 We believe Solana is the best blockchain for onboarding the next billion users. And when we draw people to using Jup, they also end up using everything else on Solana. 
 And when we have a full set of powerful trading products that work as well as their centralized counterparts, they have no reason to go back to CEXes. 
 And when there is a critical mass of use cases and fun stuff you can do on-chain, there will be increasingly fewer reasons to pull your capital out. 
 Lastly, we can move the entire crypto space forward by being a shining example of what decentralized products, ethos and communities can do, hopefully playing a part in moving past the bad examples set by the last generation of fallen kings. 
 If not us, then who? 
 No Cats Left Behind 
 Over the past 5 weeks, we have spent enormous effort on making sure that everyone involved so far will be part of the journey at the very beginning. There are 3 main groups: Mercurial Stakeholders, Jupiter Users and Community Contributors. 
 
 Mercurial Stakeholders
For those who are unaware, Jupiter is a new project started when we were working on Mercurial  (which transited to Meteora on Feb 23) . Here are a couple of posts summarizing the background: 
 
 https://twitter.com/0x__fp/status/1721491581872586992
https://twitter.com/_ilmoi/status/1730789327456678330 
 Last week, after many rounds of public and private discourse, we finalized the 5% JUP position for Mercurial stakeholders (as of Feb 2023), which will come from the strategic reserve managed by the team. We also communicated the decision accordingly both to early Mercurial investors as well as in the Meteora discord. 
 https://meteoraag.medium.com/update-for-mercurial-stakeholders-as-of-feb-2023-2bf091627e52
https://discord.com/channels/841152225564950528/981108341482868736/1183160599073529926 
 https://discord.com/channels/841152225564950528/854683268519559189/1183176837019484230 
 NGL, it was extremely gratifying to connect with and get the approval of community members who have been part of the journey since very early on. Afterall, this has been one heck of a journey and these are absolute OG legends like  @durdenwannabe ,  @PigFahy ,  @0xSoju  and  @adidogceo  who have been with us through the entire cycle! 
 Besides the JUP position, Mercurial stakeholders will also be the starting holders of  @MeteoraAG , which after 2 years of absolutely relentless hard work (led by the incredible  @hellochow ,  @sudoku_defi ) and many other super talented team members is gaining great traction in terms of product, community, and DAO formation. 
 https://x.com/MeteoraAG/status/1730784233885474869?s=20
https://x.com/MeteoraAG/status/1735538511736889434?s=20
https://x.com/adidogCEO/status/1733658028509917215?s=20 
 I aim to write a full blog post about the founding history of Jupiter next week, and the various twists and turns leading to where we are currently. A podcast with  @SolanaLegend  focused on this historical period will  be released next week as well. 
 I deeply thank everyone who had been involved from day one, and particularly, the critical voices that have been instrumental in guiding us towards the final arrangement. Even if the criticisms have been extremely hard to swallow and felt very unfair at times, I doubt that I would have got it right if not for those voices. 
 Lastly, if you are a Mercurial stakeholder as of Feb 23, and you are not sure how to participate in the coming events, please reach out, we will spare no effort in making sure you are all caught up. 
 
 10K Community Airdrops Review Requests
The other thing we have been spending a ton of time on is the 10 thousand community airdrop review submissions, and we are finally almost done, thanks to the ungodly effort put in by  @9yointern . 
 
 AFAIK, we were the first project to openly debate the airdrop mechanism, to openly explain the criteria used, and also the first to open up a mechanism to allow people to protest the criteria. This is of course actually tremendously time-consuming and tiring, but we think it is an important process because we want to make sure we really tried our best to take into account every single point of view as well as do our best to address every complaint that came in. 
 The final allocations will be released tomorrow by   and there will be no more changes afterward. One thing here - do not harass our intern any further, regardless of your unhappiness. 
 She’s the most patient, anon-loving, SQL-churning, pepe-aware intern in the world, and everyone needs to appreciate the immense effort she put into it. We are normally pretty chill, but any mean messages will result in your airdrop being zeroed. Some things just cross the line, especially if someone super nice is trying her goddamn best. 
 Another major area of concern were also those with compromised accounts. There is no way to solve this totally elegantly, but what we will do for now is to not allow claiming on those wallets at the onset, and will likely have some kind of social media identification process and allowing claiming if there isn''t any double claims. 
 
 Community Contributors
Finally, next week there will be a site for anyone who has contributed meaningfully to Jupiter prior to Nov 2nd to connect their Twitter, Discord, and associated wallet address. 
 
 Similarly, this part will take likely take 2-3 weeks to finish reviewing, and will be a tremendous use of effort on our end. But yet, as I mentioned in one of the recent podcasts - it is important for me because I would really like to recognize everyone who took the extra effort to help Jupiter out, even when we were just a product with absolutely no indications of rewards whatsoever. 
 It means a fuck ton to us, and I will try my best to make sure you are recognized in one way or another.🩷 
 JUP FOR JUP 
 At Breakpoint, I presented our  “Grow The Pie”  presentation and green paper. Ever since then, we have been flooded with an absolutely incredible level of feedback, and we are extremely grateful for the energy and enthusiasm that everyone have shown us. Of course, all the wens and airdrop demands can get pretty intense at times, but it''s all part of the job. 
 To all the airdrop recipients, we are very grateful to be able to provide a present, and it is gratifying to hear from some of you regarding how it could being a really big difference in your life. That’s exactly what we are here for! 
 Also, I understand some of you are very anxious to claim it and maybe liquidate it for more stable assets. Don’t worry, it will happen soon in Jan, and we will do our best to make the whole process as seamless as possible and even make it as easy as possible for you to sell it or easily set the price you want for your JUP. 
 My only request is this - I hope you keep at least a bit of genesis JUP from the airdrop, because regardless of anything, you were an important part of the early journey. It will mean a lot to us if everyone involved at the beginning kept at least a bit of JUP with them. That way, we can keep in touch as we go through the coming years together. 
 Tokens are fungible, memories are not.🐱', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-07-27-jup-v3-metis-routing-algo/index.md', 'slug: jup-v3-metis-routing-algo
title: "Jupiter v3: The Metis Routing Algo" 
 
 Today, we are excited to announce Jupiter v3, which introduces Metis, a novel routing algorithm that further enhances our industry leading aggregator. Metis significantly improves route discovery for all pairs, substantially reduces slippage for large trades, and offers vastly improved scalability in preparation for upcoming Solana upgrades and new DEXs. 
 In order to be able to support Metis to run on Solana’s hyper fast blocktimes, we have also made major improvements to our backend infrastructure. In addition, we also introduce the Dollar-Cost Averaging beta, the testing of a new contract that removes the need for users to have intermediate token accounts, integrations of Limit Orders into our routing, the Jupiter space station and several new features that’s based on user feedback. 
 The upgrade, coming only a few months after v2, embodies our efforts to push the boundaries of Solana to offer the most powerful yet simple experience in all of crypto, and build a genuine CEX replacement to help with the inevitable migration to come. 
 This is obviously a mega update so let’s dive right in! 
 Metis 
 Today, we introduce Metis, our new advanced routing algorithm, a heavily modified variant of the  Bellman-Ford algorithm  catered for the key requirements of offering best price routing at scale in a very dynamic operational space. 
 Key Features 
 Incremental Route Building 
 To find the best price, Metis streams the input tokens to incrementally build a route to split and merge at any stage. By generating the routes for each split iteratively one after another, we can also use the same DEX in different splits - allowing us to find routes with better prices with more complex trades. 
 
 Combine Route Generation and Quoting 
 To improve the efficiency of the algo, we combine route generation and quoting into a single step, allowing us to avoid generating and using bad routes, which besides improving the efficiency, also allows us to use a larger set of tokens as intermediaries. 
 Future Proofing 
 v2 runs fast when the total number of DEXs used is small since Solana limits us to use at most 4 DEXs in a swap  (due to the account lock limit of 64) . Future Solana upgrades will relax this limit and allow more DEXs to be used in a single transaction. In addition, we foresee the continued growth of the Solana DeFi ecosystem, which means there will be many more DEXs emerging. 
 With Metis, we are well equipped to be able to handle both these trends, since the algorithm is able to scale to include more DEXs in a route when account lock limits are increased, and can support more DEXs with only a modest increase in running time. 
 
 Infra Upgrade 
 In addition, determining the cost per hop for various amounts of splits is obviously a major challenge, since there are many potential outputs for different amounts, including for vastly different liquidity venues like CLOBs and CLAMMs, and getting quotes from lots of AMMs is slow, which limited the scalability of the system.  To resolve this, we embarked on a major infra upgrade to refresh quotes in parallel and in real time. 
 Performance Improvements 
 The system has undergone rigorous testing over the past few weeks in production. At the same time, we have been benchmarking the performance of the algorithm. On average, Metis quotes prices that are 5.22% better than our v2 engine, with the improvements increasing sharply based on the trade size. 
 
 Powering Liquidity On Solana 
 And of course, this kind of insanely powerful engine will be completely out of reach for the average user in most other platforms, given the high level of gas cost this will incur. On Solana, the cost to the user will remain small and miniscule. 
 In addition, an great routing engine is crucial for DeFi in so many ways - liquidations require single transactions for large amounts to be as efficient as possible, new DEXs need a fair chance to be leveraged for volume as the more established ones, and of course, we need to keep on pushing the limits of Solana, so more people understand how powerful shit can get! 
 
 DCA (Dollar-Cost Averaging) 
 Secondly, we are also delighted to introduce our DCA Beta, a non-custodial, on-chain dollar cost averaging solution to automate the purchase or sale of any token. 
 
 How it works 
 If you choose to use USDC 900 to buy SOL daily over 9 days, 900 USDC will be transferred from your wallet to the non-custodial program and executed over the next 9 days. 
 
 Your first order to sell 100 USDC for SOL will take place immediately at the best price available then. 
 Your second order to sell the next 100 USDC for SOL will take place approximately 24 hours after the initial order at the best price available then 
 Subsequently, 7 more orders will all take place approximately 24 hours after the previous order until the full DCA order has been executed. 
 
 Ease Of Use 
 As with all Jupiter systems, we aim to make very complex transactions as simple as possible. You will automatically receive purchased tokens in your wallet within the same transaction of each order and a link to the blockchain transaction will be visible to you on  jup.ag . 
 Also, during the last order of your DCA, any remaining tokens will be sent to you and all program related accounts opened for your DCA will be closed and the rent returned to you automatically. 
 Notes 
 
 To ensure best price execution, DCA keepers use Jupiter and also perform price checks against an external price data provider i.e. Birdeye. 
 To prevent people from querying and hijacking the order right before the order is about to be executed, orders have a + 2 ~ 30 second variability. 
 Note that there is a 0.1% keeper fee for DCA order executions, only taken upon successful completion. 
 You can read more about key details like fees and technical implementation here 
 For the Beta phase, we’re limited to trade only the Top 20 tokens, with a cap of $5,000 USD for each DCA order. We will progressively increase the number of support tokens and lift the order size limit as we move out of beta. 
 
 :::tip Beta phase!
DCA is still in beta! So please give us as much feedback as possible to help us help everyone accumulate as much SOL as possible! :D
::: 
 
 Limit Order Integration Into Jupiter 
 At Jupiter, we aim to build the easiest limit orders in DeFi. Over the last couple of months, we have been steadily improving Jupiter limit orders behind the scenes, particularly on vastly improving the efficiency of the path discovery and order execution. Now, we are happy to share that Jupiter Limit Order has been integrated into Jupiter. 
 Jupiter will now compare Jupiter LO orders with the quoting engine quote price to provide users with the best possible price. This feature is especially useful for large limit orders, as they can be split, quoted, and filled by multiple Jupiter swaps. This improves the fulfilment of orders at the best price from both ends. 
 For example, there is a 20k USDC - RLB sell order here, being matched directly with one of the Jupiter Limit Order. Since this is the best price possible in the whole market, anyone will be able to take this order with zero slippage if they want to buy RLB. 
 
 We will continue to make major improvements to the limit orders over the next few months - improving it in terms of functionality, order discovery and usability. We cannot wait to make the easiest limit orders in DeFi even better than ever! 
 
 
 Jupiter Space Station 
 Jupiter Space Station is a comprehensive resource for everything related to Jupiter, all in one place for easy access! 
 
 Our station includes: 
 
 Statistics about Jupiter 
 Guides to using Jupiter Products 
 Development docs 
 Integration guidelines 
 List of partners 
 
 Open Contribution 
 In addition, it is an open-source system that allows anyone to contribute. You can add your protocol to the partners page, create an ELI5 user guide, or report an error in the syntax. Contributing is easy - simply add a pull request to our GitHub repository and help us make Jupiter Station even better. 
 Here are some examples of how our friends and users have contributed so far: 
 
 An insightful  article  authored by SolanaFM on how to verify transactions using block explorer. 
 Sphere  adding  their protocol into the partners page. 
 Enhancing our homepage with more  content . 
 
 We will be constantly improving this page, in our quest to make this the all in one and most helpful resource for everyone. In particular, we will be adding a community section too, to share a lot more about how the community can contribute! 
 
 New Improved Features 
 Jupiter v3 also features a number of smaller but important improvements based on user and developer feedback. 
 Feedback Mechanism 
 We have a direct feedback channel on top of our Discord support. Whenever a transaction or swap fails, there will be a quick button that prompts a feedback form. This allows users to inform us of any issues they are facing. If you miss the toast message, you can find the feedback form on the bottom-right of the site. The feedback form goes directly to the team. If you require a prompt response, please reach out to us through our official Discord channel. 
 
 Fallback Mechanisms 
 Aggregator works with a dozen DEXs and AMMs, and sometimes, DEX/AMM errors can cause certain routes to fail, resulting in the swap failing to go through. To improve this, our fallback mechanism will exclude any affected DEX/AMM causing errors in our trading routes and immediately refetch a new quote. Traders can then execute the new route and perform the swap without any issues. We have extended this mechanism to both Ver. Txn and Legacy routes to ensure a seamless trading experience for all our users. 
 
 Expanded Market Selection 
 To optimise for a safer and more robust trading experience, we previously set a strict criteria for the pools and markets where we stimulate swaps between $250 worth of tokens, with no more than a 70% loss/price difference. In our latest update, we are also including tokens that have already had liquidity elsewhere, as well as markets with single-sided liquidity of $1,000 within 20% of market price. 
 Shared Intermediate Token Accounts 
 We are testing a new contract that will leverage shared intermediate token accounts. The need for manually opening up intermediate token accounts has been a pain point for users given the initial setup cost and high number of potential swap failures. The new shared account feature streamlines the integration process and brings cost-saving benefits to partners and users alike. 
 Summary 
 With v3, we carry on the 3 core Jupiter traditions: 
 
 Upholding the JUP Promise (Best price, Best selection, Best UX) 
 Pushing the limits and possibilities of Solana 
 Introducing super easy to use, yet powerful features for the user 
 
 Again, nothing will ever be perfect or done, so your feedback is super important to helping us improve - the good, bad and ugly. We will work with everyone to ensure that no matter what, Solana will be home to the very best swap experience in all of DeFi and beyond.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-11-02-green-paper/index.md', 'slug: green-paper
title: "Jupiter Green Paper" 
 
Slides presented at breakpoint 2023 can be viewed  here 
 Growing the Pie 
 In this paper, we share an overview of what Jupiter has built in the past year, our ethos and our strategic direction for the future. **This paper serves a consultative purpose. We want to invite you to engage in dialogue with us, and contribute to shaping the future of Jupiter and its role within the Solana ecosystem. ** 
 We will be also introducing for the first time  $JUP, Jupiter Start and Jupiter Labs . We hope that the details in here will serve as a catalyst for fruitful discussions. 
 Today, Jup.ag is the default destination for traders on Solana. We have the best aggregator in crypto and the most seamlessly integrated platform in Solana – powering a variety of trading activities, including but not limited to swaps, limit orders, dollar cost averaging strategies and more ... 
 
 2023: Building the Best Decentralised Trading Experience 
 In the depths of the bear market in November 2022, we decided to double down on Solana. The collapse of FTX underscored the urgent need for a trustless alternative to centralised exchanges (CEX). And we believe that Solana, with its high-performance capabilities and robust community, is the best blockchain for this endeavour. 
 Our commitment was met with prolific shipping throughout 2023, as we successfully launched an array of new routes, innovative products, and better developer infrastructure. For example: 
 
 Our routing improvements include the launch of Metis – a novel routing algorithm that was customised for Solana’s fast blocktimes.  We also launched instant staked SOL to SOL swaps that gives you the best price across all trade sizes. 
 Our product portfolio expanded to include Dollar Cost Averaging(DCA), Limit Orders and a Bridge tool. 
 Our developer tooling improved with 2 major API Upgrades, Jup for Payments & Games, and the Jupiter Terminal. 
 
 A full list of our products and product announcements can be found on our  documentation website  and  blog . 
 By the end of October 2023, we facilitated a cumulative trading volume of $35 billion, executed 102 million transactions, and were used by 955,000 unique wallets, solidifying our position as the most used trading platform. We account for the majority of retail flow, with approximately 80% of organic swap volume originating from Jupiter. 
 Feedback from our user community  has been overwhelmingly positive, with many highlighting that the superior pricing and exceptional user experience provided by Jupiter were surpassing those offered by traditional centralised exchanges. 
 Core Anchors for Excellence in Product Development & Ecosystem Enhancement 
 The progress and innovations at Jupiter can be attributed to three core anchors that guide every decision and strategy we undertake: 
 
 
 **The JUP Promise: Best Price, Best Token Selection, Best UX: **This deceivingly simple and straightforward promise is the driving force behind our obsessive efforts in product innovation. From enhancements in routing algorithms to the integration of new tools, they are all aimed at delivering an exceptional trading experience for both users and developers. 
 
 
 **Maximising the Potential of Solana’s Technical Capabilities: **Much like harnessing the full potential of a high-performance vehicle, we strive to make the most of Solana’s capacity for providing swift and efficient trading experiences. Jupiter has been at the forefront of adopting new Solana features such as lookup tables, priority fees, and token 2022 standards. 
 
 
 Improving the liquidity landscape in Solana:  We are committed to the rapid integration of new liquidity sources and innovative use cases, ensuring the continual growth and competitive edge of the Solana ecosystem. 
 
 
 These anchors have been instrumental in the development and launch of various products at Jupiter. A prime example is  Metis, our advanced routing algorithm , which is a heavily customised version of the Bellman-Ford algorithm designed to provide optimal price routing in Solana’s fast block-times. 
 It guided us to prioritise the integration of Sanctum,  facilitating instant staked SOL to SOL conversions at the most favorable rates , irrespective of the trade size. This helps to accelerate the adoption of liquid staking tokens (LSTs) within the ecosystem, and paves the way for new composable innovations. 
 Furthermore, we introduced the bridge tool, a tool that allows users to seamlessly compare and select the most efficient bridge for transferring tokens from other chains to Solana, so that we can help to bring more capital to Solana. 
 Most recently, during the  Jupiter Planetary Developer Week , we unveiled a plethora of new features, including the V6 Swap API, Jup for Payments, and the upgraded Jupiter Terminal V2. 
 Having provided an insight into our recent product developments, you might now be curious about our future plans and directions. 
 Help Solana Grow aka Grow the Pie! 
 Our vision for the future is intrinsically tied to the growth and prosperity of the Solana ecosystem. We are driven by the conviction that a flourishing Solana ecosystem translates to collective benefits for all stakeholders involved. In simple terms, when the pie grows, everyone gets more pie. 
 In alignment with this vision, we are excited to introduce The Jupiter Plan, a strategic framework encompassing three pivotal components: 
 
 
 $JUP Governance Token:  Our goal is to cultivate a robust community and DAO for Jupiter. We also aim to incentivize engagement and new capital flows into the Solana ecosystem, thereby fostering its growth and vibrancy. NOTE: $JUP is not live yet, please beware of fake tokens. 
 
 
 Jupiter Start : This is a year-long initiative designed to help great new projects win on Solana, with a focus on projects that contribute to the health of the Solana ecosystem, not short term pump and dumps. There will also be a commitment to transparency and public seeding, so that the community can invest in good projects early on without gatekeeping. 
 
 
 Jupiter Labs:  In collaboration with our community and the JUP DAO, we will launch cutting-edge decentralised finance (DeFi) projects specifically tailored for the Solana ecosystem. We have 2 new initiatives to introduce – a novel LP-to-trader perpetual exchange, and a xSOL leveraged stablecoin. 
 
 
 **$JUP: Unveiling our Governance Token ** 
 NOTE: $JUP is not live yet, please beware of fake tokens. 
 We are thrilled to formally announce the impending launch of the $JUP token, a milestone that our community has been keenly anticipating. Our approach to introducing the JUP token has been deliberate, and we believe that the conditions are now optimal for its launch, as several key pieces are falling into place: 
 
 Having a broad and engaged user base 
 Completion of major platform upgrades 
 Having a pipeline of ecosystem projects 
 Strong belief in the coming upswing of Solana 
 
 The primary objectives of launching the JUP token are to: 
 
 Energise the ecosystem by attracting new capital flows and users to Solana. We aim to attract new investments, users, and capital to Solana, contributing to its overall growth and vitality. 
 Generate momentum for new ecosystem tokens: The JUP token can help to catalyse the momentum for more new ecosystem tokens. 
 Build a Strong and Distributed JUP Community: We are focused on establishing a robust and broad community that is engaged and committed to supporting crucial initiatives in the long term. 
 
 JUP will be a Governance token. Initially, the token will be locked, and the DAO will decide the exact unlock date. JUP token holders will have the ability to vote on critical aspects of the token itself, such as the timing of initial liquidity provision, future emissions beyond the initial mint, and key ecosystem initiatives, including determining the projects that will be a part of Jupiter Start. 
 For the initial supply of tokens, the proposed allocation will be as follows: 
 
 40% Community Growth (4 rounds of airdrop distribution) 
 20% Locked Token Sale 
 40% Team & strategic reserve (vested) 
 
 There will be 3 parts to the launch phases; the Community Airdrop, the Growth Airdrop and the Locked Token Sale. 
 Initiating a 2 week consultation period for airdrop mechanics 
 Traditionally, the mechanics of airdrops are unilaterally determined by the team, with the community subsequently informed of the decision. This often leaves limited scope for discourse or community input. 
 In our quest to foster a more collaborative ecosystem, we are opting for an alternative approach, where the community plays an integral role in shaping the mechanics of the upcoming airdrop. This green paper does not lay out the specifics of the airdrop criteria. Instead, starting from today, we are initiating a two-week consultation period, during which we invite open dialogue and contributions from all community members. 
 We want to devise a plan that resonates with the values of the community, so that we can own this journey together and be proud shared owners of JUP. 
 Community Airdrop 
 For the first round of community distribution, we propose an airdrop for existing users and community members to reinvigorate the community and give everyone a stake in the JUP and Solana. Given that 955,000 users have used Jupiter before, this will be one of crypto''s biggest organic airdrops. As it has been a very challenging (and often painful) year, we suggest prioritising users who have been consistently part of Jupiter and Solana throughout the whole time, especially the most bearish times. 
 Growth Airdrop 
 In the Growth Airdrop phase, we will see the formation of the DAO that will help decide on the Token Launch. In addition, the second round of our community distribution has a growth-centric focus, with the primary objective of attracting new users and enhancing liquidity within the Solana ecosystem. 
 We will reward trading on Jupiter and Solana to incentivise users to trade more actively. Moreover, we are anticipating the emergence of a new wave of promising ecosystem tokens early next year, and we want to drive as much focus and attention to these tokens as possible. It is crucial that users who are incentivised to start trading on Solana again can appreciate the significant strides made by Solana in terms of ux and ecosystem growth. We look forward to experimenting with the community and ecosystem on this! 
 Locked Token Sale Phase 
 To reinvigorate the public sale market of Solana, we are initiating a Locked Token Sale (LTS) phase for 20% of tokens. In order to make it as egalitarian as possible, there will be no exclusivity in terms of whitelisting nor early access, providing an equitable opportunity for all. 
 Tokens acquired in this sale will be locked, but they will confer voting rights upon the holders. This includes the ability to vote on pivotal decisions such as determining the initial liquidity date of the token. Consequently, participants in the token sale will effectively become the inaugural members of the DAO, playing an integral role in shaping its direction. 
 Over the public LTS and 2 rounds of community distribution, our objective is to cultivate a DAO that is not only highly engaged but also eagerly invested in the success and prosperity of Solana. 
 This approach represents a deliberate shift away from prevailing narratives of retail investors being disadvantaged, insider dominance, high FDV & low float token launch games, and uncertainties surrounding token emissions in Solana. Instead, we are championing a model of transparency and equitable participation – our airdrops and token sales have no insiders and no centralised voting, a high float from the start, and diverse investors that include previous users and new users. 
 By granting the DAO the authority to determine subsequent community distributions and sanction future mints, we cement a system that guarantees full transparency of emissions. The role of the DAO will also be growth centric, collaborating not just on the current initiatives but also to grow new world class products in the future. 
 There is a very clear distribution of roles between the team and the DAO - The team manages products, protocols, and development, while the DAO manages one of the most crucial aspects - token distribution & future emissions. 
 The entire initial supply belongs to community participants through the token sale, airdrops, and growth incentives, while the team’s allocation will be vested over 2 years. The strategic allocation (for potential future investors and talent) can only be used by the team at least a year after token liquidity, and there will be at least 6 months notice before any tokens are released from this pool. 
 Our aim is to energise the Solana ecosystem by driving investment, users and capital to Solana, generate more momentum for new ecosystem tokens and build up a strong and focused Jupiter community to help improve Solana. 
 Together, we work towards a future where the victories of Solana translate to victories for all. Solana wins, everybody wins! 
 Jupiter Start 
 Jupiter Start is a year-long initiative that seeks to redefine the launchpad experience, placing a strong emphasis on the long-term success and sustainability of new projects within the Solana ecosystem. We believe that for a project to truly thrive, it requires more than just a successful token launch; it needs a robust community, ongoing momentum, and strong visibility from investors. 
 New projects are essential for invigorating new ecosystems, and this underscores the significance of launchpads. However, the current landscape of existing launchpads leaves much to be desired. Their predominant focus tends to be on short-term token price gains, often neglecting the long-term viability and sustainability of projects. This short-term approach is further compounded by the absence of an engaged and supportive community, which is integral for the flourishing of any project. 
 Most fundamentally, launchpads today seem more focused on pumping the value of their own platform token rather than genuinely supporting new projects and the crypto ecosystem, with unfair advantages given to insiders and the encouragement of FOMO and speculative behaviour that leads to tokens dumping quickly post-launch. 
 The crypto industry is at a point where the need for real-world use cases, trustworthiness, and long-term sustainable projects has become more apparent than ever. There is a strong desire among community members and investors to contribute to projects that show promise and innovation. After all, the beauty of crypto is the ability of anyone to be involved in the entire value creation as early as possible. At the same time, new and legitimate teams are in need of support in terms of users, community engagement, and financing to build momentum and bring their visions to life. 
 Also, crypto needs a lot more use cases and trust worthiness. Two of the most prominent criticisms of crypto have been that there are no real use cases for real world adoption and that the prevalence of scams and rugs erode trust among retail investors. 
 With one of the most highest level of active developer participation, technical platform suitable for mainstream adoption, and invaluable experience from the dangers of short-termism, we believe that Solana is the perfect place to usher in a new era for crypto - focused on new use cases and long term thinking that is so very much needed. 
 Jupiter Start will be made up of 3 core components, which will be incrementally launched over the next few months. 
 
 
 Jupiter Token Spark: This initiative is committed to demystifying new tokens, simplifying the complexities associated with token launch, and ensuring immediate tradability on Jupiter. We highlight exceptional projects, providing them with visibility within our community and DAO. 
 
 
 Jupiter Launchpad: We aim to address the current inadequacies of launchpad models, concentrating on fostering long-term alignment, nurturing an organic community, maintaining ecosystem health, and integrating delegation features. 
 
 
 Jupiter Public Seeding: Our initiative supports communities in investing in new projects through a public venture capital funding model. This enables communal participation in seeding teams from day one, while incorporating crucial mechanisms such as vested funding. 
 
 
 Jupiter is well positioned to do this for the following reasons: 
 
 jup.ag  is the go-to platform for the most active traders, making it an ideal place to showcase and introduce new projects. 
 In conjunction with the launch of JUP, we are cultivating a broad and varied community, alongside a decentralised autonomous organisation (DAO). This network is poised to actively engage with and participate in new ventures. 
 The JUP DAO can facilitate independent decision-making on project involvement, effectively mitigating potential conflicts of interest. Furthermore, our extensive collaborations across the entire ecosystem position us to significantly contribute to and encourage cooperative efforts. 
 
 The first component to be launched will be Jupiter Token Start, which will provide both a step by step guide to launching a token for immediate discovery and trading on Jupiter, as well as provide an avenue for the best projects to be discovered by the Jup.ag user base and JUP community, while offering potential investors and traders the chance to explore, interact and understand the new tokens. 
 These components set themselves apart from prior cryptocurrency initiatives with the following core values: 
 
 100% transparency of end to end processes 
 Commitment to long term health of the Solana ecosystem 
 Inclusive participation regardless of token ownership 
 No insider advantage or preferential treatment 
 Co-development with the broader ecosystem 
 Clean, productive alignment of interests 
 Support for genuine user and community building 
 
 We hope that Jupiter Start will illuminate Solana''s significant advancements, showcasing it as a leader in progress, productivity, and ethical practices within the cryptocurrency ecosystem. And we want to work side by side with the projects, community and the broader ecosystem to achieve this! 
 Jupiter Labs 
 Jupiter Labs  will debut top-tier DeFi protocols in partnership with Jupiter users, JUP DAO, and the Solana community. We aim to bolster Solana''s DeFi ecosystem by nurturing new projects, leaders, and tokens. Although these initiatives will originate within Jupiter, they are ultimately designed to launch and operate independently. 
 Jupiter Labs is initiating two innovative projects which are at different stages of development: 
 
 
 LP <> Trader Perpetuals : This is a novel LP-to-trader perpetual exchange on Solana that offers up to 100x leverage. By utilising pool liquidity and oracles, it ensures zero price impact, zero slippage, and deep liquidity. Oracles enable stable market operations during liquidations and stop-loss events, removing risks of position bankruptcy and LP pool fund loss. Users can open and close positions in one simple step, eliminating the need for additional accounts or deposits. With Jupiter Swap integration, any Solana token can be used to open positions. 
 
 
 xSOL Leveraged Stablecoin : We propose sUSD, a new stablecoin backed by SOL and uses leveraged LSTs as the primary yield mechanism with protocol level dynamic rebalancing for stability. Borrowers can mint sUSD using SOL as collateral through interest-free loans with returns from the staked leveraged SOL covering the borrowing costs while providing annualised returns of 7~20% to sUSD holders. We suggest several mechanisms to further enhance the stability and utility of sUSD, including USDC-sUSD pool and various sUSD redemption mechanisms. 
 
 
 These projects will be bootstrapped in conjunction with Jupiter users, the JUP DAO and the Solana ecosystem. Jupiter users will be granted priority access to test and benefit from incentives associated with these protocols and the JUP DAO will receive part of the protocol tokens. Crucially, we would invite knowledgeable members of the Solana ecosystem to be part of the process of community and protocol development early on, with community tokens allocated for this purpose. 
 In Summary 
 Crypto is in dire need of more users, an expansion of use cases, and an enhancement of trust. Solana is the perfect place for all 3 - It can be the most used, most useful and most trusted ecosystem. 
 Jupiter can help: 
 
 $JUP:  Driving an increase in on-chain users and activity. 
 Start:  Broadening the spectrum of use cases and bolstering retail trust. 
 Labs:  Introducing innovative and impactful DeFi protocols. 
 
 Together, let''s shape a future where we don’t need CEXes anymore, where crypto is useful, and where your mum is proud of you for working in crypto. 
 Woohoo, LFG!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2022-12-21-jupiter-muses-1.md', 'slug: jupiter-muses-1
title: "Jupiter Muses #1" 
 Hey everyone, here are some updated thoughts on the Solana landscape, Jupiter direction and community alignment based on my observations over the last few weeks since and from discussions from the last community call. 
 Solana Landscape 
 A few months ago, we tweeted that Solana is the most likely candidate to be a major trading hub in crypto, and our confidence in that has not changed. That said, it is important to recognize several key issues plaguing Solana right now. 
 
 
 For DeFi, these include lack of liquidity depth, decreased on-ramp / off-ramp options, shaky oracles and wrapped tokens. 
 Many retail investors still feel very burnt by recent events, and continue to be doubtful over the lack of clarity of FTX in Solana. 
 In addition, many developers are unhappy about perceived biases towards insiders and celebrities, and there are also others who have focused their efforts in search of opportunities elsewhere. 
 
 That said, we are still strong believers in Solana’s long term prospects, and believe that Solana is the chain most likely to onboard the next generation of mainstream users.  There are many reasons for this, and one of it is the existence of a unique core developer community that is unlikely to be matched anytime soon by other ecosystems  (except than ethereum) , as demonstrated by the amazing speed in which the replacement for Serum came about. 
 The combination of a very strong core developer community, existing retail userbase, enthusiasm by various industry players  (offchain resources, gaming)  and a proven, battle hardened technical platform makes it hard for new entrants to catch up. 
 On our end, we have been very active in pushing Solana forward. In the last month alone, we integrated 6 new protocols and upgrades in the last month alone. We are also the first to leverage on Solana’s transaction v2 upgrade, encouraging wallets to support this new standard. 
 Moving forward, we will look to help re-invigorate Solana by investing large amounts of effort in helping improve liquidity and price discovery, showcasing new projects to users and embarking on marketing efforts to help new users come onboard Solana. 
 In summary, Solana is weakened, but it is a chance for the existing ecosystem and foundation to reset a lot of the cultural flaws and for new entrants to establish a foothold. And we will work hard to help on every step of the way. 
 
 Jupiter Direction And Product 
 The main goal for Jupiter is to  advance the usage of decentralized liquidity and replace the need for anyone to use centralized liquidity platforms like FTX . We will do so by aggregating, building or integrating key services under a single, super easy to use system. 
 In the near term, we will be making big improvements to our existing system by launching full txn v2 support, making a push for composability, and revealing a new routing engine. 
 In the long term, we aim to expand the set of DeFi use cases on Solana, starting with limit orders that leverage on the full availability of liquidity on Solana. In addition, we want to scale the  JUP Promise  of  best price ,  best selection ,  best ux  across the entire crypto universe. 
 We have very exciting plans in 2023 for these, will be excited to share more soon! In addition, there were a few other topics that was discussed in the last call regarding product: 
 
 We fix a lot of issues for projects that we integrate since we are often the first to spot issues with their onchain program or sdk issues, or get shit from users when things do not work. 
 Possible protocol revenue comes from referral bonuses  (need to make this an industry standard) , optional fees  (tying to token plans) , positive slippage, new services with fees 
 Most of Solana users come through Jupiter in one way or another - how can we use that to help new projects and tokens get discovered?
Will be fun to continue this topics in following calls! 
 
 
 Community Building 
 The hardest thing about community building is that it is very easy to do the simple thing and hype things up but ruin the goal of building a genuine userbase, evangelists and developers who care about the project long term. 
 We started the JUP spirit discussion a few months ago, culminating in what I thought was an awesome representation towards what the community should look like -  most vocal, most long term, most critical . 
 Our community building program therefore needs to be focused on achieving this, vs creating short term hype, instant gratification or convenient promises. The crypto space suffers greatly from an over-emphasis on these 3, and it is imperative that we do not repeat these mistakes as we go about building the best community in crypto. 
 The other major topic that we discussed in the call was around the role of the community - the current consensus is that the community can focus on evangelizing and growth, while the team can focus on building great products that the space needs to wean off our dependence on centralized platforms. 
 In addition, here are a few other notes, some from the call, and some from the discussion afterward. 
 
 We believe in rewarding community members who actively participate in improving product, evangelizing Jupiter and trying out new untested products. 
 Community ownership needs to be focused on sustainable rewards for long term players or driving growth for a new product 
 Users, community, developers are all equally important to us, and we need to make sure all 3 groups are taken care of 
 
 Although we are not ready for a fully liquid token yet, we think we can continue these discussions to move the ball forward: 
 
 Brainstorm how we can be helpful for re-invigorating the Solana landscape 
 Agree on the key goal of any community programs we embark on, whether it is growth, ownership or long term alignment 
 Focus on quality vs quantity moving forward. Existing discord channels shall be archived, and new ones for quality contributions opened up 
 Discuss how we can allow the community to take on enhancement and autonomy for growth and evangelism, vs from team-driven marketing efforts 
 
 
 Summary 
 Even though Solana DeFi has taken quite a big hit this past 2 months - we have been shipping faster than ever before, and we are very confident of delivering great products and value for users in Solana and beyond in our quest to  help wean the space off the need to use centralized systems. 
 Lets buidl the  most long term ,  most constructive  and  most vocal community  in crypto, and achieve this goal together.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-11-01-jup-native-usdc-circle-wormhole/index.md', 'slug: jup-native-usdc-circle-wormhole
title: "Jupiter Bringing Native USDC to Solana, Powered by Wormhole and Circle''s CCTP" 
 We are excited to announce our plans to integrate Circle’s Cross-Chain Transfer Protocol  (CCTP)  to bring native USDC to Solana powered by Wormhole. CCTP is a permissionless on-chain utility that ensures secure USDC transfers between blockchains using a native burn-and-mint process. 
 Understanding CCTP­­ 
 Circle''s Cross-Chain Transfer Protocol (CCTP) is an on-chain utility designed by Circle. Its primary function is to enable the seamless transfer of USDC across various blockchains through a burn-and-mint mechanism. When users want to transfer USDC from one chain to another, CCTP burns USDC on the source chain and then mints a corresponding amount on the target chain. This process guarantees that the USDC''s total supply remains consistent, preserving its integrity across blockchains. 
 CCTP''s Role in Solana and Jupiter 
 The imminent integration of CCTP into Solana marks a pivotal moment for Jupiter. With this integration, Solana''s ecosystem stands to benefit from increased liquidity, reduced fragmentation from fewer wrapped USDC versions, and enhanced interoperability. By facilitating native USDC transfers within Jupiter, users are presented with the benefit of efficient, zero-slippage cross-chain transfers without ever departing from the Jupiter app interface. 
 Integrating Wormhole Connect in Jupiter 
 Wormhole has established itself as the industry standard for cross-chain messaging protocols, powering cross-chain applications. Currently, it connects over 30 leading blockchains. The Uniswap Foundation''s bridge assessment committee recently recognized it as the industry’s top bridging provider, following an extensive security and decentralization  report . By integrating  Wormhole Connect  into Jupiter, we offer users unparalleled access to liquidity across all major chains without the need to exit the Jupiter platform. This streamlined cross-chain capability not only elevates the user experience but also helps drive our product and community''s growth. 
 Ending notes 
 Being the most used dapp on Solana, we are excited to bring this liquidity to all users in the ecosystem. Once the Solana CCTP goes live, this will be available on our UI, where users will be able to connect their non-Solana wallets and transfer their USDC into Solana with zero slippage regardless of transaction size. 
 This advancement promises unmatched liquidity for all Solana enthusiasts, extending Solana''s unique features and advantages to other chains, heralding a new era of interconnectivity in the DeFi realm. 
 Stay tuned to our  Twitter  for real-time updates on the launch of this integration.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-11-30-jup-start/index.md', 'slug: jup-start
title: "Grow The Pie Update #2" 
 Grow The Pie Update #2: Jupiter Start 
 At Breakpoint, we presented 3 major initiatives to grow the Solana Pie: $JUP, Jupiter Start, and Jupiter Labs. Today, after extensive discussions with the ecosystem, we are delighted to elaborate more about Jupiter Start. 
 For a long time, we have been wondering how we can encourage traction and awareness for great new projects while not accidentally promoting scams or being biased one way or the other. 
 It is crucial for ecosystems to strike the balance - new projects and tokens are literally the lifeblood of ecosystems, but hyping the wrong projects is probably the biggest breaker of trust for retail investors. 
 If we hit that balance though, we will be able to help good projects get more traction and awareness while making trading and investing more fun, trustworthy, and rewarding for users. 
 If we achieve that, we will also in essence be encouraging the safe, effective decentralized trading of new tokens, while helping the Solana ecosystem build more trust and connectivity. 
 Jupiter Start will be our year-long initiative to do so, banking on close collaboration with the community and ecosystem to help vet, debate, understand, and highlight great new projects. 
 The 5 aspects of Jupiter Start are: 
 
 Jup Community Introductions 
 Jup Prelisting 
 Jup Educate 
 Jup Launchpad 
 Jup Atlas 
 
 We will start piloting the first 3 as soon as next week, while the next 2 will be done next year, since they involve funds and will need to be more carefully designed. As with all pilots, we will be iterating and experimenting with the formats very frequently. 
 
 A. Jupiter Community Introductions 
 Jupiter Community Introductions are to let Jupiter community members and users learn more about new projects and tokens in the Solana ecosystem. 
 Each introduction will last about a week, in which the project will be featured on our Discord forum. Projects will share key information about their idea, tokenomics, and key details like origination transactions and distribution of ownership. 
 Our community members will be able to help vet, understand, and discuss these projects. If the responses are positive and no red flags are found, we can spread the word further by tweeting about it and probably featuring it on our homepage. 
 Community members that  prove  expertise and thoughtfulness over time to their peers will also be able to earn corresponding rewards and recognition. 
 To kick this off, our first set of community introductions will be
 @OvolsNFT  and  @MyroSOL ! 
 B. Jupiter Pre-Listing 
 Jupiter Pre-Listing aims to allow new tokens to be safely traded on Jupiter by users. 
 The  token will show up in the token selector earlier, and the users can set limit orders at the price they want, perform DCA, etc. 
 Given that these are new tokens and liquidity will be very thin at the start, there will be lots of UI reminders and prompts to make sure the user knows what they are doing. 
 To ensure that these are not scam tokens, projects must be sufficiently known by the ecosystem, or need to post in a pilot forum in our Discord with sufficient time for our community to vet. Things like credibility are subjective, and we will iterate along the way. Obviously, tokens with misleading names similar to prominent projects or persons, or overlapped with the strict list will not be approved. 
 If you have a new token coming up, and want to make trading on Jupiter as easy as possible the moment the token is launched, let us know today! 
 If you’re a member of the ecosystem with expertise in evaluating various aspects of an early project — token distributions, legitimacy, etc. — let us know! 
 Pre-listings are NOT an endorsement of the project by Jupiter, merely a way to encourage a vibrant trading ecosystem. DYOR is extremely critical when investing in new tokens, be careful! 
 C. Jupiter Educate 
 Jupiter Educate is to let qualified traders and users of Jupiter learn more about great projects in the Solana ecosystem. The project will be featured on our social media as well as a section on our site. Qualified users and traders will be able to earn points or tokens by reading materials and performing certain on-chain actions. 
 With this initiative, we aim to have a sustainable, ongoing engine to let users know about great new on-chain projects, while also providing awareness and qualified active users for exciting new projects. 
 This will be a highly selective and customized process, and we will poll our communities ahead of time, and only projects with clear community support and strong ecosystem support will be part of this. 
 Pending a community poll, our first Educate partner will be  @ZetaMarkets , an awesome perps exchange platform and a great friend of Jupiter! 
 D. Launchpad and Atlas 
 Launchpad and Atlas are 2 funding-related initiatives to be launched next year. Launchpad will help projects get community and their token launched, Atlas to allow the community to partake in VC-style seed funding for early-stage projects. Whenever funding is involved, it obviously becomes a lot more complicated, so we will be taking our time with these, while also applying some of the lessons. 
 Community-Driven Approach 
 As with all our key initiaitives, we are committed to doing these in conjuction with the community and doing it in a way that greatly enhances the trust of users in the Solana ecosystem. 
 If you fall into any of the following categories: 
 
 A user with strong interest in vetting projects and understanding tokenomics 
 A project looking to launch a new token or idea 
 A community leader looking to connect new projects with your community 
 
 Please get in touch with  @benliewxyz , and we will try our best to involve you! By the way, due to the extremely high demand from projects to be featured or supported for Jupiter Start, we apologize if we cannot accommodate all. 
 The most challenging thing about this whole endeavor is defining what ''good'' means and who gets to decide that. 
 As such, we are designing Jupiter Start in a way such that the team is not the only entity involved in the process – instead, the community will play a leading role in proposing, deciding, or vetoing these endeavors. 
 Let''s make Solana and crypto a better place for both good new projects and users - our moms will be very proud if that happens!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-08-18-jup-lst/index.md', 'slug: jup-lst-with-sanctum
title: "Jupiter LSTs Integration with Sanctum" 
 Unlocking The Potential Of LSTs With The Sanctum Integration 
 
 In order to maximize the adoption of LSTs  (Liquid Staking Tokens)  with users and protocols alike, we have integrated  Sanctum  into our routing system, allowing users to swap from xSOL-SOL with the best possible rates, regardless of trade amount. 
 This integration coincides with the formal launch of Sanctum and its reserve pool with over 200K SOL - meaning large amounts of xSOL can be immediately swapped for tokens like USDC via the pool and Jupiter. 
 Key Features of the Sanctum 
 
 
 Instant Unstaking:  Leveraging Sanctum’s SOL reserve pool, users can instant unstake LSTs. Unlike traditional LST-SOL pools that fragment liquidity, Sanctum services every staked pool with one SOL pool, enabling every stake pool token to be accessible across DeFi. 
 
 
 Improved Validators Experience:  Validators can easily launch stake-pools-of-one by tapping into Sanctum''s shared liquidity. This reduces concerns about sourcing liquidity and unlocks a substantial portion of staked SOL for use in Solana''s DeFi ecosystem. 
 
 
 Competitive Pricing:  Sanctum routing provides a pricing edge for smaller stake pool tokens and transactions, shifting away from heavy reliance on liquidity provision to AMMs. 
 
 
 Three Main Functions on Jupiter 
 
 SOL - xSOL:  Direct staking through Sanctum, allowing SOL deposits into stakepools, with users receiving corresponding LSTs. 
 xSOL - xSOL:  Support for LSTs trading, with partial support for various xSOL routes. 
 xSOL - SOL:  Integration with Sanctum enables instant unstaking and liquidity access for staked SOL. 
 
 Benefit To The Ecosystem 
 LSTs have always held great potential for use by both users and DeFi protocols as a valuable source of yield. However, they''ve been hindered from mass adoption due to the challenge of instantly liquidating large LST amounts. Liquidity in standard markets is insufficient for large traders or liquidators who need rapid liquidity exit. 
 With this launch and integration, many of these problems are mitigated. Liquidators can now efficiently liquidate both small and large xSOL positions, leveraging Jupiter’s liquidity routes that include the Sanctum SOL reserve pool and other integrated liquidity sources instantly, with optimal prices and minimized price impact and slippage. 
 This unlocks LST adoption, introducing more tradable assets to Solana that can significantly increase TVL, unlock $9B in staked DeFi capital, and most importantly, enable protocols to maximize their capital efficiency and yield without typical cooldown or liquidity constraints. This pivotal step is a game-changer, and we eagerly anticipate the innovative products to be built upon this foundation.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-09-18-dca-out-of-beta/index.md', 'slug: dca-official-launch
title: "Jupiter DCA Is Now Officially Launched!" 
 In an important step towards building the most powerful and usable set of spot trading features in DeFi, we are thrilled to announce that  Jupiter DCA is now officially launched!  After many rounds of rigorous testing and user feedback, we have incorporated a ton of improvements based on valuable suggestions and ideas from partners and users to increase platform stability and add more features. 
 
 Jupiter DCA Recap 
 2 months ago, we launched the beta version of Jupiter DCA - a non-custodial, on-chain dollar cost-averaging solution to automate the purchase or sale of any token. 
 When you set up a DCA order, your chosen tokens get moved from your wallet to a special account owned by the DCA program. Imagine it like putting your tokens in a vault. The first order happens right after you create your DCA, and then more orders come in at the times you pick. So, if you''re DCA-ing 1,000 $USDC into $SOL every day for 10 days, the first 100 $USDC -> $SOL order goes through when you start, and you''ll have 9 more daily orders to go. 
 Key use cases for DCA include: 
 
 Bear market accumulation 
 Bull market profit taking 
 Splitting up large orders 
 Exiting low liquidity tokens 
 
 To ensure the best price execution, DCA keepers use Jupiter and also perform price checks against an external price data provider i.e. Birdeye. In addition, to prevent people from querying and hijacking the order right before the order is about to be executed, orders have a + 2 ~ 30 seconds variability. 
 Upgrades From Beta 
 
 
 Advanced Pricing Strategy:  Introducing Min/Max parameters for users to define a precise, user-defined executable price range. This gives users more control over their investments and helps them avoid buying or selling at unfavorable prices. 
 
 
 Expanded Tradable Tokens:  Now offering access to over 600 tokens listed on the Jupiter Strict Token List, giving users a significant increase in token selection from the initial Top 20 tokens. 
 
 
 Any-to-Any Token Trading Pairs:  Enabling trading between any-to-any token pairs for more diverse trading options. 
 
 
 Metis Algorithm Implementation:  Leveraging the Metis algorithm for enhanced routing and improved pricing. 
 
 
 Increased Global Upper Limit:  We have increased the global upper limit for a single DCA order from $5,000 USD to $20,000 USD. This change offers users more flexibility for a wider range of use cases. 
 
 
 Enhanced Default Slippage Rate for Improved Order Fulfillment:  The default slippage rate has been adjusted to 10 basis points (bps) for an improved and better transaction fulfillment rate without disrupting the DCA flow. 
 
 
 Enhanced Safety Mechanism with additional checks and warnings:  Verifying scheduled date/time, token validation against the Jupiter Strict List, and issuing warnings for high price impact. Users can now see estimated price impacts for each cycle, and lower-cap tokens have more precise decimal market rates, with more warnings and banners to bolster the trading experience. 
 
 
 
 Advanced Pricing Strategy 
 
 
 
 One of the most eagerly requested additions from our users and partners is the introduction of a Min/Max parameter or Advanced Pricing Strategy, addressing the need for precise control. This feature is implemented at the contract level, empowering users to define a minimum price for selling and a maximum price for buying within their DCA orders, adding an extra layer of control for more precise order execution. This strategy ensures order execution within a user-defined price range. If the price falls outside the range during the execution, Jupiter will reattempt to fill your order at a later time till successful, while also enforcing our randomiser at a later time so your trade remains unpredictable. 
 
 The example above sets both the minimum and maximum prices for the DCA order to be executed. 
 
 Minimum price - $19 
 Maximum price - $20 
 
 So in this scenario, if the  SOL price is within $19-$20 , the DCA will execute the order, and if it  falls below  or  pump above  the range, Jupiter will retry at a later time to try to check with the price, and if it is within the user-defined range, Jupiter will attempt to execute the order while enforcing our randomiser so your trade remains unpredictable. 
 
 Expanded Tradable Token Selection 
 Additionally, we''ve significantly broadened our range of supported tokens, expanding from the  top 20 traded tokens on Jupiter''s list to encompass over 600 tokens . This expansion is backed by the community-verified  Jupiter Strict Token List . 
 
 Any-to-any token trading pairs & Metis Algorithm Implementation 
 In line with our extensive Metis-powered enhancements, DCA now effortlessly enables trading between any-to-any pairs with improved routing and pricing efficiency. 
 Metis, our powerful routing engine, dynamically operates on a vast scale. It optimizes routes by splitting and merging input and output tokens, ensuring the best prices for even more complex trades. This enhanced efficiency opens doors to a broader range of intermediary tokens while keeping costs minimal, just a fraction of a cent. 
 Minimum Frequency and Maximum Cycle Settings 
 Introducing settings that allow for a maximum duration of one year to meet specific trading needs. 
 We have a suggestive text that explains each min and max frequency for each iteration, this will make the frequency input feel more natural and it will always show the frequency error message if input falls out of bounds or when the wallet is not connected or no input value. 
 
 Minute → 2 - 1440 minutes (~ 1 day) 
 Hour → 2 - 168 hours (~1 week) 
 Day → 2 - 30 days (~1 month) 
 Week → 2 - 52 weeks (~1 year) 
 Month → 2 - 12 months (~1 year) 
 
 
 Join us! 
 These measures collectively strengthen the safety and effectiveness of Jupiter DCA, enhancing your experience while reducing potential risks. Your trust and feedback propel us forward, and we are committed to refining and expanding DCA''s capabilities. We are dedicated to providing a seamless and secure environment for your DCA journey. Join us on this exciting path and stay informed within our active community. https://discord.gg/jup', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2024-01-24-jupiter-LFG-launchpad-beta/index.md', 'slug: jupiter-lfg-launchpad
title: "Jupiter LFG Launchpad" 
 Jupiter LFG Launchpad Beta! 
 Delighted to share our very beta LFG Launchpad, the first and only system whose goal is to infuse projects with love 💕 from a genuine Jupiter DAO and community, sets them up with long term success and protects their buyers from hype, fomo and rugs. 
 Unlike other launchpads, this launchpad will not have any complex  (and often fucked)  incentive mechanisms, or isolated price discovery systems - relying on the community, open market and ecosystem to do their things instead. 
 There will also be 2 tokens launching on LFG in Jupuary, of which we share more details below too. This is  VERY BETA , so we expect to uncover a lot more issues over these 2 weeks, including the JUP launch. 
 It is risky, but hey, if we don''t dogfood our own launchpad with our own JUP, how am I going to ask others to trust me with theirs right? So let''s see if we can make this work😆 
 Key Features: 
 
 Largest community rooting for you, maybe even becoming users! 
 Millions of airdrop recipients can claim at once 
 Launch pool that''s customizable for projects needs, locks team LP for days and mitigate bot advantage powered by the awesome  @MeteoraAG  DLMM 
 Highly intuitive tool to design the liquidity pool exactly the way you want* 
 Special network reporting and gas management panel to handle on-chain chaos 
 Full trading features but focused on the pre-ordering process 
 Integration with full network of bots so you can choose your fav bot to use it with 
 Full enterprise level RPC, Cloudflare and FE support 
 
 
 Key Goals: 
 
 LFG Price discovery: Everyone starts at once, no complicated isolated pool mechanisms. The open market should be where discovery happens 
 Immediate liquidity for paper recipients to dump, while there will be sufficient buy liquidity, preventing very erratic price swings. 
 Sufficient backstop buyer-regret liquidity for price to stabilise before liquidity can be withdrawn by team. This prevents a situation where the price dumps shortly but the team has all the stable liquidity. 
 Fully transparent on-chain market making, completely zero shennigans. 
 A focused UX for the user to buy/sell wo making a lot of possible mistakes around gas and trades 
 
 
 
 DAO Vote, Community Rallying and Technical Support 
 The DAO will vote for all projects to be launched, ensuring that this is a project the community can get behind. 
 After the DAO vote, the project will be fully and thoroughly introduced to the community via a few sharing sessions on Discord and Twitter as well as being featured on the Jupiter homepage for a few days. 
 This will ensure that the most active community members and users will get to know the project very, very well - increasing the chances not just of a one day buying, but a long term, highly synergistic relationship. 
 Removing all potential worries for projects by providing full operational, scaling, technical support and expertise. Our best in class user support will extend to you too. 
 References: 
 For more details on motivations and technical updates, you can refer to this draft jupresearch post. 
 https://jupresear.ch/t/jupiter-lfg-launchpad-beta/31 
 Custom Price Curve Modeling 
 Unlike other liquidity curves the point here is NOT price discovery or equilibrium, but rather liquidity bootstrapping and backstopping. Along with every project''s extremely different needs and context, a custom price curve tool is needed. 
 Enter The LFG Price Curve design, maths, paper and website is being developed by intern #2  @Village_Idiot , who is mid way through high school. 
 https://lfg-design.jup.ag 
 This tool here to help project teams design the price curves they want, which will then automatically tell them the amount raised at different price points, executes the mathematical translation into DLMM bins etc. 
 The important here is that there is no need to determine or set an initial price - you can just decide your initial price (which is important for determining bot advantage), your final price (important depending on your liquidity needs) and how steep you want the price to increase. 
 
 Graph y-axis does not start from 0 
 For example, in this configuration you can see here the starting price is low to incentivize early liquidity, but the curve steeps strongly upwards with only a small number of tokens available for early takers before a more gentle slope occurs. This incentivizes early aggressive price action while leaving most tokens for users. 
 Alternatively, less hyped project can certainly opt for a more gentle slope with a higher starting price, which will allow everyone to acquire the tokens gradually over time without much price advantage for early buyers. 
 While the current tooling only supports on single curve, we will be adding a lot more curves over the coming year, including S-shaped and U-shaped ones.  We look forward to experimenting with various configurations over this year, and I am sure best practises will start to show up over time! 
 The full research paper and post will be up soon. He writes like a 5th grader, so be kind. 
 First 2 Projects For LFG Beta: 
 We are trying out a lot of new things with this launchpad, and many, many things can go wrong. As such, we will host a lower stakes launch first, and then finally eat our own dog food with JUP. 
 
 A fun coin managed by our good friends  @OvolsNFT  will launch this week some help from me.  I will have zero financial stake in it, and Jupiter will have zero involvement in the memecoin. 
 
 With even more airdrop recipients than JUP, it will be a much lower stakes, fun, but similarly extremely technically challenging test for the launch pad. 
 
 Following week, on 31st of Jupuary, we will of course launch JUP. Yes, we are dogfooding our own launchpad ourselves with JUP. 
 
 Jupiter DAO 
 In both cases, both  @OvolsNFT  and  @Jupiterexchange  will provide 1% to LFG launchpad, of which the upcoming JUP DAO will receive 75% and the team 25%. 
 So that should be a nice early bonus to the DAO. The team will keep this first, and transfer to the DAO after it forms. 
 Moving forward, the Jupiter DAO will approve new projects to be on the launchpad. It has to be throughly responsible for making sure the projects are worthy of being promoted to all Jupiter users, and then doing what they can to make the project as successful as possible. 
 There will be no bullshit like insider arrangements, secret profit sharing and token gating. The above arrangement is a pure, simple and mutually beneficial approach to token launches. 
 Given that the Jupiter DAO will be the largest, most non-insider voting, most dynamic and open minded DAO in the history of DAOs, we are confident 
 The team will provide all required support to projects approved by the DAO, with the likely maximum of one project every 2 weeks to maintain a very high quality pipeline. 
 1st Feb: Ready For Projects 
 We hope this gives a nice overview of our LFG launchpad, and our road towards launching Jupiter. We look forward to your active participation in these 2 launches. 
 If all goes well, we will be able to start offering the launchpad to projects who would like to launch with Jupiter! 
 Otherwise.... Well, at least we mess up together as a community right? 🩷', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-02-10-jupiter-token-list-api/index.md', 'slug: jupiter-token-list-api
title: "Introducing the Jupiter Token List API" 
 Introducing the Jupiter Token List API – an open, collaborative and dynamic token list to make trading on Solana a more transparent and safer experience for users and developers. 
 
 Today, we are introducing the Jupiter Token List API. We are designing this token list to be open, collaborative, and dynamic, to build a safer and more transparent trading experience for users and developers. 
 A key part of our  JUP Promise (Best Price, Best Token Selection, Best UX)  is the idea that users should be able to trade any token they want on Jupiter while having the peace of mind that the token they are trading is the right one. 
 
 This is super challenging in DeFi when the only true identifier of a token is its mint address, versus the more commonly human-referenced metadata of a project, such as its symbol, name, and icon, that can be impersonated. With new projects being created every day, it is not only difficult for protocols to police but it also creates a burden for users to be extra careful with what they''re trading. 
 Having an up-to-date and trusted token list is crucial for both users and projects. Users depend heavily on the applications to display the right tokens. New projects want their tokens to be discoverable and tradable everywhere, whether they are famous or not. 
 In addition, a robust list should contain other types of data to give us the full picture of a token, including on-chain metadata from project creators, actual market liquidity, data from developers like Wormhole, SolanaFm, Birdeye, AllBridge, and community validation data. 
 With all these in mind, we would like to share how we addressed safety, openness, and the ability to trade any token while incorporating various sources of data into the token list. 
 Our Approach 
 
 Dynamic:  The full list updates automatically with new projects as long as there is sufficient liquidity. This makes it available for trading on Jupiter immediately. 
 Open:  We include market and partner data about a token so you can choose what you need. The full list will always contain all tokens available for trade to give open access to all projects. 
 Safety:  Only validated tokens are shown on the ''Strict'' list by default. 
 Collaborative:  We engage ecosystem partners to build a robust and comprehensive list with us by including their data. 
 Community Driven:  Our community drives the token-list validation process. 
 
 For example, take this USDCet token symbol. 
 {
    "address":"A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM",
    "chainId":101,
    "decimals":6,
    "name":"USD Coin (Portal from Ethereum)",
    "symbol":"USDCet",
    "logoURI":"https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/A9mUU4qviSctJVPJdBJWkb28deg915LYJKrzQ19ji3FM/logo.png",
    "extensions":{
        "coingeckoId":"usd-coin-wormhole-from-ethereum"
    },
    "tags":[
        "old-registry",
        "wormhole"
    ]
}
 
 You can see that this token has 2 tags – it is found in both the old Solana token registry and the list of bridged Wormhole tokens. 
 In following these 3 key principles of being collaborative, dynamic & open, we hope to build up a comprehensive solution for everyone in the ecosystem while taking care of the safety of users. 
 
 Token List API 
 The API has a  “strict”  option – which we use as the default on our UI. 
 The strict list only includes tokens from Solana’s original token list, Wormhole’s token list, and Jupiter’s community-validated tokens. It freezes important metadata (symbol, name, logo) on validation to stop projects from changing their metadata to impersonate another token. 
 Endpoints 
 Jupiter’s token lists are designed to be open. We include tags about its source so that developers can choose the tokens for their use case. For your convenience, we included the tokens we show in “strict” mode on our UI in a separate endpoint. 
 Strict:  https://token.jup.ag/strict 
 
 This returns only tokens that are tagged "old-registry", "community", or "wormhole" verified. No unknown and banned tokens are returned. 
 
 All:  https://token.jup.ag/all 
 
 This returns all tokens including unknown/ untagged tokens. 
 It does not include banned tokens by default. To bring up banned tokens, append this flag to the endpoint. (?includeBanned=true). 
 Our lists are designed for trading and so only lists tokens that satisfy our minimum liquidity requirements and are available for trading on Solana. 
 
 Metadata 
 Tags:  Each token can have 1 or more of the following: 
 
 Old-registry:  These are tokens added to the archived solana labs token list repo before July 2022. As this is the original token list in Solana, the tokens here are generally more recognised. 
 Community:  These are tokens attested by Jupiter''s communities, including newer and widely traded tokens created after the old-registry was archived like Bonk and Hades. 
 Wormhole:  These are bridged assets to Solana via wormhole, mostly from Ethereum. 
 No tags / Unknown ("tags:[ ]"):  These are tokens that are picked up automatically by Jupiter. 
 
 Extensions: 
 
 isBanned:  These tokens are flagged by our community, typically for trying to impersonate another project. 
 
 
 Jupiter App 
 Our UI uses the API and defaults to showing tokens from the “Strict” list. Users can toggle on the “All” list that includes unknown tokens. 
 
 Even if the token has not been immediately validated, it will still be surfaced via symbol and mint address search with additional prompts. 
 
 Community Validation for Strict Mode (BETA) 
 Our community drives the token vetting process. We are iterating on it together, with a focus on safety and openness. 
 To follow the conversation, see  our public Github Repo  and talk to us in  our discord . 
 Collaborate with us 
 The Jupiter Token API is still early and we want to work w everyone – users, community members, protocols, and data consumers to build a better one: 
 
 Ecosystem Partners:  If you have your own token data (e.g. Wormhole tokens, SolanaFM validated tokens) that we can incorporate, let us know. 
 Community:  Join our validation process and tell us what you want to see in the strict list! 
 Users:  Try out the 2 modes on the UI and give us feedback! 
 
 We are excited to improve on the  JUP Promise  – of the  best price, best UX, and best token discovery  – to our users and the ecosystem, letting users discover all tokens while helping them to stay safe. 
 The Jupiter Token API is our third API on top of the Price API and Swap API, joining a set of important lego pieces to unlock trading and liquidity on Solana. 
 A robust token list is fundamental to any DeFi trading landscape - let’s work together towards a safer, more dynamic, and open trading env on Solana!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2022-08-24-creating-jup-spirit.md', 'slug: creating-the-jup-spirit-together
title: "Creating The JUP Spirit Together 🦄🪐" 
 A strong community is at the heart of every good crypto protocol; especially for Jupiter, our community has been cheering us on, guiding development from day one, and filling in the team’s blindspots with talent and passion. 
 We wouldn’t have been the same without you. 
 
 Here are some examples of how the community has shaped Jupiter: 
 
 Helped make Jupiter one of the fastest growing Defi platforms ever by sharing their positive experiences on Twitter, Discords, private groups 
 Alerted the team to bugs and issues to make the product as good as it can be 
 Supported new users in navigating the platform with a lot of patience and empathy 
 Made art that we’ve used in our materials and it made Jupiter more lively 
 Translated Jupiter into 7 languages and wrote articles for their home communities 
 Created and ran AMAs, trivia, and other events in very creative and engaging ways 
 Moderating other users’ comments in discord with care and intuition 
 
 Thanks to everyone’s incredible help, we have made tremendous progress in the last 9 months, which includes crossing $22B in volume traded, being the most integrated protocol in Solana by most of the major projects, running Solana’s most consistent podcast, and growing a substantial organic community. 
 As we take the next step towards our  broader goal of bringing decentralized liquidity to everyone , we would like to invite the community to create a new manifesto and incentive system together. 
 The  JUP Promise  of best token selection, best price, and best experience for users and developers helped Jupiter to become one of the best products and top DEXes in Defi. 
 The  JUP Spirit  will help Jupiter build one of the most vocal, most long term oriented and most critical communities in crypto. 
 
 Drafting The JUP Spirit Together 🎨 
 To get things started, here’s a draft of the JUP Spirit, and the ethos we want to engender. It is a draft of how we envision the community coming together: 
 
 
 Be critical yet optimistic about product improvements:  It is very difficult to build a leading aggregator and maintain that lead. We need YOU to join the hustle. Tell us where we can do better, and be critical yet optimistic about improving the product with us. 
 
 
 Tell the world about Jupiter:  If a tree fell in the middle of the forest and no one saw it, did it fall? If Jup is the best Defi product in the world, but no one knows about it, is it still the best product in the world? We need a community committed to pushing us to be the best in the world, and telling the world about it! 
 
 
 Maintain a long-term mindset:  Short-termisms plague crypto. We are determined to build a community that is critical yet supportive through ups and downs, lefts and rights, #BUIDL-ing together for the long term. 
 
 
 How to help:  What impressed you so far about the Jupiter community? What other communities do you think have great ethos that moves the project forward? How would you change the draft we have above? 
 
 How do we manifest the JUP Spirit? 
 On one side is the community ethos; on the other side are the incentives that drive behaviour. We want to create a fun yet meaningful role and incentive system to reward and encourage contributors. 
 Currently, we award roles for Jupion (helpful contributors, winners of events), Jupassador (consistent help and repeated wins), and Jupioneer (the earliest users and contributors to Jupiter when we started and heroic contributors), while XP is awarded for participants of our events such as AMAs and Twitter spaces. 
 While our current system has worked very well in terms of bootstrapping the community, there are some issues we need to resolve: 
 
 Impactful contributions (helping us work through bugs, product feedback that gets incorporated, partnership wins, great tweets) are not rewarded 
 XP is disjointed from roles and it’s not clear what purpose it serves 
 Consistency in community contribution (support, artwork) is not recognised 
 
 We would like to evolve a new system alongside the JUP Spirit that will help us manifest a great community.  This system will also be the foundational groundwork before any decentralised token community is formed.  Not to worry, any existing roles and XP collected to date will be recorded and migrated to the new setup. 
 There are many areas that we will like to grow contributions in - developer innovation, art and memes, infographics, active product testers, creative and active evangelism, etc. 
 The community sees things that we do not see – they are in many other communities, try the product from a user’s perspective, and leverage Jupiter in ways we can only imagine. We want to tap on the fullness of their talents, skills, and intuition to help Jupiter to grow, by sharing more context and empowering people to act. 
 How to help:   Reading the draft of the JUP Spirit, what do you think is good and what is lacking in terms of our current setup? How do we encourage either valuable or long-term participation? 
 
 LFGGGG! 
 We will be running this conversation for the next 2 weeks — we hope to come away with renewed energy and a better sense of how to be helpful as a community and embody the JUP Spirit.  This conversation will be facilitated by our 2 newly minted lead mods - Timoon and LJQ, who will be sharing regular updates to keep the conversation going. 
 Please refer to the earlier questions in the “How to help” sections and share your thoughts, or just share anything you want! You are probably less boomer and more in touch than us, so you know best. 
 Here are the channels to participate in the Jup Spirit discussions. Feel free to cross-post! 
 
 Discord:  The easiest way to chat. Go to 🔆・jup-spirit category in our discord and join the conversation: discord.gg/jup 
 Email:  If you’re feeling shy and like it classic, you can email feedback@jup.ag 
 
 Top contributors will get first dibs on whatever roles are decided in the new system, as well as some awesome amazing Jupiter swag! 
 We need to build a strong community foundation ahead of any token-related work. The formation of the JUP Spirit is a crucial step for that foundation that will anchor our main goal of bringing decentralized liquidity to everyone.
Very, very, excited to work together to create the most active, robust and long-term communities in crypto together. 
 LFGGGGG!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-03-28-jup-v2-major-upgrade-to-routing-engine/index.md', 'slug: jup-v2-major-upgrade-to-routing-engine
title: "Jupiter v2 - A Major Upgrade to our Routing Engine!" 
 
 We are excited to announce Jupiter v2 - a major upgrade to our routing engine! Rewritten in Rust to tap on the speed of Solana, it now offers advanced routing across 20+ liquidity venues for better pricing on both large and small trades. 
 This engine was made possible by the introduction of major composability improvements in Solana last year, including Versioned Transactions, where more complex transactions such as multiple hops and split trades can be executed together within one atomic transaction. 
 Our quote and pricing API will similarly undergo major upgrades, allowing integrators to seamlessly adopt the new engine for better quoting and more accurate/deeper real-time price data. 
 
 In addition, there are a few other significant improvements, including: 
 1. Dynamic Priority Fees 
 Where the program determines the added transaction priority fee needed for a successful trade. The feature, when turned on, will run in the background, reducing the chances of failed transactions. 
 
 2. Safety Improvements 
 User safety and security are our top priority. By default, we show only community-validated tokens and added safeguards against trades where the price impact or price warning exceeds 15%. 
 
 3. New Design and Navigation 
 We will introduce a refreshed brand with an even better user experience at Jupiter. We are committed to collaborating closely with the community, sharing design ideas and gathering feedback throughout the process to make this happen! 
 
 We will be rolling out these enhancements incrementally and engaging the community along the way. Stay tuned for product updates and feature/design discussions in Discord. Your feedback and suggestions will help shape our products and features for v2! 
 With Jupiter v2, we progress towards building the most powerful trading engine in DeFi and a platform to replace the need to use CEXes. This is us keeping to the key JUP Promise of Best Price, Best Token Selection and Best UX! 
 Come give it a spin here:  v2.jup.ag', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-09-01-jupiter-limit-order-upgrade/index.md', 'slug: jup-limit-order-upgrade
title: "Limit Order Upgrade: Any-to-any token trading, 0% maker fee and more!" 
 
 Today, we’re introducing the key upgrades to Jupiter Limit Order, with features like  any-to-any tokens trading ,  fee removal  and  enhancements  that will elevate your trading experience and open up exciting new possibilities. 
 Let’s dive into more details: 
 Any-to-any Token Trading 
 Responding to user feedback and demands, we''re thrilled to unveil any-to-any token trading within Jupiter Limit Order. Unlike before, where it was restricted to specific base tokens like USDT, USDC, and SOL, this update leverages an upgraded Limit Order contract and Jupiter''s latest routing algorithm to empower trading of any token pairs. This expansion broadens the scope, providing users with even more trading options and opportunities. 
 
 TradingView Chart 
 Empowering your Jupiter Limit Order experience further, we''ve integrated our trading chart with TradingView, utilizing data from BirdEye. This integration offers a comprehensive TradingView chart within our platform, making it much easier to perform technical analysis and place limit orders with a few clicks through the interface. 
 
 It''s important to note that while this integration offers exceptional functionality, some low liquidity token pairs might face limitations due to insufficient historical data. 
 Keeper/Taker guideline 
 We are coming up with a comprehensive guidelines for users and developers interested in running their own keepers or takers, complete with example code. This initiative will empower more participants in the system to efficiently run and execute orders, potentially benefiting from order profit execution and positive slippage. 
 The taker code facilitates keepers in accessing, filtering, and sorting open orders on-chain based on price. Furthermore, keepers can gather quotes from the Jupiter Swap API to evaluate trade profitability. Notably, this integration also enables the merging of Jupiter Swap Instructions with Limit Order Instructions, streamlining execution. 
 This enhancement enables a broader group of keepers to participate in executing Jupiter Limit Orders, thus enhancing order execution and decentralization. 
 Check out GH Repo here 
 0% Fees for placing orders 
 Considering all these updates, we''re making a significant alteration to the fee structure: reducing  Jupiter Limit Order fees to 0% for placing orders . This strategic move aims to encourage heightened usage of Limit Order. This not only encourages order placement but also improves order matchability with swaps as active orders increase.  We are also working on a more streamlined referral fees structure for partners and integrators which we will be releasing more details in the upcoming developer-focused updates. 
 Your feedback is invaluable to us, and we''re dedicated to refining your trading experience on Jupiter. These enhancements mark the beginning of an exciting journey. Our unwavering commitment to delivering even more remarkable features in the future remains steadfast. We encourage you to continue sharing your suggestions and feedback; your insights greatly contribute to our progress. Connect with our active community on Discord. 
 Join our Discord community 
 Lastly, we''re excited to announce a series of trading campaigns, commencing with $SOL. As we align with the evolving ecosystem, we''re gearing up to roll out campaigns in collaboration with our partners. Stay tuned for more updates and let''s embrace the momentum together by placing those limit orders! 
 Trade now:  https://jup.ag/limit/USDC-SOL', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-06-29-jup-token2022-support.md', 'slug: jup-token2022-support
title: "Jupiter Token 2022 Support" 
 After rigorous testing over the past few weeks,  Token2022 is now officially supported by Jupiter !  Fluxbeam  has been integrated into our routing, and tokens like  $BERN  and  $MOON  can now be traded along with other tokens in the Solana universe. 
 Token2022 is a new token standard developed by Solana Labs that presents a superset of functionality provided by the standard  SPL Token Library  which includes transfer fees, interest bearing tokens, non-transferability, and immutability. 
 This enables new types of tokenomics to be developed. For example, $BERN leverages a 6.9% transfer fee to reward holders of $BERN and $BONK while Solarmoon leverages transfer fees to reduce supply and create deflationary tokenomics for $MOON. 
 With the large number of updates over SPL Token Program, we had to make significant upgrades to our backend, UI and aggregator program to handle both the standard token library and token2022 in one seamless UX. Most notably, we had to support transfer fees across the entire stack and update our crawler to recognize Token2022 tokens. 
 In addition, as Jupiter is deeply integrated across many major wallets and dapps — not all of whom support 2022 yet — it was important for us to break this work out into a separate token list API as not to affect existing partners. 
 It’s important to note that Token2022 is currently still undergoing development and auditing. In addition, as features like transfer fees make it more difficult for integrators to adopt, we recommend sticking to the standard token library unless there is a strong need for those specific features. 
 To understand more about the standard, you can refer to these resources: 
 
 https://spl.solana.com/token-2022 
 https://twitter.com/KEMOS4BE/status/1663960214637539329 
 https://twitter.com/heliuslabs/status/1671551473950531585 
 
 We are really excited to support Token 2022 standards and can''t wait to see the amazing things that projects cook up with these new possibilities. To a greater Solana platform!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2022-09-14-unveil-jup-spirit/index.md', 'slug: unveiling-the-jup-spirit
title: "Unveiling the JUP Spirit (🦄​ ,🪐​)" 
 We spent the last 2 weeks sharing an ethos for Jupiter’s community and debated how we can best rally and recognize what is important to us. You showed up with passion and ideas. And together, we thought really hard as a community about what matters to us. 
 The essence of why community is important is captured here: Without a community, we are just a website and code, much like how the body is just flesh and blood. The soul gives us life, and the community brings Jupiter alive. 
 
 
 The JUP Spirit 
 With that in mind, we are excited to unveil the JUP Spirit! It will be the guiding force behind our community as we work together to bring decentralized liquidity to everyone. 
 
 Most Vocal, Most Critical, Most Long Term 
 Yup. The JUP Spirit may be simple but it covers so much of what we care about. It captures the essence of being there for Jupiter in the most helpful and genuine way. This is also a massive improvement over the first draft, pointing to the importance of community in co-creating a vision with us. 
 Just like how the JUP Promise of Best Tokens, Best Price and Best UX helped us to create one of the top products in DeFi, the JUP Spirit of Most Vocal,
Most Critical and Most Long-Term is a rallying cry to create one of the most active and helpful communities around! 
 Most Vocal:  A vocal community does what they can to support and spread Jupiter far and wide. After all, what’s the point of building something great if no one knows about it? Yes, go forth and activate all of the viral dark arts you know. 
 Most Critical:  It is very difficult to build a leading aggregator and to stay ahead. The community is out there and we need all of your eyes and ears to help us be the very best. We hope you can give us feedback on all kinds of issues, large or small. 
 Most Long-Term:  So much of crypto is plagued by short-termisms – in tokenomics, product and more. We don’t like that. We want to build the most sustainable product and organic community that gives a shit regardless of whether the market is up or down, left or right. 
 
 Unleashing The Jup Spirit 
 Now that we spent a very productive 2 weeks discussing the JUP Spirit, we are focusing the next 2 weeks on working out how we can unleash the JUP Spirit in our community! 
 Here’s what you can look forward to: 
 1/ Discord Revamp:  To make it easier for you to participate, we will cut back on some channels that are no longer relevant and open some new ones. It’s day 1 again! 
 2/ New Experimental Activities:  We will pause our current set of events (quizzes, weekly winners) to make it easier for new community-led activities in line with the JUP Spirit to arise. 
 3/ Rework of Roles:  We will begin to rework roles and incentives to recognize and reward our people, starting with folks who are the most JUP Spirited. 
 4/ Updated Community Content:  We will refresh some content like FAQs and invite you to help. 
 To kick off this new period, a community call will be held  this Friday, 2pm UTC on our discord  to celebrate the very beginnings of our JUP Spirit bonfire!! It will be a chat with friends and not a 1-way speaking street, so we hope you come and participate actively. 
 Buckle up Jupinauts 
 Together, we hope to build a Jupiter that belongs to all of us. This is the start. 
 And yes, this is alpha and financial advice. 
 Let''s UNLEASH the JUP Spirit! (🦄​ ,🪐​) 
 
 P.S.: Shout out to these amazing people who contributed to the conversation! We are so, so happy to meet and hear from you. 
 THANK YOU   pixel, cryptoRon, Humprey1 | Jupiter, LJQZZZ, scot, Surime, thimerosa, binlxyz, Timoon_21, Bentley, tikijiu | Jupiter, Aremia Vincenzo, dendaMx0, freaky, MANHJUPI, Surime, Drswagoon, Morty | from Jupiter, yukaz, UP | Jupiter, Zhing Richard, !spice, silver | popbone, snow, tralava, bruda.sol, sadovnik, msNik,  clara, Stand, Loyal, Optimus prime, abuwazir, zeck, ushenry, smarty, poopo, lucha, Peterpan, hopper255, summertime, Poseidon, akashc8, Belami, jentelo', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2022-05-25-jupiter-the-liquidity-infrastructure-for-solana.md', 'slug: jupiter-the-liquidity-infrastructure-for-solana
title: "Jupiter: The Liquidity Infrastructure For Solana" 
 Over the last few months, Jupiter has become the key swap liquidity infrastructure for Solana growing to over $16B in trading volume, aggregating across 15 integrated DEXs and facilitating the liquidity flow of many key projects in the ecosystem. 
 What we''ve accomplished today has been the result of a successful collaboration between the team, the community, and the Solana ecosystem. Only through constant feedback and close collaboration with everyone, have we been able to continually work towards the JUP promise of providing the  best price ,  best token selection , and  best UX  in DeFi. 
 As crypto captures more markets like banking, gaming, and payments, we believe Solana will be one of the key hubs for all that activity, with the number of applications, users, and protocols set to explode in the years to come. 
 Jupiter will provide the single liquidity endpoint for all these stakeholders to connect effortlessly and the swap infra to allow the entire ecosystem to scale exponentially. But, unlocking this growth requires the collective efforts of not just the team, but, a larger body of the community, ecosystem, and users working together. 
 
 
 Why Solana? 
 We are committed to building the swap infrastructure for Solana because we see Solana as becoming one of the key trading hubs of crypto. It is also perfectly positioned to capture the next billion crypto users where usability, transaction costs, and scalability remain key barriers to entry for them. 
 Solana’s blazing speed and throughput are key enablers of innovation. Liquidity protocols that would be impossible on slower and less scalable blockchains, including full-fledged order book systems and rapidly updating oracle-based AMMs, can finally be brought to life on Solana. 
 Beyond that, Solana''s developer ecosystem is unique in crypto. Rooted by the goal to be the "useful" blockchain in people''s daily lives, the ecosystem is filled with some of the smartest, most helpful product-focused builders around building ever more unique, useful and innovative apps. 
 Additionally, Solana has also attracted major audiences in finance, gaming, NFT, and payments, enough to reach a tipping point of users, devs, and businesses building on top of it, as seen by the significant growth of dev users and wallet downloads. This will lead to the flywheel effect where more users → more assets → more liquidity in the whole Solana ecosystem, making swap infrastructure more critical for growth. 
 As with any trading hub, one critical aspect is the links to external platforms. With Solana, it’s well-poised on both centralized exchanges and decentralized cross-chain connections, and continues to be one of the top priorities for connections with all the emerging protocols and standards. 
 Last but not least, the Solana ecosystem is just plain fun. We have been in many crypto ecosystems in the past, and the Solana ecosystem strikes us as the most fun, pragmatic and focused on user experience vs ideologies. And that’s really important for us! 
 Of course, there are some critical technical issues to be addressed such as network slowdowns, txn size, and compute unit limits, but we are confident the problems will be resolved by the excellent team over at Solana labs, who have proven time and time again that they are one of the best technical and operational executing blockchains in crypto. 
 
 Jupiter Overview 
 Originally, Jupiter was a team experiment, where we built a standalone program to integrate Mercurial and Serum to provide more utility for stables like $UST & $PAI and help establish them as key stables in Solana. In doing so, we launched the first cross-protocol liquidity swap on Solana. 
 Encouraged by our own dogfooding and the highly receptive response from the community (and the geeks in us loved playing with all the various networks, and solving all the tricky problems, like txn size limits, and all that good stuff), we decided to start Jupiter as a standalone project, launching in November 2021. 
 Along the way, we developed the JUP Promise to anchor us to the value we want to deliver - best price, best token selection, and best UX for users and developers. Sticking to this promise, along with the relentless feedback and debugging help provided by our community of users and developers, has been crucial in helping us improve the platform and make significant progress on key objectives. 
 We''d like to take the chance to share what these objectives are, the main challenges we had to solve to get here, and some of the cool things we have in the works. :D 
 1: Build the best swap experience in DeFi 
 With everyone''s help, we''ve come a long way towards building one of the best aggregators in DeFi, with the goal of allowing anyone using Solana for the first time to have an amazing experience trading with the best price and best experience possible. 
 To have the most comprehensive liquidity coverage in Solana along with a seamless experience, there were a large number of technical challenges we had to solve, including fitting advanced swap routes within the transaction size limit of 1232 bytes and compute unit limits, and incorporating very different technical models like Serum’s orderbook mechanism, Lifinity’s rapidly updating oracle based pricing mechanism and Crema’s concentrated liquidity mechanism. 
 Over time, we have developed a very strong and flexible technical foundation (both on-chain and off-chain), as well as a solid process of working closely with other teams to overcome any initial technical challenges, sharing feedback and often working with them very early in their launch process to improve their platform and SDK, allowing us to roll out new integrations rapidly. 
 Now, we have the widest and most comprehensive liquidity coverage in Solana, having integrated over 15 DEXes into one seamless interface and SDK, including very technically different platforms like Serum, Orca, Lifinity, and Crema. 
 2: Be the swap infrastructure for Solana 
 To ensure the seamless and healthy flow of liquidity throughout the ecosystem, we work towards providing the most comprehensive and robust swap infrastructure possible for Solana for any user or project to reliably transact on. 
 We do so by providing a single liquidity endpoint where any users, dapp and protocol can seamlessly access all the available liquidity, achieving the best price and ux for their own projects, regardless of whatever platform or language they are using. This liquidity endpoint is accessible via 3 main mechanisms: A user facing website on jup.ag, a comprehensive and robust SDK and API, and onchain program instructions. 
 We have since built up an extremely diverse ecosystem of projects leveraging Jupiter for their swap needs, including top Solana projects like Mango, Tulip, Defi Land - ranging from native swaps in wallets to facilitating key DeFi use cases like vaults, liquidations, and payments. 
 3: Build one of the best communities in crypto 
 With over 50k community members across Twitter and Discord, we have built one of the best organic DeFi communities in Solana. Our community has been a cornerstone of Jupiter’s development and growth. This is true not just for product, but also in terms of evangelising, support, content contributions, and just plain vibe, making Jupiter a fun place to spend time connecting with others. 
 What makes our community so special is an amazing group of content creators and moderators who have created a lot of great content, spread a lot of great energy, answered questions, and also led a lot of events, including community AMAs, where we discuss various community members journey into crypto, international AMAs, etc. 
 Beyond that, our community has been essential at evangelising Jupiter to the other users and the ecosystem, with many of the most important integrations and partnerships have come because various members have spoken up and championed Jupiter in their respective communities, with Mango, DeFi Land, and Project Galaxy are just a few notable examples. 
 Ask-Me-Anything (AMA) has been a constant initiative for us to connect with key players in the ecosystem and vice versa, which eventually blossomed into some amazing partnerships. Not only that, it’s a really helpful platform for all of our community to learn more about DeFi protocols, NFTs, GameFi projects, and the Solana ecosystem in-depth. In the AMA series, we hosted some of the most talented guest speakers in Solana and garnered a wide range of audiences live on Twitter Spaces and Discord. 
 The series then continued on to morph into our very own podcast series - Exploring Solana with Jupiter - to reach a larger audience especially outside of Solana, for people to learn more about the community. 
 Our growing community of developers building on top of Jupiter have helped us be able to scale supporting the growing number of projects who all have different platforms and use cases they are building for. They’ve not only shared solutions that have worked but also code. 
 
 What''s next? 
 Despite the incredible progress we have made the past 6 months, the whole ecosystem is only at its infancy and there is still so much more work to do in order to help Solana scale. It is also because we are at this early stage, there is so much potential and opportunities waiting to be unleashed. 
 Jupiter will be kickstarting a new phase and we are planning on many exciting developments. On the product side, we are going to support interesting integrations like direct staking/ minting routes and a wider range of use cases such as Solana Pay, TWAP and streaming payments. As more liquidity sources and tokens come online, enabling routing between all of them and maintaining a scalable robust swap layer will be an ongoing investment in infrastructure building. 
 On the community end, we hope to nurture the next set of leaders who can eventually lead our teams, truly embodying the spirit of empowerment and service of the community. We have also seen much success with our AMAs series and we will increase our content marketing such as podcasts and opinion pieces, to educate and bring new users to Solana. 
 As we look beyond Solana, we see many opportunities to improve cross-chain migration of assets into and out of Solana with Jupiter well placed to add immense value in this area.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-10-23-jupiter-planetary-developer-week/index.md', 'slug: jup-planetary-dev-update
title: "Jupiter Planetary Developer Week" 
 
 Introduction 
 Calling all Jupiter Space Catdets, welcome to the Jupiter Planetary Developer Week! 
 We''ve been working really hard to bring you fantastic new features that will make it even easier for you to create amazing liquidity use cases on Solana. 
 This is a whole week dedicated to Solana developers, where we will unveil major improvements to our tools, just in time for the Breakpoint conference. 
 So, get ready to supercharge your  BUIDLing  journey with us! 
 Day 1 - V6 Quoting API Official Release 
 Today, we are happy to announce the official release of our v6 API! This is DeFi’s most powerful and comprehensive liquidity API and will power the development of sophisticated use cases and complex DeFi processes on Solana. 
 
 This announcement comes on the heels of 2 months of relentless stability and feature-level improvements, helped immensely by key early adopters, including  Solend ,  Mango ,  Drift ,  Birdeye ,  Hawksight ,  Sphere , and  Kamino  who not just helped to iron out a lot of the kinks for any new infrastructure service, but also guided us towards specific improvements to make it possible for them to use Jupiter for their use cases. 
 In this article, we will go through key upgrades made for v6 to make building liquidity use cases much more powerful and easier: 
 
 Upgrade to use the Metis Algo for higher liquidity to support key use cases 
 Using shared intermediate token accounts for integration simplification and cost savings 
 Token ledger for increased swap success rates 
 A brand new referral fees system 
 
 In addition, we will also show advanced usage patterns, examples of how our partners are using it. 
 This launch of the v6 API is part of a series of developer announcements we are rolling out to enhance the liquidity infrastructure landscape for Solana. Stay tuned! 
 Key features for V6 Quoting API 
 Metis Algo As Backbone For v6 Routing 
 Three months ago, we launched Metis on our homepage. It''s an innovative new algorithm with real time streaming and discovery, with the routing engine also completely rewritten in Rust. This heavily modified variant of the Bellman-Ford algorithm incorporates key features such as incremental route building, combined route generation and quoting, and it''s also future-proofed for much better scalability as we add more DEXes and tokens. 
 The previous version of the API utilized an older version of the algorithm that had significant limitations. Most notably, it did not provide efficient routing for large trades, which constrained its applicability for major use cases such as margin trading and liquidations. Moreover, it employed the former JavaScript engine, resulting in inconsistent API performance. 
 
 With the v6 API now using Metis, all partners can enjoy a far higher level of liquidity for key use cases. For example, Solend which is using it for margin trading, where the trading amount is often much larger and requires deeper liquidity. 
 On the backend, we are constantly upgrading the API and making incremental improvements to deliver an easier, smoother and more efficient liquidity infrastructure for our partners. 
 Shared Intermediate Token Accounts For Integration Simplification and Cost Savings 
 The idea of Shared Intermediate Token Accounts came about because there was an increasing number of intermediate token accounts to be created in order for a swap to be successful, which increased integration complexity and cost for users that needed to be addressed. 
 Previously: 
 
 
 Integrators needed to create every single intermediate token account before integrating and obtaining quote routes, to make sure that the swaps were executed without any disruption. Any token accounts that were missed out would lead to swap errors. 
 
 
 In Solana, an account rent fee is incurred for every Solana account to store data on the blockchain. With a large number of intermediate token accounts to be created per protocol, users incur a sizable amount of rent. 
 
 
 With the Shared Intermediate Token Accounts, Jupiter creates and maintains a set of Associated Token Account  (ATA)  contracts for intermediate token accounts. These shared accounts are global and shared among all protocols and partners integrated with Jupiter. Integrators now only need to ensure they have the final output token account to receive tokens for every swap. 
 On top of this, OpenBook Open Orders accounts are no longer required as well, because all orders accounts are also globally initialized and shared amongst integrators. 
 For instance, when swapping from Token A → Token B → Token C, instead of having to create accounts for Token B and Token C, integrators will only need to set up for the final out token  (Token C in this case) . Any intermediate tokens in between, regardless of the number of token hops, are automatically initialized and managed by Jupiter’s pre-established shared token accounts. 
 Creating individual token ATA accounts incurs account rent fees, which accumulate over time due to the growing number of intermediate tokens. With fewer intermediate token accounts required, users benefit from not having to incur account rent fees for maintaining their individual token ATA accounts with each protocol they swap on. 
 We also see a much simpler integration process for partners and integrators, as the need to create and manage numerous intermediate token ATA accounts via route maps is eliminated. 
 Integrators can also better compose swap instructions that fit within a single transaction size limit, as the number of accounts to pass through in each instruction is streamlined with these shared ATA accounts. 
 Token Ledger For Increased Swap Success Rates 
 It is very important to have a good swap success rate for a great experience for users as well as integrators. Token Ledger was developed because the common way of relying on simulation to facilitate swaps is not always reliable and can lead to swap failures especially during times of market volatility. A method that is based on actual amounts transacted, and combined into a single transaction is greatly needed, leading to the birth of The Token Ledger. 
 The Token Ledger is a collection of three instructions  (Set Token Ledger, Send Instruction, Swap Instruction)  that consolidate withdrawal and swap instructions into a single transaction. Integrators/partners can now effortlessly instruct a swap to be executed based on the actual sent amount, after taking into account fees and slippages. 
 Before the introduction of the Token Ledger, swap instructions relied on a simulation-driven approach to approximate the amount deducted from a user''s wallet to facilitate the swap. This estimation approach often ended up with discrepancies between the estimated and actual amounts, especially during periods of market volatility with high slippages, leading to swap failures. 
 Consider this scenario where a user intends to withdraw 1,000 USDC from Meteora’s USDC vault into wBTC. Note that users hold vUSDC LP tokens in Meteora vaults. 
 
 In the first instruction, the Token Ledger will verify and record the user’s initial USDC balance within their wallet. For the purpose of this example, let’s assume the initial balance is 100 USDC. 
 In the second instruction, an amount equivalent to 1,000 USDC in vUSDC is withdrawn from Meteora vaults into USDC, and we examine the user’s balance. Due to factors like slippage, the USDC balance is found to be 1090 USDC. 
 For the third instruction, subtracting the initial 100 USDC from the current 1090 USDC balance, it’s evident that the user has effectively withdrawn 990 USDC, which will then be utilized to swap for wBTC as the final output token. 
 
 Without the Token Ledger, the previous swap method relied on estimated amounts, which could fluctuate due to market volatility and performance variations, frequently resulting in suboptimal user experiences. 
 With the Token Ledger, integrators can issue swap instructions based on actual amounts that have taken into account slippage and related fees. This eliminates the need for simulation and significantly increases the success rate of swaps, all within a single transaction. 
 The Token Ledger caters to a wide range of use cases, which include but are not limited to: 
 
 Withdrawing assets from a protocol to any desired token, such as converting to USDC from a wBTC vault. 
 Supporting protocols that transition positions to a different token from their original position, as seen in Perpetuals. 
 Facilitating the exchange of NFTs for tokens other than SOL. 
 
 Read more about the Token Ledger:
https://station.jup.ag/docs/old/apis/swap-api#using-token-ledger-instruction 
 Referral Fees Program to Simplify Fee Collection 
 In our pursuit of making life easier for our partners, we''ve streamlined the process of charging referral fees with the new referral fees program. 
 In the past, setting up referral fees for our partners was not straightforward. Distributing referral fees to Referrer A and Jupiter required adding two more accounts to the instruction. It was also challenging to accommodate varying percentages of referral fees for different partners, needing to pass more accounts into the instruction to calculate these fees. 
 The motivation behind building the referral fees system was to automate the process of calculating all these fees, while providing a user-friendly interface to set up referral accounts and claim the referral fees collected. 
 Referral Fees System Features 
 
 Set up referral accounts with Jupiter via a simple interface requiring only a few clicks. 
 Only 1 single referral account is needed across the different Jupiter products. 
 Checking on the total fees collected across the token accounts with an easy button to claim them 
 
 The partner journey is now hyper easy - They head over to Jupiter, create a referral account, and then plug the referral account parameters into their integration. It''s that simple! 
 Give our dashboard a spin here: https://referral.jup.ag 
 Read here on how to add your platform fees to Jupiter Swap : https://station.jup.ag/docs/old/apis/adding-fees 
 More info on Jupiter Referral Program: https://station.jup.ag/docs/old/additional-topics/referral-program 
 
 Performing Advanced Swaps with Jupiter v6 
 Cross Program Invocation (CPI) & Flash-fill 
 The Cross Program Invocation (CPI) and Flash-fill are two approaches to integrate Jupiter swap with your protocol. In Jupiter v6 API, we have made CPI calls much easier to use by turning transaction payload into instructions for API users. 
 CPI Approach 
 To better understand how to swap via CPI, let us walk through an example of utilizing Jupiter Swap via CPI to swap from any tokens to SOL even if the user has insufficient SOL. 
 For CPI to work, the transaction will be composed of these instructions: 
 
 Borrow enough SOL from the program to open a wSOL account that the program owns. 
 Swap X token from the user to wSOL on Jupiter via CPI. 
 Close the wSOL account and send it to the program. 
 The program then transfers the SOL back to the user. 
 
 Read more here: https://station.jup.ag/docs/old/apis/cpi 
 The CPI approach is not without its limitations - because of Solana’s transaction limit of 1232 byte size, lookup tables cannot be used within a CPI call, swaps via CPI can fail at runtime since Jupiter routes may involve multiple DEXes in order to reduce price impact. Instead, we recommend taking the “flash-fil” approach to utilizing Jupiter Swap. 
 Flash-Fill Approach 
 The “Flash-fill” approach is a way to integrate your program with Jupiter swap without the limitations of CPI. Flash-filling allows the use of Versioned Transactions in combination with Address Lookup Tables to include more accounts per transaction while keeping within the 1232 bytes limit. 
 To understand the Flash-Fill approach, we will walk through the same example of utilizing Jupiter swap via Flash-Fill to swap from any token to SOL even if the user has insufficient SOL. Note that Flash-Fill can facilitate swaps from any token to any token, not limited to SOL. 
 For Flash Fill to work, the transaction will be composed of these instructions: 
 
 Borrow enough SOL from the program to open a wSOL account that the program owns. 
 Create the wSOL account for the borrower. 
 Swap X token to wSOL 
 Close the wSOL account and send it to the borrower. 
 Repay the SOL for opening the wSOL account back to this program. 
 
 This approach entirely bypasses the need for CPI calls, effectively sidestepping the constraints imposed by CPI. 
 To delve deeper into these two approaches, check out our documentation here: https://station.jup.ag/docs/old/apis/flash-fill 
 Partners Using v6 API 
 A big shout out to our key early adopters for running our v6 API and helping us improve our stability and features. Check out how they are using Jupiter to power their use cases. 
 
 Drift  leveraged swaps utilise the power of “flash loans” to allow traders to increase their spot buying or selling potential by up to 5x. These leveraged swaps are powered by Jupiter, to find the best price routes and get access to deep liquidity across Solana. 
 Solend  Margin Trading is an extension of their lending where it combines flash loans, swapping, and depositing the proceeds back into Solend all in a single transaction. The trading view features a swap UI powered by Jupiter. 
 Birdeye  is an on-chain trading data aggregation platform that utilize Jupiter Swap for all SPL tokens including the latest Token2022. With the latest v6 upgrade, it offers more improved speed that enhances trading experience on Birdeye. 
 Hawksight  integrated Jupiter v6 for their auto-swap deposits, making it super easy for users to maximise yield through auto-compounding and auto-rebalancing their LP positions efficiently. 
 Ultimate Wallet  integrated Jupiter into their native in-wallet swap. With the upgrade from v4 to v6, Token2022 is fully supported and the latest Metis algorithm expanded the price routes, enabling their users to swap over the widest range of tokens and access even better price quotes for their users. 
 Sphere  is a payments platform and API for digital currencies, where businesses can start accepting card, ACH, wire, stablecoins, and other digital currencies in a single universal checkout page. Jupiter provides the swap infrastructure for the built-in token swap. 
 Sollinked  is a social app designed for gated communities, offering a platform for newsletters or "paid" email inboxes that can be prioritized through incentives. Sollinked utilizes Jupiter to facilitate payments for emails and reservations using all SPL tokens. 
 
 Day 1 Ending Notes 
 Jupiter’s goal is to provide the best possible liquidity infrastructure for Solana. 
 With this major v6 upgrade, we are confident we have taken a major step in this direction. As always, we would love feedback and your thoughts on how we can improve, please join our feedback conversations on  Discord ! 
 
 
 
 Day 2 - Jupiter for Payments v2 
 Today, we are thrilled to dive into the world of Jupiter for payments, where we will introduce you to the upgraded ExactOut API. Join us as we delve into the improvements we have made to our ExactOut API, and how we have been facilitating online and offline payments in recent months. 
 A big shout out to  Sollinked ,  CandyPay ,  Sphere  and  Helio  for integrating Jupiter swap into their payment systems. These are super exciting times as we break down the barriers separating the world of crypto from traditional finance. 
 So, without further ado, let''s get started! 
 ExactOut v2 API to Power Payments 
 ExactOut is an important feature, particularly in supporting payment use cases within any ecosystem. Jupiter''s ExactOut API allows users to specify the precise amount of output tokens they require, with the input token amount being calculated accordingly. For instance, with ExactOut integrated, a protocol’s user can indicate they wish to receive exactly 100 USDC in exchange for SOL via Jupiter, instead of having to manually calculate and input the amount of SOL required to swap for an approximate amount of 100 USDC. 
 In the initial release of ExactOut v1, we could only support direct routes, limiting token selection and routing options that can be used. However, in Jupiter v6 API, our program has been updated to conduct on-chain calculations, thus enabling multi-hop routes for ExactOut v2. 
 This upgrade significantly broadens the range of supported routes from around 20 to over 400 trading pairs, enhancing route options and price selections. With 20 times more available price routes, aggregated across our partner platforms like Raydium and Orca, users can expect considerably better prices for their ExactOut swaps. 
 How ExactOut is used 
 ExactOut is particularly useful in scenarios involving the purchase of NFTs, allowing users to make payments with any tokens they possess. To illustrate, let''s consider a situation where an NFT Marketplace has integrated ExactOut on its platform. You wish to buy your favorite NFT which is priced at 40 SOL, but most of your liquid assets are in BONK. Without ExactOut, you would need to estimate the amount of BONK required to obtain 40 SOL and manually swap on an external platform to convert BONK into SOL. 
 The good news is that since the NFT Marketplace has integrated ExactOut into its interface, you can simply purchase the 40 SOL NFT and Jupiter swap would automatically calculate the most optimal amount of BONK required to purchase the 40 SOL NFT. This is achieved in a single click, eliminating the need to leave the site or perform additional calculations, while ensuring that you receive the best possible price through Jupiter.
This is extremely important to Solana as payments are a crucial part of bridging crypto with real-life applications, ultimately contributing to the mainstream adoption of the Solana ecosystem. 
 Read more about ExactOut here: https://station.jup.ag/docs/old/apis/payments-api 
 ExactOut Showcase #1 - Sollinked 
 Sollinked is a social app designed for gated communities, offering a platform for newsletters or "paid" email inboxes that can be prioritized through incentives. Sollinked utilizes Jupiter to facilitate payments for emails and reservations using all SPL tokens. 
 See how Sollinked users make payments with various SPL tokens to bump up their newsletters and emails, even though payments are primarily denominated in USDC. This is possible through the integration with Jupiter ExactOut. 
 
 
 ExactOut Showcase #2 - CandyPay Coffee 
 Candy Pay has integrated Jupiter to power built-in swap transactions to facilitate payments in SPL tokens. Users can now make purchases with any token they have in their wallets. 
 Check out this demo of a user buying a cup of coffee priced in USD with their SAMO tokens. How cool is that! 
 https://twitter.com/JupiterExchange/status/1638799925348794369 
 ExactOut Showcase # 3 - Helio 
 Helio, the leading payments app for Solana, powers sales for +3,000 creators & merchants who sell NFTs, digital content, e-commerce and more with the power of blockchain payments. Helio partnered with Jupiter to power seamless token swaps inside the Helio checkout flow. Buyers can spend SOL or any token, while merchants always receive USDC or their asset of choice. 
 "The future of commerce is based on lightning fast blockchain payments and one of the key advantages is that buyers can spend any token while merchants instantly receive their own currency of choice. Jupiter has abstracted the complexity of a DEX and given us a few simple lines of code to help us deliver on this promise"   CTO - Jim Walker 
 
 ExactOut Showcase # 4 - Sphere Pay 
 Sphere is an end-to-end payments API for digital currencies, offering on-ramp, multi-chain and fiat payments, to off-ramp in a single integration. 
 Sphere uses Jupiter to enable “universal settlement”, where customers can pay in whichever currency they want, and merchants will receive any currency of their choice — with Jupiter handling the ExactOut swap behind the scenes at the best possible rates. 
 Here is an example of how Sphere users can select to pay in any currency of their choice, with merchants receiving any currency they wish. Thanks to v6, these swaps are blazing fast, and shared ATAs and versioned transactions/lookup tables allow all of this to be bundled into a single transaction. 
 
 Ending Words 
 With Jupiter providing the essential infrastructure support for payments, we see Jupiter playing an important role in helping support the payment and fees infrastructure of Solana. 
 If you have any feedback and product improvements, do feel free to swing by and share them on our  Discord ! 
 
 
 Day 3 - Jupiter Terminal v2 
 Today we will be unveiling the brand new Jupiter Terminal V2! It is the smallest, fastest and easiest way to add Jupiter to your dApp with just a few lines of code! 
 
 A big shout out to  Meteora ,  MarginFi ,  FamousFoxFederation  and  Bonk  for being one of the early adopters of Terminal V2, seamlessly implementing swap functionality for their users without the need to navigate away from their pages. 
 In this update, we will go through key upgrades made for Terminal v2 to make implementing swap functionality for your dApp better, easier and just more fun: 
 
 Terminal v2 is now equipped with the latest v6 API, featuring Metis 
 Cross app state sharing with Jupiter Terminal 
 Unified Wallet Kit integration 
 Fee support for partners and integrators 
 Improved UX enhancements 
 
 Let’s dive in! 
 
 What’s new in Terminal V2 
 Terminal is a very popular way to integrate Jupiter into various platforms and applications, enabling protocols to seamlessly implement swap functionality for their users. It is also super easy to customize, from configuring input/output mint states, exact output mode, displaying tokens from Jupiter’s strict token list, all these are toggled on and off with just a few clicks to generate the code snippet. 
 Here are the details of what’s new in v2: 
 
 
 Jupiter Terminal v2 is upgraded to v6 API that is running Metis, bringing to you the most powerful price quote engine for the best prices and best token selection, with the best user experience. 
 
 
 We introduce cross app state sharing with Jupiter Terminal through the new syncProps() API function: 
 
 Starting with wallet Passthrough, syncProps() API will make sure your wallet states are always in sync, and Terminal can also callback to your dApp to request for wallet connection. 
 We are actively working on implementing cross-app state syncing for slippage, verTx, priority fees, as well as input mint and amount. 
 
 
 
 import { useWallet } from ''@solana/wallet-adapter-react''; // Or @jup-ag/wallet-adapter;

const passthroughWalletContextState = useWallet();
useEffect(() => {
  if (!window.Jupiter.syncProps) return;
  window.Jupiter.syncProps({ passthroughWalletContextState });
}, [passthroughWalletContextState.connected, props]);
 
 
 
 Terminal v2 is using the  Unified Wallet Kit  - an open-sourced wallet adapter, that incorporates wallet standards and passthrough wallet capabilities. It seamlessly interfaces with many well used wallets out there, to give the best wallet experience for your users. 
 
 
 Jupiter Terminal now offers fee support for partners and integrators. Partners can choose to enable platform fees on top of the swaps. To facilitate this, partners need to create token fee accounts to begin collecting platform fees. The Jupiter Referral Dashboard allows partners and integrators to monitor and claim these fees conveniently. 
 
 
 We have also enhanced the user experience by implementing additional error and warning messages to guide users. There is now a built-in RPC monitor that notifies users of any RPC abnormalities or degradation in the Solana network. 
 
 
 
 Terminal Showcase 
 Check out this mini showcase of how our partners have integrated Terminal to provide swap functionality for their users: 
 Terminal Showcase #1 
 Meteora ''s mission is to grow liquidity on Solana by building dynamic liquidity protocols - including stablecoin liquidity, LST liquidity and multi-token pools. Idle capital is dynamically distributed to various lending protocols to earn additional yield on top of swap fees and rewards. Meteora’s keeper - Hermes will continuously watch lending pool utilization rates and reserve levels, ready to withdraw the funds for safety.
Terminal v2 has been integrated on Meteora via the widget approach to let their users easily swap on-site for the required tokens to participate in liquidity provisioning. 
 
 Terminal Showcase #2 
 FamousFoxFederation , an NFT and gaming project, offers raffles and sweepstakes to participate in their NFT events. Users are able to both auction and trade their NFTs through raffle events, as well as stand a chance to win NFTs through the sweepstakes.
FamousFoxes has seamlessly integrated Jupiter Terminal into their raffle platform via the Modal approach to let their users stay on the site and effortlessly swap for the tokens required to buy the raffle tickets. 
 
 Terminal Showcase #3 
 MarginFi  is one of the leading lending/borrowing protocols in Solana. It offers users a comprehensive platform where they can seamlessly borrow, lend, and even stake SOL for LSTs – all within a unified environment.
MarginFi integrated Jupiter Terminal via the Integrated mode, rendering the swap as part of its dapp, on a dedicated page. Their users can stay on the site to also swap their tokens on top of participating margin trading. 
 
 Ending Words 
 Terminal v2 is like the magic wand for adding swap superpowers to your Solana dApp in the most hassle-free and elegant way. If you haven''t given it a spin yet, now''s the perfect time to unlock its awesomeness and inject some fun and additional functionality into your project! 
 https://terminal.jup.ag/ 
 
 
 Day 4 - Unified Wallet Kit 
 Today, we will be introducing the  Unified Wallet Kit , which was born out of our desire to help developers build more easily on Solana, fast tracking through all the challenges we faced in trying to support the majority of the wallets out there and building a great wallet UI/UX. 
 
 Unified Wallet Kit is an open-sourced, Swiss Army Knife wallet adapter, striving for the best wallet integration experience for developers, and best wallet experience for your users. 
 
 Along with  Terminal , it''s the fastest way to get started on Solana. 
 Let’s learn how. 
 Unified Wallet Kit to make BUIDLing Easier 
 To bootstrap a dApp with a wallet, we often find ourselves repeating the same setup, such as getting the various wallet adapters (both Solana Wallet Standard and custom wallets) installed, building notifications for wallet state (selected, connected, disconnected etc.), auto-reconnecting to the last connected wallet, adapting to a mobile-first responsive design, theming etc., over and over again. 
 This is our biggest motivation in building the Unified Wallet Kit - to have all these essential yet repetitive basic building blocks provided in a simple package that anyone can just plug and play. 
 Being one of the most used dApps on Solana, where we facilitate the majority of liquidity exchange in the ecosystem, we built our own world-class wallet adapter to support the majority of wallets for access to this liquidity. This wallet adapter includes all the important blocks mentioned above and more, to provide users with the best wallet experience. 
 Now, we want to give back to the developer community. We hope that by bringing our world class wallet adapter open-source, we will allow any developers to fast track and bootstrap their projects in no time! 
 Features of Unified Wallet Kit 
 
 
 Main ESM bundle at a compact 94KB (~20KB gzipped) 
 
 
 Built-in Wallet Standard, Mobile Wallet Adapter support 
 
 
 Abstracted wallet adapter, with a Bring Your Own Wallet (BYOW) approach where you can select the wallets your dapp wishes to support. This allows you to add custom and legacy wallets. 
 
 
 Mobile responsive 
 
 
 Smart notification system where you can either plug in your own notification system or use it by itself. This notification system does not interfere with your dapp. 
 
 
 Internationalization with language support for English, Chinese, Vietnamese, French, Japanese, Bahasa Indonesia and Russian 
 
 
 Theming - select from light, dark and Jupiter modes. More customisation to come. 
 
 
 Pluralization for i18n 
 
 
 New user onboarding 
 
 
 The Unified Wallet Kit will allow integrators to very quickly enable these features and let wallets connect to their dApps with only a few lines of code. It can’t get any easier than this. 
 
 Similarly with Terminal, the live playground is available at https://unified.jup.ag. Come swing by and check it out. 
 Quick Notes on Unified Wallet Kit 
 
 
 Unified Wallet ships with WalletStandard and Mobile Wallet Adapter by default as we echo the push for the Wallet Standard specification. However any additional wallets or custom implementations can still be added easily with the Bring Your Own Wallet (approach) so that it does not bloat your dapp. 
 
 
 We understand that different dapps have their own notification implementation, therefore the notification system is optional and can be plugged in with your existing notification system. 
 
 
 The Unified Wallet Kit is currently used on  Meteora , do give it a spin. 
 
 
 
 Ending Words 
 Jupiter is dedicated to help make BUIDLing easier for everyone. Developers should have zero friction building on Solana, we believe that having this great developer experience is important to help attract even more brilliant people to come build together and drive innovation. This is just the beginning, and we are excited to introduce more open-source projects in time to come. 
 Let’s keep moving forward together! 
 
 
 Day 5 - Jupiter Gaming Unity SDK 
 
 Today, we are excited to delve into the world of Jupiter for gaming, where we will look at how Jupiter has been facilitating in-game swaps and enabling gaming use cases through the integration with the  Solana.Unity-SDK , developed by the talented team at MagicBlock. This post is brought to you in collaboration with  MagicBlock . 
 Live Demo: https://magicblock-labs.github.io/Solana.Unity-SDK/ 
 
 In this post, we will learn about: 
 
 Why Solana is the major blockchain for on-chain games 
 Solana.Unity-SDK and its main features 
 Jupiter’s role in supporting gaming, use cases that the Jupiter x Solana Unity SDK powers, and a partner showcase 
 
 Before anything else, a big shout out to  Star Atlas ,  Guac , Genopets ,  DefiLand  and  FamousFoxes  for integrating Jupiter and enriching the gaming experience of their users, by providing a seamless and immersive swap experience. 
 Without further ado, let’s dive in. 
 Solana, the major blockchain for on-chain gaming 
 On-chain games are introducing a paradigm shift in the way players interact, own and experience new forms of entertainment. It’s no surprise Solana stands out as a major blockchain for on-chain gaming, thanks to its high throughput, low transaction fees, and robust ecosystem. Its ability to process thousands of transactions per second ensures that gamers experience minimal latency, creating a seamless and enjoyable gaming experience. 
 Furthermore, Solana’s vibrant community and extensive developer tools make it an attractive platform for game developers of all sorts, from those looking to infuse their game with on-chain assets to the ones pushing the boundaries with fully-on-chain games. 
 Solana is also designed to be interoperable with other blockchain networks. This means game developers can easily add Solana-based games to other blockchain platforms, allowing for seamless user experience. 
 As the gaming sector grows, Solana is poised to take the lead in on-chain gaming over all the other chains. 
 Solana Unity SDK and its main features 
 MagicBlock , the team behind the Solana Unity SDK, is an end-to-end infrastructure provider for on-chain gaming on Solana, empowering developers to create a new category of composable and permissionless gaming experiences. 
 The Solana Unity SDK simplifies the integration of Solana-based NFTs, tokens, and on-chain programs into Unity games, making it easier for game developers to create web3 games and experiences. 
 Some features of Solana.Unity-SDK: 
 
 Full JSON RPC API coverage 
 Transaction and message decoding/encoding from base64 and wire formats 
 Non-custodial Solana wallet setup in Unity, supporting Solana Wallet Adapter (Phantom, Backpack, Solflare...) and Web3auth (Social login) 
 TokenWallet object for sending and receiving SPL tokens and JIT provisioning of Associated Token Accounts 
 Additional capabilities include NFT support, compiling games to xNFTs (Backpack), native DEX operations (Orca, Jupiter), and websockets for custom events, along with Solana Mobile Stack support 
 
 With the Unity-SDK game developers can easily create seamless onboarding flows with wallets, social authentication and gasless API. Now, they can also provide a seamless trading experience with Jupiter swap! 
 Give the SDK a spin here: https://github.com/magicblock-labs/Solana.Unity-SDK 
 Jupiter x Solana.Unity-SDK Native Integration to Power Gaming 
 As the liquidity infrastructure of Solana, Jupiter provides the best rates and deep liquidity from across the ecosystem. This is important in gaming contexts where gamers trade in-game assets frequently, especially rare assets that are very valuable. The best prices and higher liquidity makes it much easier for the gamers to stay within the game to trade these assets, improving the overall gaming experience. 
 Jupiter is natively supported in the Solana.Unity-SDK and runs the v6 Quote API and ExactOut v2 API for the best swap prices. 
 The integration features: 
 
 Utility methods to easily retrieve tokens information, get swap quotes and perform swaps. Game developers can easily integrate Jupiter swaps in their games and compile cross platforms without changing a single line of code. 
 A native integration that ensures a smooth and uninterrupted game experience for the players where users can exchange assets from the game UI, without annoying popups or embedded iframes. 
 Furthermore, you can effortlessly combine Jupiter with other instructions through the SDK, such as Session Keys, which eliminates the need for manual transaction approvals and ensures uninterrupted gameplay. 
 
 This integration caters to a wide range of use cases, which include but are not limited to: 
 
 Marketplace purchases 
 In-game payment with any coin 
 Asset swaps 
 Gamified trading experiences 
 
 Ready to include Jupiter into your game? Check out the docs here: https://docs.magicblock.gg/SolanaUnitySDK/guides/jupiter 
 Showcase - DeFi Land 
 DeFi Land  is a multi-chain agriculture-simulation game created to gamify Decentralized Finance. While there are games that make use of the blockchain, DeFi Land takes DeFi as a whole and aggregates the various actions that can be taken on each DeFi platform and turns them into an interactive game that can be played. 
 Check out how Defi Land has integrated Jupiter to power their in-game Market, taking the entire experience of DeFi swaps to the next level. 
 
 DeFi Land is built with the Unity Engine 2021.2.1 and uses the IDexAggregator interface in the SDK to create their Market. 
 The interface provides convenient methods for performing swaps and accepting payment - while working seamlessly on any platform. Most notably, DeFi Land is also available as xNFT where players directly leverage Backpack to perform in-game swaps, powered by Jupiter. 
 Ending Words 
 Jupiter is Solana''s liquidity hub, offering the best prices and deep liquidity, strongly supporting diverse use cases and enhancing the gaming experience. We believe that Solana is the best place for web3 gaming, with amazing infrastructure support from teams like MagicBlock with their Solana Unity SDK, the perfect foundation for game development. 
 We can’t wait to see the brilliant game creations of the builders of Solana! 
 
 This marks the end of our inaugural Jupiter Planetary Developer Week. It was an amazing week of developer focused updates where we unveiled the spanking new v6 API with Metis for routing, Referral Fees System for easy fee management, ExactOut v2 for Payments, Terminal v2 for the easiest way to integrate Jupiter, Unified Wallet Kit for the best wallet integration experience and showcasing Jupiter for games. We are committed to making things easy for you to create awesome liquidity use cases. 
 All these just in time for the Breakpoint Conference happening next week! Thanks for following through all days of our massive update, we hope you had supercharged your BUILDling journey with us. 
 Come talk to us and join our upcoming talks at Breakpoint', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2022-12-31-jupiter-community-call-27-12-summary.md', 'slug: jupiter-community-call-27-12-summary
title: "Jupiter Community Call 27/12 Summary" 
 Dear Jupiter community - Happy NY eve, and looking forward to a super fun 2023! Despite of the macro headwinds, we are making awesome progress towards being the swap layer of Solana and helping  move crypto users away from ever having to need to use centralized exchanges like FTX ever again . 
 
 We also had a really fun community call on  Tuesday 27/12/22 ,  and here''s a quick summary: 
 Solana and Multi-chain 
 
 A pretty big deal is being made out of the fact that deGods and other projects are expanding outside of Solana. The main thing is, this is not really a big deal since even on Ethereum, even the most loyal and OG projects are multi-chain in all but name 
 That said, the timing is rather unfortunate - since the current narrative about Solana is overwhelmingly negative and this adds to the flood of negativity 
 From our point of view, we are heavily invested in Solana, and our long term perspective is not affected. We are committed to building the best decentralized finance trading tools on Solana, and these movements does not change our position one iota 
 
 Possible Jupiter Launchpad 
 
 The second thing we discussed in detail was Jupiter starting a community driven launchpad to help surface great new projects, which is very much needed in the ecosystem 
 It would also be an interesting complement to the Jupiter community, since the alignment between our users and the new projects will be very strong and relevant 
 The most important thing of course, is that the community is the one who will be driving the discussions, picking the projects and promoting it, rather than centralized parties where the incentives are extremely skewed. 
 
 Community Ownership Discussion 
 
 We are extremely committed to growing and involving the community more actively in 2023 
 It is important to both recognise past usage and contributions, while also incentizing a new generation of users and community members to be part of the long term effort to build up world class system, community and economics 
 It is obviously not a great time to launch a token, so it will not be wise or feasible to do so now, regardless of the initial hype it might generate - so we have to think of more creative ways of doing so beyond the standard airdrop model! 
 
 Ending thoughts:  Jupiter’s long term goal is to help remove the need for users to use centralized exchanges like FTX. To reach this goal requires us to get to a world class system, community and token - which is anything but easy. But we inch closer, every single day!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/blog-v1/2023-11-16-grow-the-pie-update-1/index.md', 'slug: grow-the-pie-1
title: "Grow The Pie Update #1" 
 Grow The Pie Update #1: Community Airdrop 
 Here’s the breakdown for the first round of the community airdrop, along with a detailed rationale about how we arrived at it. 
 We want to be as open as possible about explaining our thought processes, unique circumstances and data points we have gathered, and make sure that the airdrop is as understandable as possible, even the nuances of the discussion. 
 We take every part of the airdrop discussion very seriously, and we are immensely grateful for all the time and effort that everyone put in. Even if we cannot give everyone what they deserve or think is correct, I would like everyone who ever interacted with Jupiter to know that their usage/contribution was seriously considered. 
 An official airdrop allocation site will be up for everyone to check their stats and allocations.
That will conclude the current phase, moving us to the next phase of the JUP token launch. 
 BASICS: 
 
 
 There will be 10B JUP Tokens. 
 
 
 As mentioned in our Breakpoint talk, this airdrop is to engage users who used us in the past, and invite them to be closely involved with the next phase of the Jupiter journey. Which means, the  955K wallets  who interacted with Jupiter directly before  Nov 2nd  are eligible for consideration. There will be future rounds of airdrops for new users, so stay tuned for that. 
 
 
 This is obviously a massive number of wallets, and with 35B of volume, how to slice it up to make it meaningful was always going to be a challenge, but we are gonna try our best. 
 
 
 All users who interacted with Jupiter via our many amazing integrations for example Solincinerator, Solendprotocol and all the wallets will be included in the airdrop if the transaction was signed directly by the user and we have that data. 
 
 
 Also as mentioned, 40% will be allocated to the community over 4 rounds of airdrops. 10% will be allocated in this round, which will be 1B tokens. We expect to start one more round of growth oriented airdrop before token launch. 
 
 
 We have never announced or even hinted at any form of airdrop or even token until a couple of days pre-breakpoint. All growth has been purely organic. There was no massive increase in wallets in those few days, so there’s no reason to think that we were massively spammed. Therefore, de-duplication is not a particular area of concern for us, but will definitely be for future rounds. 
 
 
 All previously published dashboards and criteria were from 3rd parties. While certainly a good proxy, we are taking into account a much wider set of data points and nuances into consideration. So do wait for the official site to check both the volume, score and allocation. 
 
 
 First round allocations will be up to check but tokens will not be live yet. There are several phases to the token launch, which we covered in the breakpoint talk and we will share more later on. 
 
 
 PERSPECTIVES 
 There were many extremely different perspectives and proposals being floated over the last week, with 2 major directions, the first being a completely even distribution, and the other being a completely volume based distribution. There were also many great proposals that aimed to strike a balance, and we took inspiration from many of those. 
 DATA 
 Based on these feedback and ideas, we looked into the data in a lot of  detail, which you can see in the attached image. 
 
 
 Massive Power Law At Play
The most important data point here is the massive power law in terms of trading volume. 0.1% of wallets account for 60% of volume, while 0.2% account for 80% of volume. Even within the 0.2 tier, there are non-bot users that account for 240M of volume, far more than the average user in this elite tier. Conversely, the lower 70% accounts for much less than 1% of volume. 
 
 A linear (or even quadratic) proportion based on volume will not work for a good distribution, even for relatively power users with >100k or >1M of volume. We did not want to overcomplicate it with fancy maths too much  (base x logs) , so we opted for a reasonable tier method instead that will ensure that no one will get way too much or too little. 
 
 
 Bigger wallets were more active before 2022, while smaller wallets were more active after 2023.
A larger number of the bigger wallets turned out to have used it mostly before 2023, while smaller wallets were more active in 2023. This suggests that a multiplier for 2023 volume will have the effect of bumping up small wallets into higher tiers. 
 
 
 Stable/xSOL-SOL/Bot volume were more significant at the highest levels
One interesting observation was that stable/xSOL-SOL/bot volume was far higher at the highest levels. For example, the 2 wallets that did >500M in volume were purely arb traffic. While our share of user volume has greatly increased over time, arb bots consisted of a fairly large volume, especially early on in the cycle. 
 
 
 To be clear, there are many kinds of bots, and many of them play an important part in the liquidity ecosystem, so this is an observation to open up the conversation about whether to differentiate between these volumes. 
 There are many other interesting observations not covered above, but feel free to join our discord and chat more! 
 AIRDROP BREAKDOWN 
 With these in mind, we would like to present the airdrop breakdown for the first 10%. 
 
 Even distribution for all wallets  (2%) 
 Tiered score based distribution, with score based on  adjusted volume  (7%) 
 Community members on discord, twitter, developers  (1%) 
 
 We believe this breakdown will reward power users and contributors significantly more, while likely giving everyone else a reason to come back and engage. 
 Let me dive into each of these categories: 
 
 Even distribution between all wallets  (2% / 200M tokens) 
While not using volume as the major criteria was always going to be a non-starter, we also greatly appreciated the point that we should aim to be as inclusive as possible to maximise the community building potential here, and bring as many people back as possible regardless of volume. 
 
 As such, we are allocating 200M tokens, which means about 200 tokens for each account, which would be a nice welcome present if Jupiter does well. For those who have not tried out Jupiter or Solana for a long time, do come back and try us out again - lots have changed! 
 We are not de-duplicating here for reasons mentioned above. We have never announced an airdrop before, and neither did we see a huge influx of wallets at any point in time, so we think it''s more important to have everyone included, vs performing opaque methods of deduplicating. 
 
 Tiers Based On Adjusted Volume Score  (7% / 700M Tokens) 
The vast majority of tokens in this drop will be allocated towards a tier based scoring system, with adjusted volume being the main point of reference. 
 
 Here’s where we leave the simplistic into the much more nuanced landscape of allocating based on how much they engaged with the network, how much they used Jupiter in during the bear market, and the nature of the volume. 
 Based on the  NON-ADJUSTED  volume, we will be looking at approximately: 
 
 Tier 1: Top 2K users, 100,000 tokens each (est >1M trading vol) 
 Tier 2: Next 10K users, 20,000 tokens each (est > 100K trading vol) 
 Tier 3: Next 50K users, 3000 tokens each (est > 10K trading vol) 
 Tier 4: Next 150K users, 1000 tokens each (est >1K trading vol) 
 
 It is important to remember that we are using these volume numbers as a proxy, since the final tiering will be based on the top X users in the given tiers based on adjusted volume. 
 The adjustments will likely be the following: 
 
 multipliers for 2023 volume (likely counted 2X or 3X) 
 zeroing of arb volume (defined as samemint - samemint txns) 
 removing of known accounts (for example wormhole exploiter) 
 
 So, someone who traded mainly in 2022 but disappeared in 2023 will likely be dropped in tier, while someone active throughout 2023 will likely gain in tier. 
 One question that we are going to leave open will be whether to discount stable, xsol-sol and bot traffic. 
 The obvious flaw with this approach is simple - the tiers are pretty broad, tiering is kinda sorta unfair to those who just missed out on the past tier. For example, even in tier 1, you have a user who traded 240M in volume vs the average of 1M traded in that tier. 
 We opted for this approach because as mentioned in the earlier section, there are massive power laws at work and we want to design a system where we get meaningful amounts of tokens into large numbers of active users of Jupiter, yet have it be meaningful for everyone if they do well. 
 This approach ensures that anyone who used Jupiter actively, particularly in 2023, will likely see their activity reflected in the various tiers. 
 And since this is a community building activity, not an academic exercise to have the mathematically perfect distribution, and I personally don’t like things that are not understandable by everyone this is what we opted for in the end. 
 
 Community Contributors  (1% / 100M Tokens) 
Given that community contribution cannot be placed side by side with users, we have created a completely different allocation for discord contributors, Twitter supporters and developers. 
 
 There will be multiple tiers here to reflect the level of contribution these amazing folks have in helping us become the platform we are today. We will have a preliminary list up next week, and allow people to submit additional requests as well. 
 
 Wrapping Up The Community Airdrop Consultation 
 Hey all, wanted to share the main changes that we are making to the community airdrop after the last few days of very intense debates. We will also share important clarifications and explain some of the hotly debated decisions. 
 With this update, we are formally wrapping up the community airdrop consultation and will be focusing on getting the allocation checker website up and running asap. 
 This has been a long process for everyone, but we are seriously grateful for those who took the time and effort to chim in, and that we managed to talk to so many of you representing all various segments of Jupiter users. 
 Sorry that this update was a couple of days late - I wanted to make sure that anyone who is interested can understand the decisions and thought processes as much as possible. 
 
 Changes made from first proposal
After talking to everyone, I agree that we missed out on certain important aspects around OGs n consistency. As such, there will be 3 main changes we are making from the initial proposal: 
 
 
 Acknowledge OGs who used the protocol in the first few months 
 Add a consistency modifier, with preference to those who have used Jupiter sufficiently over the last couple of years vs one off usages. 
 2023 volume multiplier only applies to older users who stayed on 
 
 The exact details of these changes, as well as the end decisions on stables and bots will be shared on the interns wrap up the analysis of numbers and get the checker up and running. 
 
 Important Clarifications 
 
 
 Tiers are based on adjusted scores, not volumes
The volume we indicated in my last post is to explain the guidelines as to how the tiers are derived. 
 
 Therefore, there will NOT be a sharp volume based cutoff, but rather based on top 2000/10000/50000/150000 users based on the volume adjusted score. 
 
 The 1% community allocation is for all contributors
The 1% community allocation is to allow us to have high levels of discretion for various types and levels of contribution that go far beyond volume. This includes developers, Twitter contributors, Discord, etc. We will have an initial list but also allow everyone to provide submissions on their contributions. This is similarly retroactive, so only contributions made before nov 2 will be considered. 
 
 Folks with Discord roles will be allocated something simple, but this allocation is mostly focused on contribution, which we will put in serious time and effort into reviewing to do justice to everyone who helped us above and beyond in debugging, promoting, moderating, etc. 
 
 The coming website is an allocation checker site
The coming website is an allocation checker site. The token will go live later. We have a very clear token launch plan made up of 3 meows that we want to work closely with the community to execute. 
 
 
 Explainers on hotly debated decisions
We have to stand by certain hotly debated decisions, including the tiering system based on adjusted score, having an allocation for universal distribution, and the 2023 multipliers. 
 
 
 Bonuses for 2023 volume
Probably the hottest point of contentment was the 2023 multiplier, since it appeared to prioritize newer users rather than older users. The 2023 multiplier might seem arbitrary, so let me explain. Even though the price of SOL started tanking in 2022, 2023  (after the ftx fallout)  was when we really saw on-chain activity drop dramatically, and belief in Solana has completely tanked. 
 
 It is likely not a false statement to say that those continued to be active in 2023 is a big reason why Solana survived, and we want to acknowledge that. We continue to believe that a multiplier for 2023 volume is appropriate, but we will add in additional conditions to ensure that it applies only to old users who stayed on. 
 
 
 No de-duplication for the even distribution
The lack of de-duplicating here for the even distribution is a concern for some, but the reason here is that it is extremely hard to de-dup without making use of tedious and opaque machine learning approaches, that is at the end of the day, not foolproof. We will avoid that to make this airdrop as understandable as possible. Having a min number of transactions is not ideal as well, since that rules out a lot of users who used us via integrations and we want to be as inclusive as possible for this part of the allocation. We will likely add more rules for this in future rounds of airdrops, but not in this one. 
 
 
 Disproportionate allocation for power users
Many people have critiqued that power users will get a disproportionately large amount of the airdrop. However, this difference is actually much smaller compared to the difference in volume, which is closer to 1000x or even as large as 240,000x. So the extremes have actually been very much nerfed, while still making it meaningful per tier. It also encourages usage instead of farming via multiple wallets. 
 
 
 Disparity in same tier
Conversely, some users within the same tier have also commented why given their volume, they might get the same as someone who traded less. The difference in volume within a tier might seem big until you comprehend the massive power law at work, where a non-bot single whale can trade 240M, and 0.2% accounts for 80% of the volume even with bots excluded. 
 
 
 Just missing out on tiers
We understand that like airline mileage tiers, it sucks to just miss out on a tier, and we sincerely apologise for that, but this is the best we can do at the moment to prevent an overly top heavy distribution, while making it meaningful for people in each tier, and keeping the overall system relatively simple. 
 
 
 
 Reflections on the community consultation
As mentioned, this post formally ends the consultation period for the airdrop. 
 
 Next steps: 
 
 A site will be up soon with official criteria, scores and allocations. 
 There will also be a place for users to submit their pre-breakpoint community contributions 
 We will share some thoughts on this process of community consultation for airdrops, and how the process will be updated for the next few rounds. 
 
 Thanks again to everyone for being part of this process. We know it has been extremely tiring for everyone. For us, this retroactive airdrop is a once in a lifetime chance to work with all the amazing users who have been part of our journey, so we are deeply appreciate the change to engage with everyone.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-how-to-use-apepro.md', 'sidebar_label: How to Use ApePro
title: How to Use Ape Pro
description: Learn the basics of how to use Ape Pro. 

      How to Use Ape Pro: A Guide 
     

 Account Creation 
 
 Visit : Go to  ape.pro . 
 Sign Up : Choose a login method (social login or Web3). 
 No Seed Phrase : Accounts are secured without the need for a seed phrase. 
 
 Deposit Funds & Activate Your Account 
 
 Activate Your Account : Deposit at least 0.1 SOL to activate your account. 
 
 Trading 
 
 Quick Trades : Use quick buy and sell features to trade without signing wallet transactions. 
 MEV Protection : Enjoy MEV-protected swaps with intelligent fee optimisations 
 
 Managing Positions and PnL 
 
 Positions : Monitor open token positions and your profit and loss (PnL) in real time. 
 Transaction History : Access your trading history in your profile drawer. 
 
 Exploring New Tokens 
 
 New Tokens Page : Discover new tokens launched in the past 24 hours. 
 Hunt Gems Page : Use the Hunt Gems feature to find new and graduating tokens. 
 
 Token Checklist 
 
 Before trading, use the token checklist to assess tokens for potential risks', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-how-swap-works/1-metropolis-features.md', 'sidebar_label: Metropolis Features
description: "Explore Jupiter V3 Metropolis: better token discovery, improved slippage, and seamless trading. Enhance safety and efficiency."
title: Metropolis Features
slug: /jupiter-swap/how-swap-works/metropolis-features 

     Jupiter Metropolis Explained: Enhanced Swapping Guide | Jupiter Station 
     

 The Jupiter swap backend systems have been completely re-engineered for the Metropolis update. This upgrade has significantly improved token discovery, slippage management, token search functionality, and safety measures. 
 
 Instant Routing for New Tokens 
 New tokens from Raydium, Meteora, and Orca are immediately added to Jupiter Routing. This means that newly launched tokens can be utilized across the entire Jupiter suite instantly! This includes features like DCA, Limit Orders, and Value Averaging, or simply swapping at the best prices available. 
 <video controls style={{ maxWidth: ''65%'', height: ''auto'' }}>
<source src={require(''../../../static/media/instant-routing-video.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Dynamic Slippage 
 Dynamic Slippage offers a seamless swapping experience. You can set a maximum slippage cap and never worry about slippage issues again. By leveraging a combination of backend liquidity computation and frontend inference, the best possible slippage rate is calculated, which is likely to pass while minimizing MEV. 
 <video controls style={{ maxWidth: ''65%'', height: ''auto'' }}>
<source src={require(''../../../static/media/dynamic-slippage-video.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Intelligent Token Search 
 With the rapid growth of tokens on Solana, finding the correct token can be challenging. The token list search feature has been vastly improved, taking into account near real-time information such as liquidity, volume, community verification, and potential dubious tokens. Imposter tokens and duplicates are automatically filtered out, making the search much faster and more accurate. 
 <video controls style={{ maxWidth: ''65%'', height: ''auto'' }}>
<source src={require(''../../../static/media/token-search-video.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Master Token List Standard 
 This upgrade enhances the token verification process. Instead of relying on a single strict list as in V2, Metropolis incorporates a range of lists across the entire ecosystem. Currently, different token lists are aggregated into an Ecosystem Master List, with new labels such as "LST," "Pump," "Clone," and a unified standard for partners to contribute. 
 <video controls style={{ maxWidth: ''65%'', height: ''auto'' }}>
<source src={require(''../../../static/media/master-token-list-video.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Streamlined Warnings UX 
 Non-blocking labels are now more relevant and provide warnings about issues like freeze authority and strict list verification in an easily digestible format directly on the swap interface. 
 <video controls style={{ maxWidth: ''65%'', height: ''auto'' }}>
<source src={require(''../../../static/media/safety-warnings-video.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Jupiter Swap V3 brings us much closer to fulfilling the Jup Promise: Best Price, Best Token Selection, Best UX! 
 See original tweet announcing Metropolis here ->', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-how-swap-works/2-how-swap-works.md', 'sidebar_label: How Swap Works
description: Learn how Jupiter Swap uses smart routing and safety features to innovate token trading on Solana. Discover its mechanisms in this beginners guide.
title: How the Jupiter Swap Works
slug: /jupiter-swap/how-swap-works/how-swap-works 

     Understanding Jupiter Swap: Smart Routing & Features 
     

 The Jupiter Swap is a decentralized exchange aggregator designed to provide the best rates for swapping SPL tokens on the Solana blockchain. It routes trades through multiple liquidity sources to ensure optimal prices, low slippage, and efficient transaction execution. Users benefit from its seamless interface, deep liquidity, and the ability to perform complex token swaps in a single transaction. 
 Jupiter V3 Upgrades 
 Jupiter V3 introduced multiple improvements to the swap experience! 
 The Metropolis upgrade introduced Instant Routing, Dynamic Slippage, Smart Token Filtering, Ecosystem Token List and new Safety features.
 Dive into these new features in detail here! -> 
 Metis, a routing protocol, was also introduced to improve route discovery, reducing slippage and scalability in V3.
 Dive into key features of the Metis routing protocol here! -> 
 Token Ledger For Increased Swap Success Rates 
 The Token Ledger is a collection of three instructions  (Set Token Ledger, Send Instruction, Swap Instruction)  that consolidate withdrawal and swap instructions into a single transaction. Integrators/partners can now effortlessly instruct a swap to be executed based on the actual sent amount, after taking into account fees and slippages. 
 Before the introduction of the Token Ledger, swap instructions relied on a simulation-driven approach to approximate the amount deducted from a user''s wallet to facilitate the swap. This estimation approach often ended up with discrepancies between the estimated and actual amounts, especially during periods of market volatility with high slippages, leading to swap failures. 
 Consider this scenario where a user intends to withdraw 1,000 USDC from Meteora’s USDC vault into wBTC. Note that users hold vUSDC LP tokens in Meteora vaults. 
 
 In the first instruction, the Token Ledger will verify and record the user’s initial USDC balance within their wallet. For the purpose of this example, let’s assume the initial balance is 100 USDC. 
 In the second instruction, an amount equivalent to 1,000 USDC in vUSDC is withdrawn from Meteora vaults into USDC, and we examine the user’s balance. Due to factors like slippage, the USDC balance is found to be 1090 USDC. 
 For the third instruction, subtracting the initial 100 USDC from the current 1090 USDC balance, it’s evident that the user has effectively withdrawn 990 USDC, which will then be utilized to swap for wBTC as the final output token. 
 
 Without the Token Ledger, the previous swap method relied on estimated amounts, which could fluctuate due to market volatility and performance variations, frequently resulting in suboptimal user experiences. 
 With the Token Ledger, integrators can issue swap instructions based on actual amounts that have taken into account slippage and related fees. This eliminates the need for simulation and significantly increases the success rate of swaps, all within a single transaction. 
 The Token Ledger caters to a wide range of use cases, which include but are not limited to: 
 
 Withdrawing assets from a protocol to any desired token, such as converting to USDC from a wBTC vault. 
 Supporting protocols that transition positions to a different token from their original position, as seen in Perpetuals. 
 Facilitating the exchange of NFTs for tokens other than SOL. 
 
 Read more about the Token Ledger:
https://station.jup.ag/docs/old/apis/swap-api#using-token-ledger-instruction 
 Safety Notifications 
 :::info UI Notifications
Jupiter offers several information signals to help users make informed trading decisions and protect themselves from potential losses. We will explain the difference between price impact, slippage, and price warnings below.
::: 
 Price Impact 
 Price impact refers to the change in an asset''s price due to the execution of a trade. This is especially relevant in decentralized exchanges (DEXs) or automated market makers (AMMs) due to their liquidity model. 
 Price Impact is influenced by the available liquidity to settle the trade and the size of the trade. For example, if you want to swap a large amount of one token for another in a liquidity pool, the larger your trade compared to the pool''s size, the more significant the price impact will be. This is because the execution of your trade will shift the balance between the tokens in the pool which will directly affect the price according to the AMM''s formula. 
 Price impact numbers vary across AMMs and the figure shown on Jupiter is an aggregate based on your particular route. 
 To reduce price impact, users can split trades into several smaller trades over time. Jupiter''s smart routing system checks all available liquidity pools to find the optimal route that maximizes output tokens. 
 Be sure to check the minimum amount of destination tokens quoted on the Jupiter interface, and set a Slippage amount to protect yourself. 
 
 Slippage 
 Slippage occurs when market conditions change between transaction submission and verification. The slippage rate is an important setting to prevent users from receiving fewer tokens than expected. If the price falls below the slippage rate, the transaction fails. 
 
 MEV Protection 
 Jupiter makes it easier for you to protect and hide your swap transactions against MEV and sandwich attacks also known as transaction front-running, by sending your transaction directly to a Jito validator. Note that MEV Protect minimizes loss of funds due to front-running but  slippage  still may occur when market conditions change during swap execution. 
 
 Price Warning 
 Price Warning is an additional layer of protection implemented by Jupiter to alert users when the quoted price deviates from the reference price (in this case, CoinGecko''s pricing). Price warnings can be caused by various external factors, and Jupiter adds an extra confirmation layer to prevent misclicks or human errors. 
 
 Verification Warning 
 Verification Warnings are shown for tokens that haven’t been approved by the community and added to the Jupiter Strict List. Scammers often create fake tokens with names identical to legitimate ones, attempting to deceive users into purchasing these fraudulent tokens. 
 <img src={require(''../../../img/jup-swap/authority-warning.png'').default} alt="Authority Warning" style={{ width: ''60%'', height: ''auto'' }} /> 
 Permanent Delegate Extension 
 Token-2022 tokens can be created with a  PermanentDelegate  extension, which allows for another wallet address to be the designated Permanent Delegate for that token. 
 
 It is very important for users to be aware if this extension is enabled, as this means the user does not actually have full ownership of the token, and the delegate address can burn or transfer these tokens without any limitation. 
 Valid use of  PermanentDelegate :  Developers have the ability to retrieve tokens that have been mistakenly transferred or drained out of a user’s wallet. 
 Misuse of  PermanentDelegate :  Bad actors can create a new token, get users to buy the token, then proceed to burn the tokens bought by the user. Many bad actors do this to prevent users from selling these tokens, thus allowing only the delegate wallet to sell these tokens. 
 Freeze Authority 
 Freeze Authority (FA) is a control mechanism that allows token issuers to temporarily or permanently halt the transfer or trading of a token. This can be used for both legitimate and harmful purposes. 
 
 Valid Uses of FA:  It is common for regulated tokens, such as stablecoins or RWAs, to have FA to comply with legal requirements. It allows stablecoin and RWA issuers to freeze tokens in cases of fraud, money laundering, terrorism financing, or to comply with law enforcement requests. 
 Misuse of FA:  However, FA is most commonly used by scam projects. FA is often abused to lock users out of trading or transferring the scam token, leading to significant losses. It’s a red flag for users, as it indicates a potential for market manipulation or outright fraud. 
 Freeze Authority Notifications for Unverified vs. Verified Tokens 
 Tokens not on the Jupiter Strict List will display a full FA warning. Tokens verified by the community and approved for the Jupiter Strict List will display a less ominous FA notification. 
 Users should always assess the presence of FA in a project regardless of verification status and understand the intent behind it. While it can be necessary for stablecoin and RWA projects, more often than not it is used to exploit users. 
 Additional Safety Confirmation 
 When price impact or price deviation is too high, we have an additional modal asking you to confirm the trade. 
 
 Swap Tips 
 
 Always double check the token mint address:  Token metadata such as name, symbol, and icon can be faked. The true identity of a token is its mint address.
 
 Tweet: A gentle reminder to check the mint address of the token you''re trading 
 
 
 The quote given is not the final price:  The quote given on a route is based on the current liquidity in the pools. Pool liquidity can go up or down at any time and in some cases, pools may close. An example would be oracle-based Lifinity which may stop accepting swaps after a price movement. 
 Set a slippage amount to protect yourself:  Slippage is your swap protection if the price diverges too much from the quoted price. 
 Jupiter cannot guess the final spot price or know what is a reasonable price impact for you . We encourage checking these before the swap:
 
 Check the Price Impact.  Price impact varies across the AMM and DEXes that Jupiter uses in each route. 
 Check against a price feed like  Coingecko ,  Birdeye , or CEX pricing.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-how-swap-works/3-metis-routing.md', 'sidebar_label: Metis Routing
description: Learn how Jupiter Metis Routing boosts Solana swaps using a unique algorithm for quicker trades, lower slippage, and scalable upgrades.
title: Metis Routing
slug: /jupiter-swap/how-swap-works/metis-routing 

     Jupiter Metis Routing: Optimize Swaps on Solana 
     

 Metis is a heavily modified variant of the  Bellman-Ford algorithm  catered for the key requirements of offering best price routing at scale in a very dynamic operational space. 
 Metis is designed to operate seamlessly on Solana’s hyper-fast blocktimes, supported by major improvements to our backend infrastructure. This ensures that trades are executed quickly and efficiently, even under high demand. 
 Metis enhances our industry-leading aggregator by improving route discovery for all trading pairs, reducing slippage for large trades, and offering scalable solutions in preparation for upcoming Solana upgrades and new DEXs. 
 Incremental Route Building 
 To find the best price, Metis streams the input tokens to incrementally build a route to split and merge at any stage. By generating the routes for each split iteratively one after another, we can also use the same DEX in different splits - allowing us to find routes with better prices with more complex trades. 
 
 Combine Route Generation and Quoting 
 To improve the efficiency of the algo, we combine route generation and quoting into a single step, allowing us to avoid generating and using bad routes, which besides improving the efficiency, also allows us to use a larger set of tokens as intermediaries. 
 Future Proofing 
 v2 runs fast when the total number of DEXs used is small since Solana limits us to use at most 4 DEXs in a swap  (due to the account lock limit of 64) . Future Solana upgrades will relax this limit and allow more DEXs to be used in a single transaction. In addition, we foresee the continued growth of the Solana DeFi ecosystem, which means there will be many more DEXs emerging. 
 Metis(v3) is equipped to handle both of these trends, since the algorithm is able to scale to include more DEXs in a route when account lock limits are increased, and can support more DEXs with only a modest increase in running time. 
 
 Performance Improvements 
 Metis is able to refresh quotes in parallel and in real time. Compared to v2, metis on average quotes prices that are 5.22% better. These improvements increase sharply based on the trade size. 
 
 Read about more awesome features of Jupiter Swap! ->', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/3-referral-fee.md', 'sidebar_label: "Referral Fee"
description: Join the Jupiter API Referral Program to boost your earnings with each transaction. Claim your fees now!
title: Referral Fees 

     Jupiter API Referral Fees Explained 
     

 Referrers are entitled to a share of referral fees, while the platform collects the remaining. The fees are collected and withheld by the program and are claimable anytime. 
 We are using the  Referral Program  to power our platform fee. You can check out how the  Referral Program  works. 
 Referral Program 
 For more information on how the Referral Program works, check it out  here . 
 :::info
The Jupiter Limit Order''s project account for the Referral Program is  45ruCyfdRkWpRNGEqWzjCiXRHkZs8WXCLQ67Pnpye7Hp .
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-jup-tokenomics/jup-tokenomics.md', 'sidebar_label: "$JUP Tokenomics"
description: Understand the $JUP tokenomics and the role the $JUP token plays in DAO processes.
title: $JUP Tokenomics 

     $JUP Tokenomics 
     

 Overview 
 $JUP is the governance token of the Jupiter DAO. It represents the interests of the Jupiter DAO. LFG and Governance Votes both utilize the $JUP Token in the ASR voting process. 
 1 $JUP = 1 vote 
 
 Total Supply:  10 Billion 
 
 $Jupuary Airdrops:  40% - 4 Billion 
 Jupiter Team:  20% - 2 Billion 
 Strategic Reserve:  20% - 2 Billion 
 Contributors and Grants:  10% - 1 Billion 
 Liquidity Provision:  10% - 1 Billion 
 
 
 Token Circulation 
 
 Team-Managed Allocation (50% of Total Supply) 
 Current Team Members (20%) 
 
 Vesting: One year cliff, two years vesting. 
 
 Strategic Reserve (20%) 
 
 Purpose: strategic reserve, used for future team members, future strategic investors, and for past Mercurial stakeholders (now Meteora). 
 Conditions for usage. 
 
 Liquidity Provision (10%) 
 
 Explanation of liquidity provision strategy. 
 Details of implementation. 
 Used in the first year. 
 
 Community Distribution (50% of Total Supply) 
 Airdrops (40%) 
 
 4 Rounds of Airdrops. First dropped 1 billion tokens on January 31st of 2024, due for 3 more each January until 2027 (if my math is right lol). 
 Criteria for eligibility and distribution process - always uncertain to prevent farming but using the Jupiter swap in an organic manner is a very good bet. 
 
 Contributors and Grants (10%) 
 
 Purpose: supporting community members contributing to Jupiter’s ecosystem. 
 Administration via JUP DAO. 
 
 
 Governance and Community Engagement 
 
 Governance in regards to DAO actions takes place utilizing the $JUP token as the vote count mechanism. 1 $JUP = 1 Vote 
 The LFG Launchpads'' voting process also hinges on $JUP holder votes to select projects to launch. 75% of the fees generated from the launchpad are returned to the users who vote, in the form of ASR or Active Staking Rewards. 100mm $JUP has been injected into the ASR pool as an additional reward for Voters in the first two quarters of voting. 
 ASR, or Active Staking Rewards takes into account the activity of $JUP holders as they participate in the governance and launchpad processes to allocate rewards to active community members that have staked and vote on DAO actions.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-perpetual-exchange/3-jlp-pool.md', 'sidebar_label: "JLP Pool"
title: "JLP Pool"
description: How to Become Liquidity Provider 
 Users can become Liquidity Providers (LPs) by allocating their assets or tokens into the Jupiter Liquidity Provider Pool (JLP Pool) and in return, you will get the JLP token. The JLP pool receives 70% of the fees, and forms an APR for all JLP holders. This APR is collected within each JLP token, whenever someone makes a trade. There is no need to "stake" or "harvest" your yield. 
 JLP token is also a SPL token. So, it can be transferred like any SPL tokens. AMM pools can also be set up for trading JLP token as well. 
 Note : JLP is a liquidity token for the Jupiter Perpetuals platform, and JUP is the governance token of the entire Jupiter platform. 
 The best way to purchase or exit JLP is always via  Jupiter Swap . 
 JLP, Liquidity Provider Token 
 JLP, or the Liquidity Provider token, represents a meticulously constructed index of assets designed for swaps and leverage trading. 
 Liquidity providers serve a crucial role as they act as counterparty to traders. When traders seek to open leverage positions, they borrow tokens from the pool. Liquidity providers, in return, earn fees from these leverage trading activities, along with borrowing fees and earnings from swaps. As a JLP holder, you receive 70% of the fees generated by the trading exchange. This amount is directly reinvested into the JLP, increasing the price of JLP, facilitating continuous compounding of yield and earnings. 
 The exchange generates fees and yield in three ways: 
 
 Opening and Closing Fees of Positions 
 Borrowing Fees of Positions 
 Trading Fees of the Pool 
 
 The fees are being compounded into the pool hourly. 
 :::info Overall Yield Calculation
It is essential to note that pool earnings and losses (index token appreciation/depreciation) are not factored in the overall yield calculation.
::: 
 Risks Associated with Holding JLP 
 JLP is denominated in USD. During a bull market, JLP may not outperform SOL, ETH, or BTC. It is suggested to consider swapping stable tokens (USDC/USDT) into JLP to potentially benefit from yield generated by perpetual trading activities. Please note that this is not financial advice. 
 Now, let''s explore some of the risks associated with holding JLP: 
 Profit and Loss (P&L) Dynamics:  Traders'' P&L from perpetual trading impacts the JLP pool. If a trader incurs a net positive P&L, the losses are sourced from the JLP pool to compensate the trader. Conversely, if a trader''s P&L is net negative, the gains are deposited into the JLP pool for LP holders. 
 JLP pool will lose in token value but not in USD value because the underlying token value in the pool appreciate in value as well.
 
Read more about a research from community member on how this work. https://skribr.io/app/article/exploring-jupiters-perpetual-futures-a-comprehensive-research-analysis/ 
 Impermanent Loss:  The JLP pool consists of both stable and non-stable tokens. Fluctuations in token prices can affect the value of JLP. As a result, users may find that their withdrawn tokens are worth less compared to their initial deposit. Additionally, deposit and withdrawal fees for the JLP Pool may further reduce the number of tokens withdrawn, particularly for shorter holding periods. 
 Can JLP go down?  Yes, JLP in USD value will go down when the fees generated are lower than assets depreciation and payout from traders'' profit. 
 Adding/Removing Liquidity 
 When an LP adds liquidity to the JLP pool, they increase the amount of liquidity in the total TVL (Total Value Locked) which increases the liquidity available on the trading side. 
 Any Liquidity providers (LPs) can acquire JLP by swapping for it on Jupiter Swap. Jupiter Swap will find the best price to acquire JLP for you, automatically. This can either be purchasing it off the open market, or swapping into a desired asset and depositing that into JLP directly. Use Jupiter Swap for a frictionless experience of getting JLP. 
 This would also apply to withdrawing, simply swap out of JLP into your desired asset. 
 And at the point of depositing assets into JLP pool, the protocol will price in the USD value. 
 Note:  JLP usually trades at a slight premium over the Virtual Price rate. This is due to the demand for JLP outweighing the TVL caps set for JLP. When TVL caps are raised, this premium closes. The team regularly increases the TVL caps to keep the premium in check. Swap for JLP when the caps are raised to minimize the premium paid. 
 Virtual Price, Market Price and AUM Limit 
 
 Virtual Price = Sum of all JLP Assets (in USD) / No. of JLP in circulation 
 Market Price = Virtual Price + Market-assigned Premium (when AUM Limit is hit) 
 
 Usually, users can mint new JLP or redeem (burn) them at the Virtual Price. However, when AUM Limits are hit, new minting of JLP is disabled to cap the amount of TVL in the pool. 
 When this happens, the demand for JLP on the market usually leads to a premium for JLP compared to the virtual price. 
 You may sell your JLP for the Market Price at any-time. If the Market Price is below the Virtual Price, your JLP tokens are redeemed (burned) at the virtual price instead of sold at the market price. 
 
 You can view the current TVL and AUM Limit on the main UI. 
 Target Ratio and Fees 
 In the JLP pool, every token has a specific target ratio or weightage. 
 The transactions involving the addition or removal of liquidity have the primary purpose of adjusting a token''s ratio in the pool to align it more closely with the predefined target, these transactions can be JLP deposit, JLP withdrawal, and token swap from the JLP pool. 
 Transactions that move the token''s ratio away from the target incurs additional fees while instructions that move it closer to the target get a fee discount. The fee is based on the swap fee. 
 Fee Calculations 
 Action Fee 
 Opening a Position 10 BPS 
 Closing a Position 10 BPS 
 Swap Fee Between 0 BPS to 200 BPS depending on pool weightage 
 Borrow Rate 1 BPS/hour x token utilization percentage 
 
 Fee calculation for opening and closing positions involves the volume of these transactions, multiplied by the fee percentage of 0.1%. 
 The borrow fee, often termed as the hourly borrow fee, is computed as follows: 
 hourly borrow fee = (tokens borrowed / tokens in the pool) x 0.01% x position size
 
 Swap fee for the pool typically ranges between 0% and 2%. 
 Example Yield 
 To provide an estimated perspective, you can calculate potential revenue by taking Jupiter perpetual exchange''s daily or weekly total volume and multiplying it by a fee percentage. For instance: 
 
 Total Daily Volume: 50 million 
 Fee Percentage: 0.1% 
 Revenue Share Percentage: 70% 
 
 Using these values, the calculation would be as follows: 
 Total revenue to be shared between JLP pool holders: 
 $50M x 0.1% x 70% = $35,000
 
 To determine your specific share or weight in the total JLP pool, use the following formula: 
 your_pool_contributed_amount / total_pool_amount x 100 = your_pool_percentage
 
 For example: 
 
 Your contribution: $1,000 
 Total pool amount: $4,000,000 
 Your share percentage: 1,000 / 4,000,000 x 100 = 0.025% 
 
 Finally, you can calculate your generated revenue share by multiplying the results of the first and second calculations: 
 revenue share you generate = $35,000 x 0.025% = $8.75
 
 Every 7 days, at ~ UTC 18:00, the Estimated APY figure is updated with the above calculation, by using the previous week''s fees and estimating an APR and APY for users.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-perpetual-exchange/1-overview.md', 'sidebar_label: "Overview"
description: Perpetual Exchange Overview 
 Summary 
 Our perpetual exchange is a novel LP-to-trader perpetual exchange on Solana, offering up to 100x leverage. Utilizing LP pool liquidity and oracles, it ensures zero price impact, zero slippage, and deep liquidity. Oracles enable stable market operations during liquidations and stop-loss events, removing risks of position bankruptcy and LP pool fund loss. Users can open and close positions in one simple step, eliminating the need for additional accounts or deposits. With the Jupiter Swap integration, any Solana token can be used to open positions. 
 The LP pool is also integrated into Jupiter to provide liquidity to the overall Solana ecosystem. Jupiter users can swap using the liquidity from the LP pool. 
 
 Overview 
 
 
 
 Trade Tab -  This is where all the trading action happens. You can trade long or short on the three main blue-chip markets we offer: SOL, ETH, and WBTC, with leverage of up to 100x. 
 
 
 Earn Tab -  This is where passive users can participate. Users can join the liquidity pool and earn passive fees generated from trading activities. 
 
 
 Different Perp Markets -  Currently, we only support the three main blue-chip markets: SOL, ETH, and BTC. 
 
 
 Price Stats -  Here, you can find a quick overview of the current real-time stats, including the current index price, 24-hour price movement, 24-hour highs, and 24-hour lows. 
 
 
 Long/Short -  Choose whether you want to go ''Long'' or ''Short'' on the respective market. 
 
 
 Token Selector (Input) -  This is the input section where you can select any SPL tokens to use as collateral to enter a position. 
 
 
 Price Chart -  This real-time price chart is generated using Pyth Oracle price data and displayed with the TradingView charting tool. 
 
 
 Leverage (1.1x - 100x) -  Here, users can increase their trading size with leverage ranging from 1.1x to a maximum of 100x. 
 
 
 Order Summary -  This section provides an order summary with all the information and stats calculated. (Please review and confirm your order before submitting the transaction). 
 
 
 
 Earn Tab 
 
 
 
 Earn Tab -  The Earn tab is where users can participate by depositing into the JLP Pool to earn passive fees generated from all trading activities. 
 
 
 JLP Pool -  The JLP Pool consists of a collection of tokens, including SOL, ETH, WBTC, USDC, and USDT. Each asset has its respective pool size, current and target weightage, and utilization. 
 
 Pool Size:  The current size of the pool. 
 Current / Target Weightage:  A comparison of the current weightage to the target weightage. 
 Utilization:  A measure of how the pool''s assets are currently being used. 
 
 
 
 Total Value Locked (TVL)  - TVL represents the total value of pool assets at their current token prices. 
 
 
 JLP Price & Total Supply -  Here, you can find the current  JLP Price  and  Total Supply  displayed. 
 
 
 Deposit & Withdraw -  This is where users can deposit SPL tokens into the JLP token and withdraw from the JLP token into SPL tokens. 
 
 
 
 Positions Tab 
 
 
 Positions Tab -  The Positions tab is where you can view and manage all your current open positions. 
 
 Item Description 
 Position Displays your current open position, including the market ticker, leverage level, and whether it''s a long or short position. 
 Net Value Net value represents the current value of your position, accounting for fees. For example, it includes the initial collateral, PnL (Profit and Loss), borrow fees, and close fees. 
 Size Size indicates the current size of your order, factoring in the leverage level. For example, it''s calculated as the initial collateral multiplied by the leverage level. 
 Collateral Collateral is the initial amount you provided when opening your long or short position. 
 Entry Price The entry price is the price at which you entered a new position. 
 Mark Price The mark price is the current market price. 
 Liq. Price The liquidation price is the threshold at which the mark price reaching this level triggers liquidation. This process is to repay any loan associated with opening the position. 
 Take Profit Take profit is the price set by the user. When the mark price hits this level, it will automatically close the position to lock in and realize gains. 
 Stop Loss Stop loss is the price set by the user. When the mark price reaches this level, it will automatically close the position to limit losses. 
 
 
 Close Order / Share -  This button allows you to immediately close the current position, securing gains or losses at the current market price. 
 
 
 Trade History Tab 
 
 Trade History Tab -  The Trade History tab is where you can review all your past actions and activities that have occurred with your open positions and orders. 
 Item Description 
 Position This column represents your position where the action or event was triggered, along with the current market ticker and the timestamp of when it occurred. 
 Action In the Action column, you can see the specific action or event that occurred for the respective position. 
 Order Type This column indicates the type of order that occurred for the position. For example, it could be Market, Trigger, or Liquidation. 
 Deposit/Withdraw Here, you can find the amount that was either deposited into or withdrawn from the position. 
 Price The Price column displays the mark price at which the action or event occurred, triggering the action order. 
 Size This column reveals the size of the position that triggered the action or event. 
 PnL The PnL column shows the Profit and Loss associated with the position. 
 Txn In this column, you can find a transaction link to the action or event that took place on-chain.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-perpetual-exchange/4-how-it-works.md', 'sidebar_label: "How It Works"
description: Key Concepts of Perpetual Exchange 
 How It Works 
 Overview 
 Jupiter Perps is a LP-based perpetual exchange based on oracle prices. 
 Our pool consists of 5 tokens, SOL, ETH, WBTC, USDC, and USDT. Users acquire JLP by swapping on  Jupiter Swap . Jupiter Swap automatically finds the cheapest way of acquiring JLP, by swapping to the desired asset and depositing that, or purchasing off the market. 
 Traders open leveraged positions by putting up collateral and borrowing
the rest of the position from the pool. 
 For Traders 
 Example Trade 
 For example, a trader opens a 2x long SOL position at a position size of $100
USD by depositing $50 USD worth of SOL as collateral and borrowing $50 USD
worth of SOL from the pool. 
 Suppose the SOL price is up 20% when the position is closed. Assuming 0 fees,
the position will have gained $20 USD. The trader will receive $70 USD (50 + 20)
worth of SOL tokens and the rest of the tokens are returned to the pool. 
 Suppose instead that the SOL price is down 20% when the position is closed.
Assuming 0 fees, the position will have lost $20 USD. The trader will receive
$30 USD (50 - 20) worth of SOL tokens and the pool will get the remaining
tokens. 
 To open a long position, a trader deposits collateral matching the underlying
asset. For example, to open long SOL-USD position, the trader deposits SOL. 
 Conversely, to open a short position, a trader deposits collateral matching one
of the stablecoins in the pool. 
 Leverage 
 To allow for leverage, traders borrow assets from the pool to create a
larger position. To create a 2x long position SOL-USD, the other 1x SOL will be
borrowed from the pool. 
 This borrow leads to a hourly borrow rate to be paid to the pool. Positions always pay borrow fees and are never paid funding. 
 Hourly Borrow Rate 
 Traders pay an hourly borrow fee to the pool based on the hourly borrow rate, position size, and
token utilization percentage. This is computed for each token that a trader borrows. 
 hourly borrow fee = tokens borrowed/tokens in the pool * hourly borrow rate * position size 
 For example, suppose SOL is at 50% utilization and assuming an hourly funding
rate of 0.01%. Then a trader with a long position SOL-USD of size 1000 USD will
accumulate funding fees at a rate of 0.05 USD per hour. 
 Auto Closing Positions that Exceed Maximum Leverage 
 The maximum allowed leverage is 200x. 
 Positions where the trader''s collateral less fees and less unrealized losses is less than 0.5% of the position size will be liquidated. 
 Extra fund from position closure will be returned to the trader automatically. 
 Oracle 
 Jupiter Perps always use Pyth oracles on the trading prices and chart data. However, there are 2 types of Pyth oracles, the  mainnet-beta  oracle and the  pythnet  oracle. 
 For position changes, such as opening, closing or liquidating positions, keeper bots utilize Pyth''s mainnet-beta prices. In times of congestion, they will use the backup Pythnet oracles. This improves reliability for traders to adjust their positions. 
 For chart data, we are using the Pyth  Hermes  web service. The Hermes web service is using the prices from Pythnet. There might be slight deviations between the chart and your execution prices occasionally, due to the small variation between  mainnet-beta  and  pythnet  prices. 
 You can check out the SOL/USD mainnet-beta oracle  here  and the SOL/USD pythnet oracle  here . 
 You can also utilize  Pyth Benchmarks  to check the oracle price for any of Pyth''s listed tokens at any timestamp. Use this to independently verify historical oracle prices.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-perpetual-exchange/6-audit.md', 'sidebar_label: "Audit"
description: Contract Audit 
 Audit 
 
 OtterSec 
 Sec3', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/Moved/2-perpetual-exchange/2-trading.md', 'sidebar_label: "Trading"
title: "Trading on Jupiter Perpetual Exchange"
description: Trading on Jupiter Perpetual Exchange 
 Opening a Position 
 Commence by selecting the perpetual market you wish to open a position on, such as  SOL-PERP ,  ETH-PERP , or  WBTC-PERP . Proceed to choose  Long  or  Short  on the trading form based on your desired position. 
 Long Position: 
 
 Yields profit if the token price increases. 
 Incurs losses if the token price decreases. 
 
 Short Position: 
 
 Yields profit if the token price decreases. 
 Incurs losses if the token price increases. 
 
 Upon selecting your side, navigate to the  You''re Paying  tab, choose the token, input the desired payment amount, and specify the leverage. Above the  LONG/SHORT  button, find a concise summary of your  collateral  and  size in USD  with the leverage multiplier  (ranging from 1.1x to 100x) . 
 Below the  LONG/SHORT  button, review order details, including: 
 
 Entry Price 
 Liquidation Price 
 Trading Fee (0.1% for opening and closing positions) 
 Borrow Fee (calculated hourly based on pool utilization) 
 Available Liquidity 
 
 While trades incur no price impacts, slippage may occur due to price variations between transaction submission and blockchain confirmation. Slippage, the difference between expected and execution prices, can be customized in the icon at the top right of the trading form. 
 When entering a position, whether Long or Short, it hinges on the available liquidity within the JLP pool. 
 
 Long Positions: For SOL, ETH, WBTC, it relies on the availability of the respective assets within the JLP pool. 
 Short Positions: In the case of SOL, ETH, WBTC, it depends on the availability of stablecoin assets, specifically USDC and USDT. 
 
 Managing Positions 
 Upon opening a position, it becomes accessible in your  Positions  list. To adjust leverage and liquidation price, click on  Edit . This feature enables efficient management of your positions. 
 When initiating a position or depositing collateral, a snapshot of your collateral''s USD value is captured. For instance, if your collateral is 1 SOL and SOL''s price is 40 USD, your collateral is valued at 40 USD, remaining constant despite SOL price fluctuations. 
 Profit and loss are proportionate to your position size. For instance, a long SOL position of 1,000 USD with a 10% SOL price increase yields a profit of 100 USD, while a 10% decrease results in a 100 USD loss. Conversely, a short position with a 10% SOL price decrease garners a 100 USD profit, but a 10% increase incurs a 100 USD loss. 
 Leverage for a position is represented as  Size (position size) / Collateral (position collateral) . 
 Closing a Position 
 You can close a position by clicking on the  Close  button in the position row. 
 
 
 Long Positions:  Profits from long positions are disbursed in the asset you are longing. For instance, if you''ve gone long on SOL, your profits will be received in SOL. 
 
 
 Short Positions:  Profits from short positions are paid out in the same stablecoin used to open the position, such as USDC or USDT. 
 
 
 Take-Profit / Stop-Loss Orders 
 You can set take-profit and stop-loss trigger orders by selecting the  Add TP  or  Add SL  button in the position row. 
 Once you create a trigger order, it will be displayed in your position''s row under the  Take Profit  and  Stop Loss  columns. You have the flexibility to edit the order and adjust the trigger price as needed. 
 In the event of manually closing a position, the associated trigger orders will be automatically canceled and closed, providing a seamless experience when opening new future positions. 
 Note: While  TP/SL  orders are set, keepers will monitor the mark price, when reaching the specified price level, TP/SL will close the whole position. 
 Liquidations 
 In the scenario of opening a long position in SOL, where the position size surpasses the collateral value, there exists a critical point known as the Liquidation Price. This price is calculated based on the threshold where the loss amount, collateral value, and borrow fee collectively dip below 0.2% of your position''s size. If the token''s price surpasses this point, the system will automatically close the position. 
 It''s crucial to note that the liquidation price is subject to change over time, particularly with leverage exceeding 10x and extended position durations. Regularly monitoring your liquidation price is essential. To mitigate the risk of liquidation, collateral adjustments and leverage fine-tuning can be performed through the  Edit  button in the position row, offering an avenue to add collateral and enhance the liquidation price. 
 Upon liquidation, any remaining collateral, net of losses and fees, will be kept as liquidation fee to the JLP pool. 
 Pricing 
 On Jupiter Perpetual Exchange,  trades incur no price impact , allowing for the execution of large trades precisely at the mark price. 
 Mark prices are conveniently presented in the same row as the market name  (e.g., SOL-PERP) . Notably, long positions and short positions are opened and closed at the same price as  Mark Price  when initiating market order. 
 Fees 
 Opening or closing a position on Jupiter Perpetual Exchange incurs a fee equivalent to 0.1% of the position size. You also have to pay an hourly borrow fee as calculated as such: 
 hourly borrow fee = (tokens borrowed / tokens in the pool) x hourly borrow rate x position size
 
 For long positions, the collateral is the token being longed  (e.g., SOL for SOL longs, BTC for BTC longs) , while short positions are collateralized with supported stablecoins like USDC or USDT. 
 Jupiter Perpetual Exchange seamlessly integrates Jupiter Swap. Consequently, when a swap is required during the opening or closing of a position, regular DEX fees and slippages are applicable. 
 Solana Fee 
 Users will have to pay SOL for submitting transactions onto the Solana chain. At the same time, a minor SOL amount will be used for rent to create an escrow account ( PDA ). The SOL rent will be returned to you once you close your position. 
 Keepers 
 Jupiter Perpetual Exchange works based on a keeper model. A typical trader action involves a 2-step process: 
 
 Trader submits a request transaction onto the Solana chain. 
 Keeper monitors the request transaction and executes it as a separate transaction onto the Solana chain. 
 
 Sometimes, if the oracle price is stale or the oracle price hits the trader slippage, the keeper will close the trader''s request and return the SOL rent on the request and collateral (when opening a position) back to the trader. You will see this a separate transaction on your wallet submitted by our keeper. 
 You may also notice multiple failed transactions on your wallet submitted by our keepers. You can safely ignore these failed transactions, they don''t alter any state on your wallet. This happens because we have multiple keepers to execute your request in order to make sure that the trader experience is swift.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/11-jupiter-lock/1-jupiter-lock.md', 'sidebar_label: Jupiter Lock Overview
title: Jupiter Lock Overview
description: "Jupiter Lock is an open-sourced, audited, and free ecosystem tool to lock and distribute tokens over-time." 

     Jupiter Lock 
     

 Jupiter Lock (https://lock.jup.ag/) is an  open-sourced , audited and free way to lock and distribute tokens over-time. Lock will be free for all project teams to lock tokens, implement cliff, and vest non-circulating supply in a clear and transparent manner. 
 Jupiter Lock Specifications 
 Jupiter Lock is currently in Beta, we aim to improve and introduce additional features. Let us know what you are interested in! 
 Audited Twice by  OtterSec  &  Sec3 . 
 Program code is available here: https://github.com/jup-ag/jup-lock 
 Mainnet Deployment:  LocpQgucEQHbqNABEYvBvwoxCPsSbG91A1QaQhQQqjn 
 The  IDL  for the Jupiter Lock program can be found on  Solscan , or available here: 
 :::info Jupiter Lock is in Beta
Feel free to submit PRs, suggestions, or reach out to us! If you need help with Jupiter Lock or have any feedback on how to improve, let us know on Discord or  Telegram .
::: 
 
 How to Use Jupiter Lock 
 Create Token Lock 
 <video controls style={{ maxWidth: ''50%'', height: ''auto'' }}> 
 <source src={require(''../static/media/lock-walkthrough.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Video credits:  Aremia Vincenzo 
 
 Navigate to https://lock.jup.ag/. 
 Click  + Create Token Lock  button. 
 Click  Connect Wallet  button. Note that you can only lock the tokens you have in your connected wallet. 
 Search for the token you wish to lock via contract address or ticker. 
 Fill in the required details:
 
 Lock Title. Name this lock e.g. Team Tokens. 
 Lock Amount. You can see the amount of token within your wallet. 
 Recipient Wallet Address. The tokens can be claimable by this wallet after the defined vesting period. 
 Vesting Start Date. You can select any future date and time. This is based on your current timezone. 
 Vesting Duration and intervals. Vesting Duration determines the entire vesting schedule from the Start Date. 
 (Optional) Cliff Period & intervals. Cliff refers to a time period that has to pass before the tokens start vesting. 
 Unlock Schedule. This determines how much tokens is being vested and unlocked within that regular time interval. 
 Who can cancel the contract and who can change the recipient. Choose None, Only Creator, Only Recipient or Either Creator or Recipient 
 
 
 (Optional) Add more locks for the same token but with different parameters by clicking  Add Another Lock  button. 
 Press  Proceed  to review the token lock contract. After confirming all the details, click  Create Contract  button. 
 Navigate to Jupiter Lock home page is to view the lock that you’ve created! 
 
 
 View Locks & Claim Tokens 
 
 Navigate to https://lock.jup.ag/. You will be able to see All Locks powered by Jupiter Lock. 
 Click  Connect Wallet  at the upper right corner to check Your Locked Tokens and Locks You Created.
 
 Your Locked Tokens include tokens that others and yourself have locked and your wallet is a recipient. 
 Locks You Created shows the locks that you created. 
 
 
 Select the token of interest and check all locks associated, powered by Jupiter Lock. The details include:
 
 Lock Title: Title describes the lock. Clicking on this will be directed to the explorer. 
 Unlocked/Total: Amounts of token vested and unlocked over the total locked amount. 
 Actions: The  Claim  button will light up if there''s unlocked tokens to claim. 
 Vesting Schedule: The schedule shows the full vesting period, including date and time. 
 Cliff Date: If a cliff date was added to the contract, it will show up here. 
 Unlock Rate: The amount of token vested and unlocked will be shown against the time period. 
 Creator/Recipient: The wallet addresses of Creator and Recipient. 
 Claim Progress: Progress bar showing the tokens claimed against locked amount. 
 
 
 
 
   Jupiter Lock Terms and Conditions 
 Last Updated: 27 September 2024 
 These Terms and Conditions of Use (these "Terms") are between you (also referred to herein as "user", "you" and "your") and Block Raccoon S.A., a company incorporated under the laws of Panama ("Jupiter Lock", "we", "us" and "our"). These Terms govern your use of the services provided by Jupiter Lock described below (the "Services"). By accessing the Services made available on https://lock.jup.ag/ (the "Website") you agree that you have read, understand, and accept all of the terms and conditions contained in these Terms. 
 We may make changes to these Terms from time to time. If we do this, we will post the revised Terms on the Website and will indicate at the top of this page the date the was last revised. You understand and agree that your continued use of the Service or the Website after we have made any such changes constitutes your acceptance of the new Terms. 
 
 INTRODUCTION 
 
 1.1.	Eligibility
To be eligible to use the Website you must be at least eighteen (18) years of age or older. The Website, interface and Services (as defined below) is strictly NOT offered to persons or entities who reside in, are citizens of, are incorporated in, or have a registered office in any Restricted Territory, as defined below (any such person or entity from a Restricted Territory shall be a “Restricted Person”). If you are a Restricted Person, then do not attempt to access or use the Website. Jupiter Lock will implement technical measures such as "geoblocking" to ensure that the Website, interface and Services are not available to Restricted Persons. Use of a virtual private network (e.g., a VPN) or other means by Restricted Persons to access or use the Website, interface or Services is prohibited. For the purpose of these Terms, Restricted Territory shall mean the United States, People''s Republic of China, Russia, Democratic People’s Republic of Korea (North Korea), or any other state, country or region that is subject to sanctions enforced by the United States, the United Kingdom or the European Union. 
 1.2.	Terms
We reserve the right to disable access to the Website interface at any time in the event of any breach of the Terms, including without limitation, if we, in our sole discretion, believe that you, at any time, fail to satisfy the eligibility requirements set forth in the Terms. Further, we reserve the right to limit or restrict access to the Website interface by any person or entity, or within any geographic area or legal jurisdiction, at any time and at our sole discretion. We will not be liable to you for any losses or damages you may suffer as a result of or in connection with the Website interface being inaccessible to you at any time or for any reason. 
 1.3.	Legality
You are solely responsible for adhering to all laws and regulations applicable to you and your use or access to the Website and interface thereon. Your use of the Website and Services is prohibited by and otherwise violate or facilitate the violation of any applicable laws or regulations, or contribute to or facilitate any illegal activity. We make no representations or warranties that the information, products, or services provided through the Website, are appropriate for access or use in other jurisdictions. We reserve the right to limit the availability of our Website to any person, geographic area, or jurisdiction, at any time and at our sole and absolute discretion. 
 
 THE SERVICES 
 
 2.1.	Jupiter Lock and Services 
 Jupiter Lock is a open-sourced, audited and free tool for users to lock and distribute their own digital assets over-time, allowing project teams to lock tokens, implement cliffs, and vest non-circulating supply in a clear and transparent manner. Jupiter Lock performs its core functions via interoperable smart contracts, functioning solely as a back-end technical tool allowing users to perform the above functions. 
 2.2.	Peer-to-peer interactions
The Services facilitates peer-to-peer interactions between users (for example, between third party project teams which decide to utilise the Services to lock their tokens and the community members of such third party projects) and we are not a party to any such arrangements. Accordingly, you agree that we are not responsible for any activities between users accessing the Services, and you shall bear all risks (including civil claims or regulatory risk) of (a) all activities being performed by you in connection with any other user utilising the Services, and (b) all activities and interactions with other users. Any claims arising in connection with the foregoing shall be directly against the relevant user, and we shall not be liable for the same. 
 Users are solely responsible for the acquisition and security (including without limitation enabling of access, applying appropriate security measures, encrypting sensitive data, and not allowing unauthorised access to) while utilising the Services. 
 2.3.	Usage of Services
Jupiter Lock may launch, change, upgrade, impose conditions to, suspend, or stop offering the Services or any component, feature, element or function of the same, including additional sign-on procedures and requirements, and the manner of access to the Services (including any code repositories or URLs used in connection therewith) without prior notice. 
 2.4.	Non-custodial nature of smart contracts
The user interface will allow you to access a non-custodial smart contract to perform a variety of transactions. In particular, you confirm that all actions and functions performed via the Jupiter Lock smart contract are irrevocable. You remain in full control of your digital assets, which are not held or controlled in any way by Jupiter Lock. Jupiter Lock does not custody your digital assets, nor collect or hold your keys or information - accordingly, if you lose control over these assets, Jupiter Lock cannot access your digital assets; digital backups; recover keys, passwords, or other information; reset passwords; or reverse transactions. You are solely responsible for the safety of your digital assets and your use of the Services, including without limitation for storing, backing up, and maintaining the confidentiality of your private keys, passwords, and information, and for the security of any transactions you perform using the Website. You expressly relieve and release Jupiter Lock from any and all liability and/or loss arising from your use of the Services. 
 2.5.	Service fees
If you elect to utilise the Services, all transactions will be conducted solely through the relevant blockchain network (on which your tokens are issued). We will have no insight into or control over these payments or transactions, nor do we have the ability to reverse any transactions. With that in mind, we will have no liability to you or to any third party for any claims or damages that may arise as a result of any transactions that you engage in via the Website, or using the smart contracts, or any other transactions that you conduct via the relevant blockchain network. 
 The underlying blockchain network typically requires the payment of a transaction fee ("Gas Fee") for every transaction that occurs on the relevant blockchain network. The Gas Fee funds the network of validators, nodes or resource providers that run the decentralised network. This means that you will need to pay a Gas Fee for each transaction that occurs via the Website. 
 Jupiter Lock also reserves the right to levy additional fees for access via the smart contracts or the Website in the future. You agree to promptly pay all aforementioned fees and commissions. 
 2.6.	Not an Offering of Banking business, Trust business, Custodial business, Escrow business, Securities or Commodities
You understand and affirm that Jupiter Lock is a non-custodial provider of technical smart-contract services which allow users to manage their digital assets. The content of the Website and the Services do not constitute any banking business, trust business, custodial business, escrow business, any offer to buy or sell, or a solicitation of an offer to buy or sell investments, securities, partnership interests, commodities or any other financial instruments in any jurisdiction. The content or the Website and the Services also do not constitute, and may not be used for or in connection with, an offer or solicitation by anyone in any state or jurisdiction in which such an offer or solicitation is not authorized or permitted, or to any person to whom it is unlawful to make such offer or solicitation. In particular, the Services do not constitute any "banking business" within the meaning of any banking laws, "custody" within the meaning of any virtual assets law, or "capital markets products" or "securities" within the meaning of any securities law. 
 2.7.	No Advice
Jupiter Lock makes no representation or warranty, express or implied, to the extent not prohibited by applicable law, regarding the advisability of participating in digital assets on any blockchain, any financial products, securities, funds, commodity interests, partnership interests or other investments or funding or purchasing loans. Jupiter Lock is merely a technology service provider allowing you to manage your own digital assets connecting you with various third parties and does not offer fiduciary services, and is not your agent, trustee, advisor or fiduciary. 
 2.8.	Non-reliance
The Services allow users to create a variety of applications. It is solely your responsibility to determine the legality of the applications created and the legal relationship created between you and your end user in respect of such developed applications/users services. Jupiter Lock provides no guarantees as to the suitability or legality of the Services or software tools. 
 2.9.	Taxes
It is your sole responsibility to determine whether, and to what extent, any taxes apply to any interest received through the Services, and to withhold, collect, report and remit the correct amount of tax to the appropriate tax authorities. 
 2.10.	Amendment or Withdrawal of Services
Jupiter Lock may impose additional terms for the usage of the Service, as set forth in separate Service-specific Terms and Conditions. Jupiter Lock may increase or restrict the scope of Services, and may modify, limit or discontinue existing Services, from time to time and at Jupiter Lock ''s sole discretion. 
 2.11.	Technical documentation
You must comply with all relevant technical documentation applicable to the Services as posted and updated by Jupiter Lock from time to time on the Website. You further agree, as a continuing condition for your use of the Services, to abide by all license terms and conditions of all third-party software components, libraries and application programme interfaces comprised in any Services as from time to time notified on the Website. 
 
 USER TERMS 
 
 3.1.	User Conduct
You agree that you are responsible for your own conduct while accessing or using the Website or the Services, and for any consequences thereof. You agree to use the Website and the Services only for purposes that are legal, proper and in accordance with these Terms and any applicable laws or regulations, including without limitation you may not: (a) send, upload, distribute or disseminate any unlawful, defamatory, harassing, abusive, fraudulent, obscene, or otherwise objectionable content; (b) distribute viruses, worms, defects, Trojan horses, corrupted files, hoaxes, or any other items of a destructive or deceptive nature; (c) impersonate another person (via the use of an email address or otherwise); (d) upload, post, transmit or otherwise make available through the Website or the Services any content that infringes the intellectual proprietary rights of any party; (e) use the Website or the Services to violate the legal rights (such as rights of privacy and publicity) of others; (f) engage in, promote, or encourage illegal activity (including, without limitation, money laundering); (g) interfere with other users'' enjoyment of the Website or the Services; (h) exploit the Website or the Services for any unauthorised commercial purpose; (i) modify, adapt, translate, decompile, disassemble or reverse engineer any portion of the Website or the Services; (j) attempt to bypass any measure of the Website or the Services designed to prevent or restrict access to the same (or any portion thereof); (k) harass, intimidate, or threaten any of our employees or agents engaged in providing any portion of the Website or the Services to you; (l) remove any copyright, trademark or other proprietary rights notices contained in the Website, the Services or the Content (or any part thereof); (m) reformat or frame any portion of the Website; (n) display any content on the Website or the Services that contains any hate-related or violent content or contains any other material, products or services that violate or encourage conduct that would violate any criminal laws, any other applicable laws, or any third party rights; (o) use any robot, spider, site search/retrieval application, or other device to retrieve or index any portion of the Website or the Services or the content thereon, or to collect information about its users for any unauthorised purpose; (p) upload or transmit (or attempt to upload or to transmit) any material that acts as a passive or active information collection or transmission mechanism, including without limitation, clear graphics interchange formats (“gifs”), 1×1 pixels, web bugs, cookies, or other similar devices (sometimes referred to as “spyware” or “passive collection mechanisms” or “pcms”); (q) access or use the Website or the Services by automated means or under false or fraudulent pretences; (r) access or use the Website or the Services for the purpose of, directly or indirectly, creating or enabling a party to create a product or service that is competitive with any of our products or services; (s) use the Website, the Services or the underlying smart contracts to advertise or offer to sell goods and services; (t) conduct any activity that violates any applicable law, rule, or regulation concerning the integrity of trading markets, including (but not limited to) the manipulative tactics commonly known as spoofing, wash trading, cornering, accommodation trading, fictitious transactions, "money pass" (i.e. transactions without a net change in either party''s open positions but with a resulting profit to one party and a loss to the other party), or pre-arranged or non-competitive transactions, or (u) disparage, tarnish, or otherwise harm, in our opinion, us and/or the Website or the Services. If you engage in any of the activities prohibited by this section 3, we may, at our sole and absolute discretion, without notice to you, and without limiting any of our other rights or remedies at law or in equity, immediately suspend or terminate your access to the Website or the Services and delete all your provided input as well as output generated/processed in connection with the Services. 
 3.2.	User Representations and Warranties
By using the Website, the Services or the underlying smart contracts, you represent and warrant that: (a) you have read and understood these Terms and all documentation on the Website and/or relating to the Services; (b) you have good and sufficient experience and understanding of the functionality, usage, storage, transmission mechanisms and other material characteristics of cryptographic tokens, token storage mechanisms (such as token wallets), blockchain technology, blockchain-like technology and blockchain-based software systems to understand these Terms and to appreciate the risks and implications of using or otherwise interacting with the Website or the Services; (c) you acknowledge and agree that we may impose eligibility criteria to access certain functionality in respect of the Services which may require you to incur additional time and money costs; (d) you use and/or  interact with the Website and the Services for your own account and shall not do the same on behalf of any other entity or person; (e) your usage and/or interaction with the Website and the Services complies with applicable law and regulation in your jurisdiction, and the law and regulation of any jurisdiction to which you may be subject (including, but not limited to legal capacity and any other threshold requirements for using and/or interacting with the Website or the Services, interacting with other users of the Website or the Services, and any governmental or other consents that may need to be obtained; (f) all information you submit will be true, accurate, current, and complete (if you provide any information that is untrue, inaccurate, not current, or incomplete, we have the right to refuse or terminate your current or future use of the Website or the Services (or any portion thereof); (g) you will maintain the accuracy of such information and promptly update such information as necessary; (h) you have the legal capacity and you agree to comply with these Terms; (i) you are not a minor in the jurisdiction in which you reside; (j) you will not use the Website, the Services or the underlying smart contracts for any illegal and unauthorised purpose; (k) you will not use the Website or the Service or the underlying smart contracts for any commercial purpose (save as approved by us in writing); (l) your use of the Website, the Services and the underlying smart contracts will not violate any applicable law or regulation; and (m) any funds or digital assets you use to interact with the Website or the Services are not derived from or related to any unlawful activities, including but not limited to money laundering or terrorist financing and all applicable statutes of all jurisdictions in which you are located, resident, organised or operating, and/or to which it may otherwise be subject and the rules and regulations thereunder (collectively, the "Compliance Regulations"), and you will not use the Website, the Services or the underlying smart contracts to finance, engage in, or otherwise support any unlawful activities or in a manner which aids or facilitates another party in the same. To the extent required by applicable laws and regulations, you shall fully comply with all Compliance Regulations. 
 
 RISK FACTORS 
 
 You acknowledge and agree that the Services are currently in the initial development stages and there are a variety of unforeseeable risks with utilising the Services or Website. In the worst scenario, this could lead to the loss of all or part of your digital assets associated with the Services. IF YOU DECIDE TO UTILISE SERVICES YOU EXPRESSLY ACKNOWLEDGE, ACCEPT AND ASSUME THE BELOW RISKS AND AGREE NOT TO HOLD JUPITER LOCK OR ANY OF THEIR RELATED PARTIES RESPONSIBLE FOR THE FOLLOWING RISKS: 
 4.1.	Third-party Risk
The Services rely on whole or partly, on third-party open and closed source software networks, and the continued development and support of third parties. There is no assurance or guarantee that those third parties will maintain their support of their software, which might have a material adverse effect on the Services. Further, where digital assets are locked as collateral for applications built with Jupiter Lock tools and/or are deployed by such third party applications towards third-party decentralized finance protocols to further generate yield, a failure or security incident in respect of such third-party protocol may result in users losing all or substantially all of their digital assets. 
 4.2.	No Insurance
Digital assets are not legal tender, are not backed by the government, and are not subject to the Deposit Insurance Scheme or protections under any banking or securities laws. Jupiter Lock is not a bank and does not offer fiduciary services, nor does it offer any security broking services. 
 4.3.	New Technical Risk
The software used for Jupiter Lock is new. While this software has been extensively tested, the underlying smart contracts and software used for the Services is still relatively new and could have bugs or security vulnerabilities. Further, the software is still under development and may undergo significant changes over time that may not meet users’ expectations. 
 4.4.	Risks
The underlying smart contracts run on a variety of supported blockchain networks, using specially-developed smart contracts. Accordingly, upgrades to the relevant blockchain network, a hard fork in the relevant blockchain network, re-organisations of blockchain structure or blocks, or a change in how transactions are confirmed on the relevant blockchain network may have unintended, adverse effects on the smart contracts built thereon, including Jupiter Lock software and smart contracts. 
 4.5.	Information Security Risk
Digital assets, and use of the Services may be subject to expropriation and/or theft. Hackers or other malicious groups or organizations may attempt to interfere with the Services in a variety of ways, including, but not limited to, malware attacks, denial of service attacks, consensus-based attacks, Sybil attacks, smurfing and spoofing. Furthermore, because the underlying blockchain networks comprise open-source software, there is the software underlying the Services may contain intentional or unintentional bugs or weaknesses that may negatively affect the Services or result in the loss of the user’s digital assets, the loss of the user’s ability to access or control their digital assets. In the event of such a software bug or weakness, there may be no remedy, and users are not guaranteed any remedy, refund or compensation. 
 4.6.	Regulatory risks
The regulatory status of digital assets, and distributed ledger technology is unclear or unsettled in many jurisdictions. While every effort has been taken to ensure that the Services are compliant with local laws, it is difficult to predict how or whether regulatory agencies may apply existing regulation with respect to the Services. It is likewise difficult to predict how or whether legislatures or regulatory agencies may implement changes to law and regulation affecting distributed ledger technology and its applications, including the Services. Regulatory actions could negatively impact Jupiter Lock in various ways, and thus the Services may not be available in certain areas. 
 4.7.	Taxation Risk
The tax characterization of digital assets, and the usage of the Services are uncertain. It is possible that the user''s intended treatment of digital assets may be challenged. You must seek your own tax advice in connection with the Services provided by Jupiter Lock, which may result in adverse tax consequences to you, including, without limitation, withholding taxes, transfer taxes, value-added taxes, income taxes and similar taxes, levies, duties or other charges and tax reporting requirements. 
 4.8.	Additional conditions of usage of the Website and Services 
 Your usage of the Website and Services is subject to the following additional conditions:
(a)	Unlawful Activity: you agree not to engage, or assist, in any activity that violates any law, statute, ordinance, regulation, or sanctions program, including but not limited to the U.S. Department of Treasury’s Office of Foreign Assets Control (OFAC), or that involves proceeds of any unlawful activity.
(b)	Abusive Activity: you agree not to engage in any activity that poses a threat to Jupiter Lock or the Website, for example by distributing a virus or other harmful code, or through unauthorized access to the Website or other users’ digital assets.
(c)	Inappropriate Behaviour: you agree not to interfere with other users’ access to or use of the Services.
(d)	Communication: you agree not to communicate with other users for purposes of (1) sending unsolicited advertising or promotions, requests for donations, or spam; (2) harassing or abusing other users; (3) interfering with transactions of other users. You agree not to use data collected from the Website to contact individuals, companies, or other persons or entities outside the Website for any purpose, including but not limited to marketing activity.
(e)	Fraud: you agree not to engage in any activity which operates to defraud Jupiter Lock, other users, or any other person; or to provide any false, inaccurate, or misleading information to Jupiter Lock.
(f)	Gambling: you agree not to utilize the Services to engage in any lottery, bidding fee auctions, contests, sweepstakes, or other games of chance.
5.	WEBSITE AVAILABILITY AND ACCURACY 
 5.1.	Access and Availability
Access to the Services may become degraded or unavailable on Jupiter Lock during times of significant volatility or volume. This could result in the inability to interact with Jupiter Lock, or third-party services for periods of time and may also lead to support response time delays. Users will, however, be able to access these third-party services through other means. Although we strive to provide you with excellent service, we do not guarantee that the Website or Services will be available without interruption and we do not guarantee that requests to interact with third-party services will be successful. 
 5.2.	Website Accuracy
Although we intend to provide accurate and timely information on the Website, the Website (including, without limitation, the Services and the content on the Website may not always be entirely accurate, complete or current and may further also include technical inaccuracies or typographical errors. In an effort to continue to provide you with as complete and accurate information as possible, information may, to the extent permitted by applicable law, be changed or updated from time to time without notice, including without limitation information regarding our policies, products and services. Accordingly, you should verify all information before relying on it, and all decisions based on information contained on the Website are your sole responsibility and we shall have no liability for such decisions. Links to third-party materials (including without limitation any websites) may be provided as a convenience but are not controlled by us. You acknowledge and agree that we are not responsible for any aspect of the information, content, or services contained in any such third-party materials accessible or linked to from the Website. 
 5.3.	Not a Backup or Storage Site
The Website is intended solely to provide you with a visual interface to access and use the Services. It is not intended for use as a data backup or storage site. You are solely responsible for ensuring that you maintain copies of your applications developed, code base, or other content. Except as may be required under applicable data privacy or other laws and regulations, Jupiter Lock is under no obligation to provide you with access to any data or other materials stored on the Website or to ensure their reliability or availability. 
 
 CONSENT TO ELECTRONIC DISCLOSURES AND SIGNATURES 
 
 6.1.	General
Because Jupiter Lock operates only on the Internet, it is necessary for you to consent to transact business with us online and electronically. As part of doing business with us, therefore, we also need you to consent to our providing you certain disclosures electronically, either via our Website or to the email address (if applicable) you provide to us. By agreeing to these Terms, you agree to receive electronically all documents, communications, notices, contracts, and agreements arising from or relating to your use of the Website and Service. 
 6.2.	Scope of Consent
Your consent to receive disclosures and transact business electronically, and our agreement to do so, applies to any transactions to which such disclosures relate, whether between you and Jupiter Lock or a third party by and through the Service. Your consent will remain in effect for so long as you are a user and, if you are no longer a user, will continue until such a time as all disclosures relevant to Services received through the Website. 
 6.3.	Withdrawing Consent
You may withdraw your consent to receive agreements or disclosures electronically by contacting us at legal@jup.ag. However, once you have withdrawn your consent you will not be able to access the Services. 
 
 INTELLECTUAL PROPERTY, COPYRIGHTS AND IDENTIFYING MARKS 
 
 7.1.	Jupiter Lock Intellectual Property
You acknowledge that all Intellectual Property Rights in Jupiter Lock smart contracts, the Website, or any service/product thereon (including without limitation any information, licenses, business plans, data, patent disclosures, system applications, structures, models, flow charts, techniques, processes, compositions, compounds, software, programs, source code and object code, comments to the source or object code, specifications, documents, reports, presentations, test results, findings, ideas, knowhow, copyright, trade secrets, abstracts and/or summaries thereof) exclusively belongs and shall exclusively belong to Jupiter Lock, and you shall have no rights in or to such Intellectual Property Rights, save that you are granted a license during the term of this Agreement to utilise the published Jupiter Lock contracts issued under the relevant [BSL] License) at code repository [*], and subject always to the provisions of these Terms. 
 To the extent any Jupiter Lock intellectual property rights are deemed to belong to you, you hereby irrevocably assigns and transfers to Jupiter Lock all right, title and interest in all such intellectual property rights, and agrees to execute all documents reasonably requested by Jupiter Lock for the purpose of perfecting such assignment and/or transfer and applying for and obtaining any domestic and foreign patent and copyright registrations.
 
 7.2.	Limited License
All content on the Website, including but not limited to designs, text, graphics, pictures, video, information, software, music, sound and other files, and their selection and arrangement (the "Content"), are the proprietary property of Jupiter Lock with all rights reserved. No Content may be modified, copied, distributed, framed, reproduced, republished, downloaded, displayed, posted, transmitted, or sold in any form or by any means, in whole or in part, without Jupiter Lock''s prior written permission, except as provided in the following sentence and except that the foregoing does not apply to your own User Content (as defined below) that you legally post on the Website. Provided that you are eligible for use of the Website, you are granted a limited license to access and use the Website and Services, and to download or print a copy of any portion of the Content solely for your use in connection with your use of the Website or Service, provided that you keep all copyright or other proprietary notices intact. Except for your own User Content (as defined below), you may not republish Content on any Internet, Intranet or Extranet site or incorporate the information in any other database or compilation, and any other use of the Content is strictly prohibited. Any use of the Website or the Content other than as specifically authorized herein, without the prior written permission of Jupiter Lock, is strictly prohibited and will terminate the license granted herein. Such unauthorized use may also violate applicable laws including without limitation copyright and trademark laws and applicable communications regulations and statutes. Unless explicitly stated herein, nothing in these Terms shall be construed as conferring any license to intellectual property rights, whether by estoppel, implication or otherwise. This license is revocable by us at any time without notice and with or without cause. 
 7.3.	Trademarks
Jupiter Lock and other Jupiter Lock graphics, logos, designs, page headers, button icons, scripts, and service names are registered trademarks, trademarks or trade dress of Jupiter Lock in Panama and/or other countries. Jupiter Lock''s trademarks and trade dress may not be used, including as part of trademarks and/or as part of domain names, in connection with any product or service in any manner that is likely to cause confusion and may not be copied, imitated, or used, in whole or in part, without the prior written permission of Jupiter Lock. Jupiter Lock may, at its sole discretion, limit access to the Website by any users who infringe any intellectual property rights of Jupiter Lock or others. 
 7.4.	Copyright Complaints
If you believe that any material on the Website infringes upon any copyright which you own or control, you may send a written notification of such infringement to Jupiter Lock at legal@jup.ag. 
 7.5.	Suggestions
You acknowledge and agree that any questions, comments, suggestions, ideas, feedback or other information about the Website or the Service ("Suggestions"), provided by you to Jupiter Lock are non-confidential and shall become the sole property of Jupiter Lock. Jupiter Lock shall own exclusive rights, including all intellectual property rights, and shall be entitled to the unrestricted use and dissemination of these Suggestions for any purpose, commercial or otherwise, without acknowledgment or compensation to you. 
 
 DATA PROTECTION AND SECURITY 
 
 8.1.	Loss or Compromise
Any loss or compromise of your electronic device or your security details may result in unauthorized access to your digital assets by third parties and the loss or theft of such assets. 
 8.2.	Shared Access
You should never allow remote access or share your computer screen with someone else when you are accessing the Services. Jupiter Lock will never under any circumstances ask you for your private keys or passwords, or to screen share or otherwise seek to access your computer or digital assets. You should not provide your details to any third party for the purposes of remotely accessing your computer or digital assets. 
 8.3.	Safety and Security of Your Computer and Devices
Jupiter Lock is not liable for any damage or interruptions caused by any computer viruses or other malicious code that may affect your computer or other equipment, or any phishing, spoofing or other attacks. We advise the regular use of a reputable and readily available virus screening and prevention software. 
 
 USER FEEDBACK, QUERIES, COMPLAINTS, DISPUTES 
 
 9.1.	Contact Jupiter Lock
If you have feedback or general questions, please contact us via our User Support at legal@jup.ag. When you contact us please provide us with your name, email address, and any other information we may need to identify you, your transactions conducted, and digital assets held. 
 9.2.	Dispute Resolution
PLEASE READ THIS SECTION CAREFULLY BECAUSE IT CONTAINS CERTAIN PROVISIONS, SUCH AS A BINDING ARBITRATION SECTION AND CLASS ACTION WAIVER, WHICH AFFECT YOUR LEGAL RIGHTS. THIS SECTION REQUIRES YOU TO ARBITRATE CERTAIN DISPUTES AND CLAIMS WITH JUPITER LOCK AND LIMITS THE MANNER IN WHICH YOU CAN SEEK RELIEF FROM US.
Each party (i) waives all its respective right(s) to have any and all disputes, claims, suits, actions, causes of action, demands or proceedings (collectively, "Disputes") arising from or related to these Terms resolved in a court, and (ii) waive all its respective right(s) to have any Disputes heard before a court. Instead, each party shall arbitrate Disputes through binding arbitration (which is the referral of a Dispute to one or more persons charged with reviewing the Dispute and making a final and binding determination to resolve it instead of having the Dispute decided by a judge or jury in court). 
 Any Dispute arising out of or related to these Terms is personal to you and will be resolved solely through individual arbitration, and in no circumstances shall be brought as a class arbitration, class action or any other type of representative proceeding. There will be no class arbitration or arbitration in which an entity attempts to resolve a Dispute as a representative of another individual or group of individuals. Further, a Dispute cannot be brought as a class or other type of representative action, whether within or outside of arbitration, or on behalf of any other individual or group of individuals. 
 Any Dispute arising out of or in connection with these Terms (including without limitation the enforceability of this section or any question regarding its existence, validity or termination) shall be referred to and finally resolved by arbitration administered by Panama Conciliation and Arbitration Centre in accordance with its procedural rules for the time being in force. The tribunal shall consist of 1 arbitrator. The language of the arbitration shall be English. 
 Each party will notify the other party in writing of any Dispute within thirty (30) days of the date it arises, so that the Parties can attempt in good faith to resolve the Dispute informally. Notice to Jupiter Lock shall be sent by e-mail to Jupiter Lock at legal@jup.ag. Notice to you shall be either posted on the Website or, if available, will be sent by email to your email on record. Your notice must include (i) your name, postal address, email address and telephone number, (ii) a full and sufficient description of the nature or basis of the Dispute, and (iii) the specific relief that you are seeking. If you and Jupiter Lock cannot agree on how to resolve the Dispute within thirty (30) days after the date the notice is received by the applicable party, then either you or Jupiter Lock may, as appropriate and in accordance with this section, commence an arbitration proceeding or, to the extent specifically provided for in this section, file a claim in court. 
 The arbitrator does not have the authority to conduct a class arbitration or a representative or class action, which is prohibited by these Terms. The arbitrator may only conduct an individual arbitration and may not consolidate more than one individual’s claims, preside over any type of class or representative proceeding or preside over any proceeding involving more than one individual. 
 If any term, clause or provision of this section is held invalid or unenforceable, it will be held to the minimum extent applicable and required by law, and all other terms, clauses and provisions of this section will remain valid and enforceable. Further, the waivers set forth in this section are severable from the other provisions of these Terms and will remain valid and enforceable, except as prohibited by applicable law. 
 You agree that this section of these Terms has been included to rapidly and inexpensively resolve any disputes with respect to the matters described herein, and that this section shall be grounds for dismissal of any court action commenced by you with respect to a dispute arising out of such matters. 
 A printed version of these Terms shall be admissible in judicial or administrative proceedings. 
 9.3.	Disclaimers
None of Jupiter Lock, its parent, any of its affiliates, subsidiaries, providers or their respective officers, directors, employees, agents, independent contractors or licensors (collectively the "Indemnified Parties") guarantees the accuracy, adequacy, timeliness, reliability, completeness, or usefulness of the Services or the Content, and the Indemnified Parties disclaim liability for errors or omissions in the Content. This Website, the Services and all of the Content is provided "as is" and "as available," without any warranty, either express or implied, including the implied warranties of merchantability, fitness for a particular purpose, non-infringement or title. Without prejudice to the generality of the foregoing, Jupiter Lock provides no warranties as to the results of your use of the Services or Content, or any application development in connection therewith. The Indemnified Parties do not warrant that the Website is free of viruses or other harmful components. This does not affect those warranties which are incapable of exclusion, restriction or modification under the laws applicable to these Terms. Jupiter Lock cannot guarantee and does not promise any specific results from use of the Website and/or the Service. 
 9.4.	Availability
The Website and the Service may be temporarily unavailable from time to time for maintenance or other reasons. Jupiter Lock assumes no responsibility for any error, omission, interruption, deletion, defect, delay in operation or transmission, communications line failure, theft or destruction or unauthorized access to, or alteration of, user communications. Jupiter Lock is not responsible for any problems or technical malfunction of any telephone network or lines, computer online systems, servers or providers, computer equipment, software, failure of email or players on account of technical problems or traffic congestion on the Internet or on the Website or combination thereof, including injury or damage to users or to any other person''s computer related to or resulting from participating or downloading materials in connection with the Website and/or in connection with the Service. Under no circumstances will Jupiter Lock be responsible for any loss or damage, including any loss or damage to any user Content, financial damages or lost profits, loss of business, or personal injury or death, resulting from anyone''s use of the Website or the Service, any User Content or Third Party Content posted on or through the Website or the Service or transmitted to users, or any interactions between users of the Website, whether online or offline. 
 9.5.	Limitation on Liability
EXCEPT IN JURISDICTIONS WHERE SUCH PROVISIONS ARE RESTRICTED, IN NO EVENT WILL JUPITER LOCK OR ITS DIRECTORS, EMPLOYEES OR AGENTS BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY INDIRECT, CONSEQUENTIAL, EXEMPLARY, INCIDENTAL, SPECIAL OR PUNITIVE DAMAGES, INCLUDING FOR ANY LOST PROFITS OR LOST DATA ARISING FROM YOUR USE OF THE WEBSITE OR THE SERVICE OR ANY OF THE CONTENT OR OTHER MATERIALS ON OR ACCESSED THROUGH THE WEBSITE, EVEN IF JUPITER LOCK IS AWARE OR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
 NOTWITHSTANDING ANYTHING TO THE CONTRARY CONTAINED HEREIN, TO THE EXTENT PERMITTED BY APPLICABLE LAW JUPITER LOCK''S LIABILITY TO YOU FOR ANY CAUSE WHATSOEVER, AND REGARDLESS OF THE FORM OF THE ACTION, WILL AT ALL TIMES BE LIMITED TO THE AMOUNT PAID, IF ANY, BY YOU TO JUPITER LOCK FOR THE SERVICES. IN NO CASE WILL JUPITER LOCK''S LIABILITY TO YOU EXCEED $200. YOU ACKNOWLEDGE THAT IF NO FEES ARE PAID TO JUPITER LOCK FOR THE SERVICE, YOU SHALL BE LIMITED TO INJUNCTIVE RELIEF ONLY, UNLESS OTHERWISE PERMITTED BY LAW, AND SHALL NOT BE ENTITLED TO DAMAGES OF ANY KIND FROM JUPITER LOCK, REGARDLESS OF THE CAUSE OF ACTION. 
 CERTAIN LOCAL, STATE OR FEDERAL LAWS DO NOT ALLOW THE EXCLUSION OR LIMITATION OF CERTAIN DAMAGES OR LIMITATIONS ON IMPLIED WARRANTIES. IF THESE LAWS APPLY TO YOU, SOME OR ALL OF THE ABOVE DISCLAIMERS, EXCLUSIONS OR LIMITATIONS MAY NOT APPLY TO YOU, AND YOU MAY HAVE ADDITIONAL RIGHTS. 
 9.6.	Governing Law; Venue and Jurisdiction
By visiting or using the Website and/or the Service, you agree that the laws of Panama, without regard to any principles of conflict of laws that would require or permit the application of the laws of any other jurisdiction, will govern these Terms. If you contract with any third party through Jupiter Lock, the terms of such contract will be governed by the contractual terms prescribed by such third party. 
 9.7.	Indemnity
You agree to indemnify and hold the Indemnified Parties, its subsidiaries and affiliates, and each of their directors, officers, agents, contractors, partners and employees, harmless from and against any loss, liability, claim, demand, damages, costs and expenses, including reasonable attorney''s fees, arising out of any dispute with another user of the Website or any third party. You also agree to indemnify and hold the Indemnified Parties, its subsidiaries and affiliates and service providers, and each of its or their respective officers, directors, agents, joint venturers, employees and representatives, harmless from any claim or demand (including attorneys'' fees and any fines, fees or penalties imposed by any regulatory authority) arising out of or related to your breach of these Terms or your violation of any law, rule or regulation, or the rights of any third party. 
 
 GENERAL PROVISIONS 
 
 10.1.	Amendments
We may amend or modify these Terms by posting on the Website the revised Terms, and the revised Terms shall be effective at such time. If you do not agree with any such modification, your sole and exclusive remedy is to terminate your use of the Services and Website. You agree that we shall not be liable to you or any third party for any modification or termination of the Services, or suspension or termination of your access to the Services, except to the extent otherwise expressly set forth herein. If the revised Terms include a material change, we will endeavour to provide you advanced notice via the Website before the material change becomes effective. 
 10.2.	Force Majeure
Jupiter Lock shall not be liable for delays, failure in performance or interruption of service which result directly or indirectly from any cause or condition beyond our reasonable control, including but not limited to, significant market volatility, any delay or failure due to any act of God, act of civil or military authorities, act of terrorists, civil disturbance, war, strike or other labour dispute, fire, interruption in telecommunications or Internet services or network provider services, failure of equipment and/or software, other catastrophe or any other occurrence which is beyond our reasonable control and shall not affect the validity and enforceability of any remaining provisions. 
 10.3.	Links to Other Web Websites and Content
The Website contains (or you may be sent through the Website or the Services) links to other websites ("Third Party Websites"), as well as articles, photographs, text, graphics, pictures, designs, music, sound, video, information, software and other content belonging to or originating from third parties (the "Third Party Content"). Such Third Party Websites and Third Party Content are not investigated, monitored or checked for accuracy, appropriateness, or completeness by us, and we are not responsible for any Third Party Websites accessed through the Website or any Third Party Content posted on the Website, including without limitation the content, accuracy, offensiveness, opinions, reliability or policies of or contained in the Third Party Websites or the Third Party Content. Inclusion of or linking to any Third Party Website or any Third Party Content does not imply approval or endorsement thereof by us. If you decide to leave the Website and access Third Party Websites, you do so at your own risk and you should be aware that our terms and policies no longer govern. You should review the applicable terms and policies, including privacy and data gathering practices, of any site to which you navigate from the Website. 
 10.4.	Assignment
These Terms, or your rights and obligations hereunder, may not be transferred by you, but may be assigned by us without restriction (without having to seek your prior consent). Any attempted transfer or assignment by you in violation hereof shall be null and void. These Terms shall be binding and inure to the benefit of the parties hereto, our successors, and permitted assigns. 
 10.5.	No-Waiver
The failure of Jupiter Lock to exercise or enforce any right or provision of these Terms shall not constitute a waiver of such right or provision in that or any other instance. If any provision of these Terms is held invalid, the remainder of these Terms shall continue in full force and effect. If any provision of these Terms shall be deemed unlawful, void or for any reason unenforceable, then that provision shall be deemed severable from these Terms and shall not affect the validity and enforceability of any remaining provisions. 
 10.6.	Relationship of the parties
You agree and understand that nothing in these Terms shall be deemed to constitute, create, imply, give effect to, or otherwise recognize a partnership, employment, joint venture, or formal business entity of any kind; and the rights and obligations of the parties shall be limited to those expressly set forth herein. Except for the indemnity and exculpation provisions herein, nothing expressed in, mentioned in, or implied from these Terms is intended or shall be construed to give any person other than the parties hereto any legal or equitable right, remedy, or claim under or in respect to these Terms to enforce any of its terms which might otherwise be interpreted to confer such rights to such persons, and these Terms and all representations, warranties, covenants, conditions and provisions hereof are intended to be and are for the exclusive benefit of you and us. 
 10.7.	Notices
To give us notice under these Terms, the user must contact Jupiter Lock by email at legal@jup.ag. 
 10.8.	Entire Agreement
These Terms and our Privacy Policy, incorporated by reference herein, comprise the entire understanding and agreement entered into by and between you and us as to the subject matter hereof, and supersede any and all prior discussions, agreements, and understandings of any kind (including without limitation any prior versions of these Terms), as well as every nature between and among you and us. 
 10.9.	Severability
If any provision of these Terms shall be determined to be invalid or unenforceable under any rule, law, or regulation of any local, state, or federal government agency, such provision will be changed and interpreted to accomplish the objectives of the provision to the greatest extent possible under any applicable law and the validity or enforceability of any other provision of these Terms shall not be affected. If such construction is not possible, the invalid or unenforceable portion will be severed from these Terms but the rest of these Terms will remain in full force and effect. 
 10.10.	Survival
The following provisions of these Terms shall survive termination of your use or access to the Website: the sections concerning Intellectual Property, Disclaimer of Warranties, Limitation on Liability, Waiver, Applicable Law and Dispute Resolution, and General Provisions, and any other provision that by its terms survives termination of your use or access to the Website. 
 10.11.	English language
Notwithstanding any other provision of these Terms, any translation of these Terms is provided for your convenience. The meanings of terms, conditions, and representations herein are subject to their definitions and interpretations in the English language. In the event of conflict or ambiguity between the English language version and translated versions of these terms, the English language version shall prevail. You acknowledge that you have read and understood the English language version of these Terms.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/4-get-your-token-on-jupiter.md', 'sidebar_label: "How to Get Your Token on Jupiter"
description: Learn to list your token on Jupiter, ensuring liquidity and metadata compliance for enhanced safety.
title: Get Your Token on Jupiter 

     How to Get Your Token on Jupiter 
     

 
 How to Get Your Token Verified 
 All unverified tokens are marked with a  ''⚠️’  label to encourage users to double-check that the mint addresses are the right ones before trading. 
 If you''ve created a token and want to get it verified on the Jupiter Ecosystem List, you can submit your token for review on  catdetlist.jup.ag . 
 For approval, your project needs to: 
 
 Be at least 21 days old 
 Have daily volume of more than 10K 
 Have a market cap of more than 100K 
 Have unique metadata (Symbol and Name does not duplicate another project on the community list) 
 Have more than 500 unique holders 
 
 :::tip Note
Your token does not have to be verified to be tradable. All new pools are supported for instant routing for  14 days  before pools get re-evaluated. Remind your users to search via your mint address so they can swap safely!
::: 
 More resources on the community tag initiative can be found here: 
 
 Community Tag Application Site :  https://catdetlist.jup.ag/ 
 Community Tag FAQ :  https://www.jupresear.ch/t/faq-jupiter-community-tag/23074 
 Community Tag Overview :  https://www.jupresear.ch/t/get-your-token-a-community-tag/18963 
 Master Token List API :  https://www.jupresear.ch/t/ecosystem-master-token-list/19786 
 
 How to Get Your Pool Routed on Jupiter 
 To provide users access to new tokens, all new markets on supported AMMs are instantly routed for  14 days . 
 After 14 days, markets that fit the criteria will continue to be routed on Jupiter. 
 :::tip Supported AMMs
We currently support Fluxbeam, Meteora DLMM, Meteora CPMM, 1Intro, Pump.Fun, Raydium CLMM, Raydium CP, Raydium V4 and Whirlpools for Instant Routing.
::: 
 To ensure your market gets routed on Jupiter after 14 days, your market must fit  one of the following criteria : 
 
 Less than 30% price impact on $500 
 
 Using a benchmark position size of  $500 , a user should encounter less than  30%  price impact after swapping in AND out of the token from the same pool. 
 Price Impact = ($500 - Final USD value) / $500
 
 For example, a user swaps  $500  worth of SOL into the token, then swaps the same output amount back into SOL. We then use the formula to calculate the price impact percentage. 
 If the price impact is more than  30% , it means that there is insufficient liquidity in the pool for the benchmark position size of  $500 . 
 
 
 (For additional markets)   Less than 20% price difference on new pools 
 
 For additional markets on already supported tokens, there should be a variance of less than  20%  between the new pool and the pool existing in routing.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/7-media-kit.md', 'title: Jupiter Media Kit
sidebar_label: "Media Kit"
description: "Get the official Jupiter media kit, including logo, brand materials, and the $JUP token icon. " 

     Download the Jupiter Media Kit | Jupiter Station 
     

 Please find official Jupiter information, imagery, infographics, and contacts below for your own use. 
 For additional info or media inquiries, please contact feedback@jup.ag 
 Or contact Jupiter through  Twitter  or  Discord', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/6-faq.md', 'title: Frequently Asked Questions
sidebar_label: "Jupiter FAQ"
description: "Discover FAQs on Jupiter Swap, DCA, and more. Get quick answers and master Jupiter''s trading tools." 

     Frequently Asked Questions | Jupiter Station 
     

 Jupiter Swap Aggregator 
 Does Jupiter swap charge any fees? 
 Jupiter does not charge any fees , the transaction fees that you see in the details, are the Solana fees  (aka gas fees) , and if you are swapping into any new token or through a new DEX / AMM, there will be a minor deposit fees / rent fees to create the  ATA (Associated Token Accounts)  which will be refunded when you close the account. 
 Are Liquidity Provider fees included in the quoted price? 
 
 Yes, the displayed price includes liquidity provider fees and price impact 
 You can find the details in the  Price info  table. 
 
 My swap fails, reporting a slippage error. What should I do? 
 
 Slippage occurs because of changing market conditions between the moment the transaction is submitted and its verification. 
 Your slippage rate is an important setting, it works as a protection. If the price falls below your slippage rate, then the transaction will fail in order to prevent you from getting less tokens than you want. 
 You can adjust your slippage. By default, slippage is set to 0.5%, meaning if the price slips more than 0.5% of your quote, the trade will not be completed. 
 Learn more about  slippage and price impact 
 
 What does it mean when I get the ''some routes failed to load...'' 
 
 This means that when Jupiter tried to refresh the routes to fetch the most up-to-date pricing, it failed to return those routes. This could be due to RPC node issues. We won''t let you swap because the current route pricing options we show may be outdated, and that put you at risk of getting the less optimum price. 
 You may try to change the RPC  (setting accessible from the top-right wheel icon)  and refresh the page and try to fetch those routes again. 
 
 How do I integrate Jupiter swap into my protocol / dApp? 
 Protocols / Projects are free to integrate Jupiter swap with  Swap API , Jupiter operates in a decentralized way. That said, we encourage protocols/ projects to reach out to our team when the integration is done and live, we are happy to work together on co-marketing and getting the words out. 
 
 Jupiter Limit Order 
 Does Jupiter Limit Order charge any fees? 
 
 Jupiter Limit Order do charge a platform fees of  0.2%  on taker. 
 In the case of partners integrating Jupiter Limit Order, they will be entitled to a share of 0.1% referral fees, while Jupiter collects the other 0.1% as platform fees. 
 The fees are collected and withheld by the program and are claimable anytime. 
 
 Why is my Limit Order not getting fulfill even when the price hit my limit price? 
 
 Jupiter Limit Order execute your order based on the price that you have set by matching with the available liquidity on-chain across Solana.
A few scenarios or cases where the order is not being fulfill 
 If the order size is too large  (and there is insufficient liquidity on-chain)  - in this case, Jupiter keeper will attempt to execute your order in a smaller chunk to partially fill your orders and will continue to do so until order is fully executed 
 The price wick happen for a very short period of time, and the liquidity have all been taken up at that price. 
 For more information on how Jupiter Limit Order works -  How Limit Order Works 
 
 
 In the Wallet transaction history, of using the Limit order, I see many failed transactions, did I pay for that transaction fees? 
 
 By initiating an order on the limit order, a keeper will try to fill your orders with swaps as soon as the specified price is reached. Sometimes, mostly due to slippage, transactions can fail. 
 The transaction fees for transactions initiated  (and signed)  by the keeper are paid by the keeper. 
 
 
 Jupiter DCA 
 Does Jupiter DCA charge any fees? 
 
 Jupiter DCA do charge a platform fees of  0.1%  on order completion. 
 The fees are collected and withheld by the program and are claimable anytime. 
 
 Will there be any risk of my order getting frontrun? 
 
 Jupiter DCA added some randomness in executing order to prevent potential frontrunning . 
 For more information on how Jupiter DCA works -  How DCA Works 
 
 
 Jupiter Space Station 
 How do I add my protocol / project into Jupiter Space Station partners page? 
 
 To add your protocol or project into Jupiter Station partners page, simply submit a PR to our  Space Station public repo  and share a little about how you utilizing or integrating Jupiter. 
 Here is a sample PR - https://github.com/jup-ag/space-station/pull/98 
 
 Can I contribute to Jupiter Space Station? If yes, how? 
 
 Yes, we welcome anyone to contribute and help us improve Space Station alongside with us. 
 You can submit a PR to our  Space Station public repo , it can be in the form of updating some misinformation / outdated information that we have in Space Station, or you can come up with a community guide to help users and community members to navigate around the Solana ecosystem. Here is an example done by SolanaFM on  How to verify swaps using block explorer 
 
 
 New Token & Token Validation 
 How do I get my new project token to be available to trade on Jupiter? 
 
 All new tokens on supported AMMs are instantly routed on Jupiter for 14 days, and are marked with a ''⚠️’ label to encourage users to double-check that the mint addresses are the right ones before trading. 
 Learn more about how to get your token verified and routed on Jupiter  here . 
 
 
 Others 
 In the Wallet transaction history, I don''t see the swap, did I receive my tokens? 
 
 The wallet transaction history is based on blockchain data decoding. 
 Some wallets may not decode the data correctly. 
 You can check your swap history on Jupiter, from the right menu. 
 From this menu, you can click on the link to the block explorer to check the transaction. 
 Block explorer allows you to check by using the  "SOL Balance Change"  and  “Token Balance Change”  tabs. 
 A swap requires the use of liquidity pools  (LP)  on DEXs. Some DEXs use an LP-token burn mechanism during the swap. This has no impact on the tokens received. 
 
 What does it mean when I see "unable to fetch balance changes" in Phantom? 
 
 This just means the phantom simulator can’t simulate the transaction. 
 The phantom simulator is just a helpful tool to summarize what it thinks is going to happen, but, there are transactions where it''s unable to do that.  It does not guarantee anything and a malicious dApp can still take control of your wallet. 
 If you trust the dApp and have had successful transactions, then there is nothing to worry about. 
 If it''s your first time approving a dApp, click on "view advanced transaction details to review the actual transaction. Pay attention to the amounts approved. Another option is to just use a burner wallet with only the needed funds on your first transaction to protect yourself. 
 
 My swap fails, reporting that the account does not have enough SOL. Why? 
 
 On Solana, you use SOL to pay transactions  (around 0.000005 SOL)  but also to pay rent fees for token accounts. It''s around 0.002 SOL and they are refundable when you close the account. 
 Read:  What does rent for accounts mean? 
 
 What does rent for accounts mean? 
 
 Everything on Solana is an account, if you want to store data, in particularly the amount of a token you own, you must open a new account to hold that data. 
 So for every token you own, you must open an account to store/hold how much of that token you own. 
 To create an account you must pay rent every epoch to maintain it otherwise it will be automatically closed. 
 However if you deposit 2 years worth of rent, then your account becomes rent-exempt and you will be able to keep your account open forever, or until you close it. This deposit of 2 years rent is approximately  0.02 SOL  at the moment. And this is why many programs deduct this amount from your main account to deposit into a token account created to hold the new tokens you''ve just acquired. 
 Token accounts aren''t the only types of accounts that are opened for you. 
 All SOL balances held in these accounts can be reclaimed by closing those accounts. 
 
 My swap fails, reporting my wallet may not support Versioned transaction. I use a Ledger. What should I do? 
 
 This error usually occurs when the ledger is not up-to-date, or just after updating if you haven''t re-allowed blind signing. To solve this:
 
 Check the firmware version and update your ledger if necessary. 
 Allow blind signing in the Solana app on your ledger. 
 
 
 Or you can also try using Jupiter without Versioned Transaction in the swap setting. 
 
 
 How or who do I reach out to for partnerships or collaboration? 
 
 We''re happy to partner and colab with anyone in the ecosystem, please refer to the following READMEs to get featured on the various pages
 
 Github Repo  to  Jupiter Space Station Partner Page 
 Github Repo  to  Welcome to Solana Page 
 
 
 In order for Jupiter to feature you or participate in co-marketing efforts, we require you to clearly indicate and label the usage of Jupiter''s products such as (but not limited to) APIs, widgets, interfaces, etc. 
 If you need further assistance or enquire about marketing efforts, you can reach us in our  discord , we will try to get in touch as soon as possible.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/3-blinks.md', 'sidebar_label: "Actions & Blinks"
description: Explore Blinks on Jupiter''s leap in Solana swapping and boost your trading experience. Seamless integration across platforms. Learn today in our guide!
title: Jupiter, Action & Blinks 

     Blinks on Jupiter: Innovative Solana Swap Actions | Jupiter Station 
     

 Jupiter: Actions & Blinks 
 Jupiter is a partner of Solana Actions, which power Blockchain Links (Blinks) across the ecosystem. 
 Currently, you can make Swap Blinks on Twitter, with the goal of bringing Jupiter to meet more users, wherever they are. 
 Read More: 
 
 Solana''s Announcement 
 Dialect''s Announcement 
 Dialect''s Documents 
 
 Swapping on a Swap Blink 
 
 Enable Blinks on your Wallet. Read the Guides (Phantom, Backpack) 
 Watch the Blink unfurl on Twitter. 
 Click (or input) the amount to swap. 
 Sign the Wallet TX. 
 
 
 And you''re done! 
 Creating a Swap Blink 
 
 Go to https://jup.ag, and then select the desired input and output token. 
 Copy the URL, it should look something like this https://jup.ag/swap/SOL-JUP 
 Post it on Twitter! 
 
 
 Users can now swap with your Blink, if their wallet has Blinks enabled.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/5-wrapped-sol.md', 'sidebar_label: Wrapped SOL
description: Learn what Wrapped SOL (wSOL) is and its benefits for trading. Quick insights and tips at Jupiter Station.
title: What is Wrapped SOL (wSOL)? 

     Wrapped SOL (wSOL) Explained | Jupiter Station 
     

 Wrapped SOL is native SOL that is wrapped using the Solana Token Program, which allows it to be treated like any other Token program token type. 
 :::tip
You can now use wSOL (wrapped SOL) to trade directly with any SPL token on Jupiter!
This makes Jupiter even faster and more convenient for traders who trade frequently with SOL, since it avoids having to wrap/unwrap SOL, which might result in multiple transactions when the routes are complicated.
::: 
 Why the need to wrap SOL 
 Currently, Jupiter has to wrap and unwrap SOL when trading in SOL due to the fact that native SOL itself is not an SPL token. 
 To read more about wrapping SOL, please click  here . 
 To read more about transferring tokens, please click  here . 
 Because of Solana''s transaction size limits, sometimes we need to break up the transaction into multiple ones when wrapping is involved. This can be a source of friction for power traders who transact a lot. 
 We expect this problem to be resolved with the upcoming transaction size increase in the next Solana upgrade. In the meantime, we have a new feature that allows users to trade directly in wSOL. 
 
 
 
 The Wrap and unwrap tool bar 
 
 
 
 The swap setting to turn on/off of using wSOL 
 Once wSOL is toggled on, user will see wSOL as the default for SOL in the token selector 
 
 Enabling Jupiter wSOL feature 
 
 To enable this feature, go to "Swap Settings" and turn on "Use wSOL". 
 
 
 
 Once enabled, "wSOL" will show up on your Jupiter swap where you can turn on or turn off for your swaps. 
 
 Regular mode (wSOL disabled and/or off) 
 The regular mode that most users will experience is where the wSOL feature is disabled and/or off. There is no difference to the day-to-day trades that you are currently doing - for any transactions involving SOL, Jupiter will automatically do the wrapping and unwrapping of wSOL behind the scenes to facilitate your token swaps. 
 :::info
Jupiter will still be able to detect if you have wSOL and provide an option to unwrap it back to SOL.
::: 
 wSOL mode (wSOL enabled and switched on) 
 The wSOL mode is for advanced users who are familiar dealing with the wSOL token and wish to experience better performance and control for their swaps. 
 
 With wSOL switched on, all trades will transact in wSOL instead of SOL by default. This means that so long you have sufficient wSOL, you can immediately execute your swaps. The wSOL received will also not be automatically unwrapped to native SOL. 
 You will be able to manually wrap SOL and unwrap wSOL. 
 
 
 Wrap SOL - wSOL feature 
 
 Easily wrap SOL into wSOL by either clicking on "Manage" or "Wrap SOL now" link in wSOL enabled mode. 
 
 Unwrap wSOL feature 
 
 Our unwrap wSOL feature currently only processes unwrapping of all existing wSOL in your wallet to SOL, we do not support partial unwrapping. 
 
 To read more about closing SOL accounts, click  here .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/2-verify-swaps-with-SolanaFM.md', 'sidebar_label: ''Verifying Swaps''
description: Learn to verify and track swaps on Solana effectively with our concise guide at Jupiter Station. Perfect for all traders.
title: Verifying Swaps on a Block Explorer 

     Verifying Swaps on Solana: A Step-by-Step Guide 
     

 :::tip This is a community contributed guide
This is a community guide to verifying Jupiter swaps on a Block Explorer, created by  @0xmiir , Marketing Lead at SolanaFM. 
 Anyone can contribute a guide to Jupiter Station! Simply send us a PR.
::: 
 When swapping tokens on Solana, you might come across occasional hiccups — sometimes transactions might not go through, a different amount of tokens may appear in your wallet, or the token doesn’t appear at all. How do you figure out what’s going on? 
 This guide will walk you through how to verify your swaps on Jupiter. 
 :::tip Pro-tip: You can set your Default Explorer
To set a Default Explorer, click on the  ''settings''  icon in the Jupiter app and set your ''Preferred Explorer''.
::: 
 Viewing Your Swap Transaction 
 
 In this scenario, I’ve swapped  0.5SOL  for an estimated  10.08USDC  via  Saber  and  Orca . 
 After completing the swap, the status of the swap appears on the bottom left of the interface — Let’s verify the details of the swap using the  SolanaFM Explorer . 
 Verifying your Swap 
 On SolanaFM, you can verify: 
 
 Transaction Failure/Success 
 Instructions Executed (The operations taking place within the transactions) 
 Movement of tokens (e.g. in and out of your wallet) 
 
 Let’s go through these in more detail. 
 Transaction Failure/Success 
 
 At the top of the transaction interface, you can easily verify the status of the transaction. 
 A successful transaction shows “Success”, “Finalized” and “Maximum Confirmations Achieved”, while a failed transaction will show “Error”. 
 Instructions Executed 
 Instructions within a transaction refer to the operations that have taken place for this transaction to happen successfully. 
 
 Here, we can see that the  Jupiter Program  had interacted with the  Saber Stable Swap Program  and the  Orca Whirlpool Program  for the swap to take place. 
 Swap 1: 0.25  SOL  → 0.225  stSOL 
 Swap 2: 0.225  stSOL  → 5.04  USDC 
 Swap 3: 0.25  SOL  → 5.04  USDC 
 Movement of Tokens 
 The Transaction Flow helps us understand which tokens moved, and how much of each token moved in and out of your wallet accounts. 
 
 We’ve seen from the Instructions that 50% of the SOL amount was swapped into stSOL before being converted into USDC (via Saber), while the other 50% was converted directly into USDC (via Orca). 
 Movement 1: 0.5 SOL is converted and transferred into a wSOL token account 
 Movement 2: 0.25 SOL is converted into 0.2255 stSOL 
 Movement 3: 0.2255 stSOL is converted into 5.04 USDC and transferred into the original Sender account 
 Movement 4: 0.25 wSOL is converted into 5.04 USDC and transferred into the original Sender account 
 Once you confirm the transaction tallies with the details shown on the block explorer, you’re good to go. LFG!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/1-personal-security-on-solana.md', 'sidebar_label: "Personal Security On Solana"
description: A short guide to keeping your assets secure as you enjoy Jupiter and Solana.
title: Personal Security on Solana 

     Personal Security on Solana: Safeguard Your Assets 
     

 :::tip This is a community contributed guide
This is a community guide to personal security on Solana, created by  @julianhzhu . 
 Anyone can contribute a guide to Jupiter Station! Simply send us a PR.
::: 
 Personal security on Solana can be understood in two parts -  private key security  and  transaction security . 
 1 - Private Key Security 
 Private key security is about ensuring that your private keys stay private and only known to you.
:::info
Like all blockchains, your assets on Solana are not actually “stored” in your wallet, they are “stored” on accounts on the blockchain.
:::
Whoever has the private key will be able to sign transactions and transfer these assets in the wallet to other accounts on the blockchain. Hence it is extremely important that you keep your private key safe and only known to yourself. 
 Closely related to the private key is the concept of a seed phrase/passphrase. These are usually made up of 12 or 24 random words. Each passphrase can typically be used to generate many private keys and their corresponding public addresses. If your passphrase is stolen, the hacker will get access to  all  your wallets controlled by that passphrase. 
 Quick Recap 
 
 One  seed phrase/passphrase → can generate  many  private keys. 
 One  private key →  One  public key/wallet address 
 Whoever has the private key can take ownership of the assets on the wallet, so we should keep this private. 
 
 For the regular Web3 user 
 :::tip A few simple steps you can take 
 
 Never screenshot or store your private key & seed phrases in plain text. 
 If you need to store them on any device, consider using a password manager for example  Bitwarden  that has a free version for personal use. This will ensure that they are stored with  encryption . 
 Install a trustworthy antivirus and malware scanner and keep it up-to-date with regular scheduled scans. E.g.  Bitdefender ,  Malwarebytes  are some of the highly-rated ones with a free option available for basic use. 
 Avoid pointing any camera at your seed phrase & private key or revealing it in public. 
 
 ::: 
 Other Considerations 
 Physical Security 
 
 Who else has access to the space where your device is stored? 
 Are your hardware wallets and backups locked up in a safe? 
 Do you have secondary backups in second physically secure location? 
 
 Hardware 
 
 How secure is the user’s device? Are there any backdoors on the device itself? 
 
 Software 
 
 Malware, virus, malicious files that scan your filesystem and steal the keypair files 
 Input capture such as keyloggers, screen capture applications 
 
 Best Practices 
 
 Use a safe hardware wallet where the private key never leaves the wallet. 
 Consider the use of multisig wallets with keys stored separately and safely for high-valued assets. 
 Encrypt all files containing the private key when stored on the local filesystem. 
 Be careful when installing any software that may capture your system’s inputs and/or scan your file system. 
 Avoid installing any fake/pirated software as these often contain malware. 
 Install all wallet software from official sites only, double-check they are the correct URL before downloading as there are many fake wallet sites. 
 
 2 - Transaction Security 
 The second aspect of personal on-chain security is transaction security. This is different from private key security in that attackers do not need to get hold of your private key in order to steal your funds from you. All they need to do is to trick you to sign a transaction that does a malicious transfer of assets. 
 The good news is that preventing this type of attacks is easy and 100% within your control as long as you incorporate a few good practices to your journey on Solana. 
 Transaction Simulation 
 Transaction simulation by modern Solana wallets are extremely powerful tools to help safeguard you from loss of funds. 
 
 Always pay attention to what is written and if a transaction simulation fails or is reverted, as a general rule, do  NOT  sign the transaction. You really only want to break this rule if you are a thousand percent certain that the site you are on is a legitimate site and that there is a very good reason that you are aware of as to why the transaction is failing to simulate. 
 Understanding URL Structure 
 Learning to recognise the structure of URLs is very important so that you can avoid fraudulent sites. This practice is called typo-squatting and malicious sites will go to great lengths to mimic legitimate sites with the only difference being a single character in the URL. 
 Let’s take a look at an example 
 https://lfg.jup.ag/jup 
 The trick is to always look for the position of the  dots  (periods) in the URL. 
 A URL will either have 1 or 2 dots. 
 In the example above, there are 2 dots, one after “lfg” and one after “jup”/before "ag". Double-check it for yourself and make sure you are following along with this example. 
 Since there are 2 dots in this URL, then what you need to pay attention to is what is  after the first dot . For example lfg.jup.ag, after the first dot is “jup.ag”.  If this is an official domain then it is safe. 
 If there is only 1 dot in an URL, for example https://twitter.com then you need to pay attention to the  parts surrounding the dot . If that makes an official website domain, then the URL is safe. An example twitter.io would not be safe and could be malicious for example. 
 Scammers will often register similar-looking domains such as lfg-jup.ag to try and trick you. Notice in this case there is only 1 dot, hence you need to look at both parts surrounding the dot. Clearly lfg-jup.ag is NOT an official site and it is a fake site trying to trick you. 
 Here are some more links for you to practice your scam-link identification skills. Some of the urls may not even exist. The list is just for you to practice. 
 
 beta.jup.ag ✅
 
 2 dots, so we look at what''s after the first dot, in this case jup.ag is an official site. 
 
 
 www.jup.ag ✅
 
 2 dots, so we look at what''s after the first dot, in this case jup.ag is an official site. 
 
 
 beta-jup.ag ❌
 
 1 dot, so we look at what''s surrounding the dot, in this case beta-jup.ag is not an official site. 
 
 
 jup-ag.com ❌
 
 1 dot, so we look at what''s surrounding the dot, in this case jup-ag.com is not an official site. 
 
 
 jup.io ❌
 
 1 dot, so we look at what''s surrounding the dot, in this case jup.io is not an official site. 
 
 
 lfg-jup-ag.com ❌
 
 1 dot, so we look at what''s surrounding the dot, in this case lfg-jup-ag.com is not an official site. 
 
 
 jup.jup.ag ✅
 
 2 dots, so we look at what''s after the first dot, in this case jup.ag is an official site. 
 
 
 
 Alpha:  You can also use this method to sometimes guess what the actual URLs of new releases or features may be and get there before everyone else! 
 :::tip 
 Always  double-check the URL  of the domain in the browser URL bar before interacting with any site.
::: 
 Social engineering attacks 
 This can happen in Discord, Telegram, Twitter, basically anywhere with communication taking place. How it works is that scammers will try to post a fake link. If you are careful and check the URL in the browser bar before doing anything on a site, you will be safe. 
 Note, even if you accidentally connect your wallet, As long as you did not sign any transactions, you are still safe. See the part on transaction simulation as a safeguard. 
 For the regular Web3 user 
 :::tip A few simple steps you can take 
 
 Never rush. Whenever you rush, it is more likely that you will make mistakes. 
 Avoid signing a transaction that does not clearly simulate in the wallet. Read all balance changes shown in the simulation carefully before signing any transaction. 
 If you really really have to sign something on an untrusted site or sign a transaction that does not simulate, always use a separate wallet with very limited funds to minimize any possibility of a malicious transaction draining all of your funds. Creating a new wallet is very easy on most wallet apps and it is very cheap to fund new wallets on Solana due to low fees. Don’t be cheap or lazy. 
 
 ::: 
 And with that, I wish you all the best on your journey on Solana. It no doubt has one of the best user experience across any blockchain and by following these tips I have shared here, I am confident that you will have a great time here.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/12-general/8-edge.md', 'title: Edge
sidebar_label: "Edge"
description: "Explore the latest cutting-edge tech features on Edge. Try out new features and give your feedback." 

     Edge: Explore Jupiter''s latest cutting-edge features 
     

 
 What is Edge? 
 Edge, or  edge.jup.ag , is Jupiter''s innovation testing ground, designed for power users who want to experiment with cutting-edge tech before they are released on  jup.ag . 
 On Edge, we ship our newest features for Spot and Perpetuals, let users try it out and give us feedback,    then we re-iterate and improve on the features before it lands into the production site. 
 How to Access Edge 
 Anyone can access  edge.jup.ag  and help us out with testing. However, please note that the latest features are still in Beta and may not function perfectly as intended. 
 How to Find New Features on Edge 
 Edge includes a changelog that highlight the latest features and additions, making it easy for you to see what’s new and available for testing. 
 
 How to Provide Feedback 
 If you want to report a bug or suggest something new, you can join our Discord server and create a ticket/post a message in the  ‘💭 · edge-jup-ag’  channel. 
 
 The goal of Edge is to create a  continuous feedback loop : 
 
 We add new features into the changelog 
 You try them out and tell us what you like/dislike 
 We reiterate and improve on the features 
 
 Your feedback is crucial in helping us improve Jupiter! 
 Try It Out 
 
 Visit  edge.jup.ag  and start exploring the latest features on Jupiter 
 Join the Jupiter Discord server ( discord.gg/jup ) and give us your feedback!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/9-jupsol/1-jupsol.md', 'sidebar_label: "JupSOL Overview"
description: "Discover JupSOL, offering high APYs, zero fees, and strong security. Earn rewarding staking and MEV returns while staying liquid in DeFi."
title: "JupSOL Overview" 

     JupSOL Explained: Elevate Earnings with Jupiter''s Rewards 
     

 JupSOL -  A Liquid Staking Token 
 JupSOL represents staked Solana (SOL) tokens with Jupiter’s validator, which is hosted and managed by Triton. Jupiter passes all validator rewards collected and 100% of MEV (Maximal Extractable Value) along to stakers for maximum yield. The JupSOL token is issued through Sanctum. 
 Review the official JupSOL announcement forum post  Here . 
 How does JupSOL Work? 
 SOL that’s deposited into JupSOL is staked. The staking rewards from that SOL accrue to the JupSOL token, which starts at 1:1 with SOL and grows in value over time relative  to  SOL. (Note that while JupSOL  will always  increase relative  to SOL, it may still lose value in  dollar  terms.) By simply holding JupSOL, you will earn staking rewards. 
 Where does the yield come from? 
 JupSOL earns staking yields and MEV kickbacks from Jupiter’s validator, which has no fees. Additionally, the Jupiter team has delegated 100K SOL to the Jupiter validator. They will use the yield from that SOL to enhance the APY of JupSOL. Expect to see higher than average APYs on JupSOL compared to regular LSTs. 
 
 For Example: 
 
 When the JupSOL validator pool was launched, 1 JupSOL = 1 SOL. 
 Assuming a 10% APR (inclusive of all rewards) and a Solana epoch time of ~2 days that equates to ~0.000547945 SOL rewards per epoch. 
 At the end of one epoch, 1 JupSOL = ~1.000547945 SOL. 
 At the end of two epochs, 1 JupSOL = ~1.001096191 SOL. 
 And at the end of one year, 1 JupSOL = ~1.105163349 SOL due to compounding rewards. 
 
 JupSOL Fees 
 
 0% management fee 
 0% validator commission 
 0% stake deposit fee 
 0.1% SOL deposit fee 
 0% withdrawal fee 
 
 :::info Arbitrage Protection
Jupiter charges a small SOL deposit fee to prevent an arbitrage attack on the pool.
::: 
 JupSOL Security 
 JupSOL is powered by the SPL stake pool program. The SPL stake pool program is one of the safest programs in the world. It has been  audited multiple times , is used by the largest stake pools like jitoSOL and bSOL, and has secured more than $1B of staked SOL for years without any issues. 
 The program authority is secured by a multisig that includes, among others, members from Sanctum, Jupiter, Mango, marginfi and Jito. Any changes to the program will have to be approved by a majority vote from this multisig. No single party can unilaterally change the program. We plan to significantly grow the size of the multisig and eventually freeze the program. 
 For more details, check out this post on  Sanctum . 
 Benefits of Holding JupSOL 
 Buying and holding JupSOL helps you earn native staking yields on your SOL; this is the “risk-free” rate of SOL. As an extra incentive to hold JupSOL, Jupiter is returning all validator MEV rewards to JupSOL. This should lead to higher APY than native staking. 
 When you hold JupSOL, you also help Jupiter improve its transaction inclusion rate, making it easier for all Jupiter users to swap, DCA or place limit orders in congested conditions. 
 What is a Liquid Staking Token? 
 Liquid staking lets you participate in DeFi while earning staking yields. Liquid staking solves the  Staking Dilemma  by giving you the best of both worlds – it lets you secure the network and use your SOL at the same time. 
 You can think of staking as putting gold in a vault, and liquid staking as issuing a piece of paper money (an IOU, "I owe you") for the gold in that vault. In the same way that a paper IOU can be redeemed at any time for the gold, a liquid staking token (LST) can be redeemed at any time for unstaked SOL. Unlike natively-staked SOL, this liquid staking token is transferable. It can be used in all of DeFi – borrow-lend, perps, stablecoin issuance, etc.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/6-ape/4-faq.md', 'sidebar_label: FAQ
title: Ape Pro Frequently Asked Questions
description: Have any questions about Ape Pro? This page might have just the answer!
slug: /apepro/faq 

     : Frequently Asked Questions | Ape Pro 
     

 Q: What are ApePro’s fees? 
 
 A : ApePro charges a platform fee of 0.5% on swap transactions. 
 
 Q: I logged in via Phantom/Solflare. Why is my Ape vault address different? 
 
 A : Your Web3 login acts like a key to generate and access your Ape vault which is an entirely separate wallet address. 
 
 Q: Can I import an existing Phantom account into ApePro? 
 
 A : No. Refer to the  Ape Account Program  to learn more. 
 
 Q: Can I export my private key? 
 
 A : Not at the moment. ApePro uses a smart wallet program that differs from traditional wallets like Phantom. Refer to the  Ape Account Program  to learn more. 
 
 Q: How do I access my referral link? 
 
 
 A :  The Referral Program is currently available to a select group of early access users, public access coming soon! 
 Obtain your ref link via: 
 
 The Referral page, accessible via the  Refer  button 
 Pressing the  Share Icon  your URL from any token page. This copies your current URL (your ref ID is appended automatically). 
 Sharing your PnL flex card 
 
 You are required to activate your account via a minimum 0.1 SOL deposit in order to earn ref fees. 
 
 
 Q: Is there an ApePro mobile app? 
 
 A : Currently, there is no dedicated Ape.Pro mobile app. However, you can add the ApePro web app to your home screen for an app-like experience. Refer to the  Mobile Optimisation Hack  to learn more. 
 
 Q: What is the Safety Checklist? 
 
 A : A checklist that provides token risk assessments, including checks for  Mint Authority ,  Freeze Authority ,  LP burnt % ,  top 10 holders ,  Dev mints  and potential rug pull indicators.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/6-ape/2-limit-order.md', 'sidebar_label: Limit Order (v1)
title: ApePro Limit Order (v1)
description: Learn more about Ape Pro''s Limit Order mechanism.
slug: /apepro/limit-order 

     ApePro Limit Order (v1) 
     

 ApePro Limit Order (v1) allows users to set a Target Price/Mcap (to be referred to interchangeably) for a trade to be automatically executed once specified conditions are met. Once the order is placed, Ape’s Keeper will continuously monitor the target level and execute the swap when the market price reaches your specified price. 
 Understanding Limit Orders on ApePro 
 On ApePro, limit orders are executed as  market orders within a specified slippage tolerance  once certain price conditions are met. While you can input a target market cap as a reference,  the actual trigger for executing your order is the token''s price , not its market cap. 
 When you create your orders,  your MEV protection and slippage settings are saved  and will be applied when the target price is reached. Consequently, the success of your limit orders depends on whether sending transactions via RPC or Jito (MEV Protect) is most suitable under current market conditions. 
 Diagram 
 
 Types of Limit Orders 
 ApePro supports four types of limit orders to suit different trading strategies: 
 
 Take Profit : Sell a token when its Target Price cap reaches a specified higher level to secure profits. 
 Stop Loss : Sell a token when its price / market cap drops to a specified lower level to prevent further losses. 
 Buy Dip : Buy a token when its price / market cap falls to a specified lower level, allowing you to capitalise on price dips. 
 Buy Above : Buy a token when its price / market cap rises to a specified higher level, allowing you to buy, allowing you to capitalise on expected momentum. 
 
 Setting Up Limit Orders 
 To set up a limit order: 
 
 Select the  Limit  Tab : Navigate to the swap widget and click on the  Limit  tab to access limit order options. 
 Input Trade Details :
 
 Trade Amount : Enter the amount of the token you wish to buy or sell. 
 Target Price or Market Cap : Input your target price. You can also enter a market cap as a reference, but remember that  the price is what triggers your order . 
 
 
 Review and Create Order : Double-check all the details of your order and confirm to create a limit order. 
 
 Managing Your Limit Orders 
 ApePro provides intuitive tools to help you monitor and manage your orders: 
 
 Orders Tab : Located under the chart component, this tab is your central hub for all order-related activities. 
 Open Orders :
 
 Access the  Open Orders  tab to view all your active limit orders. 
 Use filters to narrow down orders for the current token. 
 Cancel your orders here or on the chart. 
 
 
 Order History :
 
 The  Order History  tab displays all your past orders. 
 Here, you can see:
 
 Successful Orders : Details about completed orders — the amount received, the price or market cap your order was filled at etc. 
 Failed Orders : Reasons for failure, such as slippage issues or expired orders. 
 Expired Orders : Any orders that have passed the 72hr expiry.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/6-ape/1-overview.md', 'sidebar_label: Ape Pro Overview
title: Ape Pro Overview
description: Trade meme coins safely with Ape''s unique vault technology. Enjoy low fees and dynamic slippage for secure, uninterrupted transactions. Ape in today!.
slug: /apepro/overview 

     Ape Pro Overview: Ape Memes, Ape Pro 
     

 ApePro is Solana’s Memecoin Terminal, bringing traders pro-performance while having superior mobile optimisations, featuring: 
 🍌  MPC based AA program with social logins (powered by Web3Auth) 
 🍌  Best price swaps with the lowest platform fees (0.5%) on top of intelligent fee optimisations (powered by Jupiter) 
 🍌  Signless MEV protected swaps (powered by Jito) 
 🍌  Real-time charts, transactions, data, everything! 
 Features 
 Ape Account Program 
 
 Seamless Logins : Both social logins and Web3 methods are supported; Goodbye seed phrases. 
 Secure Accounts : ApePro uses Multiparty Computation (MPC) for securing accounts, ensuring security without compromising usability. 
 Smart Wallet Program : ApePro operates on a proprietary Solana program, which differs from your typical Externally Owned Account (EOA) that you access via wallet providers like Phantom and Solflare. The ApePro program allows the platform to implement advanced functionalities such as instant signless transactions, intelligent fee optimisations and automatic transaction retries. While you own the private key, the platform is currently restricting access to exporting the private key as current wallet providers like Phantom and Solflare do not support this, and this otherwise will cause more user confusion 
 Easy Account Activation : Simply deposit at least 0.1 SOL to activate your Ape Vault and you can get started 
 Withdrawals : Ape currently only supports withdrawal of SOL and not other tokens 
 
 New Tokens Feed 
 
 Real-Time Token Feed : View tokens launched in the past 24 hours to discover new opportunities. 
 Quick Buys & Sells:  Trade tokens quickly directly from the feed without the need to sign wallet transactions for each trade. 
 Filters : Customise the token feed by applying filters such as:
 
 Show Pump.fun : Show tokens created via Pump.fun. 
 Dev Mints : No. of tokens minted by token dev. 
 Token Checklist : Mint Authority Disabled, Freeze Authority Disabled, LP locked/ burned, Top 10 holders. 
 At least one social : Tokens with at least one social link. 
 Metric Ranges : Set minimum and maximum values for 24h Volume, Market Cap, Bonding Curve %, Liquidity, 24h Transactions, Buys, and Sells. 
 
 
 
 Hunt Gems Feed 
 
 Real-time feed of new and emerging tokens, categorised into three sections:
 
 New Creations : Newly created tokens with at least one liquidity pool. 
 Graduating Soon : Pump.fun tokens with bonding curve progress above 50%. 
 Graduated : Pump.fun tokens that have migrated liquidity to Raydium. 
 
 
 Quick Buys & Sells:  Trade tokens quickly directly from the feed without the need to sign wallet transactions for each trade. 
 
 Signless MEV-Protected Swaps 
 
 MEV Protection : Execute accelerated swaps without signing wallet transactions, protected from Miner Extractable Value (MEV) attacks, powered by Jito. 
 Intelligent Fee Optimisations : Benefit from automatic fee adjustments to minimise swap costs. 
 Best-Price Swaps:  Access best-price swaps through integration with the Jupiter router, ensuring competitive rates across liquidity pools. 
 Near-Instant Trading : Trade tokens FAST without the need to sign wallet transactions 
 
 Managing Positions and PnL 
 
 Positions Management : Monitor all your open positions and track profit and loss (PnL) 
 Portfolio balances : View your net worth and token balances 
 Trade History : View past trades with their relative time labels (e.g. 4h), token amounts traded and a link to the block explorer 
 
 Realtime Charts and Transaction 
 
 Realtime Charts : Access realtime charts to view token prices and market cap
 
 Quote Denomination : On the TradingView chart widget, users can switch between denominating token prices or marketcap in  SOL  or  USD 
 Show price or marketcap : You can switch between viewing p rice  or m arketcap  on the chart 
 Dev Trades : You can visualise buy and sell labels of the token deployer on the chart 
 
 
 Transaction History : Monitor trades for a token and view your transaction history 
 
 Token Checklist 
 
 Risk Indicators : Assess risks by checking if liquidity pools are burned or locked, monitoring top 10 holders, and detecting developer mints.
 
 Mint Authority : Ability for devs to mint new tokens 
 Freeze Authority : Ability for devs to freeze token accounts 
 LP burned/Locked : % of liquidity pool burned. Green check if
more than 50% burned 
 Top 10 Holders : % owned by top 10 holders. Green check if
top 10 holders owns less than 15% 
 Dev Mints : Number of tokens minted by token dev 
 
 
 
 Mobile Optimization 
 
   🍌  Mobile UX Hack 
 
 Use ApePro on mobile devices with optimised UI/UX 
 You can add the ApePro web app to your home screen for an app-like experience
 
 
 For iOS (Safari Browser) : 
 
 Open  ape.pro  in Safari. 
 Tap the  Share  icon at the bottom of the screen. 
 Scroll down and select  Add to Home Screen . 
 Tap  Add  in the upper-right corner. 
 
 
 
 For Android (Chrome Browser) : 
 
 Open  ape.pro  in Chrome. 
 Tap the  Menu  icon (three dots) in the upper-right corner. 
 Select  Add to Home screen . 
 Tap  Add . 
 
 
 
 
 
 By adding ApePro to your home screen, you can access it with a single tap, just like a native app. This Progressive Web App (PWA) provides an immersive, full-screen experience.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/6-ape/3-referral-program.md', 'sidebar_label: Referral Program
title: Ape Pro Referral Program
description: Learn more about Ape Pro''s referral program.
slug: /apepro/referral 

     : Ape Pro Referral Program 
     

 ApePro offers a Referral Program to reward users for inviting frens to the platform. The Referral program is currently only available to early access users and whitelisted partners. It will be opened to public on 24th Oct 2024. 
 For Referrers 
 
 
 Earnings : Earn 50% of the platform fees from your referees. 
 
 
 Activation Requirement : Deposit a minimum of 0.1 SOL to activate your account and start earning referral fees. 
 
 
 Sharing Referral Link : 
 
 The Referral page, accessible via the  Refer  button 
 Pressing the  Share Icon  your URL from any token page. This copies your current URL (your ref ID is appended automatically). 
 Sharing your PnL flex card 
 
 The Referral Program is currently available to a select group of early access users, public access coming soon! 
 
 
 For Referees 
 
 Discount : Receive a 10% discount on platform fees (undiscounted fee is 0.5%) when signing up through a referral link. 
 Activation Requirement : Deposit a minimum of 0.1 SOL to activate your account and start earning referral fees. 
 
 Referral Link Format 
 
 Example :  https://ape.pro/login?ref=[refid]', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/8-perpetual-exchange/1-overview.md', 'sidebar_label: "Perpetual Exchange Overview"
title: "Perpetual Exchange Overview"
description: Explore Jupiter Perps for up to 100x leverage on Solana, seamless swaps, and optimized trading strategies. 

     Understanding Jupiter Perps: Trading on Solana 
     

 The  Jupiter Perpetuals  decentralized exchange allows traders to open leveraged (up to 100x) long and short positions for the following tokens: 
 
 SOL 
 ETH 
 wBTC 
 
 Traders can deposit or withdraw collateral to manage their position, and close their positions fully or partially. The Jupiter Perpetuals exchange uses price oracles for token prices. So, large trades will not incur price impact like traditional derivatives platforms. 
 Liquidity for the Jupiter Perpetuals exchange is provided by the  JLP Pool , which holds  SOL ,  ETH ,  wBTC ,  USDC , and  USDT  as the underlying tokens. The pool provides attractive returns for liquidity providers, while providing ample liquidity for traders to open highly-leveraged positions. 
 :::info Statistics Dashboards
You can find various metrics on Jupiter Perpetuals on the following dashboards: 
 
 Chaos Labs Dashboard 
 Gauntlet Dashboard 
 Dune Analytics 
::: 
 
 Perpetual Trading Interface 
 
 
 Perpetual Trading Tab:  This is where all the trading action happens. You can trade long or short on the three main blue-chip markets we offer: SOL, ETH, and WBTC, with leverage of up to 100x. 
 Earn Tab:  This is where passive users can participate. Users can join the liquidity pool and earn passive fees generated from trading activities. (For information on the earn tab and the liquidity used by perpetuals, head over to  JLP ). 
 Perp Market Selector:  Currently, we only support the three main blue-chip markets: SOL, ETH, and BTC. 
 Price Stats:  Here, you can find a quick overview of the current real-time stats, including the current index price, 24-hour price movement, 24-hour highs, and 24-hour lows. 
 Long/Short Selector:  Choose whether you want to go ''Long'' or ''Short'' on the respective market. 
 Input Token Selector:  This is the input section where you can select any SPL token to use as collateral to enter a position. 
 Leverage Slider:  Here, users can increase their trading size with leverage ranging from 1.1x to a maximum of 100x. 
 Order Summary:  This section provides an order summary with all the information and stats calculated. (Please review and confirm your order before submitting the transaction). 
 
 
 Positions Tab 
 
 
 Positions Tab:  The Positions tab is where you can view and manage all your current open positions. 
 Value Display:  Shows the value of the currently open positions. By hovering over the number value of your position you can see the overall position details. This includes the fees being incurred by your trading actions, such as: opening, closing, and borrowing. 
 Size:  Size indicates the current size of your positions factoring in the leverage as well. It''s calculated as the initial collateral amount multiplied by the leverage level. 
 Collateral:  This is the initial amount you provided when opening your long or short position. You can use the  Edit  Button to add or remove collateral to more closely manage your positions. 
 Entry / Mark Price:  The entry price indicates the price at which the position was opened. The mark price indicates the current market price of the position asset. 
 Liquidation Price:  The liquidation price is the threshold at which the mark price reaching this level triggers liquidation. This process is to repay any loan associated with opening the position. 
 Take Profit:  Set up a Take Profit order for your position. A take profit order is a conditional sell order set by the user to close a position if it reaches a specified price level. This is a common way to secure profits on a winning trade at pre-defined price levels. 
 Stop Loss:  Set up a Stop Loss order for your position. A stop loss order is a conditional sell order set by the user to close a position if it reaches a specified price level. This is a common way to limit losses on trades. 
 Close Positions / Share:  Immediately close all positions or individually close positions, securing gains or losses at the current market price. 
 
 
 Trade History Tab 
 
 The Trade History tab is where you can review all your past actions and activities that have occurred with your open positions and orders. 
 
 Position:  This column represents your position where the action or event was triggered, along with the current market ticker and the timestamp of when it occurred. 
 Action:  In the Action column, you can see the specific action or event that occurred for the respective position. 
 Order Type:  This column indicates the type of order that occurred for the position. For example, it could be Market, Trigger, or Liquidation. 
 Deposit / Withdraw:  Here, you can find the amount that was either deposited into or withdrawn from the position. 
 Price:  The Price column displays the mark price at which the action or event occurred, triggering the action order. 
 Size:  This column reveals the size of the position that triggered the action or event. 
 PNL:  The PNL column shows the Profit and Loss associated with the position. 
 Fee:  In this column, you can find a transaction link to the action or event that took place on-chain.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/8-perpetual-exchange/2-how-it-works.md', 'title: "How Perps Trading Works"
sidebar_label: "How It Works"
description: Explore how Jupiter Perps enables leveraged trading with a LP-based model and integration with Pyth oracles for accuracy. 

     Understanding How Jupiter Perps Works: Complete Guide 
     

 Jupiter Perps is a  LP-based perpetual exchange  based on oracle prices. 
 Our pool consists of 5 tokens,  SOL ,  ETH ,  WBTC ,  USDC , and  USDT . Users acquire JLP by swapping on  Jupiter Swap . Jupiter Swap automatically finds the cheapest way of acquiring JLP, by swapping to the desired asset and depositing that, or purchasing off the market. 
 Traders open leveraged positions by putting up collateral and borrowing
the rest of the position from the pool. 
 Position Management 
 Longs 
 Traders can open long positions or increase the size for existing positions for SOL, ETH, and wBTC with up to 100x leverage based on the initial margin (collateral). 
 Collateral Management 
 Traders can deposit or withdraw collateral from the position to manage the position''s margin. 
 
 When traders deposit collateral, the liquidation price and leverage for the long position decreases as the maintenance margin increases. 
 When traders withdraw collateral, the liquidation price and leverage for the long position increases as the maintenance margin decreases. 
 
 Underlying Collateral 
 The underlying collateral for a long position is the token for the open position, as shown below: 
 Position Collateral 
 Long SOL SOL 
 Long wETH wETH 
 Long wBTC wBTC 
 
 Profits and collateral withdrawals are disbursed to traders in the token that is being longed.  
 For example, a trader with a profit long SOL position will receive SOL when they close the position. 
 Shorts 
 Traders can open short positions or decrease the size for existing positions for SOL, ETH, and wBTC with up to 100x leverage based on the initial margin (collateral). 
 Collateral Management 
 Traders can deposit or withdraw collateral from the position to manage the position''s margin. 
 
 When traders deposit collateral, the liquidation price and leverage for the short position increases as the maintenance margin increases.  
 When traders withdraw collateral, the liquidation price and leverage for the short position decreases as the maintenance margin decreases. 
 
 Underlying Collateral 
 The underlying collateral for a short position is either one of the USDC or USDT stablecoin, depending on the stablecoins''  utilization rates  at the time when the position is opened: 
 Position Collateral 
 Short SOL USDC / USDT 
 Short wETH USDC / USDT 
 Short wBTC USDC / USDT 
 
 Profits and collateral withdrawals are paid out to traders in the stablecoin used as the underlying collateral for the position. 
 For example, a trader with a profitable short SOL position with USDC as the underlying collateral will receive USDC when they close the position or withdraw collateral. 
 Limit Orders 
 Limit Orders operate independently from your existing positions. 
 
 They remain active until either triggered at your specified price unless manually cancelled. 
 If triggered, they will either:
 
 Open a new position if you have no existing position. 
 Increase and combine with your existing position in that market. 
 
 
 They stay active even if you close or get liquidated on an existing position. 
 
 :::warning Placing LO near Liquidation Price
Jupiter Perps does not enforce First-in, First-out (FIFO), meaning execution order is not strictly based on price priority. Instead, it depends on which transaction - your Limit Order (LO) or the liquidation transaction - gets processed first. 
 If you create a Limit Order at a price near your liquidation level, expecting it to save your existing position, the outcome is uncertain: 
 
 If the Limit Order executes first = the position may be saved from liquidation 
 If the Liquidation executes first = the existing position will be liquidated, but the Limit Order will remain active, potentially opening a new position immediately.
::: 
 
 :::warning Liquidation Price on Order Form
The liquidation price on the order form for a Limit Order will be the  simulated liquidation price  based on the position requested at the time when you fill in the order form. 
 
 If you have an existing position = liquidation price includes existing position + current requested order 
 If you have no existing position = liquidation price based on current requested order 
 
 However, the liquidation price on the order form does not represent the liquidation price when the limit order is triggered and the position is opened. 
::: 
 :::info Limitation on Limit Orders 
 
 The Perps V2 Beta does not support multiple limit orders  on the same pair and side , please cancel the existing limit order before creating a new one. 
 When the selected market''s utilisation is above 80%, new limit orders cannot be created.
::: 
 
 Limit Price 
 When creating a Limit Order, you can set your desired entry price either above or below the current market price. 
 Position Type Limit Price Rules Example 
 Long Max: 1% less than market Min: 50% of market price Market: 100 Max: 98 Min: 50 
 Short Max: 1% more than market Min: 200% of market price Market: 100 Max: 102 Min: 200 
 
 Take-Profit / Stop-Loss Orders 
 An active Associate Token Account (ATA) is needed for TP/SL to be triggered and executed: 
 
 ETH ATA for ETH-Long 
 wBTC ATA for wBTC-Long 
 USDC or USDT ATA for ALL Short positions 
 
 An ATA will be automatically created for you when you create a TP/SL. 
 Please note that the TP/SL will not be triggered if you close the respective ATA needed. 
 In the event of  manually closing a position , the associated trigger orders will be automatically canceled and closed, providing a seamless experience when opening new future positions. 
 :::info
While  TP/SL  orders are set, keepers will monitor the mark price, when reaching the specified price level, TP/SL will close the whole position. More info on keepers  here .
::: 
 PnL 
 Profit and loss calculations directly corresponds to the size of your  position . Here are two examples to illustrate this: 
 
 Long position example:
 
 Position: 1,000 USD long on SOL 
 If SOL price increases by 10%: You profit 100 USD 
 If SOL price decreases by 10%: You lose 100 USD 
 
 
 Short position example:
 
 Position: 1,000 USD short on SOL 
 If SOL price decreases by 10%: You profit 100 USD 
 If SOL price increases by 10%: You lose 100 USD 
 
 
 
 In both cases, the profit or loss is 10% of the  position size , matching the percentage change in SOL''s price. 
 Calculating realized and unrealized PnL 
 // 1) Get the current token price / exit price

exitPrice = currentTokenPrice

// 2) Determine if the position is profitable by checking if the exit price is greater than the position''s
// average price for longs, or if the exit price is less than the position''s average price for shorts

IF isLong THEN
    inProfit = exitPrice > positionAvgPrice
ELSE
    inProfit = exitPrice < positionAvgPrice

// 3) Calculate the absolute delta between the exit price and the position''s average price

priceDelta = |exitPrice - positionAvgPrice|

// 4) Calculate the PnL delta for the closed portion of the position: multiply the size being closed (`tradeSizeUsd`) 
// by the price delta, then divide by the entry price to get the PnL delta

pnlDelta = (tradeSizeUsd * priceDelta) / positionAvgPrice

// 5) Calculate the final unrealized PnL depending on whether the position is profitable or not

IF inProfit THEN
    unrealizedPnl = pnlDelta
ELSE
    unrealizedPnl = -pnlDelta

// 6) Deduct the outstanding fees from the unrealized PnL to get the final realized PnL
// Read the `Fee` section below to understand how the fee calculations work
realizedPnl = unrealizedPnl - (closeBaseFee + priceImpactFee + borrowFee)
 
 :::info
This  code snippet  shows an example of calculating a position''s PNL programmatically.
::: 
 :::info
 Read the Jupiter Perpetuals fee breakdown here  for more info on open / close fees, price impact fees, and borrow fees.
::: 
 Managing Leverage 
 Leverage 
 To allow for leverage, traders borrow assets from the pool to create a larger position. To create a 2x long position SOL-USD, the other 1x SOL will be borrowed from the pool. 
 This borrow leads to an  hourly borrow rate  to be paid to the pool. Positions always pay  borrow fees  and are never paid funding. 
 This means actual leverage for a position will be slightly lower as the calculation takes into account all fees associated with maintaining the position. 
 Auto Closing Positions that Exceed Maximum Leverage 
 The maximum allowed leverage is 500x. 
 Positions will be liquidated if the trader''s collateral, after subtracting fees, adding unrealized profits and subtracting unrealized losses, is less than 0.2% of the position size. 
 :::info
When reducing the size of a position, the collateral amount is reduced as well to maintain the leverage for the position. For example, if a position has a 10x leverage, and reduces its size by 50%, the same amount of collateral will be withdrew from the position to maintain the 10x leverage.
::: 
 Liquidation 
 The liquidation price for open positions represent the price at which the position will be automatically closed by the system to prevent further losses. 
 
 For long positions:
 
 Liquidation occurs when the current token price falls below the liquidation price 
 Example: If the liquidation price is $90, the long position will be closed if the token''s price drops to $90 or lower. 
 
 
 For short positions:
 
 Liquidation occurs when the current token price rises above the liquidation price 
 Example: If the liquidation price is $110, the short position will be closed if the token price rises to $110 or higher. 
 
 
 
 The liquidation price can be calculated with the following formulas. 
 
 
 price : The average price (USD) of the position 
 collateral_size : The collateral size (USD) for the position 
 close_fee : The fee (USD) charged for closing the position 
 borrow_fee : The accumulated borrowing fees (USD) for maintaining a leveraged position 
 size : The size (USD) of the position 
 max_lev : The maximum allowed leverage ( 500x  is the maximum allowed leverage in the Jupiter Perpetuals exchange for now) 
 
 
 For long positions: 
 
 For short positions: 
 
 :::info
It''s crucial to note that the liquidation price is subject to change over time, particularly with leverage exceeding 10x and the accumulation of borrow fees over extended position durations. Regularly monitoring your liquidation price is essential. 
 To mitigate the risk of liquidation, collateral adjustments and leverage fine-tuning can be performed through the  Edit  button in the position row, offering an avenue to add collateral and enhance the liquidation price.
::: 
 Fees 
 There are 4 types of fees on Jupiter Perpetual: 
 
 A flat 0.06% (6bps) base fee, applied on notional position size. 
 A price impact fee, simulating the orderbook impact given notional size. 
 Borrow fee, paid hourly on open positions, based on notional size. 
 Transaction & Priority fee to create trade requests. 
 
 Base Fee 
 A flat rate of  0.06%  of the position amount is charged when opening or closing a position. This base fee is also charged when a position is closed partially. 
 To calculate the base open or close for a trade: 
 BPS_POWER = 10^4      // 10_000

// 1. Get the base fee (BPS) from the JLP pool account''s `fees.increasePositionBps` for open position requests
// or `fees.decreasePositionBps` for close position requests
// https://station.jup.ag/guides/perpetual-exchange/onchain-accounts#pool-account
   baseFeeBps = pool.fees.increasePositionBps

// 2. Convert `baseFeeBps` to decimals
   baseFeeBpsDecimals = baseFeeBps / BPS_POWER

// 3. Calculate the final open / close fee in USD by multiplying `baseFeeBpsDecimals` against the trade size
   openCloseFeeUsd = tradeSizeUsd * baseFeeBpsDecimals
 
 :::info
This  code snippet  contains an example on calculating open and close base fees programmatically.
::: 
 Price Impact Fee 
 Large trades on the Jupiter Perpetuals exchange inherently  incur no price impact  since token prices are sourced from price oracles. While this is favourable for traders, it poses risks to the Jupiter Liquidity Pool (JLP): 
 
 Large, profitable trades can negatively impact the liquidity pool''s reserves. 
 The platform becomes vulnerable to order manipulation. 
 
 To address these risks, Jupiter Perpetuals implements a price impact fee. This fee is designed to simulate trading conditions in traditional exchanges, where larger orders typically experience more price slippage due to limited liquidity at each price level. 
 
 Benefits of the price impact fee: 
 
 Trader incentives:
 
 Encourages traders to consider trade size when placing orders. 
 Larger trades incur higher price impact fees. 
 Splitting orders exposes traders to potential price changes between oracle updates. 
 
 
 Fair compensation for JLP holders:
 
 The liquidity pool receives reasonable trading fees regardless of whether traders open large trades or split them up. 
 
 
 Market integrity:
 
 The fee structure mimics traditional order book dynamics, helping to prevent price manipulation. 
 
 
 
 This tiered fee structure ensures that costs are more proportional to the potential market impact of each trade, creating a fairer trading environment for both traders and liquidity providers. 
 To calculate the price impact fee for an open or close trade: 
 USDC_DECIMALS = 10^6  // 1_000_000
BPS_POWER = 10^4      // 10_000

Calculate Price Impact Fee:

// 1. Get the trade impact fee scalar from the custody account''s `pricing.tradeImpactFeeScalar` constant
// https://station.jup.ag/guides/perpetual-exchange/onchain-accounts#custody-account
   tradeImpactFeeScalar = custody.pricing.tradeImpactFeeScalar

// 2. Convert trade size to USDC decimal format
   tradeSizeUsd = tradeSizeUsd * USDC_DECIMALS

// 3. Scale to BPS format for fee calculation
   tradeSizeUsdBps = tradeSizeUsd * BPS_POWER

// 4. Calculate price impact fee percentage in BPS
   priceImpactFeeBps = tradeSizeUsdBps / tradeImpactFeeScalar

// 5. Calculate final price impact fee in USD
   priceImpactFeeUsd = (tradeSizeUsd * priceImpactFeeBps / BPS_POWER) / USDC_DECIMALS
 
 :::info
This  code snippet  contains an example on calculating price impact fees programmatically.
::: 
 :::info
Jupiter works with experts like  Gauntlet  to optimize the price impact fee and analyze its impact on the exchange. Consult  Gauntlet''s proposal and analysis on the price impact fee here  for additional information on calculating the price impact fee and other useful information.
::: 
 Borrow Fee 
 On the Jupiter Perpetuals exchange, traders can open leveraged positions by borrowing assets from the liquidity pool. 
 Borrow fees serve two main purposes: 
 
 To compensate liquidity providers for the use of their assets. 
 To manage the risk associated with leveraged trading. 
 
 Unlike other perpetuals exchanges, the Jupiter Perpetuals exchange does not charge funding rates for open positions. Instead, traders pay borrow fees that compound hourly based on the borrowed amount for the leveraged position. 
 The borrow fees are reinvested back into the JLP pool to increase the pool''s yield and available liquidity. It also acts as an incentive for the token mark price to align with it''s market spot price. 
 Jupiter''s hourly borrow fee is calculated using a dual slope model that adjusts based on the custody''s utilization rates. For each custody, the model defines a target utilization level. When utilization is below the target level, the borrow rate is lower which incentivizes traders to borrow from the pool, thus increasing utilization and yield for the JLP. 
 Once utilization exceeds the target level, the borrow rate increases aggressively. This higher rate serves two purposes: it incentivizes additional liquidity providers to enter the market, and it drives traders to reduce their positions as the higher borrowing costs outweigh potential returns. This dynamic approach ensures efficient liquidity allocation while preventing excessive leverage and overutilization of the JLP''s assets. 
 
 Calculating Borrow Rate 
 The dual slope model uses four parameters to calculate the borrow rate: 
 
 Minimum rate : The lowest borrow rate, applied at 0% utilization 
 Maximum rate : The highest borrow rate, applied at 100% utilization 
 Target rate : The borrow rate when utilization reaches its target level 
 Target utilization : The optimal utilization level for the custody 
 
 :::info
Jupiter works with partners like Chaos Labs and Gauntlet to set and optimize the parameters above. The parameters may be adjusted over time as market conditions change.
::: 
 :::info
The parameters above can be fetched onchain from the  min_rate_bps ,  max_rate_bps ,  target_rate_bps , and  target_utilization_rate  fields via the  custody account''s  jump_rate_state  field . 
 The following research posts dive deeper into the methodology and technical details of the dual slope borrow rate model: 
 
 https://www.jupresear.ch/t/gauntlet-dual-slope-borrowing-rate-model-implementation-and-recommendations-12-19-24/29072 
 https://www.jupresear.ch/t/chaos-labs-borrowing-rate-jump-rate-model-recommendations/29203
::: 
 
 The borrow rate calculation depends on the current utilization level: 
 # First, calculate the slopes for both curves
lower_slope = (target_rate - minimum_rate) / target_utilization
upper_slope = (maximum_rate - target_rate) / (1 - target_utilization)

# Calculate the borrow rate based on current utilization
if utilization < target_utilization:
    # Below target utilization: Use gentler slope starting from minimum_rate
    borrow_rate = minimum_rate + (lower_slope * utilization)
else:
    # Above target utilization: Use steeper slope starting from target_rate
    borrow_rate = target_rate + (upper_slope * (utilization - target_utilization))
 
 :::info
The borrow rate is calculated above is expressed as the annual rate (APR). To get the hourly borrow rate, divide the APR by 8,760 hours.
::: 
 Calculating Utilization Rate 
 To determine the current utilization rate, access the asset''s on-chain account ( as shown here ) and apply the following calculation: 
 // Calculate utilization percentage
if (custody.assets.owned > 0 AND custody.assets.locked > 0) then
    utilizationPct = custody.assets.locked / custody.assets.owned
else
    utilizationPct = 0
 
 Worked Example 
 Assume the borrow rate parameters are as below: 
 
 Minimum Rate : 10% 
 Max Rate : 230% 
 Target Rate : 60% 
 Target Utilization : 80% 
 
 Based on the formula above, we can obtain the upper slope and lower slope values for the dual slope borrow rate curve: 
 
 Lower Slope  = (60% - 10%) / 80% = 62.5% 
 Upper Slope  = (230% - 60%) / 20% = 850% 
 
 Assume the trader is opening a position with size  $10,000 . 
 Scenario 1: 40% Utilization (below target level) 
 
 Borrow Rate  = 10% + (62.5% × 40%) = 10% + 25% = 35% 
 
 The hourly borrow rate is calculated by dividing the borrow rate by the number of hours in a year: 
 
 Hourly Borrow Rate  = 35% / 8760 = ~0.004% 
 
 This means the position will accrue a borrow fee of  0.004% * $10,000 = $0.40  every hour. 
 Scenario 2: 90% Utilization (above target level) 
 Assume the current utilization rate is 85% which is above the target utilization level of 80% from the example above, the calculation is as follows: 
 
 Borrow Rate  = 60% + (850% × 10%) = 60% + 85% = 145% 
 
 The hourly borrow rate is calculated by dividing the borrow rate by the number of hours in a year: 
 
 Hourly Borrow Rate  = 145% / 8760 = ~0.0166% 
 
 This means the position will accrue a borrow fee of  0.0166% * $10,000 = $1.66  every hour. 
 :::info
Borrow fees are continuously accrued and deducted from your collateral. This ongoing deduction has two important consequences: 
 
 Your effective leverage increases over time as your collateral decreases. 
 Your liquidation price moves closer to the current market price. 
 
 It''s crucial to regularly monitor your borrow fees and liquidation price. Failure to do so may result in unexpected liquidation, especially during periods of high market volatility or extended position duration.
::: 
 How does the Jupiter Perpetuals contract calculate borrow fees? 
 Due to Solana''s blockchain architecture, calculating funding fees in real-time for each position would be computationally expensive and impractical. Instead, the Jupiter Perpetuals contract uses a counter-based system to calculate borrow fees for open positions. 
 The  pool  and  position  accounts maintain two key fields: 
 
 The pool account maintains a global cumulative counter through its  fundingRateState.cumulativeInterestRate  field, which accumulates interest rates over time 
 Each position account tracks its own  cumulativeInterestSnapshot  field, which captures the global counter''s value whenever a trade is made: when the position is opened, when its size is increased, when collateral is deposited or withdrawn, or when the position is closed 
 
 To calculate a position''s borrow fee, the contract takes the difference between the current global interest rate counter and the position''s snapshot, then multiplies this by the position size. This approach enables efficient on-chain calculation of borrow fees over a given time period without needing real-time updates for each position. 
 The example below demonstrates the borrow fee calculation: 
 // Constants:
BPS_DECIMALS = 4             // 10^4, for basis points
DBPS_DECIMALS = 5            // 10^5, decimal basis points for precision
RATE_DECIMALS = 9            // 10^9, for funding rate calculations
USD_DECIMALS = 6             // 10^6, for USD amounts as per the USDC mint''s decimals

// Main calculation:
1. Get the cumulative interest rate from the pool account:
   cumulativeInterestRate = pool.cumulative_interest_rate

2. Get the position''s borrow rate snapshot:
   borrowRateSnapshot = position.cumulative_interest_snapshot

3. Get the position''s borrow rate interval:
   borrowRate = cumulativeInterestRate - borrowRateSnapshot

4. Calculate final borrow fee (USD):
   borrowFeeUsd = (borrowRate * position.size_usd) / (10 ^ RATE_DECIMALS) / (10 ^ USD_DECIMALS)
 
 :::info
This  code snippet  shows an example of calculating a position''s borrow fees programmatically.
::: 
 Funding rate 
 There is no funding rate for Jupiter Perpetuals . The Jupiter Perpetuals platform does not behave like a standard futures platform where longs pay shorts (or vice-versa) based on the funding rate, since traders borrow from the JLP which incurs a  borrow fee . 
 Transaction & Priority Fee 
 Traders will have to pay SOL for submitting transactions onto the Solana chain. Traders also pay priority fees or Jito bundle tips (or both) depending on their settings. 
 At the same time, a minor SOL amount will be used for rent to create an escrow account ( PDA ). The SOL rent will be returned to you once you close your position. 
 Example Trade 
 Suppose a trader wants to open a 2x long SOL position at a position size of $1000 USD by depositing $500 USD worth of SOL as a collateral and borrowing $500 USD worth of SOL from the pool. Assume the hourly borrow rate for SOL is  0.012% . 
 Initial Position Value $1000 
 Initial Deposit $500 
 Borrowed Amount $500 
 Leverage 2x 
 Initial SOL Price $100 
 Utilization Rate 50% 
 Hourly Borrow Rate 0.012% per hour 
 Position Opening Fee 0.06% * $1000 = $0.6 
 
 The trader keeps this position open for 2 days, and the price of SOL appreciates by 10%. 
 Final Position Value $1100 
 Final SOL Price $110 
 Holding Period 2 days (48 hours) 
 Position Closing Fee 0.06% * $1100 = $0.66 
 
 The borrow fee accumulated throughout this period can be calculated as: 
 
 Hourly Borrow Fee = Tokens Borrowed/Tokens in the Pool * Hourly Borrow Rate * Position Size 
 Total Borrow Fee = 50% * 0.012% * 1000 * 48 = $2.88 USD 
 
 The trader''s final profit can be calculated as: 
 
 Final Profit = Final Position Value - Initial Position Value - Borrow Fee - Opening Fee - Closing Fee 
 $1100 - $1000 - $2.88 - $0.6 - $0.66 = $95.86 
 
 The trader gets a final profit of  $95.86 USD  after this trade. 
 Oracle 
 Jupiter Perps uses a new Oracle Network, Dove Oracle, co-designed by Jupiter and Chaos Labs and audited by Offside Labs. 
 The Dove Oracle relies on  Chaos'' Edge Pricing Data  and anyone will be able to use it on Solana. 
 This oracle was co-designed with Jupiter, with the usage of Jupiter Perps in mind, and comes with key benefits while having an independent team provide the price feed. 
 This oracle is extremely compute-efficient, allowing us to update all 5 oracles (SOL, BTC, ETH, USDC, USDT) when opening and closing positions. 
 
 Key Benefits 
 Benefits Old Oracle Our Oracle 
 Reliability User makes a position request, Keepers wait for 45s for the oracle to update, if the oracle doesn''t update, the position request fails. User makes a trade, Keepers update the oracle and open the position with the same transaction. 
 Latency User makes a request, Keepers have to wait for the oracle before placing the trade. User makes a trade, Keepers immediately process the trade with the oracle. 
 Chart Discrepancy between trades placed and the chart. Our oracle powers the trading view chart and all position requests, no discrepancy. 
 
 Working Together With Pyth Oracle 
 Perp Keepers also utilize Pyth: 
 
 As a reference price check (sanity check) against the Dove Oracle, ensuring that the deviation is not too big. 
 As a fallback price if our oracle''s prices are stale. 
 
 This way, Jupiter Perps benefits from the Dove oracle while still being able to rely on the Pyth oracle. 
 Oracle Price Accounts and Fetching Oracle Prices 
 The Dove Oracle used by the Jupiter Perpetuals platform stores oracle price data in the following onchain accounts: 
 Asset Oracle Account 
 SOL 39cWjvHrpHNz2SbXv6ME4NPhqBDBd4KsjUYv5JkHEAJU 
 ETH 5URYohbPy32nxK1t3jAHVNfdWY2xTubHiFvLrE3VhXEp 
 BTC 4HBbPx9QJdjJ7GUe6bsiJjGybvfpDhQMMPXP1UEa7VT5 
 USDC A28T5pKtscnhDo6C1Sz786Tup88aTjt8uyKewjVvPrGk 
 USDT AGW7q2a3WxCzh5TB2Q6yNde1Nf41g3HLaaXdybz7cbBU 
 
 :::info
The code snippet below in the examples repo shows how to fetch and stream onchain price updates from the accounts above: 
 https://github.com/julianfssen/jupiter-perps-anchor-idl-parsing/blob/main/src/examples/poll-and-stream-oracle-price-updates.ts
::: 
 Keepers 
 Jupiter Perpetual Exchange works based on a keeper model. A typical trader action involves a 2-step process: 
 
 Trader  submits a request transaction onto the Solana chain. 
 Keeper  monitors the request transaction and executes it as a separate transaction onto the Solana chain. 
 
 If the position request fails (e.g. if the oracle price is stale or the oracle price hits the trader slippage), the keeper will close the trader''s request and return the SOL rent on the request and collateral (when opening a position) back to the trader. You will see this as a separate transaction on your wallet submitted by our keeper. 
 You may also notice multiple failed transactions on your wallet submitted by our keepers. You can safely ignore these failed transactions, they don''t alter any state on your wallet. This happens because we have multiple keepers to execute your request in order to make sure that the trader experience is swift. 
 :::info
More information on Keepers can be found  here .
:::', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/8-perpetual-exchange/4-request-fulfillment-model.md', 'sidebar_label: "Request Fulfillment Model"
description: "Request Fulfillment Model" 
 Request Fulfillment model & Off-Chain Keepers 
 Request fulfilment model 
 The Jupiter Perpetuals exchange uses an onchain request fulfilment model to create and execute trade requests. 
 
 Create trade request 
 A trader can perform the following actions on the Jupiter Perpetuals exchange: 
 
 Open position 
 Close position 
 Increase position size 
 Decrease position size / close partial position 
 Deposit collateral 
 Withdraw collateral 
 Create take profit (TP) / stop loss (SL) order 
 Edit TP / SL order 
 Close TP / SL order 
 
 The trader performs the actions above through the Jupiter Perpetuals platform or via the API. The frontend or API server then verifies the action and submits a transaction on the Solana blockchain containing the trader''s request. 
 For example, if the trader created an open position request, the transaction would contain data such as the trade size, collateral size, position side, and other data required to fulfil the request and ultimately open the position. 
 Fulfil trade request 
 Jupiter hosts two keepers that continuously poll the Solana blockchain for trade requests.  
 Once a trade request is fetched by a keeper, it verifies the trade request before creating and submitting another transaction to execute the trade. 
 The trade is executed when the transaction succeeds and is confirmed by the Solana blockchain, thus updating the position or TP / SL request. 
 This means there are two transactions required to complete a trade request: one for the trade request and another one to fulfil the trade request. 
 :::info
Keepers are offchain services that listen to onchain events and perform actions corresponding to the event. They enable automatic and timely execution of trade requests without manual intervention. 
 Jupiter Perpetuals'' keepers listen to the trade requests listed above and execute them by verifying the requests and submitting transactions that contain the actual program instructions for the trade request.
::: 
 Frequently Asked Questions 
 Is the keeper code open-source? 
 The keeper code is not open-source. However, our keepers are audited and are tested extensively before they''re deployed. 
 I submitted a trade request but my trade was not executed 
 Keepers may fail to execute requests due to a variety of reasons (network congestion, keeper downtime, etc.) 
 A trade request that has not been executed after 45 seconds is considered stale and will be rejected. Tokens deposited by the trader for the trade request will be returned to the trader. Tokens will be returned to the position for collateral withdrawals or close position requests. 
 :::info
Please open a support ticket on the  Jupiter Discord support channel  if your trade request was not executed or if you face any issues creating trade requests.
::: 
 Can I host my own keeper? 
 We do not allow community members to run their own keepers at the moment. As mentioned above, our keepers are audited and tested extensively so they''re able to execute trade requests reliably. 
 Where do I see the keeper accounts? 
 We currently run two keepers: 
 
 https://solscan.io/account/A2rCQdCqQB4wu72x9Q7iq1QugtdZmcyWsiSPfgfZzu2u 
 https://solscan.io/account/DFZcDnmEYNUK1khquZzx5dQYiEyjJ3N5STqaDVLZ88ZU', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/8-perpetual-exchange/5-faq.md', 'sidebar_label: "Frequently Asked Questions"
description: Frequently Asked Questions 
 Frequently Asked Questions 
 1. I tried opening a position/adding collateral and it was not successful. Where are my funds? 
 Under normal circumstances, funds will be returned to your wallet in about 1-2 minutes. During periods of congestion on the Solana network there might be a delay for your funds to be returned to your wallet. If this is the case, you can close your expired request under the  Expired Orders  tab. 
 Follow these steps on how to find your funds. 
 
 Go to the Transaction ID 
 
 
 
 Scroll down to  CreateIncreasePositionMarketRequest 
 
 
 
 Click on  Position Request  address 
 
 
 
 Click on the latest successful transaction 
 
 
 
 You could find your returned fund here: 
 
 For  SOL , check  SOL Balance Change  tab 
 
 For  ALL other token , check  Token Balance Change  tab 
 
 :::info
Wallet service providers might not be fully parsing the transactions, so, it is always a better idea to check on-chain. If you still couldn’t locate your fund although it was shown that it’s returned on the explorers, please contact your wallet service provider accordingly.
::: 
 2. I closed my position with profit and I have not received my funds. 
 You will receive the underlying asset for a LONG-position, i.e. SOL for SOL-Long, ETH for ETH-Long, wBTC for wBTC-Long. 
 You will receive either USDC or USDT for all SHORT-positions. 
 Perform these steps to check for funds from closed positions. 
 
 Under  Transaction History  on Jupiter Perpetual Trading, click on the transaction ID of the closed position. 
 
 
 
 You could find your returned fund here: 
 
 For  SOL-Long position , check  SOL Balance Change  tab 
 
 For  ALL other positions , check  Token Balance Change  tab 
 
 3. The price has reached my Take Profit/Stop Loss price on the chart. Why is my TP/SL not triggered? 
 
 
 Missing Associated Token Accounts 
 We won''t be able to trigger a TP/SL if there is no active token account for the user. These are the associated token accounts (ATAs) needed for each position. 
 
 ETH Token Account for ETH-Long; 
 wBTC Token Account for wBTC-Long; 
 USDC and USDT Token Account for ALL Short positions. 
 
 
 
 If you are sure that you have an active ATA for the position and check the Mainnet oracle price and confirm that TP/SL is not triggered at the price it is supposed to, please open a  Perp-ticket . 
 Take note that this only applies for the Trading View Chart on Jupiter Perpetuals, and not if the price was reached on another platform. Jupiter Perps'' chart uses the Signal Oracle, which is the same oracle used for processing TP/SL. 
 4. Why is my liquidation price changing? 
 There is an hourly borrow fee on every position, the hourly borrow fee will change the liquidation price over time. 
 If you want to understand how the hourly borrow rate works, you can check it out  here . 
 5. I deposited 1 SOL (where 1 SOL = $100) for a 5x leveraged SOL-Long position and profited $50 (where 1 SOL = $110). Why did I get less than the full amount? 
 Assuming zero fees, with $50 profit, you will be getting SOL in return with value of $150.
At the time of closing the position, 1 SOL = $110, 
 $150 / $110 = 1.3636
 
 You will be getting 1.3636 SOL where the value is equivalent to $150. 
 
 Here is another example, this is a SOL-Long position, the total amount the user should be getting is $3086.28 in SOL. 
 The value of SOL at the time is $189.28, hence  $3086.28 / $189.28 = 16.30 . The user will be receiving 16.30 SOL in return. 
 :::info
The  PNL  shown is the amount before fees. The exact amount is shown under  Deposit/Withdraw  tab.
::: 
 6. I have an existing SOL-Long position. I deposited 1 SOL to open a new SOL-Long position but I don’t see my new position. 
 Both positions will be combined into one position, where 
 
 Leverage of the combined position = Average of the leverage level of each position.
e.g. (1.2x + 1.4x) / 2 = 1.3x 
 Size = initial collateral * leverage level. 
 
 The TP/SL you have set earlier will remain the same after the positions are combined. 
 7. Why are my collateral sizes fixed? 
 When providing the initial margin or depositing collateral, the exchange records the position''s collateral value in USD. The recorded USD value remains constant, even if the collateral token''s price fluctuates. 
 For example, if a trader deposits $100 USD worth of SOL to open a position, their collateral will always be valued at $100 for this position. Even if the price of SOL changes by 50% in either direction, the trader''s collateral size for this position remains fixed at $100. 
 8. Why do long and short positions use different collateral tokens? 
 Traders can deposit any  SPL token supported by Jupiter Swap  as the initial margin to open a position or to deposit collateral for an existing open position.  
 The deposited tokens will then be converted to the collateral tokens for the position (SOL / wETH / wBTC for long positions, USDC / USDT stablecoin for short positions). 
 :::info
The platform will automatically swap the deposited tokens to the right collateral token so traders don''t need to swap tokens manually before opening a position or increasing their collateral.
::: 
 The underlying collateral for long positions are the tokens themselves (SOL, wBTC, wETH) and stablecoins (USDC, USDT) for short positions. 
 This is to protect the pool from scenarios that might put the pool at risk, for example a series of ongoing profitable trades that deplete the pool''s reserves. 
 For more information on this, consult the  JLP pool documentation  which describes the dynamics between traders and the liquidity pool for long and short scenarios. 
 9. How are token prices determined? 
 Token prices for SOL, wETH, wBTC, USDC, and USDT are determined by onchain price oracles.  
 The prices sourced from the oracles are used as the mark price for: 
 
 Opening and closing positions 
 Increasing or reducing position sizes 
 Depositing or withdrawing collateral 
 Calculating PNL 
 Calculating liquidation prices 
 Triggering TP / SL requests 
 Price charts 
 
 Jupiter is working with  Chaos'' Edge Pricing Data  that provide fast, accurate, and reliable price data for the supported tokens on the Jupiter Perpetuals exchange. 
 :::info
Price data used in the Jupiter Perpetuals exchange may differ from other onchain and offchain price aggregators. Traders should use the Jupiter Perpetuals price chart and historical prices as the source of truth when making trade decisions.
::: 
 10. How many positions can be opened at one time? 
 Traders can open up to 9 positions at one time: 
 
 Long SOL 
 Long wETH 
 Long wBTC 
 Short SOL (USDC) 
 Short SOL (USDT) 
 Short wETH (USDC) 
 Short wETH (USDT) 
 Short wBTC (USDC) 
 Short wBTC (USDT) 
 
 When a trader opens multiple positions for the same side (long / short) and token: 
 
 Open positions: Price and fee calculations are based on the existing open position. This is essentially increasing or decreasing the size of an open position. 
 Deposits, withdrawals, and closing: Price, PNL, and fee calculations are also based on the existing open position.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/8-perpetual-exchange/3-onchain-accounts.md', 'sidebar_label: "Onchain Account Types"
description: Onchain Account Types 
 Onchain Account Types 
 This page contains an overview of all the  Solana account types  used in the Jupiter Perpetuals decentralized exchange. 
 This information is useful for developers looking to integrate or interact the Jupiter Perpetuals program and transactions. 
 :::info
This  repository  contains  typescript  code samples on interacting with the Jupiter Perpetuals program IDL with  anchor  and  @solana/web3.js 
::: 
 Position  account 
 The  Position  account contains the trade position data for a given token. The following is an example of a  Position  account: 
 :::info
An example  Position  account on Solscan: https://solscan.io/account/FBLzd5VM67MEKkoWerXu7Nu1ksbLXQvJDx63y5aeLEvt
::: 
 The  Position  account contains the following data: 
 
 
 owner : The public key / address for the trader''s wallet. 
 
 
 pool : The public key / address for the  Jupiter Perpetuals liquidity pool account . 
 
 
 custody : The public key / address for the position''s custody account. A custody account in the Jupiter Perpetuals exchange contains information for the token that''s being traded against for the position. 
 
 For example, a long SOL position will have the  custody  account.  7xS2gz2bTp3fwCC7knJvUWTEU9Tycczu6VhJYKgi1wdz   which contains important data like the its price impact fee scalar, tokens locked currently for potential profit payoffs, and other data used by the Jupiter Perpetuals exchanged. 
 
 
 
 collateralCustody : The public key / address for the position''s collateral custody account. 
 
 Like the custody account, a collateral custody account in the Jupiter Perpetuals exchange contains information for the token that''s used as collateral for the position (SOL / wETH / wBTC for long positions, USDC / USDT for short positions). The borrow rates for the position will also be calculated based on the position''s  collateralCustody . 
 
 
 
 openTime : The open time of the position in UNIX timestamp format. 
 
 
 updateTime : The time the position was last updated in UNIX timestamp format. 
 
 
 side : The position''s side (long / short). 
 
 
 price : The entry price of the position when it was opened. The entry price is an integer corresponding to the number of decimals used by the USDC / USDT mint (6 decimal places). For example, a value of  158225872  is equal to $158.22 (before rounding up) after factoring in the decimals. 
 
 
 sizeUsd : The position size after leverage in USD and integer format as explained in  price . A position with  sizeUsd = 0  is treated as a closed position. 
 
 
 collateralUsd : The position''s collateral size after fees in USD and integer format as explained in  price . 
 
 
 realisedPnlUsd : The position''s realized PNL when closing the position partially. When a profitable position is closed completely, the position''s  realisedPnlUsd  will be  0  as the position is considered closed (as described in  sizeUsd ). 
 
 
 cumulativeInterestSnapshot : Stores the position''s interest rate snapshot when it was last updated. 
 
 The  collateralCustody  account for the respective collateral token stores a monotonically increasing counter in  collateralCustody.fundingRateState.cumulativeInterestRate . 
 The difference between the  collateralCustody.fundingRateState.cumulativeInterestRate  and the position''s  cumulativeInterestSnapshot  is used to calculate the borrow fees for the position. 
 
 
 
 lockedAmount : The amount of tokens (SOL / wETH / wBTC for long positions, USDC / USDT for short positions) locked to pay off the position''s max potential profit i.e. it acts as a cap on the maximum potential profit of the position. This amount is locked in the collateral custody to ensure the platform has sufficient tokens to pay out profitable trades. 
 
 
 bump : The bump seed used to derive the PDA for the  Position  account. 
 
 
 :::info
The  Position  account''s address is derived from the trader''s wallet address / public key, the custody account, the collateral custody account, and a few other constant seeds. This means traders will always have the same  Position  account address for their open positions. 
 This also means that traders only have nine positions available at one time: 
 
 Long SOL 
 Long wETH 
 Long wBTC 
 Short SOL (USDC as collateral) 
 Short SOL (USDT as collateral) 
 Short wETH (USDC as collateral) 
 Short wETH (USDT as collateral) 
 Short wBTC (USDC as collateral) 
 Short wBTC (USDT as collateral)
::: 
 
 PositionRequest  account 
 A  Position  can have many  PositionRequest  accounts as each trade request is unique. 
 The  PositionRequest  account''s address is a  program-derived address (PDA)  derived from the underlying  Position  account''s address, several constant seeds, and a random integer seed which makes each  PositionRequest  account unique. 
 :::info
The following is an example of a  PositionRequest  account: https://solscan.io/account/DNnX2B1oiYqKLrbLLod1guuaZA28DQwJ8HuHsgDafoQK
::: 
 The  PositionRequest  account contains the following data: 
 
 
 owner : The public key / address for the trader''s wallet. 
 
 
 pool : The public key / address for the  Jupiter Perpetuals liquidity pool account . 
 
 
 custody : The public key / address for the position request position''s custody account. A custody account in the Jupiter Perpetuals exchange contains information for the token that''s being traded against for the underlying position. 
 
 For example, a long SOL position will have the  custody  account  7xS2gz2bTp3fwCC7knJvUWTEU9Tycczu6VhJYKgi1wdz   which contains important data like the custody''s price impact fee scalar, tokens locked currently for potential profit payoffs, and other data used by the Jupiter Perpetuals exchanged. 
 
 
 
 collateralCustody : The public key / address for the position request position''s collateral custody account. 
 
 Like the custody account, a collateral custody account in the Jupiter Perpetuals exchange contains information for the token that''s used as collateral for the underlying position (SOL / wETH / wBTC for long positions, USDC / USDT for short positions). 
 
 
 
 mint : For opening positions and collateral deposits,  mint  is equal to the input mint requested by the trader. 
 
 For example, if a trader opens a position by providing the initial margin with SOL, then  mint  will be equal to SOL''s mint address. If the trader deposits collateral in USDC, then  mint  will be equal to USDC''s mint address. 
 For closing positions and collateral withdrawals,  mint  is equal the to position collateral token''s mint address. For example, if a trader closes a long SOL position,  mint  will be equal to SOL''s mint address. If a trader closes a short SOL position,  mint  is equal to USDC or USDT''s mint address depending on the position''s collateral. 
 
 
 
 openTime : The UNIX timestamp for when the position request is created. 
 
 
 updateTime : The UNIX timestamp for when the position is last updated. 
 
 
 sizeUsdDelta : The USD amount to increase or decrease the position size by. The amount is an integer that uses 6 decimal places as specified by the USDC / USDT mints. For example, a position request to increase an open position''s size by 10 USDC will have a  sizeUsdDelta = 10000000. 
 
 
 collateralDelta : For opening positions and collateral deposits, collateralDelta  is the token amount to increase or decrease the position collateral size by. The token amount is an integer that corresponds to the decimal places used by the token specified in  mint . 
 
 For example, a position request to increase a position''s collateral size by 1 SOL will have  collateralDelta = 1000000000 . 
 For closing positions and collateral withdrawals,  collateralDelta  is the USD value of the collateral to be withdrew from the position. The amount is an integer that uses 6 decimal places as specified by the USDC / USDT mints. 
 For example, a position request to withdraw $100 from the position''s collateral will have a  sizeUsdDelta = 100000000  . 
 
 
 
 requestChange :  requestChange  will be equal to  Increase  for open position and collateral deposit requests, and  Decrease  for close position and collateral withdrawal requests. 
 
 
 requestType :  Market  for all position requests except for TP / SL requests, which have a  Trigger   requestType . 
 
 
 side :  Long  for long positions,  Short  for short positions 
 
 
 priceSlippage : The maximum price with slippage for the position request when opening, closing, or updating the position size. 
 
 When increasing the size of a long position or decreasing the size of a short position, the request will fail if the current price of the position''s token is greater than  priceSlippage . 
 When decreasing the size of a long position or increasing the size of a short position, the request will fail if  priceSlippage  is greater than the current price of the position''s token. 
 
 
 
 jupiterMinimumOut : For requests that require token swaps (e.g. opening or closing positions, updating position sizes), the output amount of the token swap must be greater than or equal to  jupiterMinimumOut . The request will fail if the swap does not satisfy  jupiterMinimumOut . 
 
 
 preSwapAmount : This is an internal attribute used by the program to calculate the  collateralDelta  for position requests that require token swaps. 
 
 
 triggerPrice : The price (USD) used for TP / SL position requests. 
 
 
 triggerAboveThreshold : When  triggerAboveThreshold  is true, the TP / SL position request will be triggered when the position''s token price is greater than or equal to  triggerPrice . When  triggerAboveThreshold  is false, the TP / SL position request will be triggered when the position''s token price is less than or equal to  triggerPrice . 
 
 
 entirePosition : This attribute is only checked when closing or decreasing position sizes. When  entirePosition  is true, the entire position will be closed (i.e. a close position request). When  entirePosition  is false, the position size will be reduced according to  sizeUsdDelta . 
 
 
 executed : Determines whether the position request is executed or not. 
 
 
 counter : The random integer seed used to derive the position request address. 
 
 
 bump : The bump seed used to derive the position request address. 
 
 
 :::info
A  PositionRequestATA  account is created for each  PositionRequest  account. The  PositionRequestATA  account is an  associated token account  derived from the  PositionRequest  that contains the tokens from the trader''s deposits or withdrawals from withdrawing collateral or closing positions. The tokens are then transferred the position token''s custody token account or returned to the trader''s wallet when the  PositionRequestATA  account is closed.
:::info 
 Take Profit (TP) / Stop Loss (SL) Requests 
 PositionRequest  accounts for non-TP / SL requests are closed as soon as the request is executed or rejected. 
 TP / SL requests are also stored onchain via  PositionRequest  accounts. However, they will only be closed when the TP / SL request is triggered and executed.  
 Active TP / SL requests can be fetched onchain (through blockchain explorers like Solscan or SolanaFM) by searching for the  PositionRequest  address or public key associated with the TP / SL request. 
 Pool  account 
 The  Pool  account contains data for the JLP pool, including AUM and custody data (which will be explained in detail later in this document).  
 :::info
There is only one  Pool  account for the JLP pool:  https://solscan.io/account/5BUwFW4nRbftYTDMbgxykoFWqWHPzahFSNAaaaJtVKsq 
::: 
 
 
 name : The name for the account. 
 
 
 custodies : An array containing the public keys for the custodies (tokens) managed by the JLP pool. 
 
 
 aum_usd : The current AUM value (USD) for the JLP pool. The  aum_usd  value''s calculation can be summarized by getting the USD value of the tokens managed by the pool minus the USD value reserved to pay off trader profits. A more detailed explanation on the  aum_usd  calculation is shown later in this document. 
 
 
 limit :  Contains values for the pool''s limits. 
 
 maxAumUsd : The max AUM for the JLP pool. This acts as a max cap / ceiling as the JLP will not accept deposits when the cap is hit. 
 tokenWeightageBufferBps : The token weightage buffer (in BPS) to calculate the token''s maximum or minimum current weightage based on the target weightage. Currently,  tokenWeightageBufferBps  is set to  2000  which means the current weightage cannot be lower of higher than + / - 20% of the token''s target weightage. For example, if SOL''s target weightage for the JLP pool is 50%, the current weightage cannot be less than 40% or exceed 60%. The pool will not allow deposits or withdrawals if the action causes the token to exceed its target weightage. 
 maxPositionUsd : Sets the maximum position size for the Jupiter Perpetuals exchange. The current  maxPositionUsd  value is  2500000000000  which means a position''s max size is $2,500,000. 
 
 
 
 fees : Sets the fee amounts or percentages for the Jupiter Perpetuals exchange. 
 
 increasePositionBps : A fixed fee of 6 BPS (0.06%) is charged for opening or increasing a position. 
 decreasePositionBps : A fixed fee of 6 BPS (0.06%) is charged for closing or decreasing a position. 
 addRemoveLiquidityBps : Fee charged when adding or removing liquidity to/from the pool. 
 swapBps : Swap fee for exchanging non-stablecoin tokens routed through the liquidity pool. 
 
 
 For stablecoins: swap fee =  stableSwapBps  ±  stableSwapTaxBps 
 For non-stablecoins: swap fee =  swapBps  ±  taxBps 
 
 
 taxBps : Tax fee for non-stablecoins, determined based on the difference between the current and target weightage. A larger difference results in a higher tax fee, encouraging liquidity providers to rebalance the pool to the target weightage. 
 stableSwapBps : Swap fee for exchanges involving stablecoins, routed through the liquidity pool. 
 stableSwapTaxBps : Tax fee for stablecoin swaps. Similar to  taxBps , this fee is determined by the difference between the current and target weightage. 
 protocolShareBps : Jupiter takes a share of 2500 BPS (25%) from the fees collected by the pool. 
 
 
 
 poolApr : Contains data related to the pool''s APR / APY calculations. 
 
 lastUpdated : The UNIX timestamp when the pool''s APR data was last updated. 
 feeAprBps : The pool''s APR in BPS format. The APR is calculated weekly by dividing the pool''s realized fees (minus the 25% collected by the protocol) by the total pool value, adjusting for the 1 week time period to annualize the rate. 
 realizedFeeUsd : The fees collected by the pool so far. This fee is reinvested back into the pool and is also used to calculate the APR as mentioned above.  realizedFeeUsd  resets to zero when the fee is reinvested into the pool hence causing the APR value to fluctuate weekly. 
 
 
 
 Custody  account 
 The  Custody  account contains information for all the custodies (tokens) managed by the JLP pool. The JLP pool currently manages the following custodies: 
 
 SOL:  https://solscan.io/account/7xS2gz2bTp3fwCC7knJvUWTEU9Tycczu6VhJYKgi1wdz 
 ETH:  https://solscan.io/account/AQCGyheWPLeo6Qp9WpYS9m3Qj479t7R636N9ey1rEjEn 
 BTC:  https://solscan.io/account/5Pv3gM9JrFFH883SWAhvJC9RPYmo8UNxuFtv5bMMALkm 
 USDC:  https://solscan.io/account/G18jKKXQwBbrHeiK3C9MRXhkHsLHf7XgCSisykV46EZa 
 USDT:  https://solscan.io/account/4vkNeXiYEUizLdrpdPS1eC2mccyM4NUPRtERrk6ZETkk 
 
 Each  Custody  account contains the following data: 
 
 pool : The public key for the pool that this custody belongs to (i.e. the JLP pool). 
 mint : The public key for the custody''s token mint account. 
 token_account : The associated token account for the custody which holds the tokens under management for the pool. 
 decimals : The number of decimals used for the token which is the same as the number of decimals specified in the token mint account. This is stored for convenience. 
 is_stable : Sets whether the custody is a stablecoin. 
 oracle : Contains data for the price oracle used for the custody. 
 pricing : Contains data for the custody''s price-related logic.
 
 trade_impact_fee_scalar : Sets the base value when calculating price impact fees when opening or closing positions. For more info on the price impact fee, read more  here . 
 max_leverage : Sets the max leverage for this custody''s positions. The max leverage for all custodies is  500x  at the time of writing. 
 max_global_long_sizes : The maximum total position size (USD) for long positions. 
 max_global_short_sizes : The maximum total position size (USD) for short positions. 
 
 
 permissions : A set of global flags that can be set by the protocol''s administrator to enable or disable trade actions which is useful during program upgrades or black swan events. 
 target_ratio_bps : The target weightage (in BPS) for the custody in the JLP pool. 
 assets : Contains data used to calculate PNL, AUM, and core business logic for the Jupiter Perpetuals exchange. This data is also useful for analytics or crafting hedging strategies, for example.
 
 feesReserves : The fees collected by all open positions for the custody.  feesReserves  resets to zero when the fees are distributed to the pool and protocol. 
 owned : The number of tokens owned by the pool for the custody. This value is increased either by providing liquidity to the pool or depositing collateral when opening or updating positions. Conversely, the  owned  value decreases when liquidity is removed from the pool or collateral is withdrawn from closing positions. 
 locked : The number of tokens locked by the pool for the custody to pay off potential profits for open positions. 
 guaranteed_usd : This value represents the total amount borrowed in USD ( position size - collateral ) across all long positions. It is updated whenever traders modify their collateral through deposits or withdrawals. The system uses this aggregated figure to efficiently calculate the total profit and loss (PNL) for all long positions, which in turn is used to calculate the AUM of the JLP pool. 
 global_short_sizes : Stores the total amount (USD) position sizes for all short positions. 
 global_short_average_prices : Stores the average price (USD) for all short positions. This value and  global_short_sizes  are used to calculate the PNL for all short positions efficiently, and is again used to calculate the AUM of the JLP pool. 
 
 
 funding_rate_state : Contains data used to calculate borrow fees for open positions.
 
 cumulative_interest_rate : Traders are required to pay hourly borrow fees for opening leveraged positions. This fee is calculated based on two primary factors: the size of the trader''s position and the current utilization of the pool for the custody. To calculate borrow fees more efficiently, each custody account contains a value called  cumulative_interest_rate . Correspondingly, each position account stores a  cumulative_interest_snapshot . This snapshot captures the value of  cumulative_interest_rate  at the time of the position''s last update. Whenever there''s a change in either the borrowed assets or the total assets within a custody, the  cumulative_interest_rate  for the custody is updated. The difference between the custody''s  cumulative_interest_rate  and the position''s  cumulative_interest_snapshot  is then used to calculate the position''s borrow fees. 
 last_updated : The UNIX timestamp for when the custody''s borrow fee data was last updated. 
 hourly_funding_dbps :  NOTE: This will be deprecated in the near future.  A constant used to calculate the hourly borrow fees for the custody. The Jupiter Perpetuals exchange works with Gauntlet and Chaos Labs to update and fine tune the  hourly_funding_dbps  to respond to traders'' feedback and market conditions. 
 
 
 jump_rate_state : Contains data used to calculate the  dual slope borrow rate model .
 
 min_rate_bps : The lowest borrow rate, applied at 0% utilization. 
 max_rate_bps : The highest borrow rate, applied at 100% utilization. 
 target_rate_bps : The borrow rate when utilization reaches its target level. 
 target_utilization_rate : The optimal utilization level for the custody.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/10-onboard/2-onramp.md', 'sidebar_label: "Onramp and CEX Transfers"
description: Learn to convert Fiat to Solana easily with top aggregated services.
title: Fiat On-ramps to Solana
slug: ./onramp 

     Fiat to Solana On-Ramping: Easy Guide: Step by Step | Jupiter Station 
     

 Jupiter has integrated with Onramper to power a direct Onramp application from dirty fiat directly into the Solana asset of your choosing. 
 Onramper is an on-ramp aggregator, helping users around the world get on-chain quickly and easily with the best prices. The Onramp application includes the top on-ramp services (Stripe, Banxa and Topper) to provide the best routing and options based on your region, desired amount and payment preference. 
 :::info
Jupiter will never charge any additional fees for using the Onramp service and Onramper is offering a reduced fee promotional period for the first six months of the integration. This reduced fee promotional period will end in December 2024.
::: 
 Let''s take a look at the Onramp App below. 
 
 Onramp UI 
 Try it out  here ! 
 
 
 Onramp App Selector:  Selector to navigate to the Onramp application. 
 Options Menu:  Select your language preferences, review the Terms of Usage and Privacy Policy, and find Help & Support here. 
 You Spend:  Selector to choose the currency and input the amount you would like to spend on your purchase. 
 You Get:  Selector to choose the Solana asset and the output amount of that asset you will get for your input spend amount. 
 Payment Processor Selector:  Select your preferred payment processor to complete the Onramp purchase. 
 Pay Using:  A dropdown to choose the payment method to use for the purchase. This includes credit, debit, Apple Pay, Google Pay and ACH options. 
 Buy Button:  Click this to begin the Onramp purchase transaction. 
 
 Once you click  Buy Button , a new tab will open for you to complete the transaction through the payment processor''s site with the inputs specified above. 
 
 CEX Transfers to Solana 
 Try it out  here ! 
 Transferring assets to Solana has never been easier. If you are looking to transfer assets from a Centralized Exchange (CEX). Each CEX can have different requirements for external transfers, so please refer to their respective guides.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/10-onboard/1-bridging.md', 'sidebar_label: "Bridging to Solana"
description: Learn how to bridge assets to Solana efficiently.
title: Bridging to Solana
slug: ./bridge 

     Bridge to Solana: Step-by-Step Asset Transfer Guide | Jupiter Station 
     

 The current cryptosphere is made up of numerous blockchains which can act as silos for assets and liquidity. With that in mind, cross-chain mobility for crypto assets is a highly desirable solution in this realm. To solve this issue, bridges were invented. Bridges are applications configured to manage asset custody and enable cross-chain asset swapping. 
 :::info
Most bridge applications work in the same way. They require connecting multiple wallets (source & destination chains), selecting the input / output tokens, and the input amount. They will also require at least 2 transactions confirming on both the source and destination chains.
::: 
 Basic Bridging User Flow 
 
 Start on the bridge application you intend to use. 
 Next, connect your source wallet that will be funding the bridging transaction. 
 Select the source token and input the amount that you want to use in the bridging transaction. 
 Connect the destination wallet that will be receiving the funds from the bridging transaction. 
 Select the token that you would like to bridge into on the destination chain. 
 Review the transaction preview to understand the total fees that the transaction will require. 
 Approve the bridge transactions. There will be two: one for the source chain and another for the destination chain. 
 
 USDC - CCTP 
 Try it out  here ! 
 The Cross-Chain Transfer Protocol (CCTP) is a permissionless on-chain utility that ensures secure USDC transfers between blockchains using a native burn-and-mint process. This bridge is powered by Wormhole and Circle. 
 USDC Bridge UI 
 
 
 USDC Bridge Selector:  Application selector to navigate to the USDC bridging tool. 
 Source Wallet Connect:  Connect the wallet associated with the source blockchain you are looking to bridge from. 
 Asset Selector & Amount Field:  Select the token from the source wallet and enter the amount of the token you would like to bridge. 
 Destination / Source Switching Tab:  This will allow you to switch destination and source chains and tokens respectively. 
 Destination Wallet Connector:  Connect the wallet associated with the destination blockchain you are looking to bridge to. 
 Asset Selector & Amount Field:  Select the token on the destination blockchain you want to bridge to. The amount field is auto-calculated based on market rates and is non-editable. 
 Route:  The best route is determined by the application and displayed here for you to review. 
 Preview:  The bridging transaction preview will build here, identifying the Amount that will be received and the total fee estimates for the transaction. Note: There will be fees on both the source and destination blockchains as you have to execute transactions on both. 
 Approve and Proceed with Transaction:  Once you have reviewed the Route and the Preview, click here to start the bridging process. 
 
 deBridge 
 Try it out  here ! 
 deBridge is a cross-chain interoperability and liquidity transfer protocol that allows decentralized transfer of data and assets between various blockchains. 
 deBridge UI 
 
 
 deBridge Selector:  Application selector to navigate to the deBridge tool. 
 Settings:  Source chain settings can be modified here, including gas fee, node selection, and other settings native to the source blockchain. 
 Source Chain & Token Selector:  Select the token from the source wallet and input the amount of the token you are looking to bridge. 
 Destination / Source Switching Tab:  This will allow you to switch destination and source chains and assets. 
 Destination Chain & Token Selector:  Select the token in the destination wallet to bridge into. The amount field will auto-calculate for you based on exchange rates of the bridging route. 
 Connect Wallet:  This button allows you to connect your source wallet to begin the bridging process. Once you connect, the UI will update and it will auto-detect the wallet balances and populate the UI. 
 
 Part two continues below, with the updated interface after connecting your wallet. 
 
 
 Transaction ETA & Fee Breakdown:  Here you can review the fees on each blockchain as well as the bridging fee and destination address. 
 Routing:  Expandable routing display to review the entire bridge route for the simulated transaction. 
 Destination Wallet Address:  If displayed, enter your destination wallet address here. 
 Confirm Trade:  After reviewing the route, fees, and token inputs, click this button to confirm the trade and begin the bridging transactions.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/index.md', 'sidebar_label: "Overview"
title: Guides Overview
sidebar_position: 1
description: Learn about Jupiter and how to use Jupiter with these beginner friendly guides. 

     Jupiter Guides: Welcome Catdets! 
     

 
 Getting Started 
 Hello, curious cat! We''re so glad you''re here to learn more about Jupiter and our products. These guides were created to get new cats like yourself up to speed and to explain the inner workings of Jupiter products. 
 Here''s a list of all our official links. Please always double check the URL matches these! 
 Platform Purpose Official Link 
 Website Experience all Jupiter products for yourself https://jup.ag 
 Discord Engage with the community and us by sharing feedback and ideas https://discord.gg/jup 
 Twitter Follow [@JupiterExchange] to stay up-to-date with all updates https://twitter.com/JupiterExchange 
 Documentation Read all about Jupiter products, for both users and devs https://station.jup.ag/ 
 YouTube Tune in to Planetary Calls and watch tutorials and guides relating to Jupiter and Solana DeFi https://www.youtube.com/@Jupiter-Exchange 
 Reddit Join our Reddit community to chat with fellow Catdets on all things Jupiter and DeFi https://www.reddit.com/r/jupiterexchange/ 
 Jupresearch Participate in forum discussion regarding Jupiter initiatives, ecosystem projects, and broader decentralised meta https://www.jupresear.ch/ 
 Launchpad Discover and participate in token launches by LFG Launchpad https://lfg.jup.ag/ 
 Governance Vote with your staked JUP on DAO proposals and earn Active Staker Rewards https://vote.jup.ag/ 
 J.U.P DAO Be a part of Jupiter United Planet or Jupiverse and contribute to governance and voting https://www.jup.eco/ 
 Token List Understand how token verification works on Jupiter and get your token verified https://catdetlist.jup.ag/ 
 Edge Test out the latest product changes before they are live on the main website https://edge.jup.ag/ 
 Ape Pro Ape into new tokens in a seamless, fast, yet secure manner with secure vault model https://ape.pro/ 
 Welcome to Solana Join us to welcome you to Solana every step of the way https://welcome.jup.ag/ 
 
 
 Navigating this Guide 
 
 Spot:  Read detailed walkthroughs on all Spot features: Swap, Limit Order, Dollar Cost Averaging (DCA), Value Averaging (VA). Deep dive into how each of them work individually and together to provide the best trading experience for you! 
 Perpetual Exchange:  Learn about the Jupiter Perpetuals Exchange and the JLP Pool and its role in securing liquidity for the Perpetuals Exchange. 
 Ape:  Discover how the vault model, auto-retry, and removal of wallet signature enables fast and secure trades. 
 JupSOL:   Check out  JupSOL  to learn about the official Jupiter LST which supports the Jupiter Validator! 
 Onboard:  If you''re coming to Solana for the first time, we care to provide a seamless experience for you. Read our guide on Bridge, Onramp, and CEX transferring. 
 General Guides:  Discover general guides relating to the Solana ecosystem such as personal security, using a block explorer to verify swaps, actions & blinks, token guide for creators, the Jupiter Media Kit, and FAQs about the Jupiter Platform. 
 
 Welcome to the community, J4J (JUP 4 JUP)!', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/7-jlp/1-JLP.md', 'sidebar_label: "JLP Overview"
description: "Explore what $JLP is, its role in Jupiter, and how it benefits traders. Boost your trading strategy with $JLP with our beginners guide."
title: "JLP Overview" 

     What is  $JLP: Jupiter Liquidity Provider Explained | Jupiter Station 
     

 The  Jupiter Liquidity Provider (JLP)  Pool is a liquidity pool that acts as a counterparty to traders on  Jupiter Perps . Traders borrow tokens from the pool to open leveraged positions on the Jupiter Perpetuals exchange. 
 The JLP token derives its value from: 
 
 An index fund of  SOL, ETH, WBTC, USDC, USDT . 
 Trader''s  profit and loss . 
 75%  of the generated fees from  opening  and  closing  fees,  price impact ,  borrowing fees , and  trading fees  of the pool. 
 
 Jupiter Liquidity Providers (JLPs) 
 Jupiter Liquidity Providers (JLPs) play a crucial role in the trading ecosystem by supplying the necessary liquidity for perpetual traders. 
 Liquidity providers (LPs) ensure there is sufficient liquidity, allowing traders to test their perpetual trading strategies. As a result, Jupiter connects LPs with traders, allowing the traders to access the liquidity provided by the LPs, and in turn allowing LPs to earn the majority of fees generated from trading activity. 
 How to Become a Liquidity Provider (LP) 
 Anyone can become a Liquidity Provider by contributing assets or tokens to the Jupiter Liquidity Provider Pool (JLP Pool). 
 
 JLP tokens represent your share of the pool. 
 Any asset traded on JUP can be used to buy into JLP. 
 There are fees associated with buying into the JLP pool (see Target Ratio and Fees). 
 
 More details on how to get the token in  How To Get JLP . 
 :::tip
The best way to purchase or exit JLP is always via  Jupiter Swap .
::: 
 Advantages of the JLP System 
 The JLP system offers a user-friendly method for participants to earn passive income while contributing to the liquidity and stability of the trading environment: 
 
 LPs do not need to actively "stake" tokens or "harvest" yields - APR earnings are embedded within each JLP token and accumulate automatically (reflected as an increase in the JLP token price). 
 The JLP token is also an SPL token, making it easily transferable and tradable like other SPL tokens within the Solana ecosystem. 
 AMM pools can be established for trading JLP tokens. 
 
 :::info
JLP is a liquidity token for the Jupiter Perpetuals platform, and JUP is the governance token of the JUP DAO.
::: 
 Rewards and Earnings 
 The  APY  of JLP is calculated based on 75% of fees generated from perps trading activities (not including assets appreciation and traders PnL). 
 The generated fees are distributed back to liquidity providers by redepositing the fees into the pool hourly. 
 More details on how JLP generates yield in  How JLP Works . 
 
 JLP UI Walkthrough 
 
 
 
 Earn Tab:  Where users can participate by depositing into the JLP Pool to earn passive fees generated from all perpetual trading activities. 
 
 
 APY:  This measure shows the current trajectory of yield from holding the JLP token. 
 
 
 Trade:  Here a user can Trade, Buy or Sell JLP. 
 
 
 Total Value Locked (TVL):   TVL  represents the total value of pool assets at their current token prices. 
 
 
 Token Selector:  The user can choose the token they would like to trade or receive. 
 
 
 Token(List):  The list of tokens currently held in the JLP pool. 
 
 
 Pool Size:  The current size of each token''s pool. Traders'' collateral assets are included in the pool. 
 
 
 Current / Target Weightage:  A comparison of the current weightage to the target weightage. 
 
 
 Utilization:  A measure of how the pool''s assets are currently being used. 
 
 
 Estimations and Fees:  The user is shown the estimated fee for trading the token they pick and the estimated JLP to be received. 
 
 
 JLP Price & Total Supply:  Here, you can find the current virtual  JLP Price  and  Total Supply  displayed. The virtual price is obtained by dividing  TVL  by  Total Supply . 
 
 More information on the  Virtual Price  and  Market Price  of JLP  here .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/7-jlp/4-JLP-Economics.md', 'sidebar_label: "JLP Economics"
description: "JLP Economics"
title: "JLP Economics" 
 The JLP Token 
 The  JLP token  is the token given to users who provide liquidity to the JLP pool. JLP can be acquired either through  Jupiter Swap  or through the  Earn page , which mints or burns JLP tokens directly from the pool. 
 More information on how to get JLP  here . 
 Custodies 
 The JLP pool manages several custodies (tokens) for liquidity providers: 
 
 SOL:  7xS2gz2bTp3fwCC7knJvUWTEU9Tycczu6VhJYKgi1wdz 
 ETH:  AQCGyheWPLeo6Qp9WpYS9m3Qj479t7R636N9ey1rEjEn 
 BTC:  5Pv3gM9JrFFH883SWAhvJC9RPYmo8UNxuFtv5bMMALkm 
 USDC:  G18jKKXQwBbrHeiK3C9MRXhkHsLHf7XgCSisykV46EZa 
 USDT:  4vkNeXiYEUizLdrpdPS1eC2mccyM4NUPRtERrk6ZETkk 
 
 More info on the  Custody  account is explained in  Onchain Account Types . 
 Assets Under Management 
 The AUM for each  Custody  account in the pool is calculated as follows: 
 Stablecoins (USDC, USDT) 
 aum = owned * current_price 
 Non-stablecoins (SOL, ETH, wBTC) 
 
 Calculate the global short position profit/loss (Unrealized PnL in USD): 
 
 unrealized_pnl = (global_short_sizes * (|global_short_average_prices - current_price|)) / global_short_average_prices) 
 :::tip
If  current_price  >  global_short_average_prices , traders are losing on short positions.
::: 
 
 Net Asset Value (NAV): 
 
 available_tokens = owned - locked 
 nav = available_tokens * current_token_price 
 guaranteed_usd = size of all trades (USD) - collateral of all trades (USD) 
 nav += guaranteed_usd 
 :::info
The  guaranteed_usd  value in each  Custody  account represents an estimate of the total size of all long positions. It is only an estimate as  guaranteed_usd  is only updated when positions are updated (i.e. opening / closing positions, updating collateral). It does not update in real-time when asset prices change. 
 guaranteed_usd  is used to calculate the pool''s AUM as well as the overall PnL for all long positions efficiently.
::: 
 
 Assets Under Management (AUM) 
 
 If traders are losing on short positions, the losses are added to the pool''s AUM: 
 aum = nav + unrealized_pnl 
 Otherwise, traders'' profits are deducted from the pool''s AUM: 
 aum = nav - unrealized_pnl 
 The Total AUM is then calculated as the sum of all the custodies'' AUM: 
 total_aum = Σ(aum) 
 :::note
The pool sizes displayed on the  Earn page  do not add up to the pool''s AUM. This discrepancy occurs because the Earn page shows each custody''s  owned  value in USD without accounting for the  traders'' unrealized PnL . 
 This simplified representation on the Earn page provides a quick overview of the pool''s holdings but doesn''t reflect the JLP pool''s true AUM.
::: 
 Virtual Price, Market Price and AUM Limit 
 Virtual Price = Sum of all JLP Assets (in USD) / Total Quantity of JLP in circulation 
 When the AUM limit is hit: 
 Market Price = Virtual Price + Market-assigned Premium 
 Usually, users can mint new JLP or redeem (burn) them at the Virtual Price. However, when the AUM limit is hit, new minting of JLP is disabled to cap the amount of TVL in the pool. 
 When this happens, the demand for JLP on the market usually leads to a premium for JLP compared to the virtual price. 
 You may sell your JLP for the Market Price at any time. If the Market Price is below the Virtual Price, your JLP tokens are redeemed (burned) at the virtual price instead of the market price. 
 
 You can view the current TVL and AUM Limit on the  JLP UI . 
 Every 7 days, the estimated APY figure is updated with the above calculation by using the previous week''s fees. 
 Fetching AUM and Calculating JLP Virtual Price 
 The code snippets below show how to fetch the AUM from the JLP pool onchain account, as well as calculating the JLP virtual price in real time: 
 Fetch pool AUM 
 Calculate JLP virtual price 
 Calculate global unrealized PnL for longs 
 The most accurate way to calculate the unrealized PnL for all open long positions is to loop through all open positions (by fetching them from onchain accounts) and use the unrealized PnL calculation shown in  calculating unrealized PnL . 
 To get an estimate of the global unrealized PnL for longs, you can use the following calculation: 
 // 1) Get the custody account you''re interested in calculating unrealized PnL for longs
// https://station.jup.ag/guides/perpetual-exchange/onchain-accounts#custody-account

// 2) Get the `assets.guaranteedUsd` field which stores the value of `position.sizeUsd - position.collateralUsd` for
// all open long positions for the custody. Note that a position''s `sizeUsd` value is only updated when a trade is made, which
// is the same for `guaranteedUsd` as well. It does *not* update in real-time when the custody''s price changes

guaranteedUsd = custody.assets.guaranteedUsd

// 3) Multiply `custody.assets.locked` by the custody''s current price to get the USD value of the tokens locked 
// by the pool to pay off traders'' profits

lockedTokensUsd = custody.assets.locked * currentTokenPriceUsd

// 4) Subtract `guaranteedUsd` from `lockedTokensUsd` to get the estimate of unrealized PnL for all open long positions. Note that
// the final value is greater than the actual unrealized PNL as it includes traders'' collateral

globalUnrealizedLongPnl = lockedTokensUsd - guaranteedUsd
 
 Calculate global unrealized PnL for shorts 
 The custody accounts store a  global_short_sizes  value that stores the USD value of all open short positions in the platform. The  global_short_average_prices  value stores the average price (USD) for all open short positions and is used together with  global_short_sizes  to get an estimate of the global unrealized PNL for shorts, as shown below: 
 globalUnrealizedShortPnl = (custody.assets.globalShortSizes * (|custody.assets.globalShortAveragePrices - currentTokenPriceUsd|)) / custody.assets.globalShortAveragePrices)
 
 The most accurate way is again to loop through all open positions and sum the unrealized PNL, as the calculation above also includes traders'' collateral. 
 Yield 
 The JLP token adopts a growth-focused approach, similar to accumulating ETFs like VWRA or ARKK. Rather than distributing yield through airdrops or additional token mints, the JLP token''s value is designed to appreciate over time. This appreciation is driven by the growth of the JLP pool''s AUM, which is used to derive the virtual price as shown above. 
 75% of all fees generated from Jupiter Perpetuals trading, token swaps, and JLP minting/burning are reinvested directly into the JLP pool. 
 This mechanism continuously enhances the pool''s liquidity and value for token holders. The remaining 25% is allocated to Jupiter as protocol fees, supporting ongoing development and maintenance. 
 For example, if trading activities generate  10 SOL  in fees,  7.5 SOL  would be added to the JLP pool, increasing its SOL holdings and AUM. 
 Fees generated by the pool are reinvested directly back into the JLP pool, mirroring how accumulating ETFs reinvest dividends. This reinvestment strategy compounds the pool''s growth, steadily increasing the JLP token''s price and intrinsic value. 
 Exposure 
 The intrinsic value of the JLP token is linked to the price movements of the liquidity pool''s underlying tokens (SOL, ETH, BTC, USDC, and USDT).  
 As a JLP holder, your portfolio is exposed to market movements, particularly to the performance of the non-stablecoin tokens: SOL, ETH, and BTC. If these tokens decrease in price, the value of your JLP position will likely decrease as well. 
 That said, JLP holders earn yield from fees generated by trading activities. When traders incur losses, these are reinvested into the JLP pool, benefiting JLP holders. Conversely, when traders profit, it comes at the expense of the JLP pool. 
 The JLP usually outperforms its underlying assets during sideways or bearish market conditions since traders often struggle to be profitable in bear markets. However, during strong bull markets, the situation can reverse. Traders may open more long positions which can lead to trader profitability at the expense of JLP holders. 
 To navigate market fluctuations, JLP investors have two primary strategies: 
 
 Time the market : Attempt to exit JLP positions before or during bullish trends. 
 Hedging : Maintain JLP holdings for yield while implementing hedges against the underlying assets in the pool. This approach aims to mitigate downside risk during adverse market movements. 
 
 Risks 
 JLP holders are exposed to risks that can impact their portfolio, such as: 
 
 Market volatility 
 
 Rapid price movements can negatively impact the JLP. 
 Extreme market events or black swan scenarios may cause correlations between assets to break down, potentially amplifying losses instead of mitigating them. 
 
 
 Counterparty risk 
 
 The JLP pool poses a counterparty risk to JLP holders, as smart contract vulnerabilities or platform issues could potentially impact the ability to maintain or close hedge positions. That said, Jupiter is working with leading firms in the field to audit and maintain our contracts to protect the Jupiter Perpetuals exchange and JLP holders. 
 
 
 Opportunity cost 
 
 Capital allocated to acquiring JLP could potentially earn higher returns if allocated elsewhere. In bull markets for example, JLP may underperform compared to simply holding the underlying assets. 
 
 
 
 **JLP holders should thoroughly research and understand the benefits and risks of the JLP token before acquiring them.
**', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/7-jlp/3-How-To-Get-JLP.md', 'sidebar_label: How To Get JLP
description: Learn how to buy $JLP tokens via Jupiter Swaps and the JLP Page for a hassle-free experience.
title: How To Get JLP 

     How to Get $JLP: Your Complete Guide to Acquiring JLP Tokens 
     

 Method 1: Jupiter Swap 
 For a detailed breakdown of swaps, check out  How to Swap . 
 
 Go to the  USDC-JLP  pair on Jupiter Swap 
 Make sure your wallet is connected. There should be an icon on the top right showing your connection status. 
 Choose the token you''d like to trade for JLP in the "You''re Selling" section with the token selector. 
 JLP should already be selected as the token in the "You''re Buying" section. 
 Decide the amount you''d like to swap. An estimate of the quantity of JLP you will receive will appear in the "You''re Buying" section. 
 Click on the  Swap  button found near the bottom of the page. 
 A notification asking for confirmation of the transaction will appear. Confirm the transaction. 
 You will receive a message on the success of the transaction. 
 
 Method 2: JLP Page 
 
 Go to  JLP Page . 
 There will be an interface on the right side with an option to Trade, Buy, and Sell. Select Buy. 
 An input box will appear at the bottom of the interface with a token selector. 
 Select the token you''d like to trade for JLP. 
 Decide the amount you''d like to trade for JLP. 
 A module will appear at the bottom showing the estimated quantity of JLP and the fees for buying into the pool (More info on these fees in  Maintaining Target Weight ) 
 A notification asking for confirmation of the transaction will appear. Confirm the transaction. 
 You will receive a message on the success of the transaction.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/7-jlp/2-How-JLP-Works.md', 'sidebar_label: How JLP Works
description: Explore how $JLP boosts investments through liquidity, yield strategies, and trading. Learn essential fee and risk management tips.
title: How JLP Works 

     How $JLP Works: Key Insights on Liquidity & Yield | Jupiter Station 
     

 Liquidity Pool 
 The Jupiter Perpetuals exchange is a trader-to-LP exchange which means traders borrow tokens from the liquidity pool (the JLP pool) for leverage. 
 Instead of periodic funding payments between long and short traders, Jupiter Perpetuals implements an hourly borrow fee mechanism. 
 Traders pay these fees to the pool based on the amount of tokens they''ve borrowed. This mechanism helps secure the balance of the pool''s assets and compensates liquidity providers for the use of their tokens. 
 Add/Remove Liquidity into JLP 
 When a user adds liquidity to the JLP pool, they increase the amount of TVL (Total Value Locked) which increases the liquidity available for perps trading. The pool is currently a collection of the following tokens:  USDC, USDT, SOL, wBTC and ETH . 
 Adding Liquidity 
 Any Liquidity providers (LPs) can acquire JLP by swapping for it on Jupiter Swap. Jupiter Swap will find the best price to acquire JLP for you, automatically. This can either be purchasing it off the open market, or swapping it for a desired asset and depositing that into JLP directly. Use Jupiter Swap for a frictionless experience of getting JLP. While JLP is still being minted, your assets may be deposited into the relevant token pool increasing the current weightage. At the point of depositing assets into the JLP pool, the protocol will re-price the TVL in the USD value. 
 Removing Liquidity 
 JLP can also be sold via Jupiter Swap. Simply swap JLP for your desired asset. The JLP token could either be transferred to another trader or may be redeemed by the JLP pool, burning the JLP token, and releasing some of the currency contained in the pool. 
 Purchasing/Exiting JLP 
 The best way to purchase or exit JLP is via  Jupiter Swap . 
 When using Jupiter Swap or programs that integrate Jupiter Swap, the minting and burning of JLP tokens occur automatically. When you swap in and out of JLP, Jupiter Swap will find the best route to mint/burn JLP automatically, or swap through other DEXes if the route offered is better. 
 :::info
This automatic minting/burning mechanism is unique to Jupiter Swap and programs that route via Jupiter Swap. If you''re interacting directly on a different DEX, you will trade JLP at the price offered by the DEX instead of the virtual price of JLP. 
 Only the Jupiter Perpetuals program (which is integrated in Jupiter Swap) has the authority to mint and burn JLP tokens. 
::: 
 Yield Generation 
 The exchange generates fees and yields in various ways: 
 Action Fee 
 Opening a Position 6 BPS (variable) 
 Closing a Position 6 BPS (variable) 
 Price Impact Fee Variable (see  reference ) 
 Swap Fee (Mint / Burn JLP) Between 0 BPS to 150 BPS depending on pool weightage 
 Borrow Rate Dynamically updated based on utilization and market conditions (see  reference ) 
 
 75% of the fees generated by JLP go into the pool.  The fees are compounded into the pool hourly. 
 :::info Yield Calculation Factor
It is essential to note that pool earnings and losses (index token appreciation/depreciation) are not factored in the overall yield calculation.
::: 
 Estimating Yield 
 To provide an estimated perspective, you can calculate potential revenue by taking the Jupiter Perpetual Exchange''s daily or weekly total volume and multiplying it by a fee percentage. For instance: 
 
 Total Daily Volume: 50 million 
 Fee Percentage: 0.06% 
 Price Impact Fees: Minimum 0.01% 
 Revenue Share Percentage: 75% 
 
 Using these values (excluding price impact and hourly borrow fees), the estimated calculation would be as follows: 
 Total estimated revenue to be deposited into JLP pool: 
 $50M x 0.06% x 75% = $22,500
 
 To determine your specific share or weight in the total JLP pool, use the following formula: 
 your_pool_contributed_amount / total_pool_amount x 100 = your_pool_percentage
 
 For example: 
 
 Your contribution: $1,000 
 Total pool amount: $4,000,000 
 Your share percentage: 1,000 / 4,000,000 x 100 = 0.025% 
 
 Finally, you can calculate your estimated generated revenue share by multiplying the results of the first and second calculations: 
 estimated revenue share you generate = $22,500 x 0.025% = $5.625
 
 JLP Fee Distribution and APR Calculation 
 Fee Distribution 
 1) Hourly Fee Distribution 
 Fee distribution into the JLP token occurs at the start of every hour, in UTC time (e.g.  00:00 UTC ,  01:00 UTC ,  02:00 UTC  and so on). 
 During this process, 75% of realized fees are withdrawn from each custody account''s  assets.fees_reserves  and deposited back into the pool, while the remaining 25% is sent to Jupiter as a protocol fee. 
 :::tip
Learn more about the on-chain accounts associated with JLP & Jupiter Perpetuals  here .
::: 
 2) Weekly APR Updates 
 The JLP pool maintains a  pool_apr.last_updated  field, which records a UNIX timestamp of the latest APR update. After a  consecutive week  of hourly fee distributions have passed, Jupiter calculates the new APR and updates the  pool_apr.fee_apr_bps  value accordingly. 
 APR Calculation 
 APR for the JLP pool is updated weekly, and can be calculated using the following formula: 
 if current_time > (last_updated_time + 1_WEEK):
    time_diff = current_time - last_updated_time
    // 10_000 represents the scaling factor used to calculate the BPS for the pool''s APR
    apr_bps = (realized_fee_usd * YEAR_IN_SECONDS * 10_000) / (pool_amount_usd * time_diff)
 
 Risks Associated with Holding JLP 
 
 Bull Markets 
 
 During a bull market, JLP may not outperform SOL, ETH, or BTC. This is because the pool is made of a mix of stable and non-stable tokens. 
 
 Profit and Loss (PnL) Dynamics 
 
 Traders'' PnL from perpetual trading impacts the JLP pool. If a trader incurs a net positive PnL, the losses are sourced from the JLP pool to compensate the trader. Conversely, if a trader''s PnL is a net negative, the gains are deposited into the JLP pool for LP holders. 
 Long Trade Scenario:  If the trader profits on the long, the JLP pool will lose in token quantity but not in USD value because the underlying token value in the pool appreciates in value as well. 
 
 Short Trade Scenario:  If the trader profits on the short, the JLP pool will lose some of the stablecoins but the shorted token will remain the same. This causes a net USD loss on the Pool. 
 
 This  research article  from LeeWay provides more detail on how this works. 
 
 Token Price Fluctuations:  The JLP pool consists of both stable and non-stable tokens. Fluctuations in token prices can affect the value of JLP. As a result, users may find that their withdrawn tokens can be worth less compared to their initial deposit. Additionally, deposit and withdrawal fees for the JLP Pool may further reduce the number of tokens withdrawn, particularly for shorter holding periods. 
 
 Can JLP go down?  Yes. As shown in the trader profiting on a short trade, JLP in USD value will go down when the fees generated are lower than depreciation of assets and payout from traders'' profit. 
 Pool Weightage 
 In the JLP pool, each asset is assigned a  target weight , which is set by the team. 
 
 Jupiter is working with  Gauntlet  and  Chaos Labs  to conduct regular risk assessments and market analyses in response to the evolving market conditions. These assessments are also discussed with the community before they are presented to the team for rollout. 
 :::tip
The risk assessments can be accessed via  Jupiter''s research forum .
::: 
 Maintaining Target Weight 
 The weightages of each asset in the JLP pool will differ based on market activity, particularly Spot Trading or Deposit & Withdrawal of assets into JLP. 
 To help maintain the Target Weight, JLP dynamically sets a Swap Fee or Mint/Redeem Fee. 
 Example: $USDC 
 
 If the current weightage of USDC is  higher  than its advised target weightage, USDC deposits into the JLP Pool will incur additional fees, while USDC withdrawals will receive a fee discount. 
 If the current weightage of USDC is  lower  than its advised target weightage, USDC deposits into the JLP Pool will receive a fee discount, while USDC withdrawals will incur additional fees. 
 
 
 Simply put: Transactions that shift an asset’s current weightage  further away  from the target weightage incur additional fees while transactions that shift it  closer to  the target weightage will receive a discount on fees. This is based on the fee incurred when minting or burning JLP during the swap. 
 This allows JLP to maintain its target weight as liquidity providers are incentivized to maintain the target weightage amid high volumes of spot trading or deposit/withdrawal activity. 
 Failsafe Mechanism 
 How far can the current weightage of an asset deviate from its target weightage? 
 An asset’s current weightage can deviate from its target weightage by a maximum of  20%  of the target weightage value. 
 Example: 
 
 If the advised target weightage of  USDC  in the JLP pool is  26%,  the current weightage of the asset in the JLP pool can deviate between a range of  20.8%  (-20%) and  31.2%  (+20%). 
 This means that USDC cannot be deposited into the pool if the current weightage goes above  31.2% , and USDC cannot be withdrawn from the pool if the current weightage goes below  20.8% . 
 
 This means that during a Black Swan event where a JLP asset depegs, the maximum loss is  Target Weight * 1.2 .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/1-swap/2-tutorials/4-how-to-earn-referral-fees.md', 'sidebar_label: How To Earn Referral Fees
description: Discover how you can earn referral fees by letting your users swap via Jupiter on your platform.
title: How to Earn Referral Fees
slug: /swap/tutorials/earn-referral-fees 
 The Jupiter Referral program allows you to earn fees by referring users to the platform. It uses URL parameters to track referrals:  https://jup.ag/?referrer=[ReferralKeyAddress]&feeBps=[FeesBps] 
 :::info Important Notes 
 
 ExactIn swaps support both input and output tokens. 
 ExactOut swaps only support input tokens.
::: 
 
 
 Connect your wallet on Jupiter (jup.ag). 
 Scroll to the bottom of the page and click the ''Referral'' button. You''ll be redirected to your referral dashboard where you can create your referral account and set up supported fee accounts (currently SOL, USDC, and USDT). 
 
 
 
 Visit the Referral dashboard (https://referral.jup.ag/). You''ll be prompted to create your referral account with a preferred name.  (Note your unique referral key (e.g., 7tme...w4hd)) 
 
 
 
 Create token accounts for SOL, USDC, and USDT. These cover most use cases. Ensure you have enough SOL to pay for token account rental fees 
 
 
 
 Once your account is set up, select your preferred fee tier (0.1%, 0.5%, or 1%). The referral mini-popup will highlight in orange any missing token accounts. 
 
 
 
 Copy your personalized referral link. Share your link to start earning referral fees for every swap you refer. Example referral link: https://jup.ag/swap/SOL-USDC?referrer=7tme...w4hd&feeBps=50 
 
 
 Last Updated: 5 November 2024', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/1-swap/2-tutorials/1-how-to-swap.md', 'sidebar_label: How to Swap
description: Learn more about the basics of swapping on Jupiter.
title: How to Swap on Jupiter
slug: /swap/tutorials/how-to-swap 

     How to Swap on Jupiter 
     

 <video controls style={{ maxWidth: ''100%'', height: ''auto'' }}>
<source src={require(''../../../static/media/how-to-swap-jupiter.mp4'').default} type="video/mp4" />
Your browser does not support the video tag.
 
 Video Credits:  Netrovert 
 
 Navigate to the Jupiter Website. Double check that the URL is https://jup.ag/ 
 Click  Connect Wallet  at the top right corner of the site. 
 Select the tokens that you want to sell and buy. 
 Enter the input amount of the token that you want to sell or use the  Half   Max  buttons of your balance amount. 
 Review the swap route and output token amounts. 
 Choose between Auto or Manual mode for Settings. We recommend Auto for starters. 
 After you have confirmed all the parameters and inputs, click on the  Swap  button, and you will be prompted with a confirmation from your wallet. If you  Confirm , your swap will be sent to the blockchain, to be finalized. 
 A notification toast will appear in the lower left corner that will inform you of the status of your transaction. 
 You can view your swap history in the Activity tab if you click on your connected Wallet. 
 
 Swap Details 
 
 
 Exchange Rate for the Selected Tokens:  This is the current exchange rate, based on the on-chain prices for the selected tokens 
 Minimum Received:  This takes into account the slippage setting and market liquidity to compute the minimum amount that you will receive even with maximum price fluctuations for a successful swap. 
 Max Transaction Fee:  This is the maximum fee you will pay to execute the quoted transaction. This takes into account your selected fee settings. 
 Deposit:  If you are transacting assets you have not owned before, Solana may require a small deposit amount to create the ATA account in your wallet to hold that asset. This will only occur with assets you have not owned previously. 
 Price Impact:  Price Impact is influenced by the available liquidity to settle the trade. The larger the trade the larger the price impact on the selected assets. 
 Price Difference:  We show the quoted rate (from Jupiter) against the market rate. The price difference can be due to various external factors such as price impact, token tax, etc. 
 
 Route Details 
 
 
 Order routing is like Jupiter''s GPS for your tokens. You can find and open the  "1 Market"  or  "2 Routes + 2 Markets"  above the Swap Button. It will show you the exact order routing path for the quote. You can also see the routes and all markets that is used along the route. 
 Last Updated: 4 November 2024', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/1-swap/2-tutorials/2-how-to-configure-settings.md', 'sidebar_label: How To Configure Settings On Jupiter
description: Find out how you can configure your settings on Jupiter to help you land your transactions effectively.
title: How to Configure Settings
slug: /swap/tutorials/configure-settings 
 Swap Settings 
 There are 2 settings that you should take note of when trading on a blockchain. These settings are uncommon in traditional contexts, and it might seem like a friction but it is to help you trade safer and smoother. 
 Transaction Fees 
 In Solana, you need to pay a base fee of 0.000005 SOL for every transaction you attempt to make. However, as the Solana network receives more usage and traffic, more transactions will attempt to compete for the same amount of space. 
 This led to the introduction to Priority Fees. It is an optimal fee that you can pay to boost the prioritization of your transaction, allowing it to process earlier, resulting in faster execution times. 
 Slippage 
 When trading in Decentralized Finance, you will often hear the term  slippage . A quick and easy way to understand slippage is, you receive a quotation of a certain trade, but during execution, the price would have very likely moved, and this causes slippage. 
 Hence, in most DeFi apps, you will be able configure your slippage thresholds in percentages, where during execution, if price moves against you in some percentage, the trade will fail. 
 :::note This seems daunting
We agree with you, it can be daunting to think about these settings. 
 At Jupiter, we do our best to continuously improve your experience, we have designed a few iterations starting from just a simple configuration which slowly evolved into a dynamic mechanism where you  configure less, and swap with more confidence . 
 Check out how to use the Auto / Manual Settings below!
::: 
 Auto / Manual Swap Settings 
 
 Select the Gear icon on the Swap Form to choose your Swap Settings Mode. 
 Choose between  Auto  or  Manual  depending on how you like it. 
 Swap away! If you need any assistance, please reach out to us in  Discord . 
 
 Feature Description 
 Auto Mode Recommended for beginners or those wanting a simplified experience. Automatically selects optimal settings for a quick and easy swap process. 
 Manual Mode Suited for experienced users seeking detailed control over their swap. Allows adjustments of parameters for a customized experience. 
 
 If you choose Auto 
 
 Slippage is determined for you using  Dynamic Slippage , which estimates based on a few factors, especially the types of tokens you are trading. 
 Transaction Fee is determined for you using our Dynamic max cap based on your trade size. 
 Decide if you want to enable MEV Protect. When enabled, your transactions will be sent directly to Jito block engines, minimising the risk of sandwiches for you. 
 
 :::tip If you are using MEV Protect or Jito only modes
Do note that your transactions may at times fail or be slow to process as not all validators are using Jito block engine.
::: 
 If you choose Manual 
 You can decide 3 levels of settings: 
 
 
 Slippage 
 
 Choose between  Dynamic  or  Fixed . 
 
 Slippage Mode Description 
 Dynamic Slippage Dynamic Slippage  estimates based on a few factors, especially the types of tokens you are trading. 
 Fixed Slippage Whereas for  Fixed , we adhere to your specified slippage threshold percentage for your swaps. 
 
 
 
 Transaction Broadcasting 
 
 Broadcast Mode : Choose from between these. 
 
 Broadcast Mode Description 
 Priority Fee Sends your transaction to a typical RPC and pays with Priority Fee to increase prioritization. 
 Jito Only Sends your transaction to a Jito RPC and pays with a Jito tip to ensure it is included in the block, which also enables your transaction to be MEV protected. 
 Both Sends your transaction vai both methods. 
 
 :::tip If you are using the Both method 
 
 When your transaction lands via typical RPCs, your priority fee will be paid. 
 When your transaction lands via Jito client validators, both your priority fee and Jito tip will be paid. 
 
 Also, MEV Protect in Auto mode is also Jito-Only in Manual mode.
::: 
 
 Priority Level : Specify the Priority Level, in increasing priority: Fast, Turbo, Ultra for the transactions you are executing. The higher the priority, the higher the fees. 
 Fee Mode : Pick your preferred Fee Mode. Either specify a Max Cap for your fee or an Exact Fee for your transactions, we also do provide the Dynamic max cap that estimates based on your trade size. 
 
 
 
 Advanced Settings 
 
 Direct Route Only:  Enabling this will ensures that the transaction will only be submitted to a single pool. This will limit a lot of intermediate tokens and filter out a lot of other viable routes that use intermediary tokens. 
 
 
 Use wSOL:  Using  Wrapped SOL (wSOL)  makes using Jupiter faster and more convenient for traders who trade frequently with SOL, since it avoids having to wrap/unwrap SOL. 
 AMM Exclusion : Enabling this will exclude specific AMMs from the routing. This will limit these AMMs in the transaction that you’re making. It can lead to a worse quote. Do note that this setting is not sticky, meaning it will revert to original state if refreshed. 
 
 
 
 Global Settings 
 
 Language:  Pick your preferred language to navigate  jup.ag . 
 Preferred Explorer:  Pick your preferred explorer from Solscan, SolanaFM, Solana Beach, Solana Explorer, XRAY, and OKLink. 
 Versioned Transaction:  Enabling  Versioned Transaction  improves composability so Jupiter will be able to fit in more routes and get even better pricing all in a single transaction. 
 RPC Endpoint:  Pick your preferred public RPC endpoint or use your own custom RPC endpoint. Each RPC Endpoint displays its active end-point latency.
 
 Due to network traffic loads, RPC endpoints can get overloaded, which can lead to latency issues that will directly impact your trade executions. Selecting the lowest latency option is a best practice to ensure the fastest trade execution. 
 
 
 
 Last Updated: 5 November 2024', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/1-swap/2-tutorials/3-how-to-trade-safely.md', 'sidebar_label: How To Trade Safely
description: Learn more about the ways Jupiter keeps you safe with various safety warnings and notifications.
title: How to Trade Safely on Jupiter
slug: /swap/tutorials/trade-safely 
 Trading in DeFi can get complex with tokens of various risk profiles and functionalities, leading to an overload of information. Jupiter is committed to balance convenience and protection for you. 
 We highlight safety notifications, non-intrusive warnings, key token info, and swap summary to reduce info asymmetry yet not overload you. 
 Warnings 
 
 Price impact alert is influenced by the available liquidity and your trade size. A large trade size in an illiquid pool often results in huge price impact, hence you can break up your trade size with  DCA . 
 We also show the quoted rate (from Jupiter) against the market rate. The price difference can be due to various external factors such as price impact, token tax, stale market price (usually derived using last traded price), etc. 
 If your trade shows a large price impact and difference, please trade with caution and feel free to seek clarity in our  Discord . 
 Token Information 
 
 Jupiter shows relevant token information to reduce information asymmetry you may face when trading. Token Verification shows as "Verified ✅" or "Not Verified ⚠️" and Token2022 extensions appears as information pills. 
 More on Token Verification criteria  here . 
 More on Token2022 extensions below: 
 Definition Valid Use Misuse 
 Permanent Delegate Allows creators to grant unlimited delegation privileges over any account for that mint, including burning or transferring any tokens from any account. Enables automatic payments, wallet recovery, and processing refunds. Scam projects could drain tokens from users'' wallets. 
 Transfer Tax Enables fees to be withheld on each transfer, redeemable by those with withdraw authority. Allows projects to generate revenue through service charges, or to collect royalties or taxes on transfers. Scam projects might arbitrarily increase transaction taxes and withdraw funds with full authority. 
 Freeze Authority Allows issuers to halt token transfers or trading, temporarily or permanently. Commonly used for regulated tokens (e.g., stablecoins) to meet legal standards; issuers can freeze tokens for compliance with legal or regulatory concerns. Scammers may use this to prevent trading or transferring scam tokens, a red flag for market manipulation or potential fraud. 
 
 MEV Protect 
 
 Jupiter introduces  MEV Protect  mode, which will only send your transactions directly to Jito block engines, minimising the risk of sandwiches for you. 
 In a sandwich attack, a bot spots your transaction, places a buy order before yours to push the price up, and places a sell order right after, pocketing the difference and leaving you with a higher cost per token. Turning on MEV Protect will hide your swaps and thus reducing the chances of MEV or sandwich attacks. 
 :::tip If you are using MEV Protect or Jito only modes
Do note that your transactions may at times fail or be slow to process as not all validators are using Jito block engine.
::: 
 Swap Summary 
 
 The summary shows you the information relating to the trade, such as the minimum received, the transaction fees, and price difference when compared to the market rate. 
 ExactOut 
 
 ExactOut gets the exact amount of tokens that you need. We share this alert because liquidity venues and routes are lesser than ExactIn. Transparently, you should know that you might get a worse price. Best practice is to compare the rates between ExactOut and ExactIn before you trade. 
 Last Updated: 5 November 2024', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/1-swap/3-how-swap-works.md', 'sidebar_label: "How Swap Works"
description: Dive into the concepts behind Jupiter Swap.
title: How Jupiter Swap Works
slug: /swap/how-swap-works 

     Jupiter Swap | Quickstart 
     

 Overview 
 Jupiter Swap is an intricate solution that has evolved over time. It began its journey by solving the expansive number of AMMs (Automated Market Makers) in Solana DeFi (Decentralized Finance). This helped users to find the best price across multiple AMMs with the least friction. 
 However, as Solana grew more popular especially with the inception of Pump.fun and the various memecoin explosions, there were many markets and tokens to be indexed. In 2024, we have improved our infrastructure to support many more markets easily while still safeguarding our users. 
 A high level overview of how swap works: 
 
 Token created, market created on any AMMs (we support most!). 
 Our indexer picks it up immediately, and regardless of liquidity requirements, they are tradable. 
 After 14 days, the market will be checked for the first time and subsequently checked every 30 minutes for its  liquidity requirements .
 
 The market will either be dropped or continue to be served 
 
 
 Our routing engine will perform math and algorithms to ensure you achieve the best quote at time of quote. 
 During swap execution, there are  settings and safeguards  to help you achieve a better user experience. 
 
 Metis: Our Routing Engine 
 Metis is one of the big parts of how Jupiter Swap works, it is a heavily modified variant of the  Bellman-Ford algorithm  catered for the key requirements of offering best price routing at scale in a very dynamic operational space. 
 Metis is designed to operate seamlessly on Solana’s hyper-fast blocktimes, supported by major improvements to our backend infrastructure. This ensures that trades are executed quickly and efficiently, even under high demand. 
 Metis enhances our industry-leading aggregator by improving route discovery for all trading pairs, reducing slippage for large trades, and offering scalable solutions in preparation for upcoming Solana upgrades and new DEXs. 
 Incremental Route Building 
 To find the best price, Metis streams the input tokens to incrementally build a route to split and merge at any stage. By generating the routes for each split iteratively one after another, we can also use the same DEX in different splits - allowing us to find routes with better prices with more complex trades. 
 
 Combine Route Generation and Quoting 
 To improve the efficiency of the algo, we combine route generation and quoting into a single step, allowing us to avoid generating and using bad routes, which besides improving the efficiency, also allows us to use a larger set of tokens as intermediaries. 
 Future Proofing 
 v2 runs fast when the total number of DEXs used is small since Solana limits us to use at most 4 DEXs in a swap  (due to the account lock limit of 64) . Future Solana upgrades will relax this limit and allow more DEXs to be used in a single transaction. In addition, we foresee the continued growth of the Solana DeFi ecosystem, which means there will be many more DEXs emerging. 
 Metis(v3) is equipped to handle both of these trends, since the algorithm is able to scale to include more DEXs in a route when account lock limits are increased, and can support more DEXs with only a modest increase in running time. 
 
 Performance Improvements 
 Metis is able to refresh quotes in parallel and in real time. Compared to v2, metis on average quotes prices that are 5.22% better. These improvements increase sharply based on the trade size. 
 
 Last Updated: 4 November 2024', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/1-swap/1-features.md', 'sidebar_label: "Features"
description: Learn about the latest features on Jupiter Swap.
title: Swap Features
slug: /swap/features 

     Jupiter Swap | Quickstart 
     

 Solana was built with trading in mind with its blazing speed and affordable transaction fees, resulting in thousands of new tokens and markets being spawned and new use cases and concepts being birthed. 
 Our goal at Jupiter is to provide a seamless experience as your Everyday Exchange. As the Everyday Exchange, you can: 
 Access best-priced tokens, quickly. 
 You can find newly launched tokens with our Instant Routing feature. New tokens & markets are automatically added to Jupiter Routing. 
 Access these tokens at best prices with our performant routing engine,  Metis . We perform the math and give you best prices at Solana speed, at 0 protocol fees. 
 Read:  How to Swap 
 Access the right tokens, safely. 
 You see all important token information (metadata, authorities, verification) and trade conditions such as price impact to help you make an informed swap decision. 
 Within Search, we also filter out imposter tokens and duplicates, utilise  community verification  of tokens, and intelligent search using real-time info (liquidity, volume). 
 Read:  How to Trade Safely 
 Trade frictionlessly, knowing it just works. 
 You get an abstracted swap experience with Auto mode by setting your Max Slippage and MEV protection. Jupiter will do the rest by configuring the best transaction fees and slippage based on your trade, heuristics, and market conditions. 
 For folks who wants more fine-tuned control e.g. choosing Fixed Slippage to  Dynamic Slippage , we have Manual mode for you. 
 Read:  How to Configure Settings 
 Last Updated: 4 November 2024', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/4-dca/3-explainer.md', 'sidebar_label: DCA Explainer and Use Cases
description: Learn the how and why behind Jupiter''s Dollar Cost Averaging (DCA) system.
title: DCA Explainer and Use Cases
slug: /dca/explainer 

     Jupiter DCA Explainer and Use Cases | Jupiter Station 
     

 
 What is Dollar Cost Averaging (DCA)? 
 Forecasting whether prices have reached their peak or bottomed out in the short term is one of the most challenging aspects of asset investment. Rather than committing a lump sum in a single transaction, which carries the risk of purchasing near the peak, employing a Dollar-Cost Averaging (DCA) strategy allows you to spread out your investment over time. This helps to smooth out your overall cost, consequently lowering your cost basis. This, in turn, reduces potential losses while enhancing your profitability over the long run. 
 If you have confidence in the value of an asset, adopting a DCA approach proves to be an effective method for gradually accumulating it over time. 
 How DCA works? 
 Dollar-Cost Averaging (DCA) is a straightforward yet powerful strategy that involves dividing your capital into multiple smaller orders over a fixed interval and period of time rather than placing a single large order. Jupiter''s DCA automates these orders for you. 
 When to DCA? 
 Bear Market Accumulation 
 While forecasting short-term price movements can be challenging, identifying a bear market is comparatively more straightforward. Given the near impossibility, if not extreme difficulty, of attaining 100% certainty about a price bottom, a prudent approach is to stagger your orders over a period (e.g., making purchases weekly for the next six months). This strategy aims to average out your entry price during a bear market, potentially yielding substantial gains once a bull market resurgence occurs. 
 Here''s an example with the oldest cryptocurrency - BTC in the prior (2018~2019) bear market: 
 
 When the price has dropped more than 50%, it''s fairly easy to say that we are in a bear market 
 Once that occurs, let''s, for illustration purposes, try to further optimize our strategy by looking at daily RSI - start a daily DCA over 7 days whenever RSI goes below 30 
 Our average price would have been approximately USD 6,000 / BTC 
 Fast forward to September 2023, we are still up a whopping 4x despite BTC prices dropping from +/- USD 64k 
 
 
*  The upper candle stick chart indicates price, the lower line chart indicates RSI. 
 Why not perform a market order when RSI < 30? 
 Based on historical data, prices can still go further lower when RSI is below 30. Buying a single lump sum back in 2018 would still be profitable today. However, going all-in the very first time RSI dipped below 30 would have resulted in an average price of around USD 7,500. Additionally, this approach would have entailed grappling with the psychological impact of a >50% capital loss when BTC ultimately hit its low at approximately USD 3,000+. In contrast, employing a Dollar-Cost Averaging (DCA) strategy would have significantly reduced those losses, ultimately improving the beta (volatility in relation to return) of your portfolio. 
 Bull Market Profit Taking 
 In the example above, we took no profit during the 2021-2022 bull market. It''s worth noting that Dollar-Cost Averaging (DCA) is not limited to just bear markets, if you started accumulating during the bear market, it''s prudent to realize profits during a bull market. Nevertheless, even in a bull market, the challenge persists: discerning the peak is no easy feat. Instead of selling your entire position all at once and potentially missing out on substantial gains if BTC prices surge another 200%, you can opt to sell over a span of time. 
 Using DCA to take profit during bull markets and accumulate during bear markets are some of the best ways to grow your wealth somewhat passively as a longer term investor. Just be sure to research on the right coin / token / asset to invest in. It may also be prudent to further diversify your investable capital to multiple coins / tokens / asset classes. 
 Splitting up large orders 
 Executing market orders, whether through decentralized or centralized exchanges, can lead to negative price impacts, particularly in times of exceptionally low liquidity or with a substantial capital. This is where Dollar-Cost Averaging (DCA) proves invaluable. By spreading your order over a period, you exert less buying / selling pressure on the market, ultimately securing a more favorable average price. With Jupiter''s DCA, you have the flexibility to divide your orders down to intervals as short as 1 minute. In essence, this transforms into a variation of a TWAP (time-weighted average price) strategy, a method frequently utilized by major investors to strategically accumulate / dispose assets. 
 Selling tokens with low liquidity 
 Tokens with low liquidity levels pose a challenge when it comes to selling, as doing so can create significant downward price pressure, leading to larger losses than necessary. Employing a Dollar-Cost Averaging (DCA) strategy can alleviate this issue by spreading out your selling activity, thereby reducing the overall selling pressure and potentially boosting your returns.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/4-dca/2-how-dca-work.md', 'title: How Jupiter DCA Works
sidebar_label: "How DCA Works"
description: Explore how Dollar-Cost Averaging works with Jupiter on Solana, and improve your crypto trading strategies.
slug: /dca/how-dca-work 

     How Dollar Cost Averaging Works on Jupiter 
     

 DCA Creation Process 
 
 When you create a DCA order, your tokens will be transferred from your wallet to a program owned associated token account. 
 As an example, if you choose to use $USDC to DCA into $SOL, the entire specified $USDC amount will be deposited into your DCA vault. 
 The first order takes place immediately after your DCA position has been created and the remaining orders will take place regularly at your selected time interval. 
 As an example, if you choose to use 1,000 $USDC to DCA into $SOL, daily over 10 days, the very first order of 100 $USDC -> $SOL will be executed right after the DCA has been successfully created, and there will be 9 more remaining orders of 100 $USDC -> $SOL to be executed daily. 
 
 :::warning
To minimize the predictability of your DCA strategy, orders are filled within a randomized padding of +/- 30 seconds from your DCA creation time.
::: 
 
 Order Mechanism 
 :::info DCA Order / Account
A DCA order or account is broken down to many orders. The number of orders depends on the options or iterations you choose. For example, if you choose to DCA into SOL with $900 USDC over 3 days, your DCA order/account will have a total of 3 trades/ transactions of $300 USDC each.
::: 
 Scenario with example: 
 If you choose to DCA into SOL with $900 USDC over 3 days 
 
 Your first transaction to swap from $300 USDC for SOL will take place immediately after the DCA order has been confirmed. 
 Your second transaction to swap the next $300 USDC for SOL will take place approximately 24 hours later after the initial transaction. 
 Your third or last transaction to swap the remaining $300 USDC for SOL will take place approximately 24 hours after the second order and so on and so forth. 
 
 The amount of SOL you receive depends on the price at the point in time when the transaction executes. 
 Continuing with the previous example: 
 
 During the first order, if the price of SOL is $20 USDC / SOL, you will receive 300 / 20 = 15 SOL. 
 During the second order, if the price of SOL is $25 USDC / SOL , you will receive 300 / 25 = 12 SOL. 
 During the third order, if the price of SOL is $15 USDC / SOL, you will receive 300 / 15 = 20 SOL. 
 
 There is a platform fee of 0.1% for Jupiter DCA. This fee is applied at time of order/ transaction execution.
With the previous example: 
 
 For the first order, instead of receiving 15 SOL, 15 * (100 - 0.1) % = 14.985 SOL, user will receive 14.985 SOL. 
 For the second order, 12 * (100 - 0.1) % = 11.988 SOL, user will receive 11.988 SOL. 
 
 
 Automatic Transfer of Purchased Tokens on every order 
 You will receive purchased tokens in your wallet within the same transaction of each order. 
 As an example, you choose to DCA $900 USDC over 3 days into SOL. 
 
 On Day 1, you will receive $300 USDC worth of SOL in your wallet automatically. If the price of SOL is $30 USDC / SOL, you will receive 9.97 SOL  (net of fees)  in your wallet. 
 On Day 2, you will receive $300 USDC worth of SOL in your wallet. If the price of SOL is $25 USDC / SOL, you will receive 11.988 SOL  (net of fees)  in your wallet. 
 On Day 3, you will receive $300 USDC worth of SOL in your wallet. If the price of SOL remains $25 USDC / SOL, you will receive 11.988 SOL  (net of fees)  in your wallet. 
 
 :::tip Caveat to auto-withdrawal
In the event your desired purchased token is not SOL, auto withdrawal for each order will only work if you have the correct associated token account (ATA) opened.
::: 
 
 
 By default, Jupiter DCA opens the necessary ATA for your wallet when you create a Jupiter DCA account. However, if you close your purchased token''s ATA manually via your wallet interface or any other 3rd-party tool, tokens will not be transferred to you automatically on every order but only at the end of your DCA cycles as a single lump sum amount.  This is only applicable to SPL tokens. For SOL: Jupiter takes care to open/close your wrapped account. 
 
 
 An example: 
 
 Say you have a DCA order of 300 $USDC -> $BONK daily over 3 days, and you  close  your wallet''s BONK token account before the 2nd trade/ transaction takes place, the 2nd 100 $USDC worth of $BONK will remain in your DCA vault and not be transferred to your wallet automatically. 
 However, during the 3rd and last trade/ transaction, auto-withdrawal will happen regardless of whether you have an open BONK token account. Based on the example above, even though your BONK tokens did not get transferred to your wallet automatically for your 2nd trade/ transaction, your BONK tokens will be transferred to your wallet on the very last trade - see auto close below for more information. 
 Regardless, you can choose to withdraw BONK from your DCA vault at any time through our UI. 
 
 
 
 
 Auto Close 
 :::info Auto Close
At the end of your DCA orders, you do not need to perform any additional actions. Any remaining tokens and rent will be transferred to your wallet account directly.
::: 
 By default, if your wallet’s ATA remains open, your purchase tokens are automatically transferred to you on every order (the program only allows your tokens to be sent to your wallet and no one else’s). 
 However, if there are still tokens yet to be transferred to you (ie. if you close your wallet’s token account for your purchase token halfway through the DCA cycle as described in  auto-withdrawal section ), the DCA program will close the PDA in-token account and utilize the rent recovered to open your wallet''s token account. 
 This allows the program to transfer the remaining purchased tokens to you. As such, you would only receive 2/3 of the rent incurred to initialise your DCA account. Having said that, this 1/3 rent is not absorbed by any third-party. This rent will remain recoverable by you if you decide to close your ATA that “holds” your purchased token. 
 :::warning
Do not close your ATA without first withdrawing the tokens or swapping them for other tokens. Doing so can result in the loss of tokens. This is not unique to Jupiter or Jupiter’s DCA. This has to do with how Solana wallets and accounts work.
::: 
 
 MEV frontrun mitigation 
 
 Orders are not placed exactly when it is due. 
 Orders have a +2 ~ 30 seconds variability, which introduces uncertainty and exposure risk to exploiters and eliminates any sort of risk-free return, rendering front-running a highly risky endeavour. 
 Before a transaction is sent to a node, prices are checked and an estimated out-token  (desired token)  amount is pre-calculated. 
 In addition to slippage settings, these parameters are included in the transaction and should the out-token amount be less than the expected minimum out-token amount, the transaction would fail.
 
 While this does not prevent MEV front-running, similar to a regular AMM swap, users are guaranteed to receive a minimum amount of out-token 
 Transactions can be reverted if an inadequate amount of out-token is received. This ensures prices will not slip to a level where it is sufficiently profitable or at-all profitable for potential front-running bots. 
 
 
 The very nature of DCA is to split an order into multiple orders over a period of time, this naturally reduces price impact from front-running activities.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/4-dca/1-how-to-dca.md', 'title: How to Use Jupiter DCA
sidebar_label: "How to Use DCA"
description: "Learn how to use Dollar Cost Averaging on Jupiter to get the best price on your trades."
slug: /dca/how-to-dca 

     How to use Dollar Cost Averaging (DCA) on Jupiter 
     

 Jupiter DCA is a dollar cost averaging solution designed to enable users to automate the purchase or sale of any SPL tokens at regular intervals over a specified period of time. 
 The DCA feature has some very powerful use cases, such as interacting with low liquidity markets, long term accumulation, or consistent profit taking without disrupting the market price too much. Check out this  Explainer Page  to learn more about DCA other use cases. 
 Basic DCA User Flow 
 
 First, navigate to the  Jupiter Website  and then click on the  DCA  icon below the top navigation bar.  Double check  that the URL in your search bar is correct: https://jup.ag/dca/ 
 Next, connect your wallet by clicking the  Connect Wallet  button in the upper right corner of the site. 
 Select the token you are allocating and the token you are going to be buying on the DCA terminal. 
 Enter the amount of the token you want to allocate to the DCA orders in the amount field. 
 Set the Frequency(Every) and the Duration(Over) for the DCA orders. 
 Double check the Order Summary details and if things look good, click the  Start DCA  button. 
 Confirm the wallet notification and the DCA Order will be submitted to the system. 
 A notification toast will appear in the lower left corner that will notify the user once the transaction has been sent and has completed. 
 Your new DCA will populate the Active DCAs section below the Terminal once it is confirmed and the UI updates. 
 You can expand the Active DCAs and inspect the progress of the DCA in the Overview tab, or inspect the individual orders on the Order tab. 
 
 Let''s go through the DCA Settings in more detail below. 
 
 Jupiter DCA Settings 
 
 
 DCA:  Select the DCA tab in the product navigation menu to arrive at the DCA terminal. 
 Input Token Selector:  Select the token you want to spend/ allocate with your DCA orders. 
 Input Field:  Enter the amount of the input tokens that you are looking to spend/ allocate with your DCA orders. 
 Output Token Selector:  Select the token that you are looking to DCA into or Buy. 
 Frequency:  Specify the time frequency for the DCA orders with a numerical input and the dropdown selector. 
 Duration:  The number of orders you want the DCA to be spread out over. 
 Order Summary:  Specify the details for the current DCA order that you are creating.
In this example:
 
 Sell Total - 50 USDC (You are selling USDC) 
 Sell Per Order - The Sell Total divided by the numerical duration entry. ( 50 USDC / 12 ) 
 Receive - JUP (You are buying JUP) 
 Order Interval - 5 minutes (A trade will take place every 5 minutes) 
 Start Date - The DCA will begin immediately upon submission. 
 Estimated End Date - The final DCA order will finish by this date. 
 Estimated Price Impact Per Order - Estimated impact on the market price of the assets being swapped per DCA trade. 
 Platform Fee - 0.1% platform fee for DCA orders. 
 
 
 Start DCA:  Click to submit the DCA instructions and start the DCA. 
 
 Active DCAs 
 
 
 Active DCAs:  This tab lists out all of your active DCA orders. 
 Individual DCA Orders:  Ongoing DCAs with a progress bar to indicate how much of the DCA has been executed. 
 Order Overview:  To see the DCA order details, expand one of your ongoing DCA orders and review the Overview Details. 
 Balance Summary:  This shows the DCA order balance progress. First is the remaining balance of the token you are spending/ allocating. Second is the amount of tokens that have been successfully purchased. Third is the amount of tokens purchased that have been withdrawn. 
 Order Summary:  This will show the current ongoing DCA order, with information like:
 
 Total Deposited - The input amount and token that you are selling or swapping from. 
 Total Spent - The progress of the DCA, or the amount spent to swap from. 
 Each Order Size - The average order size for the DCA. 
 Current Average Price - The average price for the transactions being completed over the DCA. 
 Buying - The output token you are purchasing with the DCA order. 
 Interval - The time interval specified in the Frequency fields. 
 ''#'' of Orders Left - The number of orders remaining with this DCA request. 
 Next Order - The date and time of the next order to be executed. 
 Created - The date and time when the DCA was submitted. 
 
 
 Close and Withdraw:  Use this to cancel and close the DCA. This will halt the progress on the DCA order and withdraw all funds in the order to your wallet. 
 
 Active DCA Orders 
 
 
 Orders:  Where all DCA transactions will display for active orders. 
 Trade Summary:  Shows each DCA transaction, along with the filled amount with respective date and transaction id. 
 
 
 Past DCAs 
 
 
 Past DCAs:  Here you will find all your DCA order history, whether they completed or were cancelled. 
 Overview:  The Overview tab opens up to show the order details and balance summary. 
 Balance Summary:  You can see the balance details of past order here. 
 Order Summary:  This shows all of the details of the past order including all of the details outlined above. 
 
 Past DCA Orders 
 
 
 Orders:  All the transactions for your DCA order are shown here. 
 Trade Summary:  This shows each individual order amount respective to the date and transaction id.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/3-limit-order/1-limit-order.md', 'sidebar_label: How to Use Limit Order
title: How to Use Limit Order
description: Learn how to place a limit order on Jupiter with this step-by-step guide
slug: /limit-order/limit-order 

     Limit Orders on Jupiter: Basic User Flow | Jupiter Station 
     

 Jupiter Limit Order provides the easiest way to place limit orders on Solana, offering the widest selection of token pairs and leveraging all the available liquidity across the entire Solana ecosystem. With Jupiter Limit Order, you have the flexibility to buy or sell any token pair according to your specified price limit. 
 :::tip Order Minimum & Fees
The Jupiter Limit Order feature has a minimum order size requirement of $5 (underlying assets must be greater than $5 per order) and there is a 0.1% platform fee.
::: 
 Basic Limit Order User Flow 
 
 First, navigate to the  Jupiter Website  and then click on the  Limit Order  icon below the top navigation bar.  Double check  that the URL in your search bar is correct: https://jup.ag/limit 
 Next, connect your wallet by clicking the  Connect Wallet  button in the upper right corner of the site. 
 Select the token you are selling and the token you are buying on the terminal. 
 Enter the amount of the token you are selling in the amount field, set the execution price for the order, and the expiry option in the selector. 
 Double check the limit order inputs and if things look good, click the  Place Limit Order  button. 
 Confirm the wallet notification and the Limit Order will be submitted to the system. 
 A notification toast will appear in the lower left corner that will notify the user once the transaction has been sent and has completed. 
 Your new Limit Order will populate the Open Orders Section below the Terminal once it is confirmed and the UI updates. 
 
 Let''s go through the Limit Order Settings in more detail below. 
 :::info
Global Settings still apply to the Limit Order Functionality, please reference  global settings  for more information.
::: 
 Jupiter Limit Order Settings 
 
 
 Input:  Pick a token from the selector drop-down and specify the amount of tokens that you want to limit sell. 
 Rate/ Price:  Here you specify the limit order rate / price that you''re buying the output token (Or  Use Market  for the current market price). 
 Expiry:  Set an expiry period for your order, from 10 minutes to custom, or even never. 
 Output:  Jupiter Limit Order will be able to compute your parameters and come up with the rate that you''ll be getting. 
 Place Order:  Once you''ve reviewed the order details, you will be able to place the limit order and submit the transaction to the system. 
 
 Open Order 
 
 The Open Orders section is where users will see their open submitted orders that are in the system and have yet to be filled. 
 
 Order Info:  This identifies the order token details from TokenA  (Selling)  to TokenB  (Buying)  and the amounts for the order. 
 Price:  Price is the specified user submitted rate for the limit order - When the on-chain price of the purchase token hits, order will be executed, if there is liquidity available. 
 Expiry:  This is the time dimension set by user when submitting the order, which can be helpful to auto-cancel orders after a specific time period. In this example it''s  Never , therefore the order will remain active on-chain until the price hits the specified amount, at which point the order will be executed. 
 Filled Size:  The fulfillment indicator to monitor the size of the order which has been filled. If it is a large order, and there is insufficient liquidity on-chain, Jupiter''s keeper will try to execute partially, and continue monitoring on-chain price to fulfill the rest of the order. If the order is fully executed, Jupiter will send the tokens directly to user''s wallet. There is no claiming process required once a Limit Order is entirely filled. 
 Action:  Action is where users are able to cancel and close their order/positions. 
 
 Order History 
 
 Order History section is where users keep track of orders that have been completed or cancelled. 
 
 Price:  Price is the specified user submitted rate for the limit order - When the on-chain price of the purchase token hits, order will be executed, if there is liquidity available. 
 Limit Price:  Limit Price is the single unit price for the order - X amount of TokenA per TokenB. 
 Expiry:  This is the time dimension set by user when submitting the order, which can be helpful to auto-cancel orders after a specific time period. 
 Filled Size:  Filled size shows how much of total order size has been fulfilled. 
 Status:  Status indicates the order state - Completed / Cancelled. 
 Action - Cancel:  This order was cancelled. Upon cancelling an order the users funds are refunded back to their wallet. 
 Action - Trade:  This is the actual trade transaction being executed when the on-chain price hits the specified price submitted by user. These trade actions can occur several times for each created order, depending on the available liquidity in the market. 
 Action - Create:  This is the creation of the order, where the user specified the limit order details and deposited the funds for the order to be created.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/3-limit-order/3-lo-partners.md', 'sidebar_label: Partners
title: Limit Order Partners
description: Learn about Jupiter''s limit order partners including Birdeye and TradingView.
slug: /limit-order/lo-partners 

     Limit Order Partners | Jupiter Station 
     

 Jupiter''s powerful charts data and technology are powered by  Birdeye  and  TradingView . 
 
   
     
    
   
 
 Charts data are powered by  Birdeye''s  on-chain data. 
 
 
   
     
       
         
         
       
     
     
       
         
       
     
   
 
 Jupiter uses  TradingView  technology to showcase chart data. TradingView serves as a charting platform catering to a worldwide network of traders and investors, offering exceptional access to real-time information such as the  SOL/USD  chart, the most recent news, financial reports,  Stock screener  and  Economic calendar .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/3-limit-order/2-how-lo-work.md', 'sidebar_label: How Limit Order Works
title: How Limit Order Works
description: "Discover how Jupiter''s limit orders utilize Solana''s liquidity for seamless, front-running-free trading. Perfect for all traders."
slug: /limit-order/how-lo-work 

     How Limit Orders Work on Jupiter: Beginners Guide 
     

 Jupiter Limit Order executes your order based on the price you have set by matching it with the available liquidity on-chain across Solana. Once the order is placed, keepers will continuously monitor the liquidity landscape and execute the limit order when the market price reaches your specified limit. 
 :::info Not an Order Book
This is not an order book system. The limit order system utilizes a keeper to monitor token prices on-chain and trigger the fulfillment of orders if liquidity is available.
::: 
 Scenario 
 
 If a Limit Order is placed to buy 1 $SOL with 10 USDC at a rate of 10 USDC per $SOL. 
 The keeper will monitor the price on-chain using Jupiter  Price API . 
 If the keeper detects that the on-chain price of $SOL reaches 10 USDC, it will proceed to execute and fulfill the order.
 
 If the order size is too large, and there is insufficient liquidity on-chain, the keeper will attempt to execute the order in smaller chunks. It will aim for partial fulfillment to ensure the best price with minimal price impact, continuing until the order is fully filled. 
 
 
 The executed order, whether fully or partially fulfilled, will be automatically transferred to your wallet. 
 
 
 Key Benefits 
 
 Users are able to create limit orders, providing a Centralized Exchange (CEX) experience on Solana. 
 Liquidity from anywhere on Solana is utilized to fulfill the trade. 
 Users can place an order with an expiration time. At the end of the period, the system will automatically cancel any unfilled orders and refund the tokens to the user''s wallet. 
 Limit orders ensure that you get what you''ve been quoted with no slippage. This is especially useful during volatile trading periods. 
 Transactions will not fail due to slippage errors. 
 Jupiter Limit Order offers a wider range of token selections. As long as there is sufficient liquidity in the market, the token pair will be available to trade (execution will be based on available liquidity on-chain). 
 You will never get front-run by MEV. 
 
 
 The difference between Jupiter Limit Order with CLOB 
 Jupiter Limit Order  is designed to prioritize UX, simplicity, flexibility, and the widest liquidity across Solana. 
 Orders are executed by the keeper, envisioning the keeper as similar to a liquidator in a lending protocol. When the price hits the limit price (including fees), the keeper will execute the order. After the order is executed, the user will receive what they quoted, minus the platform fees charged by Jupiter. 
 Central Limit Orderbook (CLOB)  is a mechanism used by TradFi to facilitate trading between buyers and sellers. It acts as a hub where both buyers and sellers can submit their buy/sell orders, which are matched based on specific rules and executed accordingly. 
 This mechanism requires a certain level of market-making for it to operate efficiently. For a particular market or token to be available for trading on the CLOB, it requires a market maker to be present and accessible. In contrast, Jupiter Limit Order executes orders based on on-chain liquidity aggregated by Jupiter. This liquidity consists of more than 20 decentralized exchanges (DEXs) and automated market makers (AMMs) with Solana-wide coverage of SPL tokens, all accessible through an extremely user-friendly interface.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/5-va/1-how-to-va.md', 'title: How to use Jupiter VA
sidebar_label: "How to Use VA"
description: "Learn how to use Value Averaging on Jupiter to get the best price on your trades in. Learn today!"
slug: /va/how-to-va 

     How to use Value Averaging (VA) on Jupiter 
     

 Value averaging (VA) is a strategy that works like dollar-cost averaging (DCA). It works similarly by making contributions in a consistent time period but differs by the amount of each contribution. VA focuses on equal growth of the portfolio instead of equal investments. 
 VA features the ability to react to market volatility and price action, in short, buying more tokens when price is low and buying less tokens when price is high. Check out this  Explainer Page  to learn more about VA. 
 Basic VA User Flow 
 
 First, navigate to the  Jupiter Website  and then click on the  VA  icon below the top navigation bar.  Double check  that the URL in your search bar is correct: https://jup.ag/va/ 
 Next, connect your wallet by clicking the  Connect Wallet  button in the upper right corner of the site. 
 Set the Amount  (Increase Portfolio Value By)  and the Duration  (Every)  for the VA orders.
 Do note  that the amount is based on how much of the total you want to increase by and not how much each contribution is 
 Select the token you want to buy and the token you are allocating  (Max Budget)  on the VA terminal. 
 Select between to Start Now or place the order in the future through Start At. 
 Select between to auto receive the bought tokens in your account or manually claim it. 
 Double check the order Summary details and if things look good, click the  Place Order  button. 
 Confirm the wallet notification and the VA order will be submitted to the system. 
 A notification toast will appear in the lower left corner that will notify the user once the transaction has been sent and has completed. 
 Your new VA order will populate the Active VAs section below the Terminal once it is confirmed and the UI updates. 
 You can expand the Active VAs and inspect the progress of each VA, or view previously completed VAs in Past VAs. 
 
 Let''s go through the VA Settings in more detail below. 
 
 Jupiter VA Settings 
 
 
 VA:  Select the VA tab in the product navigation menu to arrive at the VA terminal. 
 Amount:  Specify the total value where your portfolio will increase by. 
 Duration:  Specify the time frequency for the VA order with a numerical input and the dropdown selector. 
 Output Token Selector:  Select the token that you are looking to buy. 
 Input Token Selector:  Select the token you want to allocate or spend in your VA order. 
 Input Field:  Enter the amount of the input tokens you want to allocate or spend in your VA order. 
 Start Date:  Select between to start your VA order now or in the future. 
 Receive Method:  Select between to automatically receive in your account or manually claim it after every buy. 
 Backtest Result Summary:  A summary is provided based on your inputs and historical data to calculate how much you would have spent and earned in a period. 
 Backtest Result Values:  A breakdown of the backtest result summary:
 
 Average Price - The average price of bought tokens across the period. 
 Total Bought - The total amount of tokens (output token) bought across the period. 
 Number of Buys - The amount of times an order is placed across the period. 
 Total Spent - The total amount of tokens (input token) spent or used to buy across the period. 
 Current Investment Value - The total value of your bought tokens (output token) at the current price. 
 PnL - The amount of Profit or Loss based on the difference between Total Spent and Current Investment Value. 
 
 
 Order Details:  A breakdown of each backtest order when hovering over a circle:
 
 Date - The date when the backtest order was bought. 
 Spent - The amount spent in the specific order. 
 Bought - The amount used to buy in the specific order. 
 Purchased Price - The value of the bought tokens at the specific time. 
 Cummulative Bought - The total amount bought since the start of the VA order. 
 Cummulative Spent - The total amount spent since the start of the VA order. 
 
 
 Backtest Orders Graph Slider:  A sliding tool to inspect other backtest orders in the timeframe. 
 Place Order:  Click to submit the VA instructions and start the VA. 
 
 Active VAs 
 
 
 Active VAs:  This tab lists out all of your active VA orders. 
 Individual VA Orders:  Ongoing VAs with your current input token value and a PnL value. 
 Order Overview:  To see the VA order details, expand one of your ongoing VA orders and review the Overview Details. 
 Order Summary:  A quick overview of the VA order:
 
 Spent - The total amount of input tokens (with USDC value) spent. 
 Bought - The total amount of output tokens bought. 
 Average Buying Price - The average price of bought tokens. 
 Current Token Price - The current token price of the output token. 
 PnL - The amount of Profit or Loss based on the difference between total spent and Current Token Price multiplied by total bought tokens. 
 
 
 Order Breakdown:  A breakdown of the VA order:
 
 Buying - The output token you are buying with the VA order. 
 Interval - The time interval specified in the Duration fields. 
 Created At - The date and time when the VA was submitted. 
 Next Order At - The date and time of the next order to be executed. 
 Estimated $ Next Buy - The estimated price at which the next buy will be valued in USD. 
 Total Deposited - The input amount and token that you are selling from. 
 Amount Withdrawn - The amount of input or output tokens withdrawn from the order. 
 Value Balance - The amount of input or output tokens currently in the order. 
 
 
 Deposit:  Use this to deposit or allocate more input tokens to continue value averaging. 
 Withdraw:  Use this to withdraw either the input (reduce order size) or output (claim the amount bought) tokens currently in the order. 
 Close and Withdraw:  Use this to cancel and close the VA order. This will halt the progress on the VA order and withdraw all funds in the order to your account. 
 
 Active VA Orders 
 
 
 Orders:  Where all VA transactions will display for active orders. 
 Transaction Summary:  Shows each VA transaction, along with the from (input token), rate (input per output), to (output token), respective date and transaction id. 
 
 
 Past VAs 
 
 
 Past VAs:  Here you will find all your VA order history, whether they completed or were cancelled. 
 Overview:  The Overview tab opens up to show the order details and balance summary. 
 Order Summary:  You can see the balance details of past order here. 
 Order Breakdown:  This shows all of the details of the past order including all of the details outlined above. 
 
 Past VA Orders 
 
 
 Orders:  All the transactions for your VA order are shown here. 
 Transaction Summary:  This shows each individual order amount respective to the date and transaction id.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/5-va/3-explainer.md', 'sidebar_label: VA Explainer and Use Cases
description: Explore Jupiter Value Averaging to optimize investment timing. Maximize your returns and reduce market risks effectively.
title: VA Explainer and Use Cases
slug: /va/explainer 

     Jupiter VA Explainer and Use Cases | Jupiter Station 
     

 What is Value Averaging (VA)? 
 Forecasting whether prices have reached their peak or bottomed out in the short term is one of the most challenging aspects of asset investment. Instead of investing a lump sum all at once, which risks buying at a peak, Value Averaging (VA) provides a systematic approach to accumulating investments over time. VA not only helps to smooth out the overall cost but also adjusts the investment amount based on market performance, potentially lowering the cost basis and enhancing long-term profitability. 
 If you have confidence in the value of an asset, adopting a VA strategy proves to be an effective method for gradually accumulating it over time. 
 How VA works? 
 Value Averaging (VA) involves setting a target value for your investment portfolio at regular intervals. You then adjust your investment amount to meet this target, investing more when prices are low and less when prices are high. This method contrasts with Dollar-Cost Averaging (DCA), where you invest a fixed amount at regular intervals. Jupiter''s VA automates these adjustments for you. 
 When to VA? 
 Volatile Markets 
 Cryptocurrency is a highly volatile market, prices can swing dramatically within short periods. VA helps to mitigate the impact of these fluctuations by adjusting investment amounts based on market performance. When prices drop, you invest more, and when prices rise, you invest less, effectively capitalizing on market volatility. 
 Long term strategy 
 Since VA is effective at capitalizing on market volatility, regardless of market conditions, VA can be a good tool to build portfolio and invest consistently based on market conditions. In bear market scenarios, VA can be used to steadily accumulate and contrastingly, VA can be used to take profit during a bull market. VA can be more attractive to than using a set contribution schedule is that you are somewhat protected from overpaying when the market is hot. If you avoid overpaying, your long-term returns will be stronger compared to people who invested set amounts no matter the market condition. 
 Splitting up large orders 
 Executing market orders, whether through decentralized or centralized exchanges, can lead to negative price impacts, particularly in times of exceptionally low liquidity or with a substantial capital. This is where Value Averaging (VA) proves invaluable. By adjusting your order amounts based on market conditions, you exert less buying/selling pressure on the market, ultimately securing a more favorable average price. With Jupiter''s VA, you have the flexibility to adjust your orders dynamically. In essence, this transforms into a variation of a TWAP (time-weighted average price) strategy, a method frequently utilized by major investors to strategically accumulate/dispose of assets. 
 Selling tokens with low liquidity 
 Tokens with low liquidity levels pose a challenge when it comes to selling, as doing so can create significant downward price pressure, leading to larger losses than necessary. Employing a Value Averaging (VA) strategy can alleviate this issue by adjusting your selling activity, thereby reducing the overall selling pressure and potentially boosting your returns.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/guides/2-spot/5-va/2-how-va-work.md', 'title: How Jupiter VA Works
sidebar_label: "How VA Works"
description: Explore How Jupiter VA enhances strategy with Value Averaging. Master its mechanisms and features for maximum returns.
slug: /va/how-va-work 

     How Value Averaging Works on Jupiter: Full Guide 
     

 VA Creation Process 
 
 When you create a VA order, your tokens will be transferred from your wallet to a program owned associated token account. 
 As an example, if you choose to use USDC to VA into SOL, the entire specified USDC amount will be deposited into your VA vault. 
 The first order takes place immediately after your VA position has been created and the remaining orders will take place regularly at your selected time interval. 
 As an example, if you choose to use 1,000 USDC to VA into $SOL, at an increment value of 100 USD per buy, daily over 10 days, the very first order of 100 USDC -> SOL will be executed right after the VA has been successfully created, and the order will continue to execute at your interval and each buy will be 100 USD worth of $SOL. 
 
 :::warning
To minimize the predictability of your VA strategy, orders are filled within a randomized padding of +/- 30 seconds from your VA creation time.
::: 
 
 Order Mechanism 
 :::info VA Order / Account
A VA order or account is broken down into many orders. The number of orders depends on the options or iterations you choose. For example, if you choose to VA into SOL with 900 USDC over 3 days, depending on your portfolio strategy, your VA order/account will defer accordingly to the price action.
::: 
 Scenario with example: 
 If you choose to VA into SOL using 1,000 USDC and increase your portfolio value by $100 per month: 
 
 Your first transaction to buy SOL using 100 USDC will take place immediately after the VA order has been confirmed. 
 Your second transaction to buy SOL using USDC will take place approximately 30 days later after the initial transaction. 
 Your next transaction to buy SOL using USDC will take place approximately 30 days after the second order and so on. 
 
 Continuing with the previous example: 
If during each buy, the price of SOL drastically changes, this is how value average will execute: 
 Month SOL Price Total SOL Before Total Value Before Target Value To Spend To Buy Total SOL After Total Value After 
 1 $100 0 SOL $0 $100 $100 1 SOL 1 SOL $100 
 2 $50 1 SOL $50 $200 $150 3 SOL 4 SOL $200 
 3 $80 4 SOL $320 $300 $0 0 SOL 4 SOL $320 
 4 $90 4 SOL $360 $400 $40 0.444 SOL 4.444 SOL $400 
 
 VA executes by calculating predetermined amounts for the total value of the investment in future periods, then by making an investment to match these amounts at each period. Essentially, buying more when price is low and buying less when price is high. 
 Fees: 
There is a platform fee of 0.1% for Jupiter VA. This fee is applied at time of order/ transaction execution. With the previous example: 
 
 For the first order, instead of receiving 1 SOL, you will receive 1 * (100 - 0.1) % = 0.999 SOL. 
 For the second order, 3 * (100 - 0.1) % = 2.997 SOL, user will receive 2.997 SOL. 
 
 Other scenarios: 
VA may not  always  buy at the same interval. For example, the VA order is set to buy at 8AM every day. 
 
 If during the second day, the price of the token had increased, at 8AM, the keeper will calculate the value of your portfolio (which should have increased) and if the current portfolio value is more than the target value at this interval, the keeper will not execute at 8AM rather it will continue to retry. When the price of the token drops, and your portfolio does not meet the current target value, at any time, the keeper will execute a buy (with a minimum value of $0.50). 
 If the price of the token increases gradually, and the portfolio meets the first few incremented target value, eventually, the target value should have incremented enough, such that the portfolio needs to buy in order to meet the target value. 
 If the price of the token keeps increasing, and the portfolio keeps meeting the target value at every increment, VA does not need to buy. 
 
 
 Value Averaging Token2022 tokens 
 You can value average any Token2022 tokens  but not those with transfer tax . The reason is that tokens with transfer tax involved, are able to tax you when a transaction is made, this means that during every purchase in your VA order, the amount taxed is done on every transaction, which might lead you to a loss. 
 
 Automatic Transfer of Purchased Tokens on every order 
 You will receive purchased tokens in your wallet within the same transaction of each order. 
 Using the previous example: 
 
 For the first order, you will receive $100 worth of SOL in your wallet automatically. 
 For the second order, you will receive $150 worth of SOL in your wallet automatically. 
 
 :::tip Caveat to auto-withdrawal
In the event your desired purchased token is not SOL, auto withdrawal for each order will only work if you have the correct associated token account (ATA) opened.
::: 
 By default, Jupiter VA opens the necessary ATA for your wallet when you create a Jupiter VA account. However, if you close your purchased token''s ATA manually via your wallet interface or any other 3rd-party tool, tokens will not be transferred to you automatically on every order but only at the end of your VA as a single lump sum amount.  This is only applicable to SPL tokens. For SOL: Jupiter takes care to open/close your wrapped account. 
 Alternatively, if you would like to manually claim/withdraw the purchased tokens, you can toggle to the Manual option  before  confirming the VA order. 
 
 Auto Close 
 :::info Auto Close
At the end of your VA orders, you do not need to perform any additional actions. Any remaining tokens and rent will be transferred to your wallet account directly.
::: 
 By default, if your wallet’s ATA remains open, your purchase tokens are automatically transferred to you on every order (the program only allows your tokens to be sent to your wallet and no one else’s). 
 However, if there are still tokens yet to be transferred to you (ie. if you close your wallet’s token account for your purchase token halfway through the VA cycle as described in  auto-withdrawal section ), the VA program will close the PDA in-token account and utilize the rent recovered to open your wallet''s token account. 
 This allows the program to transfer the remaining purchased tokens to you. As such, you would only receive 2/3 of the rent incurred to initialise your VA account. Having said that, this 1/3 rent is not absorbed by any third-party. This rent will remain recoverable by you if you decide to close your ATA that “holds” your purchased token. 
 :::warning
Do not close your ATA without first withdrawing the tokens or swapping them for other tokens. Doing so can result in the loss of tokens. This is not unique to Jupiter or Jupiter’s VA. This has to do with how Solana wallets and accounts work.
::: 
 
 MEV frontrun mitigation 
 
 Orders are not placed exactly when it is due. 
 Orders have a +2 ~ 30 seconds variability, which introduces uncertainty and exposure risk to exploiters and eliminates any sort of risk-free return, rendering front-running a highly risky endeavour. 
 Before a transaction is sent to a node, prices are checked and an estimated out-token  (desired token)  amount is pre-calculated. 
 In addition to slippage settings, these parameters are included in the transaction and should the out-token amount be less than the expected minimum out-token amount, the transaction would fail.
 
 While this does not prevent MEV front-running, similar to a regular AMM swap, users are guaranteed to receive a minimum amount of out-token 
 Transactions can be reverted if an inadequate amount of out-token is received. This ensures prices will not slip to a level where it is sufficiently profitable or at-all profitable for potential front-running bots. 
 
 
 The very nature of VA is to split an order into multiple orders over a period of time, this naturally reduces price impact from front-running activities.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/contribution-readme.md', 'Contributing to Jupiter Documentation 
 This document is a guide for contributing to the Jupiter documentation. If you are not sure what is the best approach to make changes, you can reach out to the team via  Discord  or make an issue in this repository. 
 Understanding the Documentation Structure 
 The documentation is built using  Docusaurus , a modern static website generator. 
 
 Configuration : The documentation configuration is located in the  docusaurus.config.js  file. 
 CSS : The CSS files are located in the  /src/css  folder. 
 Navbar : The navbar config is located in the  /src/constant.ts  file. 
 Sidebars : The sidebar config of the dev docs are located in the  sidebars-docs.js  file. 
 Markdown files : The content of the dev docs is located in the  /docs  folder. 
 
 For API schema: 
 
 Configuration : The API schema configuration uses the  docusaurus-plugin-openapi-docs  plugin in  docusaurus.config.js . 
 OpenAPI schemas : The OpenAPI schemas are located in the  /openapi  folder. 
 OpenAPI generation :
 
 To generate the markdown from the schema run  pnpm docusaurus gen-api-docs <all or a specific id>  or 
 To clean the generated files run  pnpm docusaurus clean-api-docs <all or a specific id> . 
 The markdown files are generated in the  /docs/api  folder. 
 
 
 
 tldr of making changes 
 
 To add a new page, create a new markdown file in the  /docs/<category>  folder. 
 To add a new category, create a new folder in the  /docs  folder and every category has its own sidebar and navbar config.
 
 Add it to the  /src/constant.ts  file to add to navbar. 
 Add it to the  sidebars-docs.js  file.', '{}'::jsonb, NULL, NULL, NOW(), NOW());
INSERT INTO documents (id, doc_type, source_name, doc_path, content, metadata, embedding, token_count, created_at, updated_at) VALUES (gen_random_uuid(), 'jupiter', 'jupiter-docs', 'temp_jupiter_docs/src/pages/blog-redirect.md', 'title: Blog has been moved to jupresear.ch!
slug: /blog-redirect 
 
 
 We have migrated the blog over to  jupresear.ch ! 
 If you are not redirected automatically, click on this  link .', '{}'::jsonb, NULL, NULL, NOW(), NOW());
COMMIT;
-- Jupiter documents loaded
