{
  "url": "file://temp_jupiter_docs/docs/100-swap-api/2-build-swap-transaction.md",
  "content": "sidebar_label: \"Build Swap Transaction\"\ndescription: \"Jupiter Swap API helps you to build your swap transaction using the quote.\"\ntitle: \"Build Swap Transaction\" \n import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem'; \n\n     Build Swap Transaction \n     \n\n :::note \n \n Lite URL:  https://lite-api.jup.ag/swap/v1/swap \n Pro URL:  https://api.jup.ag/swap/v1/swap \n \n To upgrade to Pro or understand our rate limiting, please refer to this section. \n \n API Key Setup \n API Rate Limit \n::: \n \n The Swap API is one of the ways for you to interact with the Jupiter Swap Aggregator program. Before you send a transaction to the network, you will need to build the transaction that defines the instructions to execute and accounts to read/write to. \n It can be complex to handle this yourself, but good news! Most of our APIs and SDKs just handles it for you, so you get a response with the transaction to be prepared and sent to the network. \n :::tip Use Swap API to handle it for you or ... \n If you are looking to interact with the Jupiter Swap Aggregator program in a different way, check out the other guides: \n Swap Instructions \n To compose with instructions and build your own transaction,  read how to use the  /swap-instructions  in this section . \n Flash Fill or Cross Program Invocation (CPI) \n To interact with your own Solana program,  read how to use the  Flash Fill method  or  CPI  in this section .\n::: \n Let’s Get Started \n In this guide, we will pick up from where  Get Quote  guide has left off. \n If you have not set up your environment to use the necessary libraries, the RPC connection to the network and successfully get a quote from the Quote API, please start at  Environment Setup  or  get quote . \n :::tip API Reference\nTo fully utilize the Swap API, check out the  Swap API or Swap Instructions Reference .\n::: \n Swap API \n From the previous guide on getting a quote, now using the quote response and your wallet, you can receive a  serialized swap transaction  that needs to be prepared and signed before sending to the network. \n Get Serialized Transaction \n Using the root URL and parameters to pass in, it is as simple as the example code below! \n :::tip Optimizing for Transaction Landing is super super important!\nThis code block includes additional parameters that our Swap API supports, such as estimating compute units, priority fees and slippage, to optimize for transaction landing. \n To understand how these parameters help, the next step,  Send Swap Transaction guide  will discuss them.\n::: \n const swapResponse = await (\nawait fetch('https://lite-api.jup.ag/swap/v1/swap', {\n    method: 'POST',\n    headers: {\n    'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n    quoteResponse,\n    userPublicKey: wallet.publicKey,\n    \n    // ADDITIONAL PARAMETERS TO OPTIMIZE FOR TRANSACTION LANDING\n    // See next guide to optimize for transaction landing\n    dynamicComputeUnitLimit: true,\n    dynamicSlippage: true,\n    prioritizationFeeLamports: {\n          priorityLevelWithMaxLamports: {\n            maxLamports: 1000000,\n            priorityLevel: \"veryHigh\"\n          }\n        }\n    })\n})\n).json();\n\nconsole.log(swapResponse);\n \n From the above example, you should see this response. \n {\n    swapTransaction: 'AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAGDkS+3LuGTbs......+/oD9qb31dH6i0QZ2IHELXUX3Y1YeW79p9Stkqk12z4yvZFJiQ4GCQwLBwYQBgUEDggNTQ==',\n    lastValidBlockHeight: 279632475,\n    prioritizationFeeLamports: 9999,\n    computeUnitLimit: 388876,\n    prioritizationType: {\n        computeBudget: { \n            microLamports: 25715,\n            estimatedMicroLamports: 785154 \n        }\n    },\n    dynamicSlippageReport: {\n        slippageBps: 50,\n        otherAmount: 20612318,\n        simulatedIncurredSlippageBps: -18,\n        amplificationRatio: '1.5',\n        categoryName: 'lst',\n        heuristicMaxSlippageBps: 100\n    },\n    simulationError: null\n}\n \n What’s Next \n Now, you are able to get a quote and use our Swap API to build the swap transaction for you. Next steps is to proceed to prepare and sign the transaction and send the signed transaction to the network. \n Let’s go sign and send! \n \n Additional Resources \n Build Your Own Transaction With Instructions \n If you prefer to compose with instructions instead of the provided transaction that is returned from the  /swap  endpoint (like the above example). You can post to  /swap-instructions  instead, it takes the same parameters as the  /swap  endpoint but returns you the instructions rather than the serialized transaction. \n :::note\nIn some cases, you may add more accounts to the transaction, which may exceed the transaction size limits. To work around this, you can use the  maxAccounts  parameter in  /quote  endpoint to limit the number of accounts in the transaction. \n Refer to the GET /quote's  maxAccounts  guide for more details. \n::: \n \n     \n         \n             \n                 /swap-instructions code snippet \n             \n         \n     \nExample code snippet of using `/swap-instruction`\n const instructions = await (\n    await fetch('https://lite-api.jup.ag/swap/v1/swap-instructions', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n        quoteResponse,\n        userPublicKey: wallet.publicKey,\n    })\n    })\n).json();\n\nif (instructions.error) {\n    throw new Error(\"Failed to get swap instructions: \" + instructions.error);\n}\n\nconst {\n    tokenLedgerInstruction, // If you are using `useTokenLedger = true`.\n    computeBudgetInstructions, // The necessary instructions to setup the compute budget.\n    setupInstructions, // Setup missing ATA for the users.\n    swapInstruction: swapInstructionPayload, // The actual swap instruction.\n    cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.\n    addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.\n} = instructions;\n\nconst deserializeInstruction = (instruction) => {\n    return new TransactionInstruction({\n    programId: new PublicKey(instruction.programId),\n    keys: instruction.accounts.map((key) => ({\n        pubkey: new PublicKey(key.pubkey),\n        isSigner: key.isSigner,\n        isWritable: key.isWritable,\n    })),\n    data: Buffer.from(instruction.data, \"base64\"),\n    });\n};\n\nconst getAddressLookupTableAccounts = async (\n    keys: string[]\n): Promise<AddressLookupTableAccount[]> => {\n    const addressLookupTableAccountInfos =\n    await connection.getMultipleAccountsInfo(\n        keys.map((key) => new PublicKey(key))\n    );\n\n    return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {\n    const addressLookupTableAddress = keys[index];\n    if (accountInfo) {\n        const addressLookupTableAccount = new AddressLookupTableAccount({\n        key: new PublicKey(addressLookupTableAddress),\n        state: AddressLookupTableAccount.deserialize(accountInfo.data),\n        });\n        acc.push(addressLookupTableAccount);\n    }\n\n    return acc;\n    }, new Array<AddressLookupTableAccount>());\n};\n\nconst addressLookupTableAccounts: AddressLookupTableAccount[] = [];\n\naddressLookupTableAccounts.push(\n    ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))\n);\n\nconst blockhash = (await connection.getLatestBlockhash()).blockhash;\nconst messageV0 = new TransactionMessage({\n    payerKey: payerPublicKey,\n    recentBlockhash: blockhash,\n    instructions: [\n    // uncomment if needed: ...setupInstructions.map(deserializeInstruction),\n    deserializeInstruction(swapInstructionPayload),\n    // uncomment if needed: deserializeInstruction(cleanupInstruction),\n    ],\n}).compileToV0Message(addressLookupTableAccounts);\nconst transaction = new VersionedTransaction(messageV0);\n \n \n Build Your Own Transaction With Flash Fill Or CPI \n If you prefer to interact with the Jupiter Swap Aggregator program with your own on-chain program. There are 2 ways to do it, typically on-chain program call  Cross Program Invocation (CPI)  to interact with each other, we also have another method called  Flash Fill  built by Jupiter (due to limitations of CPI in the past). \n :::info CPI is now recommended!\nAs of January 2025, Jupiter Swap via CPI is recommended for most users. \n The  Loosen CPI restriction  feature has been deployed on Solana, you can read more here .\n::: \n :::tip Why Flash Fill? \n With Jupiter's complex routing, best prices comes at a cost. It often means more compute resources and accounts are required as it would route across multiple DEXes in one transaction. \n Solana transactions are limited to 1232 bytes, Jupiter is using  Address Lookup Tables (ALTs)  to include more accounts in one transaction. However, the CPI method cannot use ALTs, which means when you add more accounts to a Jupiter Swap transaction, it will likely fail if it exceeds the transaction size limits. \n Flash Fill allows the use of Versioned Transaction and ALTs , hence, reducing the total accounts used for a Jupiter Swap transaction.\n::: \n \n     \n         \n             \n                 CPI References \n             \n         \n     \n A CPI transaction will be composed of these instructions: \n \n Borrow enough SOL from the program to open a wSOL account that the program owns. \n Swap X token from the user to wSOL on Jupiter via CPI. \n Close the wSOL account and send it to the program. \n The program then transfers the SOL back to the user. \n \n Links and Resources: \n \n https://github.com/jup-ag/jupiter-cpi-swap-example \n https://github.com/jup-ag/sol-swap-cpi \n \n \n     \n         \n             \n                 To ease integration via CPI, you may add the following crate  jupiter-cpi  to your program. \n             \n         \n     \n In cargo.toml \n [dependencies]\njupiter-cpi = { git = \"https://github.com/jup-ag/jupiter-cpi\", rev = \"5eb8977\" }\n \n In your code \n use jupiter_cpi;\n...\n\nlet signer_seeds: &[&[&[u8]]] = &[...];\n\n// Pass accounts to context one-by-one and construct accounts here\n// Or in practise, it may be easier to use remaining_accounts\n// https://book.anchor-lang.com/anchor_in_depth/the_program_module.html\n\nlet accounts = jupiter_cpi::cpi::accounts::SharedAccountsRoute {\n    token_program: ,\n    program_authority: ,\n    user_transfer_authority: ,\n    source_token_account: ,\n    program_source_token_account: ,\n    program_destination_token_account: ,\n    destination_token_account: ,\n    source_mint: ,\n    destination_mint: ,\n    platform_fee_account: ,\n    token_2022_program: ,\n};\nlet cpi_ctx = CpiContext::new_with_signer(\n    ctx.accounts.jup.to_account_info(),\n    accounts,\n    signer_seeds,\n);\n\njupiter_cpi::cpi::shared_accounts_route(\n    cpi_ctx,\n    id,\n    route_plan,\n    in_amount,\n    quoted_out_amount,\n    slippage_bps,\n    platform_fee_bps,\n);\n\n...\n \n \n \n \n     \n         \n             \n                 Flash Fill References \n             \n         \n     \n A Flash Fill transaction will be composed of these instructions: \n \n Borrow enough SOL for opening the wSOL account from this program. \n Create the wSOL account for the borrower. \n Swap X token to wSOL. \n Close the wSOL account and send it to the borrower. \n Repay the SOL for opening the wSOL account back to this program. \n \n Links and resources: \n \n https://github.com/jup-ag/sol-swap-flash-fill",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/100-swap-api/2-build-swap-transaction.md",
  "extracted_at": "2025-09-03T01:39:45.578313Z"
}