{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/9-legacy/1-apis/2-payments-api.md",
  "content": "sidebar_label: Payments API\ndescription: Discover Jupiter's Legacy V4 Payments API for seamless SPL to USDC conversions.\ntitle: V4 Payments API \n\n     Jupiter V4 Payments API Documentation [Legacy] | Jupiter Station \n     \n\n Payments API: Convert any token to USDC \n Jupiter supports the payments use case. You can use Jupiter + SolanaPay to pay for anything with any SPL token. With this technique you can specify an exact output token amount. \n Use Case \n Payments or interaction with a protocol can require an exact amount of token B. Users might not have token A or prefer to hold other tokens long term. The Jupiter API allows for building a swap transaction to receive an exact amount of token A for a maximum in amount of token B. \n A Practical Example using the API \n Bob is selling a delicious latte for 5 USDC, Alice only holds mSOL but Bob can use the Jupiter API to let Alice swap for exactly 5 USDC then transfer 5 USDC to his payment wallet. \n First, we need to show Alice how much mSOL will he have to spend for the latte. \n curl -s 'https://quote-api.jup.ag/v4/quote?inputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=5000000&swapMode=ExactOut&slippageBps=1' | jq '.data | .[0] | .inAmount, .otherAmountThreshold'\n \n Parameters: \n \n The input mint is mSOL and the output mint is USDC. \n swapMode  is  ExactOut , as opposed to the default  ExactIn . \n we want to receive amount=5000000, 5 USDC. \n \n Response: \n \n inAmount  is the quoted estimated amount of mSOL required to receive 5 USDC. \n otherAmountThreshold  is the maximum in amount, the quote above with the slippage tolerance. \n \n :::info\nCurrently, only Orca Whirlpool, Raydium CPAMM, and Raydium CLAMM support ExactOut mode. All tokens may not be available in this mode.\n::: \n Then Bob creates the transaction with the  /swap  endpoint, and adds a 5 USDC token transfer from Alice to his payment wallet using the  destinationWallet  argument, which Alice will verify, sign and send. \n :::info\nIn the example bellow, we assume the associated token account exists on  destinationWallet .\n::: \n import { Token, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token'; // version 0.1.x\nimport { PublicKey } from '@solana/web3.js';\n\nconst USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');\nconst paymentAmount = 5_000_000; // 5 USDC\nconst merchantWallet = new PublicKey('BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9');\n\n// get serialized transactions for the swap\nconst transactions = await (\n  await fetch('https://quote-api.jup.ag/v4/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // route from /quote api\n      route: routes[0],\n      userPublicKey: wallet.publicKey.toString(),\n    })\n  })\n).json();\n\nconst { swapTransaction } = transactions;\n\nconst userDestinationTokenAccount = Token.getAssociatedTokenAddress(\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  USDC_MINT,\n  wallet.publicKey,\n);\nconst merchantTokenAccount = Token.getAssociatedTokenAddress(\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  TOKEN_PROGRAM_ID,\n  USDC_MINT,\n  merchantWallet,\n  // @ts-ignore\n  true,\n);\n\n// deserialize the transaction\nconst swapTransactionBuf = Buffer.from(swapTransaction, 'base64');\nvar transaction = VersionedTransaction.deserialize(swapTransactionBuf);\nconsole.log(transaction);\n\n// get address lookup table accounts\nconst addressLookupTableAccounts = await Promise.all(\n  transaction.message.addressTableLookups.map(async (lookup) => {\n    return new AddressLookupTableAccount({\n      key: lookup.accountKey,\n      state: AddressLookupTableAccount.deserialize(await connection.getAccountInfo(lookup.accountKey).then((res) => res.data)),\n    });\n  });\n);\n// console.log(addressLookupTableAccounts)\n\n// decompile transaction message and add transfer instruction\nvar message = TransactionMessage.decompile(transaction.message,{addressLookupTableAccounts: addressLookupTableAccounts});\nmessage.instructions.push(\n  Token.createTransferInstruction(\n    TOKEN_PROGRAM_ID,\n    userDestinationTokenAccount,\n    merchantTokenAccount,\n    wallet.publicKey,\n    [],\n    paymentAmount,\n  ),\n);\n\n// compile the message and update the transaction\ntransaction.message = message.compileToV0Message(addressLookupTableAccounts);\n\n// ...Send to Alice to sign then send the transaction\n \n :::tip\nIf you want to add your own fees, check out:  Adding Your Own Fees \n:::",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/9-legacy/1-apis/2-payments-api.md",
  "extracted_at": "2025-09-03T01:39:45.870085Z"
}