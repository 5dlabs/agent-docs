{
  "url": "file://temp_jupiter_docs/docs/100-swap-api/7-requote-with-lower-max-accounts.md",
  "content": "sidebar_label: \"Requote with Lower Max Accounts\"\ndescription: \"Requote and adjust max accounts via the Swap API.\"\ntitle: \"Requote with Lower Max Accounts\" \n\n     Requote with Lower Max Accounts \n     \n\n In some cases where you might be limited or require strict control by adding your own instructions to the swap transaction, you might face issues with exceeding transaction size limit. In this section, we will provide some helping code to help you requote when the transaction size is too large. \n :::note\nWe provide a  maxAccounts  param in the  /quote  endpoint to allow you to reduce the total number of accounts used for a swap - this will allow you to add your own instructions. \n Refer to this section for more information and do note its limitations and important notes before using .\n::: \n Example Code \n \n Request for quote and the swap transaction as per normal. \n Serialize the transaction. \n Use the conditions to check if the transaction is too large.\n \n If too large, requote again with lower max accounts - do note that the route will change. \n If not, sign and send to the network. \n \n \n \n :::tip\nWe recommend  maxAccounts  64 and start as high as you can, then incrementally reduce when requoting. \n Do note that with lower max accounts, it will might yield bad routes or no route at all.\n::: \n :::tip\nWhen you serialize the transaction, you can log the number of raw bytes being used in the transaction. \n You can either add your custom instructions before or after serializing the transaction.\n::: \n import {\n    AddressLookupTableAccount,\n    Connection,\n    Keypair,\n    PublicKey,\n    TransactionInstruction,\n    TransactionMessage,\n    VersionedTransaction,\n} from '@solana/web3.js';\n\n// Set up dev environment\nimport fs from 'fs';\nconst privateKeyArray = JSON.parse(fs.readFileSync('/Path/to/key', 'utf8').trim());\nconst wallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));\nconst connection = new Connection('your-own-rpc');\n\n// Recommended\nconst MAX_ACCOUNTS = 64\n\nasync function getQuote(maxAccounts) {\n    const params = new URLSearchParams({\n        inputMint: 'insert-mint',\n        outputMint: 'insert-mint',\n        amount: '1000000',\n        slippageBps: '100',\n        maxAccounts: maxAccounts.toString()\n    });\n\n    const url = `https://lite-api.jup.ag/swap/v1/quote?${params}`;\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n    \n    const quoteResponse = await response.json();\n    \n    if (quoteResponse.error) {\n        throw new Error(`Jupiter API error: ${quoteResponse.error}`);\n    }\n    \n    return quoteResponse;\n};\n\nasync function getSwapInstructions(quoteResponse) {\n    const response = await fetch('https://lite-api.jup.ag/swap/v1/swap-instructions', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n            quoteResponse: quoteResponse,\n            userPublicKey: wallet.publicKey.toString(),\n            prioritizationFeeLamports: {\n                priorityLevelWithMaxLamports: {\n                    maxLamports: 10000000,\n                    priorityLevel: \"veryHigh\"\n                }\n            },\n            dynamicComputeUnitLimit: true,\n        }, null, 2)\n    });\n\n    if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n\n    const swapInstructionsResponse = await response.json();\n    \n    if (swapInstructionsResponse.error) {\n        throw new Error(`Jupiter API error: ${swapInstructionsResponse.error}`);\n    }\n\n    return swapInstructionsResponse;\n};\n\nasync function buildSwapTransaction(swapInstructionsResponse) {\n    const {\n        computeBudgetInstructions,\n        setupInstructions,\n        swapInstruction,\n        cleanupInstruction,\n        addressLookupTableAddresses,\n    } = swapInstructionsResponse;\n    \n    const deserializeInstruction = (instruction) => {\n        if (!instruction) return null;\n        return new TransactionInstruction({\n            programId: new PublicKey(instruction.programId),\n            keys: instruction.accounts.map((key) => ({\n                pubkey: new PublicKey(key.pubkey),\n                isSigner: key.isSigner,\n                isWritable: key.isWritable,\n            })),\n            data: Buffer.from(instruction.data, \"base64\"),\n        });\n    };\n\n    const getAddressLookupTableAccounts = async (\n        keys\n    ) => {\n        const addressLookupTableAccountInfos =\n            await connection.getMultipleAccountsInfo(\n                keys.map((key) => new PublicKey(key))\n            );\n    \n        return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {\n            const addressLookupTableAddress = keys[index];\n            if (accountInfo) {\n                const addressLookupTableAccount = new AddressLookupTableAccount({\n                    key: new PublicKey(addressLookupTableAddress),\n                    state: AddressLookupTableAccount.deserialize(accountInfo.data),\n                });\n                acc.push(addressLookupTableAccount);\n            }\n    \n            return acc;\n        }, []);\n    };\n\n    const addressLookupTableAccounts = [];\n    addressLookupTableAccounts.push(\n        ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))\n    );\n\n    const blockhash = (await connection.getLatestBlockhash()).blockhash;\n\n    // Create transaction message with all instructions\n    const messageV0 = new TransactionMessage({\n        payerKey: wallet.publicKey,\n        recentBlockhash: blockhash,\n        instructions: [\n            ...(computeBudgetInstructions?.map(deserializeInstruction).filter(Boolean) || []),\n            ...(setupInstructions?.map(deserializeInstruction).filter(Boolean) || []),\n            deserializeInstruction(swapInstruction),\n            ...(cleanupInstruction ? [deserializeInstruction(cleanupInstruction)].filter(Boolean) : []),\n        ].filter(Boolean),\n    }).compileToV0Message(addressLookupTableAccounts);\n\n    const transaction = new VersionedTransaction(messageV0);\n\n    return transaction;\n}\n\nasync function checkTransactionSize(transaction) {\n    // Max raw bytes of a Solana transaction is 1232 raw bytes\n    // Using the conditions below, we can check the size of the transaction\n    // (or if it is too large to even serialize)\n    try {\n        const transactionUint8Array = transaction.serialize();\n        console.log(transactionUint8Array.length)\n\n        // Use 1232 assuming you have added your instructions to the transaction above\n        // If you have not add your instructions, you will need to know how much bytes you might use\n        return (transactionUint8Array.length > 1232);\n\n    } catch (error) {\n        if (error instanceof RangeError) {\n            console.log(\"Transaction is too large to even serialize (RangeError)\");\n\n            return true;\n\n        } else {\n            throw error; // Re-throw if it's not a RangeError\n        }\n    }\n}\n\n// Main execution logic with retry mechanism\nlet counter = 0;\nlet transactionTooLarge = true;\nlet quoteResponse, swapInstructionsResponse, transaction;\n\nwhile (transactionTooLarge && counter < MAX_ACCOUNTS) {\n    try {\n        console.log(`Attempting with maxAccounts: ${MAX_ACCOUNTS - counter}`);\n        \n        quoteResponse = await getQuote(MAX_ACCOUNTS - counter);\n        swapInstructionsResponse = await getSwapInstructions(quoteResponse);\n        transaction = await buildSwapTransaction(swapInstructionsResponse);\n        transactionTooLarge = await checkTransactionSize(transaction);\n        \n        if (transactionTooLarge) {\n            console.log(`Transaction too large (with ${MAX_ACCOUNTS - counter} maxAccounts), retrying with fewer accounts...`);\n            counter++;\n        } else {\n            console.log(`Transaction size OK with ${MAX_ACCOUNTS - counter} maxAccounts`);\n        }\n        \n    } catch (error) {\n        console.error('Error in attempt:', error);\n        counter += 2; // Incrementing by 1 account each time will be time consuming, you can use a higher counter\n        transactionTooLarge = true;\n    }\n}\n\nif (transactionTooLarge) {\n    console.error('Failed to create transaction within size limits after all attempts');\n} else {\n    console.log('Success! Transaction is ready for signing and sending');\n    \n    // After, you can add your transaction signing and sending logic\n}\n \n Example Response \n Attempting with maxAccounts: 64\nTransaction is too large to even serialize (RangeError)\nTransaction too large (with 64 maxAccounts), retrying with fewer accounts...\n\nAttempting with maxAccounts: 63\nTransaction is too large to even serialize (RangeError)\nTransaction too large (with 63 maxAccounts), retrying with fewer accounts...\n\n...\n\nAttempting with maxAccounts: 57\n1244\nTransaction too large (with 57 maxAccounts), retrying with fewer accounts...\n\nAttempting with maxAccounts: 56\n1244\nTransaction too large (with 56 maxAccounts), retrying with fewer accounts...\n\n...\n\nAttempting with maxAccounts: 51\n1213\nTransaction size OK with 51 maxAccounts\nSuccess! Transaction is ready for signing and sending",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/100-swap-api/7-requote-with-lower-max-accounts.md",
  "extracted_at": "2025-09-03T01:39:45.669382Z"
}