{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/1-composing-with-versioned-transaction.md",
  "content": "sidebar_label: \"Versioned Transactions\"\ndescription: Explore Versioned Transactions with Jupiterâ€™s V4 API for streamlined swaps and more functions on Solana.\ntitle: Composing With Versioned Transactions \n\n     Versioned Transactions on Jupiter: A Full Guide \n     \n\n \n Jupiter's V4 API improves composability by utilizing Solana's Versioned Transactions and Address Lookup Tables so all Jupiter routes can be done in a single transaction. \n For anyone developing on Solana, one of the biggest hurdles in composing protocols has been dealing with the transaction size limit of 1232 bytes. Given that each account takes 32 bytes and each signature takes 64 bytes, it is easy to hit the transaction size limit frequently. For Jupiter, this meant that we were limited to two-hop swaps and used up all the transaction size just to fit the two swaps into a single transaction. \n \n Summary of constraints that affect composability \n \n transaction size  is limited to 1232 bytes.   \n compute budget  is defaulted to 200k compute units with a max of 1.4M compute units. If you exceed the compute budget, your transaction will be halted.  Most programs have designed their compute budget to take up 200k which you can use to estimate your compute budget. However, many programs do not have an upper bound on their compute budget and it's possible for them to exceed the limit.  Jupiter transactions request the full 1.4M to accommodate some of these programs as best as possible. \n cross-program invocations  are limited to 4 levels \n stack usage  can not exceed 4k  \n BPF call depth  can not exceed 64 \n \nGet more details from the  Solana runtime .\n \n By utilizing Versioned Transactions with Address Lookup Tables, all Jupiter swaps can now be done in a single transaction with approximately 50% of the transaction size freed for anyone to add their own instructions. \n What are Versioned Transactions? \n Versioned Transactions  are the new transaction format that allows for additional functionality in the Solana runtime, including  Address Lookup Tables .  Address Lookup Tables let you store the account addresses in on-chain tables instead of being stored directly in the transaction which will free up space for other instructions. \n :::info You do not need to use Address Lookup Tables to compose with Jupiter.\nWe automatically construct the transactions to use the correct Jupiter lookup tables for you.  However, using your own on-chain lookup tables will allow you to fit more instructions into the transaction.\n::: \n 1. Get the Jupiter swap transaction from the API. \n You can refer to the example code in Using the API for retrieving a Jupiter swap transaction. \n // Some more imports you will need\nimport { TransactionMessage, VersionedMessage, TransactionInstruction, sendAndConfirmRawTransaction, SystemProgram, AddressLookupTableAccount } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, Token, TOKEN_PROGRAM_ID } from '@solana/spl-token';\n\n// public key to use for this example\nconst referralWalletPublicKey = new PublicKey(\"referral_wallet_public_key\")\n \n 2. Deserialize the transaction \n // deserialize the transaction\nconst swapTransactionFromJupiterAPI = swapTransaction\nconst swapTransactionBuf = Buffer.from(swapTransactionFromJupiterAPI, 'base64')\nvar transaction = VersionedTransaction.deserialize(swapTransactionBuf)\n// console.log(transaction)\n \n 3. Construct the referral fee transfer instruction \n // construct the transfer instruction\nconst transferInstruction = SystemProgram.transfer({\n    fromPubkey: wallet.publicKey,\n    toPubkey: referralWalletPublicKey,\n    lamports: 1000,\n  }),\n \n 4. Fetch the Address Lookup Table accounts \n This will be needed to decompile and compile the transaction message. \n // get address lookup table accounts\nconst addressLookupTableAccounts = await Promise.all(\n  transaction.message.addressTableLookups.map(async (lookup) => {\n    return new AddressLookupTableAccount({\n      key: lookup.accountKey,\n      state: AddressLookupTableAccount.deserialize(await connection.getAccountInfo(lookup.accountKey).then((res) => res.data)),\n    })\n  }))\n// console.log(addressLookupTableAccounts)\n \n 5. Decompile the transaction message and add the transfer instruction \n // decompile transaction message and add transfer instruction\nvar message = TransactionMessage.decompile(transaction.message,{addressLookupTableAccounts: addressLookupTableAccounts})\nmessage.instructions.push(transferInstruction)\n \n 6. Compile the new message and update the transaction \n // compile the message and update the transaction\ntransaction.message = message.compileToV0Message(addressLookupTableAccounts)\n \n 7. Sign and send the transaction \n // sign the transaction\ntransaction.sign([wallet.payer])\n\n// Execute the transaction\nconst rawTransaction = transaction.serialize()\nconst txid = await sendAndConfirmRawTransaction(connection, Buffer.from(rawTransaction), {\n  skipPreflight: true,\n  commitment: 'confirmed',\n  maxRetries: 2\n})\nconsole.log(`https://solscan.io/tx/${txid}`)\n \n Using your own Address Lookup Tables \n If you'd like to use your own address lookup tables, you just need to append your tables to the address lookup table accounts \n // ...\naddressLookupTableAccounts.push(yourAddressLookupTableAccounts)\n// ...\n \n :::tip Resources for creating and using Address Lookup Tables \n \n Github docs on versioned transactions \n Github docs on address lookup tables \n Phantom's guide for sending a versioned transaction \n:::",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/8-additional-topics/1-composing-with-versioned-transaction.md",
  "extracted_at": "2025-09-03T01:39:45.875318Z"
}