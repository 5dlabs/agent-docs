{
  "url": "file://temp_jupiter_docs/docs/900-lend-api/oracle.md",
  "content": "sidebar_label: \"Oracles\"\ndescription: \"Oracles for Jupiter Lend.\"\ntitle: \"About Oracles\" \n\n     Oracles \n     \n\n The Oracle Program delivers accurate price data to the protocol by integrating with trusted oracle providers. It calculates exchange rates by combining multiple price sources in a structured sequence, ensuring reliable asset valuations. \n :::note\nThe Oracle program has been audited by Zenith and Offside.\n::: \n Oracle Program Address:   jupnw4B6Eqs7ft6rxpzYLJZYSnrpRgPcr589n5Kv4oc \n Hop-Based Oracle System \n The system computes exchange rates by processing prices from up to four sources in a sequential chain. Each source contributes to the final rate through multiplication or division, with the option to invert values as needed. Currently, Pyth is the supported source type. \n For example, to derive the JUPSOL/SOL rate, the system combines JUPSOL/USD and SOL/USD feeds, inverting the latter to obtain USD/SOL, resulting in an accurate exchange rate. \n This design enables the system to: \n \n Aggregate rates from multiple feeds, reducing dependency on any single provider \n Adjust for varying units or scales using predefined multipliers and divisors \n Validate data integrity at each step \n \n Freshness Enforcement \n To ensure prices reflect current market conditions, the system enforces strict time-based validity checks: \n \n User Operations : Prices must be no older than 60 seconds to be considered valid for actions like borrowing or supplying assets \n Liquidations : Prices can be up to 1800 seconds (30 minutes) old, allowing liquidations to proceed during temporary oracle delays while avoiding reliance on outdated data \n \n These checks prevent the protocol from using stale prices for liquidation or health factor calculations. \n Confidence Interval Validation \n The system evaluates the confidence interval provided by Pyth price feeds to ensure data reliability: \n \n User Operations : The confidence interval must be within 2% of the reported price \n Liquidations : The confidence interval must be within 4% of the reported price \n \n If a price feed's confidence exceeds these thresholds, it is rejected. \n Providers \n The program currently utilizes Pyth push feeds for price data. Integration with Chainlink streams is underway to broaden the range of sources. \n Oracle Verification Script \n Use this script to verify oracle prices by providing a nonce: \n import { Program, AnchorProvider } from \"@coral-xyz/anchor\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport axios from \"axios\";\n\nconst NONCE = 2; // Change this to test different oracles\nconst ORACLE_PROGRAM_ID = new PublicKey(\"jupnw4B6Eqs7ft6rxpzYLJZYSnrpRgPcr589n5Kv4oc\");\nconst IDL_URL = \"https://raw.githubusercontent.com/jup-ag/jupiter-lend/refs/heads/main/target/idl/oracle.json\";\nconst RPC_URL = \"<RPC URL>\";\n\nclass OracleReader {\n  private program: Program;\n\n  private constructor(program: Program) {\n    this.program = program;\n  }\n\n  static async create(): Promise<OracleReader> {\n    const connection = new Connection(RPC_URL);\n    const response = await axios.get(IDL_URL);\n    const idl = response.data;\n\n    const wallet = {\n      signTransaction: () => { throw new Error(\"Read-only\"); },\n      signAllTransactions: () => { throw new Error(\"Read-only\"); },\n      publicKey: new PublicKey(\"11111111111111111111111111111111\"),\n    };\n\n    const provider = new AnchorProvider(connection, wallet, {});\n    const program = new Program(idl, provider);\n    return new OracleReader(program);\n  }\n\n  private findOraclePDA(nonce: number): PublicKey {\n    const [pda] = PublicKey.findProgramAddressSync(\n      [\n        Buffer.from(\"oracle\"),\n        Buffer.from(new Uint8Array(new Uint16Array([nonce]).buffer)),\n      ],\n      ORACLE_PROGRAM_ID\n    );\n    return pda;\n  }\n\n  async getPrice(nonce: number) {\n    const oraclePDA = this.findOraclePDA(nonce);\n    const oracleAccount = await this.program.account.oracle.fetch(oraclePDA);\n    \n    const remainingAccounts = oracleAccount.sources.map((source: any) => ({\n      pubkey: source.source,\n      isWritable: false,\n      isSigner: false,\n    }));\n\n    const price = await this.program.methods\n      .getExchangeRateOperate(nonce)\n      .accounts({ oracle: oraclePDA })\n      .remainingAccounts(remainingAccounts)\n      .view();\n\n    return {\n      nonce,\n      oraclePDA: oraclePDA.toString(),\n      price: price.toString(),\n      sources: oracleAccount.sources.length\n    };\n  }\n}\n\nasync function main() {\n  const reader = await OracleReader.create();\n  const result = await reader.getPrice(NONCE);\n  console.log(result);\n}\n\nmain().catch(console.error);",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/900-lend-api/oracle.md",
  "extracted_at": "2025-09-03T01:39:45.795153Z"
}