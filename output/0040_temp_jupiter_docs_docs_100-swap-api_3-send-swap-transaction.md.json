{
  "url": "file://temp_jupiter_docs/docs/100-swap-api/3-send-swap-transaction.md",
  "content": "sidebar_label: \"Send Swap Transaction\"\ndescription: \"Jupiter Swap API helps you to optimize sending transaction to the network.\"\ntitle: \"Send Swap Transaction\" \n\n     Send Swap Transaction \n     \n\n Transaction sending can be very simple but optimizing for transaction landing can be challenging. This is critical in periods of network congestion when many users and especially bots are competing for block space to have their transactions processed. \n :::tip Improve Transaction Landing Tip\nBy using Jupiter Swap API, you can enable Dynamic Slippage, Priority Fee estimation and Compute Unit estimation, all supported on our backend and served directly to you through our API.\n::: \n Let’s Get Started \n In this guide, we will pick up from where  Get Quote  and  Build Swap Transaction  guide has left off. \n If you have not set up your environment to use the necessary libraries, the RPC connection to the network and successfully get a quote from the Quote API, please start at  Environment Setup  or  get quote . \n Prepare Transaction \n :::info Who is the signer?\nThe most important part of this step is to sign the transaction. For the sake of the guide, you will be using the file system wallet you have set up to sign and send yourself. \n However, for other production scenarios such as building your own program or app on top of the Swap API, you will need the user to be the signer which is often through a third party wallet provider, so do account for it.\n::: \n In the previous guide, we are able to get the  swapTransaction  from the Swap API response. However, you will need to reformat it to sign and send the transaction, here are the formats to note of. \n Formats Description \n Serialized Uint8array format The correct format to send to the network. \n Serialized base64 format This is a text encoding of the Uint8array data, meant for transport like our Swap API or storage. You should not sign this directly. \n Deserialized format This is the human-readable, object-like format before serialization. This is the state you will sign the transaction. \n \n Here's the code to deserialize and sign, then serialize. \n \n swapTransaction  from the Swap API is a serialized transaction in the  base64 format . \n Convert it to  Uint8array (binary buffer) format . \n Deserialize it to a  VersionedTransaction  object to sign. \n Finally, convert it back to  Uint8array  format to send the transaction. \n \n const transactionBase64 = swapResponse.swapTransaction\nconst transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, 'base64'));\nconsole.log(transaction);\n\ntransaction.sign([wallet]);\n\nconst transactionBinary = transaction.serialize();\nconsole.log(transactionBinary);\n \n :::tip Blockhash Validity\nIf you look at the response of  console.log(transaction); , you can see that our backend has already handled the blockhash and last valid block height in your transaction. \n The validity of a blockhash typically lasts for 150 slots, but you can manipulate this to reduce the validity of a transaction, resulting in faster failures which could be useful in certain scenarios. \n Read more about transaction expiry here. \n::: \n Send Transaction \n Transaction Sending Options \n Finally, there are a 2  transaction sending options  that we should take note of. Depending on your use case, these options can make a big difference to you or your users. For example, if you are using the Swap API as a payment solution, setting higher  maxRetries  allows the transaction to have more retries as it is not as critical compared to a bot that needs to catch fast moving markets. \n \n     \n         \n             \n                 Transaction Sending Options \n             \n         \n     \n Options Description \n maxRetries Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter is not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \n skipPreflight If true, skip the preflight transaction checks (default: false). Verify that all signatures are valid. Check that the referenced blockhash is within the last 150 blocks. Simulate the transaction against the bank slot specified by the preflightCommitment. \n \n \n const signature = await connection.sendRawTransaction(transactionBinary, {\n    maxRetries: 2,\n    skipPreflight: true\n});\n \n Transaction Confirmation \n In addition, after sending the transaction, it is always a best practice to check the transaction confirmation state, and if not, log the error for debugging or communicating with your users on your interface.  Read more about transaction confirmation tips here. \n const confirmation = await connection.confirmTransaction({signature,}, \"finalized\");\n\nif (confirmation.value.err) {\n    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\\nhttps://solscan.io/tx/${signature}/`);\n} else console.log(`Transaction successful: https://solscan.io/tx/${signature}/`);\n \n Swap Transaction Executed! \n If you have followed the guides step by step without missing a beat, your transaction  should  theoretically land and you can view the link in console log to see the  transaction . \n Oh? Transaction Not Landing? \n As the Solana network grew and increased in activity over the years, it has become more challenging to land transactions. There are several factors that can drastically affect the success of your transaction: \n \n Setting competitive priority fee \n Setting accurate amount of compute units \n Managing slippage effectively \n Broadcasting transaction efficiently \n Other tips \n \n How Jupiter Estimates Priority Fee? \n You can pass in  prioritizationFeeLamports  to Swap API where our backend will estimate the Priority Fee for you. \n We are using  Triton’s  getRecentPrioritizationFees  to estimate using the local fee market in writable accounts of the transaction (comparing to the global fee market), across the past 20 slots and categorizing them into different percentiles. \n Read more about Priority Fee here. \n Parameters Description \n maxLamports A maximum cap applied if the estimated priority fee is too high. This is helpful when you have users using your application and can be a safety measure to prevent overpaying. \n global A boolean to choose between using a global or local fee market to estimate. If  global  is set to  false , the estimation focuses on fees relevant to the  writable accounts  involved in the instruction. \n priorityLevel A setting to choose between the different percentile levels. Higher percentile will have better transaction landing but also incur higher fees. medium : 25th percentile high : 50th percentile veryHigh : 75th percentile \n \n const swapResponse = await (\n  await fetch('https://lite-api.jup.ag/swap/v1/swap', {\n      method: 'POST',\n      headers: {\n      'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n          quoteResponse,\n          userPublicKey: wallet.publicKey,\n          prioritizationFeeLamports: {\n              priorityLevelWithMaxLamports: {\n                  maxLamports: 10000000,\n                  global: false,\n                  priorityLevel: \"veryHigh\"\n              }\n          }\n      })\n  })\n).json();\n \n How Jupiter Estimates Compute Unit Limit? \n You can pass in  dynamicComputeUnitLimit  to Swap API where our backend will estimate the Compute Unit Limit for you. \n When  true , it allows the transaction to utilize a dynamic compute unit rather than using incorrect compute units which can be detrimental to transaction prioritization. Additionally, the amount of compute unit used and the compute unit limit requested to be used are correlated to the amount of priority fees you pay. \n Read more about Compute Budget, Compute Unit, etc here. \n const swapTransaction = await (\n  await fetch('https://lite-api.jup.ag/swap/v1/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      quoteResponse,\n      userPublicKey: wallet.publicKey,\n      dynamicComputeUnitLimit: true\n    })\n  })\n).json();\n \n How Jupiter Estimates Slippage? \n Slippage is an unavoidable aspect of trading on decentralized exchanges (DEXes). \n About Slippage \n \n Token Pair:  The same fixed slippage setting can have very different effects depending on the tokens involved. For example, swapping between two stablecoins is much less volatile than swapping between two meme coins. \n Timing:  The time between when you receive a quote and when you actually send the swap transaction matters. Any delay can result in the price moving outside your slippage threshold. \n Transaction Landing:  How efficiently your transaction lands on-chain also affects slippage. Poorly optimized transactions may experience more slippage. \n \n :::tip Use Ultra API! \n \n If you use the Swap API:\n \n You are limited to fixed and dynamic slippage settings. \n You are responsible for handling slippage and optimizing transaction landing yourself. \n \n \n Alternatively, consider using the Ultra API :\n \n All of these optimizations are handled for you - without any RPC from you. \n Additional routing is available to RFQ (Request for Quote) systems like Jupiterz where slippage is not an issue because the market maker fills your order exactly as quoted.\n::: \n \n \n \n Dynamic Slippage \n Apart from the fixed slippage setting, you can use Dynamic Slippage: During swap transaction building, we will simulate the transaction and estimate a slippage value, which we then factor in the token categories heuristics to get the final slippage value. \n :::info Dynamic Slippage vs Real Time Slippage Estimator (RTSE)\nRTSE is very different from Dynamic Slippage and has provided a much better user experience and results. RTSE is able to intelligently estimate the best possible slippage to use at the time of execution, balancing between trade success and price protection. RTSE uses a variety of heuristics, algorithms and monitoring to ensure the best user experience: \n \n Heuristics : Token categories, historical and real-time slippage data, and more. \n Algorithms : Exponential Moving Average (EMA) on slippage data, and more. \n Monitoring : Real-time monitoring of failure rates to ensure reactiveness to increase slippage when necessary. \n \n Refer to Ultra API for more information on RTSE .\n::: \n :::warning\nTo use Dynamic Slippage, you will need to pass in  dynamicSlippage=true  to both the  /swap/v1/quote  and  /swap/v1/swap  endpoints. \n Do note that we have discontinued development on Dynamic Slippage.\n::: \n const quoteResponse = await (\n  await fetch(\n    'https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000000&slippageBps=50&restrictIntermediateTokens=true&dynamicSlippage=true'\n  )\n).json();\n\nconst swapTransaction = await (\n  await fetch('https://lite-api.jup.ag/swap/v1/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      quoteResponse,\n      userPublicKey: wallet.publicKey,\n      dynamicSlippage: true,\n    })\n  })\n).json();\n \n How Jupiter Broadcast Transactions? \n Transaction broadcasting is the process of submitting a signed transaction to the network so that validators can verify, process, and include it in a block. \n Broadcasting Through RPCs \n After you’ve built and signed your transaction, the signed transaction is serialized into a binary format and sent to the network via a Solana RPC node. The RPC node will verify and relay the transaction to the leader validator responsible for producing the next block. \n Read more about how RPC nodes broadcast transactions. \n This is the most typical method to send transactions to the network to get executed. It is simple but you need to make sure the transactions are: \n \n Send in the serialized transaction format. \n Use fresh blockhash and last valid blockheight. \n Use optimal amount of priority fees and compute unit limit. \n Free of error. \n Utilize retries. \n Configure your RPCs\n \n Optional but you can send your transaction to a staked RPC endpoint also known as  Stake-Weighted Quality of Service (SWQoS) . \n Used dedicated RPC services versus free or shared, depending on how critical your usage is. \n Propagate to multiple RPC rather than reliant on one. \n \n \n \n Broadcasting Through Jito \n To include Jito Tips in your Swap transaction, you can do specify in the Swap API parameters. However, please take note of these when sending your transaction to Jito and  you can find thsese information in their documentation : \n \n You need to submit to a Jito RPC endpoint for it to work. \n You need to send an appropriate amount of Jito Tip to be included to be processed. \n \n :::note More about Jito\nYou can leverage  Jito  to send transactions via tips for faster inclusion and better outcomes. Similar to Priority Fees, Jito Tips incentivize the inclusion of transaction bundles during block production, enhancing users' chances of securing critical transactions in competitive scenarios. \n Additionally, Jito enables bundling transactions to ensure they execute together or not at all, helping protect against front-running and other MEV risks through “revert protection” if any part of the sequence fails, all while reducing transaction latency for timely execution. \n Read more about how Jito works and other details here. \n::: \n const swapTransaction = await (\n  await fetch('https://lite-api.jup.ag/swap/v1/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      quoteResponse,\n      userPublicKey: wallet.publicKey,\n      prioritizationFeeLamports: {\n        jitoTipLamports: 1000000 // note that this is FIXED LAMPORTS not a max cap\n      }\n    })\n  })\n).json();",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/100-swap-api/3-send-swap-transaction.md",
  "extracted_at": "2025-09-03T01:39:45.682549Z"
}