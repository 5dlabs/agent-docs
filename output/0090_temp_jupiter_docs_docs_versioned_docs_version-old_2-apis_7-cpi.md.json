{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/7-cpi.md",
  "content": "sidebar_label: \"CPI / Smart Contract Integration\"\ndescription: Learn how to optimize your Solana projects with Jupiter Swap CPI for efficient token swaps and advanced API integration.\ntitle: Jupiter Swap via CPI \n\n     Jupiter Swap CPI: Streamline Your Solana Integrations \n     \n\n To integrate your program with Jupiter Swap you can take two approaches. One is Flash Filling or you can utilize Cross Program Invocation (CPI). \n :::note CPI is recommended\nAs of January 2025, Jupiter Swap via CPI is recommended for most users. \n The  Loosen CPI restriction  feature has been deployed on Solana, you can find more information  here .\n::: \n :::danger CPI Limitations\nAs of August 2023, taking the CPI approach has some tradeoffs. Due to Solana's transaction limit of 1232 bytes, swaps via CPI will likely fail at runtime since Jupiter routes may involve multiple DEXes in order to reduce price impact. You could set a limit to the number of accounts used for swaps via Jupiter's swap API to fit it within your needs. However, limiting the accounts will likely incur greater price impact. \n Note: when using Jupiter's API, you can set maxAccounts to reduce the number of accounts. \n::: \n :::info Use Flash-Fill\nAn alternative method is to use the flash-fill approach. The flash-fill approach takes advantage of  Versioned Transaction  in combination with  Address Lookup Tables  to allow for more accounts per transaction while keeping within the 1232 bytes limit.\n::: \n Example \n Here we show an  example transaction  on how to utilize Jupiter Swap via CPI to swap from any tokens to SOL. This works even if the user doesn't have enough SOL. You can even allow a third-party payer if the user doesn't have any SOL at all. \n How does this work? \n For a CPI to work, the transaction will be composed of these instructions: \n \n Borrow enough SOL from the program to open a wSOL account that the program owns. \n Swap X token from the user to wSOL on Jupiter via CPI. \n Close the wSOL account and send it to the program. \n The program then transfers the SOL back to the user. \n \n Code Repo \n Here is the GitHub repo:  https://github.com/jup-ag/sol-swap-cpi . You should check out the  program code  and the  client code . \n Here is the  transaction on chain  on how this works. \n Rust Crate \n To ease integration via CPI, you may add the following crate  jupiter-cpi  to your program. \n Cargo.toml \n [dependencies]\njupiter-cpi = { git = \"https://github.com/jup-ag/jupiter-cpi\", rev = \"5eb8977\" }\n... other dependencies\n \n use jupiter_cpi;\n\n...\n\nlet signer_seeds: &[&[&[u8]]] = &[...];\n\n// pass accounts to context one-by-one and construct accounts here.\n// Or in practice, it may be easier to use `remaining_accounts` https://book.anchor-lang.com/anchor_in_depth/the_program_module.html\nlet accounts = jupiter_cpi::cpi::accounts::SharedAccountsRoute {\n    token_program: ,\n    program_authority: ,\n    user_transfer_authority: ,\n    source_token_account: ,\n    program_source_token_account: ,\n    program_destination_token_account: ,\n    destination_token_account: ,\n    source_mint: ,\n    destination_mint: ,\n    platform_fee_account: ,\n    token_2022_program: ,\n};\n\nlet cpi_ctx = CpiContext::new_with_signer(\n    ctx.accounts.jup.to_account_info(),\n    accounts,\n    signer_seeds,\n);\n\njupiter_cpi::cpi::shared_accounts_route(\n    cpi_ctx,\n    id,\n    route_plan,\n    in_amount,\n    quoted_out_amount,\n    slippage_bps,\n    platform_fee_bps,\n)?;\n\n...",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/7-cpi.md",
  "extracted_at": "2025-09-03T01:39:45.836672Z"
}