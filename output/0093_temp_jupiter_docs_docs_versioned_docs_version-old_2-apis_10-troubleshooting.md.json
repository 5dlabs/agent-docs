{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/10-troubleshooting.md",
  "content": "sidebar_label: \"Troubleshooting\"\ndescription: Master Jupiter Swap API with quick fixes for common issues like timeouts and errors. Boost your API skills now!\ntitle: Troubleshooting Tips \n\n     Jupiter Swap API Troubleshooting Tips \n     \n\n Swap Execution \n Common transaction error: \n \n Program log: Custom program error: 0x1771 \n \n \n Program Jupiter Aggregator v6 consumed 67018 of 200000 compute units \n \n \n Program returned error: custom program error: 0x1771 \n \n 0x1771  occurs when the slippage tolerance is exceeded, so when the final out amount is less than the minimum out amount. \n Wrap and Unwrap SOL \n You can refer to the documentation here: https://solanacookbook.com/references/token.html#how-to-manage-wrapped-sol. For the Jupiter API, there is also a  wrapAndUnwrapSol  parameter that you can use as well. \n Transaction Confirmation Timeout \n From time to time, you may see an error message like  Transaction was not confirmed in 60.00 seconds. , this means that your transaction expires without being confirmed. Each block on Solana has a fixed compute unit allocation. Each account can only take up certain compute units in the block. So, if you are swapping through a very hot pair, that means that many people will compete with you for those limited compute units. You will have to outbid others to get your transaction in. This usually happens if you are consistently being outbid by others to get your transaction in. \n To learn how to mitigate this problem, you should read this article about Solana transaction here:\nhttps://jstarry.notion.site/Transaction-confirmation-d5b8f4e09b9c4a70a1f263f82307d7ce \n The Jupiter API cannot fix this for you but we do have a few things that can help you: \n \n prioritizationFeeLamports  on  /swap : You can set this to  auto  which will call the  getRecentPrioritizationFees  RPC and get 2x of 75 percentile of all the writable accounts involved in your transaction. This is usually enough to outbid everyone but sometimes during high congestion, it may not be enough. If that is not enough, you can also do  {\"autoMultiplier\": 2} , which will 2x of the auto fees. In order to protect user from setting a very high fee, the fee is always capped at 0.005 SOL. \n \n const { swapTransaction } = await (\n  await fetch('https://quote-api.jup.ag/v6/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      // user public key to be used for the swap\n      userPublicKey: wallet.publicKey.toString(),\n      // auto wrap and unwrap SOL. default is true\n      dynamicComputeUnitLimit: true,\n      prioritizationFeeLamports: \"auto\",\n      // prioritizationFeeLamports: {\n      //   autoMultiplier: 2,\n      // },\n    })\n  })\n).json();\n \n \n If the  prioritizationFeeLamports  doesn't work, you can always set your own fee by using the  /swap-instructions  endpoint. \n dynamicComputeUnitLimit  on  /swap : By default, the Jupiter API assumes that each swap will take up 1.4m compute units. By setting this to  true  it will adjust the compute unit to be dynamic. Jupiter runs a simulation to estimate the compute units the swap will take then we add an extra 40% margin. By having lower compute units used we can set a higher priority fee. This will help to get a transaction through since now you are bidding with a higher priority fee. \n maxRetries  on  sendRawTransaction : This can be useful to retry sending your transaction and increase the chance of your transaction landing. \n You can check out how we send transaction on https://jup.ag  here . \n Also, the Solana documentation has some  very good tips . \n \n const txid = await connection.sendRawTransaction(rawTransaction, {\n  skipPreflight: true,\n  maxRetries: 2\n});\n \n Blockhash is Invalid/Not Found \n This can happen because of the decentralized nature of the chain. My local chain can be faster than your chain but they will eventually sync up. If you run into this problem, we suggest using  processed  commitment when submitting the transaction and use  confirmed  commitment to confirm your transaction. Setting  skipPreflight  to  true  can be very helpful too when submitting the transaction. This will mean that you will skip transaction simulation entirely. \n If this problem persists, you can always set your own blockhash before submitting the transaction. You can check out a very helpful article  here . \n const txid = await connection.sendRawTransaction(rawTransaction, {\n  maxRetries: 2,\n  skipPreflight: true, // If you set this to true, you can skip the next one.\n  preflightCommitment: 'processed'\n});",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/10-troubleshooting.md",
  "extracted_at": "2025-09-03T01:39:45.844732Z"
}