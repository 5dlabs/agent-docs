{
  "url": "file://temp_jupiter_docs/docs/600-routing/dex-integration.md",
  "content": "sidebar_label: \"Jupiter Metis v1\"\ndescription: \"Integrate your DEX into Jupiter Metis v1 Routing Engine.\"\ntitle: \"DEX Integration\" \n\n     DEX Integration \n     \n\n Jupiter is one of the most widely integrated protocols, so a lot of work is involved in minimizing issues on new integrations and making each integration valuable to our users and partners. Our top priority is ensuring security and providing the best prices and the best token selection for our users, so we will focus on DEXes that will bring the most benefits to them. \n In this section, we will walk you through the process of integrating your DEX into the Jupiter Metis v1 Routing Engine that powers the Swap API. \n :::warning We do not charge fees for integration.\n::: \n Integration Prerequisites \n As Solana grows and more DEXes are built, we have to be more cautious in the DEXes we integrate, we look into a variety of factors. \n \n Code health : It will help with integration and ensure maintainability in the future. \n Security audit : This is important to ensure users' funds are secure and the program is not malicious. \n Traction : We look at the traction of the DEX to ensure it has market demand and is well-used. \n Team and backers : This is a good indicator of the quality of the DEX if they are backed by or built by reputable or verifiable entities. \n \n AMM Interface \n To facilitate integration of your DEX into the Jupiter Core Engine: \n \n Provide a DEX SDK that works with the  Jupiter AMM Interface . \n Enable us to fork your SDK, this ensures our users that we can guarantee maintenance, support for the SDK, and fix potential bugs related to integrated DEXs. \n \n :::note\n get_accounts_to_update  provides the necessary accounts to fetch, they are batched and cached by the Jupiter Core Engine and delivered through  update  to the AMM instance, there might be multiple calls to  quote  using the same cache so  we do not allow any network calls  in the entire implementation.\n::: \n :::info Resource and Support\nYou can refer to the implementation guide https://github.com/jup-ag/rust-amm-implementation for easier integration with Jupiter. \n If you require assistance or have questions, reach out to us at  Discord \n::: \n \n     \n        AMM Interface Code Example\n     \n        ```rust\n        pub trait Amm {\n            // Maybe trait was made too restrictive?\n            fn from_keyed_account(keyed_account: &KeyedAccount, amm_context: &AmmContext) -> Result \n            where\n                Self: Sized;\n            /// A human readable label of the underlying DEX\n            fn label(&self) -> String;\n            fn program_id(&self) -> Pubkey;\n            /// The pool state or market state address\n            fn key(&self) -> Pubkey;\n            /// The mints that can be traded\n            fn get_reserve_mints(&self) -> Vec ;\n            /// The accounts necessary to produce a quote\n            fn get_accounts_to_update(&self) -> Vec ;\n            /// Picks necessary accounts to update it's internal state\n            /// Heavy deserialization and precomputation caching should be done in this function\n            fn update(&mut self, account_map: &AccountMap) -> Result<()>;\n         fn quote(&self, quote_params: &QuoteParams) -> Result<Quote>;\n\n        /// Indicates which Swap has to be performed along with all the necessary account metas\n        fn get_swap_and_account_metas(&self, swap_params: &SwapParams) -> Result<SwapAndAccountMetas>;\n\n        /// Indicates if get_accounts_to_update might return a non constant vec\n        fn has_dynamic_accounts(&self) -> bool {\n            false\n        }\n\n        /// Indicates whether `update` needs to be called before `get_reserve_mints`\n        fn requires_update_for_reserve_mints(&self) -> bool {\n            false\n        }\n\n        // Indicates that whether ExactOut mode is supported\n        fn supports_exact_out(&self) -> bool {\n            false\n        }\n\n        fn get_user_setup(&self) -> Option<AmmUserSetup> {\n            None\n        }\n\n        fn clone_amm(&self) -> Box<dyn Amm + Send + Sync>;\n\n        /// It can only trade in one direction from its first mint to second mint, assuming it is a two mint AMM\n        fn unidirectional(&self) -> bool {\n            false\n        }\n\n        /// For testing purposes, provide a mapping of dependency programs to function\n        fn program_dependencies(&self) -> Vec<(Pubkey, String)> {\n            vec![]\n        }\n\n        fn get_accounts_len(&self) -> usize {\n            32 // Default to a near whole legacy transaction to penalize no implementation\n        }\n\n        /// The identifier of the underlying liquidity\n        ///\n        /// Example:\n        /// For RaydiumAmm uses Openbook market A this will return Some(A)\n        /// For Openbook market A, it will also return Some(A)\n        fn underlying_liquidities(&self) -> Option<HashSet<Pubkey>> {\n            None\n        }\n\n        /// Provides a shortcut to establish if the AMM can be used for trading\n        /// If the market is active at all\n        fn is_active(&self) -> bool {\n            true\n        }\n    }\n    ```\n \n \n \n Market Listing \n This section explains how markets are listed and maintained on Jupiter. It covers the different types of routing (instant and normal), the criteria for a market to be included in routing, and the liquidity requirements that must be met for a market to remain routable. Understanding these rules is essential for DEX teams to ensure their markets are eligible for and remain in the Jupiter Metis routing engine. \n Routing Type \n There are 2 types of market listing on Jupiter. \n \n \n Instant routing \n \n We automatically list all new markets that are created on specific DEXes (list is below). \n These markets have a grace period, where the liquidity criteria is not applied. \n After the grace period has passed, the liquidity criteria will apply (refer to normal routing). \n For bonding curves, if it does not graduate after the grace period, it will be removed from routing.\n \n Only when the bonding curve has graduated to a new market, the graduated market will be added to routing. \n \n \n \n  \n      \n         List of DEXes that are eligible for Instant Routing\n      \n         - Meteora Dynamic Bonding Curve\n         - Meteora Dynamic AMM\n         - Meteora DAMM V2\n         - Meteora DLMM\n         - Raydium\n         - Raydium CLMM\n         - Raydium CPMM\n         - Raydium Launchlab\n         - Pump.fun AMM\n         - Pump.fun\n         - Fluxbeam\n         - Whirlpool\n         - Moonshot\n         - Virtuals\n         - Boop.fun\n  \n \n \n Normal routing \n \n This is the default for all markets. \n Every 30 minutes, we will check the liquidity of the market. \n If the liquidity is not enough, we will remove the market from routing. \n \n \n \n Market Liquidity Requirements \n The market must fit one of the following criteria for it to be routable: \n \n \n Less than 30% price difference on $500 \n Using a benchmark position size of $500, a user should encounter less than 30% price difference after buying $500 worth and then selling back on the same market. \n Price Difference = ($500 - Final USD value) / $500\nIf the price difference is more than 30%, it means that there is insufficient liquidity in the market for the benchmark position size of $500. \n \n \n Less than 20% price impact on market \n If the above (sell back $500 worth) fails, we will compare the price per token received from buying $1000 worth vs the price per token received from buying $500 worth to calculate price impact. \n If the price impact is more than 20%, it means that the market is illiquid.",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/600-routing/dex-integration.md",
  "extracted_at": "2025-09-03T01:39:45.468722Z"
}