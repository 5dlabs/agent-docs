{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/3-limit-order/1-limit-order.md",
  "content": "sidebar_label: Integrate Limit Order v2\ndescription: Master Jupiter Limit Order integration for efficient Limit Orders on Solana.\ntitle: Integrating Jupiter Limit Order v2\nslug: ./limit-order \n Jupiter Limit Order v2 (LO) provides users with the simplest way to place limit orders on Solana and receive tokens directly in your wallet when the order is filled. \n This page will serve as a general guide on integrating LO into your use case. whether you are building a bot for yourself or looking to integrate with existing (d)apps, Jupiter's LO program will work regardless of programming language used. \n Learn more about the mechanics of Jupiter's LO  here \n Start using Limit Order APIs:  here \n \n Program Address \n LO v2 Program (mainnet-beta): j1o2qRpjcyUwEvwtcfhEQefh773ZgjxcVRry7LDqg5X \n \n Create Limit Order API Walkthrough \n This guide will show you how to create limit orders using Jupiter APIs. It also applies to canceling orders. \n Install Required Libraries \n We recommend using NodeJS >= 18 for the native  fetch  API \n npm install @solana/web3.js bs58 dotenv\n \n We recommend  NodeJS >= 18  for native  fetch  support. \n You can use any of these package managers: \n \n bun  â€”  bun automatically reads  .env  files \n npm \n pnpm \n yarn \n \n Import Libraries and Set Up RPC Connection \n import {\n  Connection,\n  Keypair,\n  SendOptions,\n  VersionedTransaction,\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\n\nconst RPC_URL = process.env.RPC_URL;\nif (!RPC_URL) throw \"missing RPC_URL env var\";\n\nconst RPC_CONNECTION = new Connection(RPC_URL);\n \n For TypeScript, these are the request body and response types that can be used. \n type CreateOrder = {\n  inputMint: string;\n  outputMint: string;\n  maker: string;\n  payer: string;\n  params: {\n    makingAmount: string;\n    takingAmount: string;\n    expiredAt?: string;\n    feeBps?: string;\n  };\n  computeUnitPrice: string | \"auto\";\n  referral?: string;\n  inputTokenProgram?: string;\n  outputTokenProgram?: string;\n  wrapAndUnwrapSol?: boolean;\n};\n\ntype CreateOrderResponse = {\n  order: string;\n  tx: string;\n};\n \n Set Up Your Wallet \n Set up your wallet by decoding the private key from a base-58 string.\nDo  not  use private keys directly in production. \n const WALLET_PRIV_KEY = process.env.WALLET_PRIV_KEY;\nif (!WALLET_PRIV_KEY) throw \"missing WALLET_PRIV_KEY\";\n\nconst wallet = Keypair.fromSecretKey(bs58.decode(WALLET_PRIV_KEY));\n \n Get the serialized transactions to create the limit order \n Here we will do the following: \n \n Create the request body, \n Submit it to the API server, \n Deserialize the transaction from the response, and \n Sign and submit the transaction on chain\nDo note that steps 2-4 are asynchronous and may reject. It is recommended to wrap this section in a  try-catch  block and handle the errors accordingly. \n \n Creating the request body \n In this example, we are creating a limit order to buy 100 USDC for 0.05 SOL with no expiry and using  auto  for the  computeUnitPrice . For advanced users, you may specify a numerical  computeUnitPrice . \n const createOrderBody: CreateOrder = {\n  maker: wallet.publicKey.toBase58(),\n  payer: wallet.publicKey.toBase58(),\n  inputMint: \"So11111111111111111111111111111111111111112\",\n  outputMint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n  params: {\n    makingAmount: \"50000000\", // 0.05 SOL\n    takingAmount: \"100000000\", // 100 USDC\n  },\n\n  // \"auto\" sets the priority fee based on network congestion\n  // and it will be capped at 500,000\n  computeUnitPrice: \"auto\",\n};\n \n Send request to API server \n Ensure that the method of the request is  POST  and that the body of the request is a stringified  CreateOrder  type. \n const fetchOpts: RequestInit<RequestInitCfProperties> = {\n  method: \"POST\",\n  headers: {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify(createOrderBody),\n};\n\nconst response = await fetch(\n  \"https://api.jup.ag/limit/v2/createOrder\",\n  fetchOpts\n);\n \n Sign and submit the transaction on chain \n Sending the transaction on chain does NOT mean that the transaction is successful. We recommend using the hash returned from  RPC_CONNECTION.sendRawTransaction()  and: \n \n Check if the hash appears on an explorer, or \n Use  RPC_CONNECTION.confirmTransaction() \n \n Note that transactions may not appear on chain for some time. We recommend retrying (repeat the entire flow) only if the transaction has landed on chain but has failed (likely due to an invalid input), or if the transaction does not appear on chain after ~2 minutes*. \n // Deserialise base64 tx response\nconst { order, tx } = await response.json<CreateOrderResponse>();\nconst txBuff = Buffer.from(tx, \"base64\");\nconst vtx = VersionedTransaction.deserialize(txBuff);\n\n// Sign with wallet\nvtx.sign([wallet]);\nconst rpcSendOpts: SendOptions = { skipPreflight: true };\nconst hash = await RPC_CONNECTION.sendRawTransaction(\n  vtx.serialize(),\n  rpcSendOpts\n);",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/3-limit-order/1-limit-order.md",
  "extracted_at": "2025-09-03T01:39:45.884837Z"
}