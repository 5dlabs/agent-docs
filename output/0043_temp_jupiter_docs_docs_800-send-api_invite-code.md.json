{
  "url": "file://temp_jupiter_docs/docs/800-send-api/invite-code.md",
  "content": "sidebar_label: \"Invite Code (Beta)\"\ndescription: \"Use the Jupiter Send API to gift, pay, or onboard anyone in seconds.\"\ntitle: \"Invite Code (Beta)\" \n\n     Invite Code (Beta) \n     \n\n :::note \n \n Lite URL:  https://lite-api.jup.ag/send/v1 \n Pro URL:  https://api.jup.ag/send/v1 \n \n To upgrade to Pro or understand our rate limiting, please refer to this section. \n \n API Key Setup \n API Rate Limit \n::: \n \n Security \n The Send API is designed for  transaction building only  - it expects and exchanges parameters such as public keys, amounts, and mint addresses. The API  does not handle private keys or invite codes  for security reasons. \n All cryptographic operations must be performed client-side: \n \n Invite code generation \n Private key derivation from invite codes \n Transaction signing \n \n The following sections provide the complete implementation steps required before using the API. \n :::danger\n CRITICAL SECURITY REQUIREMENTS \n \n Never share invite codes or private keys  - treat them like passwords or seed phrases \n Store invite codes securely  - use encrypted storage, secure vaults, or environment variables \n Validate all inputs  - ensure invite codes meet expected format before processing \n Implement proper error handling  - avoid exposing sensitive data in logs or error messages \n \n ⚠️ Loss of funds:  Any exposure of invite codes or private keys may result in permanent loss of funds. Jupiter is not liable for losses due to compromised credentials.\n::: \n Overview \n \n Create invite code. \n From utils, derive the secret key - a deterministic 64-byte Solana secret key (32 bytes private + 32 bytes public key). \n Create Solana Keypair instance from the secret key. \n Post request to get Send transaction.\n \n If  craft-clawback , requires an additional  invitePDA  to be passed in. \n \n \n Sign with both sender and recipient keypair, then send transaction and wait for confirmation. \n \n \n     \n        Full Utils Code Snippet\n     \n import crypto from \"crypto\";\nimport * as ed from \"@noble/ed25519\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nconst hashFunction = (...messages) => sha512(ed.etc.concatBytes(...messages));\ned.etc.sha512Sync = hashFunction;\n\nconst { createHash } = await import(\"node:crypto\");\n\n// This function creates a random 12-character base58 invite code\n// Uses 13 random bytes (~1.4 quintillion possible codes)\nexport async function create_invite_code() {\n  const buf = crypto.randomBytes(13);\n\n  // 58^12 = 1.449225352 e21\n  return binary_to_base58(new Uint8Array(buf)).substring(0, 12);\n};\n\n// This function converts an invite code to a deterministic private key\n// Uses SHA256 hash of `\"invite:\"` + `invite_code` as the seed\n// Returns a 64-byte Solana keypair (32 bytes private + 32 bytes public key)\nexport function invite_code_to_priv_key(invite_code) {\n  // Hash the invite code with a prefix\n  const pre_hash = \"invite:\" + invite_code;\n  const sha = createHash(\"sha256\");\n  const priv_key = crypto.createHash(\"sha256\").update(pre_hash).digest();\n\n  // Use ed25519 to get the public key\n  const pub_key = ed.getPublicKey(new Uint8Array(priv_key));\n  const solana_priv_key = new Uint8Array(64);\n  solana_priv_key.set(priv_key);\n  solana_priv_key.set(pub_key, 32);\n\n  return solana_priv_key;\n};\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Taken from https://github.com/pur3miish/base58-js\nconst base58_chars =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nconst create_base58_map = () => {\n  const base58M = Array(256).fill(-1);\n  for (let i = 0; i < base58_chars.length; ++i)\n    base58M[base58_chars.charCodeAt(i)] = i;\n\n  return base58M;\n};\n\nconst base58Map = create_base58_map();\nexport function binary_to_base58(uint8array) {\n  const result = [];\n\n  for (const byte of uint8array) {\n    let carry = byte;\n    for (let j = 0; j < result.length; ++j) {\n      const x = (base58Map[result[j]] << 8) + carry;\n      result[j] = base58_chars.charCodeAt(x % 58);\n      carry = (x / 58) | 0;\n    }\n    while (carry) {\n      result.push(base58_chars.charCodeAt(carry % 58));\n      carry = (carry / 58) | 0;\n    }\n  }\n\n  for (const byte of uint8array)\n    if (byte) break;\n    else result.push(\"1\".charCodeAt(0));\n\n  result.reverse();\n\n  return String.fromCharCode(...result);\n}\n\nexport function base58_to_binary(base58String) {\n  if (!base58String || typeof base58String !== \"string\")\n    throw new Error(`Expected base58 string but got “${base58String}”`);\n  if (base58String.match(/[IOl0]/gmu))\n    throw new Error(\n      `Invalid base58 character “${base58String.match(/[IOl0]/gmu)}”`\n    );\n  const lz = base58String.match(/^1+/gmu);\n  const psz = lz ? lz[0].length : 0;\n  const size =\n    ((base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;\n\n  return new Uint8Array([\n    ...new Uint8Array(psz),\n    ...base58String\n      .match(/.{1}/gmu)\n      .map((i) => base58_chars.indexOf(i))\n      .reduce((acc, i) => {\n        acc = acc.map((j) => {\n          const x = j * 58 + i;\n          i = x >> 8;\n          return x;\n        });\n        return acc;\n      }, new Uint8Array(size))\n      .reverse()\n      .filter(\n        (\n          (lastValue) => (value) =>\n            (lastValue = lastValue || value)\n        )(false)\n      ),\n  ]);\n}\n/////////////////////////////////////////////////////////////////////////////////////\n \n \n \n     \n        Full Usage Code Snippet\n     \n import { create_invite_code, invite_code_to_priv_key } from \"./utils.js\";\nimport {\n  Connection,\n  Keypair,\n  VersionedTransaction,\n} from \"@solana/web3.js\";\nimport fs from \"fs\";\n\nconst connection = new Connection('insert-rpc');\nconst senderPrivateKey = JSON.parse(fs.readFileSync('/Path/to/sender/id.json', 'utf8').trim());\nconst sender = Keypair.fromSecretKey(new Uint8Array(senderPrivateKey));\n\n// STEP 1: Create 12-character invite code\nconst invite_code = await create_invite_code();\n\n// STEP 2: Derive secret key (public and private key)\nconst secret_key = invite_code_to_priv_key(invite_code);\n\n// STEP 3: Use secret key to create Solana Keypair instance\nconst recipient = Keypair.fromSecretKey(secret_key);\n\n// STEP 4: Post request for a Send transaction\nconst craftSendTransaction = await (\n    await fetch ('https://lite-api.jup.ag/send/v1/craft-send', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n            inviteSigner: recipient.publicKey.toBase58(),\n            sender: sender.publicKey.toBase58(),\n            amount: \"10000000\", // atomic amount before decimals\n            // mint: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\", // Defaults to SOL if `mint` is not provided\n        }, null, 2)\n    })\n).json();\n\n// STEP 5: Use sender and receipient keypair to sign and send to network\nconst transaction = VersionedTransaction.deserialize(Buffer.from(craftSendTransaction.tx, 'base64'));\ntransaction.sign([sender, recipient]); // SIGN with both SENDER and RECIPIENT keypair\nconst transactionBinary = transaction.serialize();\nconst blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: \"confirmed\" });\n\nconst signature = await connection.sendRawTransaction(transactionBinary, {\n  maxRetries: 0,\n  skipPreflight: true,\n});\n\n// Log the signature immediately after sending, before confirmation\nconsole.log(`Transaction sent: https://solscan.io/tx/${signature}`);\n  \ntry {\n  const confirmation = await connection.confirmTransaction({\n    signature,\n    blockhash: blockhashInfo.value.blockhash,\n    lastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,\n  }, \"confirmed\");\n\n  if (confirmation.value.err) {\n    console.error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n    console.log(`Examine the failed transaction: https://solscan.io/tx/${signature}`);\n  } else {\n    console.log(`Transaction successful: https://solscan.io/tx/${signature}`);\n  };\n} catch (error) {\n  console.error(`Error confirming transaction: ${error}`);\n  console.log(`Examine the transaction status: https://solscan.io/tx/${signature}`);\n};\n \n \n Prerequisite \n Dependencies \n npm install @solana/web3.js@1 # Using v1 of web3.js instead of v2\nnpm install dotenv # Useful for testing and handling of invite code and private key\nnpm install @noble/ed25519\nnpm install @noble/hashes\n \n Imports \n Create a utils file to add these functions \n import crypto from \"crypto\";\nimport * as ed from \"@noble/ed25519\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { PublicKey } from \"@solana/web3.js\";\n\n// Configure the ed25519 library to use SHA-512 for internal operations\n// This is REQUIRED before using any ed25519 functions like getPublicKey()\n// The library needs to know which hash function to use for key derivation and signing\nconst hashFunction = (...messages) => sha512(ed.etc.concatBytes(...messages));\ned.etc.sha512Sync = hashFunction;\n\n// Import createHash function from Node.js crypto module using dynamic import\n// This allows us to use the modern 'node:crypto' protocol for better compatibility\n// createHash is used for SHA-256 hashing in the invite code functions\nconst { createHash } = await import(\"node:crypto\");\n \n Functions \n Create Invite Code \n // This function creates a random 12-character base58 invite code\n// Uses 13 random bytes (~1.4 quintillion possible codes)\nexport async function create_invite_code() {\n  const buf = crypto.randomBytes(13);\n\n  // 58^12 = 1.449225352 e21\n  return binary_to_base58(new Uint8Array(buf)).substring(0, 12);\n};\n \n Derive Solana Secret Key \n // This function converts an invite code to a deterministic private key\n// Uses SHA256 hash of `\"invite:\"` + `invite_code` as the seed\n// Returns a 64-byte Solana secret key (32 bytes private + 32 bytes public key)\nexport function invite_code_to_priv_key(invite_code) {\n  // Hash the invite code with a prefix\n  const pre_hash = \"invite:\" + invite_code;\n  const sha = createHash(\"sha256\");\n  const priv_key = crypto.createHash(\"sha256\").update(pre_hash).digest();\n\n  // Use ed25519 to get the public key\n  const pub_key = ed.getPublicKey(new Uint8Array(priv_key));\n  const solana_priv_key = new Uint8Array(64);\n  solana_priv_key.set(priv_key);\n  solana_priv_key.set(pub_key, 32);\n\n  return solana_priv_key;\n};\n \n Convert Binary To Base58 \n /////////////////////////////////////////////////////////////////////////////////////\n// Taken from https://github.com/pur3miish/base58-js\nconst base58_chars =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nconst create_base58_map = () => {\n  const base58M = Array(256).fill(-1);\n  for (let i = 0; i < base58_chars.length; ++i)\n    base58M[base58_chars.charCodeAt(i)] = i;\n\n  return base58M;\n};\n\nconst base58Map = create_base58_map();\nexport function binary_to_base58(uint8array) {\n  const result = [];\n\n  for (const byte of uint8array) {\n    let carry = byte;\n    for (let j = 0; j < result.length; ++j) {\n      const x = (base58Map[result[j]] << 8) + carry;\n      result[j] = base58_chars.charCodeAt(x % 58);\n      carry = (x / 58) | 0;\n    }\n    while (carry) {\n      result.push(base58_chars.charCodeAt(carry % 58));\n      carry = (carry / 58) | 0;\n    }\n  }\n\n  for (const byte of uint8array)\n    if (byte) break;\n    else result.push(\"1\".charCodeAt(0));\n\n  result.reverse();\n\n  return String.fromCharCode(...result);\n}\n\nexport function base58_to_binary(base58String) {\n  if (!base58String || typeof base58String !== \"string\")\n    throw new Error(`Expected base58 string but got “${base58String}”`);\n  if (base58String.match(/[IOl0]/gmu))\n    throw new Error(\n      `Invalid base58 character “${base58String.match(/[IOl0]/gmu)}”`\n    );\n  const lz = base58String.match(/^1+/gmu);\n  const psz = lz ? lz[0].length : 0;\n  const size =\n    ((base58String.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;\n\n  return new Uint8Array([\n    ...new Uint8Array(psz),\n    ...base58String\n      .match(/.{1}/gmu)\n      .map((i) => base58_chars.indexOf(i))\n      .reduce((acc, i) => {\n        acc = acc.map((j) => {\n          const x = j * 58 + i;\n          i = x >> 8;\n          return x;\n        });\n        return acc;\n      }, new Uint8Array(size))\n      .reverse()\n      .filter(\n        (\n          (lastValue) => (value) =>\n            (lastValue = lastValue || value)\n        )(false)\n      ),\n  ]);\n}\n/////////////////////////////////////////////////////////////////////////////////////",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/800-send-api/invite-code.md",
  "extracted_at": "2025-09-03T01:39:45.697485Z"
}