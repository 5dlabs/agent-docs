{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/2-payments-api.md",
  "content": "sidebar_label: Payments API\ndescription: Convert any token to USDC with Jupiter Payments API. A comprehensive guide for seamless crypto transactions.\ntitle: \"Payments API: Convert Any Token to USDC\" \n\n     Jupiter Payments API Guide: Seamless Token Conversion to USDC \n     \n\n \n{`\n  .api-method-box {\n    border-radius: 8px;\n    margin: 16px 0;\n    display: inline;\n    padding: 4px;\n    font-weight: 700;\n    margin-right: 8px;\n    font-size: 12px;\n    color: white\n  }\n\n.get {\n  border: 1px solid #018847;\n  background-color: #018847 !important;\n}\n\n.post {\n  border: 1px solid #eaba0c;\n  background-color: #eaba0c !important;\n}\n\n  .api-method-path {\n    font-size: 14px;\n    display: inline;\n  }\n`} \n Jupiter's Payments API supports your payments use case. Utilize Jupiter + SolanaPay to pay for anything with any SPL token. With the Jupiter Payments API, you can specify an exact output token amount. The API doesn't just support output token to USDC, but to any SPL token! \n Use Case \n Payments or interaction with a protocol can require an exact amount of token B. Users might not have token A or prefer to hold other tokens long term. The Jupiter API allow building a swap transaction to receive an exact amount of token A for a maximum in amount of token B. \n A Practical Example using the API \n Bob is selling a delicious latte for 5 USDC. Alice wants to buy Bob's latte. The problem is, Alice only holds mSOL. Luckily, Bob can use the Jupiter Payments API to let Alice swap for exactly 5 USDC then transfer 5 USDC to his payment wallet. \n First, we need to show Alice how much mSOL she will have to spend for the latte. To do this we use the  GET /quote  endpoint. \n 1. Get Quote \n Retrieve a quote for swapping a specific amount of tokens. \n \n   Click to play video \n   \n     \n    Your browser does not support the video tag.\n   \n \n \n   \n     \n       GET \n       https://quote-api.jup.ag/v6/quote \n     \n   \n curl -s 'https://quote-api.jup.ag/v6/quote?inputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=5000000&swapMode=ExactOut&slippageBps=50' | jq '.inAmount, .otherAmountThreshold'\n \n Parameters: \n \n inputMint : The mint address of the input token (required). \n outputMint : The mint address of the output token (required). \n amount : The amount to swap, factoring in the token decimals (required). \n slippageBps : Slippage tolerance in basis points (default 50 unless  autoSlippage  is set to true). \n swapMode : Can be  ExactIn  or  ExactOut  (default  ExactIn ). \n dexes : List of DEXes to include (optional). \n excludeDexes : List of DEXes to exclude (optional). \n restrictIntermediateTokens : Restrict to a top token set for stable liquidity (optional). \n onlyDirectRoutes : Limit to single hop routes only (optional, default false). \n asLegacyTransaction : Use legacy transactions (optional, default false). \n platformFeeBps : Fee to charge in BPS (optional). \n maxAccounts : Max accounts to be used for the quote (optional). \n autoSlippage : Enable smart slippage (optional, default false). \n maxAutoSlippageBps : Max slippage BPS for smart slippage (optional). \n autoSlippageCollisionUsdValue : Custom USD value for calculating slippage impact (optional). \n \n Response : \n \n     \n       •  \n       \n       200: OK \n        Success Response\n       \n     \n {\n    \"inputMint\": \"mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So\",\n    \"inAmount\": \"23698263\",\n    \"outputMint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"outAmount\": \"5000000\",\n    \"otherAmountThreshold\": \"23816755\",\n    \"swapMode\": \"ExactOut\",\n    \"slippageBps\": 50,\n    \"platformFee\": null,\n    \"priceImpactPct\": \"0\",\n    \"routePlan\": [\n        {\n            \"swapInfo\": {\n                \"ammKey\": \"8EzbUfvcRT1Q6RL462ekGkgqbxsPmwC5FMLQZhSPMjJ3\",\n                \"label\": \"Raydium CLMM\",\n                \"inputMint\": \"mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So\",\n                \"outputMint\": \"So11111111111111111111111111111111111111112\",\n                \"inAmount\": \"23698263\",\n                \"outAmount\": \"28158132\",\n                \"feeAmount\": \"1992\",\n                \"feeMint\": \"mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So\"\n            },\n            \"percent\": 100\n        },\n        {\n            \"swapInfo\": {\n                \"ammKey\": \"CSP4RmB6kBHkKGkyTnzt9zYYXDA8SbZ5Do5WfZcjqjE4\",\n                \"label\": \"Whirlpool\",\n                \"inputMint\": \"So11111111111111111111111111111111111111112\",\n                \"outputMint\": \"hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux\",\n                \"inAmount\": \"28158132\",\n                \"outAmount\": \"100994175\",\n                \"feeAmount\": \"1\",\n                \"feeMint\": \"So11111111111111111111111111111111111111112\"\n            },\n            \"percent\": 100\n        },\n        {\n            \"swapInfo\": {\n                \"ammKey\": \"5LnAsMfjG32kdUauAzEuzANT6YmM3TSRpL1rWsCUDKus\",\n                \"label\": \"Whirlpool\",\n                \"inputMint\": \"hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux\",\n                \"outputMint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n                \"inAmount\": \"100994175\",\n                \"outAmount\": \"5000000\",\n                \"feeAmount\": \"131292\",\n                \"feeMint\": \"hntyVP6YFm1Hg25TN9WGLqM12b8TQmcknKrdu1oxWux\"\n            },\n            \"percent\": 100\n        }\n    ],\n    \"contextSlot\": 267155237,\n    \"timeTaken\": 0.010184745\n}\n \n \n \n   •  default   Error Response \n {\n    \"errorCode\": \"string\",\n    \"error\": \"string\"\n}\n \n \n \n :::info\nCurrently, only Orca Whirlpool, Raydium CLMM, and Raydium CPMM support ExactOut mode. All token pairs may not be available in this mode. To see more price options use ExactIn mode.\n::: \n Then Bob creates the transaction with the  POST /swap  endpoint, and adds a 5 USDC token transfer from Alice to his payment wallet using the  destinationTokenAccount  argument, which Alice will verify, sign and send. \n 2. Post Swap \n Returns a transaction that you can use from the quote you get from  GET /quote . \n Try it live in the playground: \n POST https://quote-api.jup.ag/v6/swap \n :::info\nIn the example below, we assume the associated token account exists on  destinationTokenAccount .\n::: \n import { PublicKey, Connection, Keypair, VersionedTransaction, VersionedMessage, TransactionMessage } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport fetch from 'node-fetch';\n\n// Replace with actual valid base58 public keys\nconst USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');  // USDC mint address\nconst bobWalletPublicKey = new PublicKey('BUX7s2ef2htTGb2KKoPHWkmzxPj4nTWMWRgs5CSbQxf9');  // Bob's wallet address\n\n// Establish a connection to the Solana cluster\nconst connection = new Connection('https://api.mainnet-beta.solana.com');\n\n// Replace these with actual valid base58 public keys\nconst feeAccount = new PublicKey('ReplaceWithActualValidBase58Key');  // Replace with actual fee account public key\nconst trackingAccount = new PublicKey('ReplaceWithActualValidBase58Key');  // Replace with actual tracking account public key\n\n// Ensure these are valid base58 strings\nconsole.log(\"USDC_MINT:\", USDC_MINT.toBase58());\nconsole.log(\"bobWalletPublicKey:\", bobWalletPublicKey.toBase58());\nconsole.log(\"feeAccount:\", feeAccount.toBase58());\nconsole.log(\"trackingAccount:\", trackingAccount.toBase58());\n\n// Get the associated token account for Bob's wallet\nasync function getBobUSDCTokenAccount(bobWalletPublicKey) {\n  const bobUSDCTokenAccount = await getAssociatedTokenAddress(\n    USDC_MINT,\n    bobWalletPublicKey,\n    true,\n    TOKEN_PROGRAM_ID,\n    ASSOCIATED_TOKEN_PROGRAM_ID\n  );\n  return bobUSDCTokenAccount;\n}\n\n// Step 1: Fetch swap info\nasync function fetchSwapInfo() {\n  const response = await fetch('https://quote-api.jup.ag/v6/quote?inputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=5000000&swapMode=ExactOut&slippageBps=50');\n  const data = await response.json();\n  return {\n    inAmount: data.inAmount,\n    otherAmountThreshold: data.otherAmountThreshold,\n    quoteResponse: data\n  };\n}\n\n// Step 2: Fetch the swap transaction\nasync function fetchSwapTransaction(swapUserKeypair, bobUSDCTokenAccount, swapInfo) {\n  const requestBody = {\n    userPublicKey: swapUserKeypair.publicKey.toBase58(),\n    wrapAndUnwrapSol: true,\n    useSharedAccounts: true,\n    feeAccount: feeAccount.toBase58(),  // Use actual key\n    trackingAccount: trackingAccount.toBase58(),  // Use actual key\n    prioritizationFeeLamports: 0,  // No prioritization fee in this case\n    asLegacyTransaction: false,\n    useTokenLedger: false,\n    destinationTokenAccount: bobUSDCTokenAccount.toBase58(),\n    dynamicComputeUnitLimit: true,\n    skipUserAccountsRpcCalls: true,\n    quoteResponse: swapInfo.quoteResponse\n  };\n\n  const response = await fetch('https://quote-api.jup.ag/v6/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(requestBody),\n  });\n\n  const { swapTransaction, lastValidBlockHeight } = await response.json();\n  return { swapTransaction, lastValidBlockHeight };\n}\n\n// Step 3: Send the transaction to the Solana blockchain\nasync function sendTransaction(swapTransaction, swapUserKeypair, lastValidBlockHeight) {\n  const transaction = VersionedTransaction.deserialize(Buffer.from(swapTransaction, 'base64'));\n\n  // Get the recent blockhash\n  // Using 'finalized' commitment to ensure the blockhash is final and secure\n  // You may experiment with 'processed' or 'confirmed' for fetching blockhash to increase speed\n  // Reference: https://solana.com/docs/oldrpc/http/getlatestblockhash\n  const bhInfo = await connection.getLatestBlockhashAndContext({ commitment: \"finalized\" });\n  transaction.recentBlockhash = bhInfo.value.blockhash;\n  transaction.feePayer = swapUserKeypair.publicKey;\n\n  // Sign the transaction with the swap user's keypair\n  transaction.sign([swapUserKeypair]);\n\n  // Simulate the transaction to ensure it will succeed\n  // Using 'finalized' commitment for the simulation to match the security level of the actual send\n  // You may experiment with 'confirmed' or 'processed' to simulate faster, but keep in mind the risks\n  // Reference: https://solana.com/docs/oldcore/transactions#commitment\n  const simulation = await connection.simulateTransaction(transaction, { commitment: \"finalized\" });\n  if (simulation.value.err) {\n    throw new Error(`Simulation failed: ${simulation.value.err.toString()}`);\n  }\n\n  // Send the transaction\n  try {\n    const signature = await connection.sendTransaction(transaction, {\n      // NOTE: Adjusting maxRetries to a lower value for trading, as 20 retries can be too much\n      // Experiment with different maxRetries values based on your tolerance for slippage and speed\n      // Reference: https://solana.com/docs/oldcore/transactions#retrying-transactions\n      maxRetries: 5,\n      skipPreflight: true,\n      preflightCommitment: \"finalized\",\n    });\n\n    // Confirm the transaction\n    // Using 'finalized' commitment to ensure the transaction is fully confirmed\n    // Reference: https://solana.com/docs/oldcore/transactions#confirmation\n    const confirmation = await connection.confirmTransaction({\n      signature,\n      blockhash: bhInfo.value.blockhash,\n      lastValidBlockHeight: bhInfo.value.lastValidBlockHeight,\n    }, \"finalized\");\n\n    if (confirmation.value.err) {\n      throw new Error(`Transaction not confirmed: ${confirmation.value.err.toString()}`);\n    }\n\n    console.log(\"Confirmed: \", signature);\n  } catch (error) {\n    console.error(\"Failed: \", error);\n    throw error;\n  }\n}\n\n// Example usage\n(async () => {\n  try {\n    // Generate keypairs for swap user and Bob's wallet, replace with actual keypairs for real usage\n    const swapUserKeypair = Keypair.generate();\n\n    // Ensure the bobUSDCTokenAccount is correct\n    const bobUSDCTokenAccount = await getBobUSDCTokenAccount(bobWalletPublicKey);\n\n    // Step 1: Fetch swap info\n    const swapInfo = await fetchSwapInfo();\n\n    // Step 2: Fetch the swap transactions\n    const { swapTransaction, lastValidBlockHeight } = await fetchSwapTransaction(swapUserKeypair, bobUSDCTokenAccount, swapInfo);\n\n    // Step 3: Send the transaction to the blockchain\n    await sendTransaction(swapTransaction, swapUserKeypair, lastValidBlockHeight);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n})();\n \n :::tip\nIf you want to add your own fees, check out: Adding Your Own Fees\n:::",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/2-payments-api.md",
  "extracted_at": "2025-09-03T01:39:45.850534Z"
}