{
  "url": "file://temp_jupiter_docs/docs/103-recurring-api/2-execute-order.md",
  "content": "sidebar_label: \"Execute Order\"\ndescription: \"Use the Jupiter Recurring API to execute orders.\"\ntitle: \"Execute Order\" \n\n     Execute Order \n     \n\n :::note \n \n Lite URL:  https://lite-api.jup.ag/recurring/v1/execute \n Pro URL:  https://api.jup.ag/recurring/v1/execute \n \n To upgrade to Pro or understand our rate limiting, please refer to this section. \n \n API Key Setup \n API Rate Limit \n::: \n \n After getting the order transaction, you can sign and send to the network yourself or use the Recurring API's  /execute  endpoint to do it for you. \n Sign Transaction \n Using the Solana  web3.js  v1 library, you can sign the transaction as follows: \n // ... GET /createOrder's response\n\n// Extract the transaction from the order response\nconst transactionBase64 = createOrderResponse.transaction\n\n// Deserialize the transaction\nconst transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, 'base64'));\n\n// Sign the transaction\ntransaction.sign([wallet]);\n\n// Serialize the transaction to base64 format\nconst signedTransaction = Buffer.from(transaction.serialize()).toString('base64');\n \n Execute Order \n By making a post request to the  /execute  endpoint, Jupiter executes the order transaction on behalf of you/your users. This includes handling of transaction handling, priority fees, RPC connection, etc. \n :::info\nDo note that you need both the signed transaction and the order id to execute the order. \n The order id is returned in the  createOrder  response .\n::: \n const executeResponse = await (\n    await fetch('https://lite-api.jup.ag/recurring/v1/execute', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n            signedTransaction: signedTransaction,\n            requestId: createOrderResponse.requestId,\n        }),\n    })\n).json();\n \n Execute Order Response \n After making the post request to the  /execute  endpoint, you will receive a response with the status of the order. \n Example response of successful order: \n {\n  \"signature\": \"...\",\n  \"status\": \"Success\",\n  \"order\": \"4DWzP4TdTsuwvYMaMWrRqzya4UTFKFoVjfUWNWh8zhzd\",\n  \"error\": null\n}\n \n Example response of failed order: \n {\n  \"signature\": \"...\",\n  \"status\": \"Failed\",\n  \"order\": null,\n  \"error\": \"Insufficient funds for the operation requested.\",\n}\n \n Send Transaction Yourself \n If you want to handle the transaction, you can sign and send the transaction to the network yourself. \n const transactionBase64 = createOrderResponse.transaction\nconst transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, 'base64'));\n\ntransaction.sign([wallet]);\n\nconst transactionBinary = transaction.serialize();\n\nconst blockhashInfo = await connection.getLatestBlockhashAndContext({ commitment: \"finalized\" });\n\nconst signature = await connection.sendRawTransaction(transactionBinary, {\n    maxRetries: 1,\n    skipPreflight: true\n});\n\nconst confirmation = await connection.confirmTransaction({\nsignature,\nblockhash: blockhashInfo.value.blockhash,\nlastValidBlockHeight: blockhashInfo.value.lastValidBlockHeight,\n}, \"finalized\");\n\nif (confirmation.value.err) {\n    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\\n\\nhttps://solscan.io/tx/${signature}`);\n} else console.log(`Transaction successful: https://solscan.io/tx/${signature}`);",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/103-recurring-api/2-execute-order.md",
  "extracted_at": "2025-09-03T01:39:45.763080Z"
}