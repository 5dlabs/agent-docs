{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/1-swap-api.md",
  "content": "sidebar_label: \"V6 Swap API\"\ndescription: \"Dive into the Jupiter Swap V6 API docs. Discover powerful swap capabilities, integration tips, and advanced features for DeFi applications.\"\ntitle: \"V6 Swap API\" \n\n     How to Integrate Jupiter Swap [API Documentation] \n     \n\n :::info\nIf you have problems landing transactions, read  Landing Transactions on Solana .\n::: \n Jupiter APIs is the easiest way for developers to access liquidity on Solana. Simply pass in the desired pairs, amount, and slippage, and the API will return the serialized transactions needed to execute the swap, which can then be passed into the Solana blockchain with the required signatures. \n :::info Risk Disclaimer\n Please use Jupiter's Swap API at your own risk .  Jupiter's Frontend UI  contains multiple safeguards and warnings when quoting. Jupiter is not liable for losses incurred by users on other platforms.\n::: \n V6 API Reference \n All Jupiter swaps are using versioned transactions and address lookup tables. But not all wallets support Versioned Transactions yet, so if you detect a wallet that does not support versioned transactions, you will need to use the  asLegacyTransaction  parameter. \n Learn more about the Jupiter API Documentation at the OpenAPI documentation. This documentation has a REST request list and a built in API Playground. Use the API Playground to try API calls now! \n :::tip API Documentation\nOpenAPI Documentation\n::: \n Guide for V6 Swap API (code example) \n 1. Install required libraries \n Running this example requires a minimum of  NodeJS 16 . In your command line terminal, install the libraries. \n npm i @solana/web3.js@1\nnpm i cross-fetch\nnpm i @project-serum/anchor\nnpm i bs58\n \n 2. Import from libraries and setup connection \n Next you can copy the following code snippets to a javascript file jupiter-api-example.js. And when you are ready to run the code, just type:  node jupiter-api-example.js \n import { Connection, Keypair, VersionedTransaction } from '@solana/web3.js';\nimport fetch from 'cross-fetch';\nimport { Wallet } from '@project-serum/anchor';\nimport bs58 from 'bs58';\n\n// It is recommended that you use your own RPC endpoint.\n// This RPC endpoint is only for demonstration purposes so that this example will run.\nconst connection = new Connection('https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/');\n \n :::tip\nAlways make sure that you are using your own RPC endpoint. The RPC endpoint used by the connection object in the above example may not work anymore. For more information about RPC endpoints see the  official Solana Documentation  to learn more about their public RPC endpoints.\n::: \n 3. Setup your wallet \n You can paste in your private key for testing purposes but this is not recommended for production applications. \n const wallet = new Wallet(Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || '')));\n \n \n{`\n  .api-method-box {\n    border-radius: 8px;\n    margin: 16px 0;\n    display: inline;\n    padding: 4px;\n    font-weight: 700;\n    margin-right: 8px;\n    font-size: 12px;\n    color: white\n  }\n\n.get {\n  border: 1px solid #018847;\n  background-color: #018847 !important;\n}\n\n.post {\n  border: 1px solid #eaba0c;\n  background-color: #eaba0c !important;\n}\n\n  .api-method-path {\n    font-size: 14px;\n    display: inline;\n  }\n`} \n 4. Get the route for a swap \n Here, we are getting a quote to swap from SOL to USDC. \n // Swapping SOL to USDC with input 0.1 SOL and 0.5% slippage\nconst quoteResponse = await (\n  await fetch('https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\\\n&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\\\n&amount=100000000\\\n&slippageBps=50'\n  )\n).json();\n// console.log({ quoteResponse })\n \n 5. Get the serialized transactions to perform the swap \n Once we have the quote, we need to serialize the quote into a swap transaction that can be submitted on chain. \n // get serialized transactions for the swap\nconst { swapTransaction } = await (\n  await fetch('https://quote-api.jup.ag/v6/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      // user public key to be used for the swap\n      userPublicKey: wallet.publicKey.toString(),\n      // auto wrap and unwrap SOL. default is true\n      wrapAndUnwrapSol: true,\n      // Optional, use if you want to charge a fee.  feeBps must have been passed in /quote API.\n      // feeAccount: \"fee_account_public_key\"\n    })\n  })\n).json();\n \n 6. Deserialize and sign the transaction \n // deserialize the transaction\nconst swapTransactionBuf = Buffer.from(swapTransaction, 'base64');\nvar transaction = VersionedTransaction.deserialize(swapTransactionBuf);\nconsole.log(transaction);\n\n// sign the transaction\ntransaction.sign([wallet.payer]);\n \n 7. Execute the transaction \n // get the latest block hash\nconst latestBlockHash = await connection.getLatestBlockhash();\n\n// Execute the transaction\nconst rawTransaction = transaction.serialize()\nconst txid = await connection.sendRawTransaction(rawTransaction, {\n  skipPreflight: true,\n  maxRetries: 2\n});\nawait connection.confirmTransaction({\n blockhash: latestBlockHash.blockhash,\n lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,\n signature: txid\n});\nconsole.log(`https://solscan.io/tx/${txid}`);\n \n :::info Solana Network Congestion\nDue to the network congestion on Solana, the  sendRawTransaction  method may not be able to help you to land your transaction. You should check out this  transactionSender  file to send transaction.\n::: \n \n   \n     \n       Whole code snippet \n     \n   \n import { Connection, Keypair, VersionedTransaction } from '@solana/web3.js';\nimport fetch from 'cross-fetch';\nimport { Wallet } from '@project-serum/anchor';\nimport bs58 from 'bs58';\n\n// It is recommended that you use your own RPC endpoint.\n// This RPC endpoint is only for demonstration purposes so that this example will run.\nconst connection = new Connection('https://neat-hidden-sanctuary.solana-mainnet.discover.quiknode.pro/2af5315d336f9ae920028bbb90a73b724dc1bbed/');\n\nconst wallet = new Wallet(Keypair.fromSecretKey(bs58.decode(process.env.PRIVATE_KEY || '')));\n\n// Swapping SOL to USDC with input 0.1 SOL and 0.5% slippage\nconst quoteResponse = await (\n  await fetch('https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\\\n&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\\\n&amount=100000000\\\n&slippageBps=50'\n  )\n).json();\n// console.log({ quoteResponse })\n\n// get serialized transactions for the swap\nconst { swapTransaction } = await (\n  await fetch('https://quote-api.jup.ag/v6/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      // user public key to be used for the swap\n      userPublicKey: wallet.publicKey.toString(),\n      // auto wrap and unwrap SOL. default is true\n      wrapAndUnwrapSol: true,\n      // Optional, use if you want to charge a fee.  feeBps must have been passed in /quote API.\n      // feeAccount: \"fee_account_public_key\"\n    })\n  })\n).json();\n\n// deserialize the transaction\nconst swapTransactionBuf = Buffer.from(swapTransaction, 'base64');\nvar transaction = VersionedTransaction.deserialize(swapTransactionBuf);\nconsole.log(transaction);\n\n// sign the transaction\ntransaction.sign([wallet.payer]);\n\n// Execute the transaction\nconst rawTransaction = transaction.serialize()\nconst txid = await connection.sendRawTransaction(rawTransaction, {\n  skipPreflight: true,\n  maxRetries: 2\n});\nawait connection.confirmTransaction(txid);\nconsole.log(`https://solscan.io/tx/${txid}`);\n \n \n Advanced error handling to disable certain AMM from the API \n Sometimes an AMM will throw an error when swapping. To prevent getting a quote from the failed AMM, you can use the  excludeDexes  parameter when getting  /quote . \n Example JS, with the help of  @mercurial-finance/optimist  package: \n import { parseErrorForTransaction } from '@mercurial-finance/optimist';\n\n// TX ID from last step if the transaction failed.\nconst transaction = connection.getTransaction(txid, {\n  maxSupportedTransactionVersion: 0,\n  commitment: 'confirmed'\n});\n\nconst programIdToLabelHash = await (\n  await fetch('https://quote-api.jup.ag/v6/program-id-to-label')\n).json();\nconst { programIds } = parseErrorForTransaction(transaction);\n\nlet excludeDexes = new Set();\nif (programIds) {\n  for (let programId of programIds) {\n    let foundLabel = programIdToLabelHash[programId];\n    if(foundLabel) {\n      excludeDexes.add(foundLabel);\n    }\n  }\n}\n\n// Request another quote with `excludeDexes`.\nconst { data } = await (\n  await fetch(`https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\n&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\n&amount=100000000&excludeDexes=${Array.from(excludeDexes).join(',')}\n&slippageBps=50`\n  )\n).json();\n \n Instructions Instead of Transaction \n Sometimes you may prefer to compose using instructions instead of one transaction that is returned from the  /swap  endpoint. You can post to  /swap-instructions  instead, it takes the same parameters as the  /swap  endpoint. \n const instructions = await (\n  await fetch('https://quote-api.jup.ag/v6/swap-instructions', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      userPublicKey: swapUserKeypair.publicKey.toBase58(),\n    })\n  })\n).json();\n\nif (instructions.error) {\n  throw new Error(\"Failed to get swap instructions: \" + instructions.error);\n}\n\nconst {\n  tokenLedgerInstruction, // If you are using `useTokenLedger = true`.\n  computeBudgetInstructions, // The necessary instructions to setup the compute budget.\n  setupInstructions, // Setup missing ATA for the users.\n  swapInstruction: swapInstructionPayload, // The actual swap instruction.\n  cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.\n  addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.\n} = instructions;\n\nconst deserializeInstruction = (instruction) => {\n  return new TransactionInstruction({\n    programId: new PublicKey(instruction.programId),\n    keys: instruction.accounts.map((key) => ({\n      pubkey: new PublicKey(key.pubkey),\n      isSigner: key.isSigner,\n      isWritable: key.isWritable,\n    })),\n    data: Buffer.from(instruction.data, \"base64\"),\n  });\n};\n\nconst getAddressLookupTableAccounts = async (\n  keys: string[]\n): Promise<AddressLookupTableAccount[]> => {\n  const addressLookupTableAccountInfos =\n    await connection.getMultipleAccountsInfo(\n      keys.map((key) => new PublicKey(key))\n    );\n\n  return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {\n    const addressLookupTableAddress = keys[index];\n    if (accountInfo) {\n      const addressLookupTableAccount = new AddressLookupTableAccount({\n        key: new PublicKey(addressLookupTableAddress),\n        state: AddressLookupTableAccount.deserialize(accountInfo.data),\n      });\n      acc.push(addressLookupTableAccount);\n    }\n\n    return acc;\n  }, new Array<AddressLookupTableAccount>());\n};\n\nconst addressLookupTableAccounts: AddressLookupTableAccount[] = [];\n\naddressLookupTableAccounts.push(\n  ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))\n);\n\nconst blockhash = (await connection.getLatestBlockhash()).blockhash;\nconst messageV0 = new TransactionMessage({\n  payerKey: payerPublicKey,\n  recentBlockhash: blockhash,\n  instructions: [\n    // uncomment if needed: ...setupInstructions.map(deserializeInstruction),\n    deserializeInstruction(swapInstructionPayload),\n    // uncomment if needed: deserializeInstruction(cleanupInstruction),\n  ],\n}).compileToV0Message(addressLookupTableAccounts);\nconst transaction = new VersionedTransaction(messageV0);\n \n Using  maxAccounts \n Sometimes, if you are composing with Jupiter Swap instruction, you may want to spare some accounts (64 max in 1 Solana transaction)\nfor your own program instruction, you can use  maxAccounts . \n // If you know that your instruction will take up 10 accounts, you\n// can pass in 54 as `maxAccounts` when quoting.\nconst { data } = await (\n  await fetch('https://quote-api.jup.ag/v6/quote?inputMint=So11111111111111111111111111111111111111112\\\n&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\\\n&amount=100000000\\\n&slippageBps=50\\\n&maxAccounts=54'\n  )\n).json();\nconst quoteResponse = data;\n// console.log(quoteResponse)\n \n The  maxAccounts  is an estimation since it doesn't consider account overlapping but it is a good start to control how many accounts\nyou want per transaction. \n Using Token Ledger Instruction \n Sometimes you may not know the exact input amount for the Jupiter swap until an instruction before the swap happens. \n For example: \n const instructions = await (\n  await fetch('https://quote-api.jup.ag/v6/swap-instructions', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      useTokenLedger: true,\n  })\n).json();\n\nconst {\n  tokenLedgerInstruction: tokenLedgerPayload, // If you are using `useTokenLedger = true`.\n  swapInstruction: swapInstructionPayload, // The actual swap instruction.\n  addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.\n} = instructions;\n\n// A withdraw instruction that will increase the user input token account amount.\nconst withdrawInstruction = ...;\n\n// Coupled with the tokenLedgerInstruction, the swap instruction will use the\n// user increased amount of the input token account after the withdrawal as input amount.\nconst tokenLedgerInstruction = new TransactionInstruction({\n  programId: new PublicKey(tokenLedgerPayload.programId),\n  keys: tokenLedgerPayload.accounts.map((key) => ({\n    pubkey: new PublicKey(key.pubkey),\n      isSigner: key.isSigner,\n      isWritable: key.isWritable,\n    })),\n  data: Buffer.from(tokenLedgerPayload.data, \"base64\"),\n});\n\nconst swapInstruction = new TransactionInstruction({\n  programId: new PublicKey(swapInstructionPayload.programId),\n  keys: swapInstructionPayload.accounts.map((key) => ({\n    pubkey: new PublicKey(key.pubkey),\n      isSigner: key.isSigner,\n      isWritable: key.isWritable,\n    })),\n  data: Buffer.from(swapInstructionPayload.data, \"base64\"),\n});\n\nconst getAddressLookupTableAccounts = async (\n  keys: string[]\n): Promise<AddressLookupTableAccount[]> => {\n  const addressLookupTableAccountInfos =\n    await connection.getMultipleAccountsInfo(\n      keys.map((key) => new PublicKey(key))\n    );\n\n  return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {\n    const addressLookupTableAddress = keys[index];\n    if (accountInfo) {\n      const addressLookupTableAccount = new AddressLookupTableAccount({\n        key: new PublicKey(addressLookupTableAddress),\n        state: AddressLookupTableAccount.deserialize(accountInfo.data),\n      });\n      acc.push(addressLookupTableAccount);\n    }\n\n    return acc;\n  }, new Array<AddressLookupTableAccount>());\n};\n\nconst addressLookupTableAccounts: AddressLookupTableAccount[] = [];\n\naddressLookupTableAccounts.push(\n  ...(await getAddressLookupTableAccounts(addressLookupTableAddresses))\n);\n\nconst messageV0 = new TransactionMessage({\n  payerKey: payerPublicKey,\n  recentBlockhash: blockhash,\n  instructions: [tokenLedgerInstruction, withdrawInstruction, swapInstruction],\n}).compileToV0Message(addressLookupTableAccounts);\nconst transaction = new VersionedTransaction(messageV0);\n \n This can be useful if you want to withdraw from Solend and immediately convert your withdrawal token into another token with Jupiter. \n Setting Priority Fee for Your Transaction \n If transactions are expiring without confirmation on-chain, this might mean that you have to pay additional fees to prioritize your transaction. To do so, you can set the  computeUnitPriceMicroLamports  parameter.  Refer to Landing Transactions guide for more tips . \n const transaction = await (\n  await fetch('https://quote-api.jup.ag/v6/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      // user public key to be used for the swap\n      userPublicKey: wallet.publicKey.toString(),\n      dynamicComputeUnitLimit: true, // allow dynamic compute limit instead of max 1,400,000\n      // custom priority fee\n\t    prioritizationFeeLamports: {\n        priorityLevelWithMaxLamports: {\n          maxLamports: 10000000,\n          priorityLevel: \"veryHigh\" // If you want to land transaction fast, set this to use `veryHigh`. You will pay on average higher priority fee.\n        }\n      }\n    })\n  })\n).json();\n \n Using Dynamic Slippage \n To understand what Dynamic Slippage is, checkout our  Jupresearch post \n Dynamic slippage is a slippage estimation and optimization mechanism during the /swap call, and is useful because: \n \n Estimates slippage closer to the time of execution. \n A set of heuristics that accounts for the type of token traded and user's max slippage tolerance. \n Safeguards the user while ensuring success rate. \n \n The frontend sends a payload to the backend with an additional  dynamicSlippage  field with  maxBps  set as the user's max slippage  (this is important to respect the user's max, the jup.ag UI sets the default to 300bps (3%)) . \n // get serialized transactions for the swap\nconst { swapTransaction } = await (\n  await fetch('https://quote-api.jup.ag/v6/swap', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      // quoteResponse from /quote api\n      quoteResponse,\n      // user public key to be used for the swap\n      userPublicKey: wallet.publicKey.toString(),\n      // auto wrap and unwrap SOL. default is true\n      wrapAndUnwrapSol: true,\n      // jup.ag frontend default max for user\n      dynamicSlippage: { \"maxBps\": 300 },\n      // feeAccount is optional. Use if you want to charge a fee.  feeBps must have been passed in /quote API.\n      // feeAccount: \"fee_account_public_key\"\n    })\n  })\n).json();\n \n The backend returns a response with a serialized transaction that is already using the final optimized slippage and a  dynamicSlippageReport  for visibility/error catching. \n {\n    \"swapTransaction\": \"// serialized transaction\",\n    \"lastValidBlockHeight\": 266691690,\n    \"prioritizationFeeLamports\": 384,\n    \"computeUnitLimit\": 107468,\n    \"prioritizationType\": {\n        \"computeBudget\": {\n            \"microLamports\": 3577,\n            \"estimatedMicroLamports\": 3577\n        }\n    },\n    \"dynamicSlippageReport\": {\n        // the final optimized slippage bps used in the serialized transaction\n        \"slippageBps\": 12,\n        // the incurred out amount observed from simulating the transaction\n        \"otherAmount\": 8759842,\n        // the simulated incurred slippage during optimization\n        // negative integer refers to the loss in bps while positive refers to the gain\n        \"simulatedIncurredSlippageBps\": -8,\n        // an amplification ratio we use to add a buffer to the estimated slippage\n        \"amplificationRatio\": \"1.5\"\n    },\n    \"simulationError\": null\n}\n \n Examples \n For more example scripts please visit the  jupiter-quote-api-node public Git repository . The repository has some further scripts and instructions for you to explore! \n \n Javascript/Typescript:  https://github.com/jup-ag/jupiter-quote-api-node \n Rust:  https://github.com/jup-ag/jupiter-api-rust-example \n \n Having issues? Head to the  Troubleshooting  section for some help.",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/2-apis/1-swap-api.md",
  "extracted_at": "2025-09-03T01:39:45.840286Z"
}