{
  "url": "file://temp_jupiter_docs/docs/100-swap-api/5-payments-through-swap.md",
  "content": "sidebar_label: \"Payments Through Swap\"\ndescription: \"Jupiter Swap API allows you to set up payments solutions for your products.\"\ntitle: \"Payments Through Swap\" \n\n     Payments Through Swap \n     \n\n The Jupiter Swap API can be utilized such that you, a merchant can allow your customer to pay in any tokens while you still receive in your preferred token payment at the end of the transaction. \n Use Case \n Let’s set the stage. You are selling a  jupcake!!!  to your customer and merchant might only accept in 1 USDC, but your customer only has 1 SOL. Well, you’re at the right place! By using the Swap API, merchant can let customer pay in SOL while merchant still receive USDC in order to complete the payment for a jupcake. \n \n Customer has 1,000,000 SOL. \n Merchant sells 1 jupcake for 1 USDC. \n Use the Swap API to swap exactly 1 USDC output from Customer's SOL. \n Merchant receives the 1 USDC, as planned! \n \n Let’s Get Started \n 1. Setup \n You will need slightly different imports and also remember to set up connection to an RPC. If you have not set up the other typical libraries or are familiar with the Swap API, please follow this  Environment Setup  and  Get Quote and Swap  guide. \n npm i @solana/spl-token\n \n import { PublicKey, Connection, Keypair, VersionedTransaction } from '@solana/web3.js';\nimport { getAssociatedTokenAddress, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';\n \n Before we start getting a quote and swap transaction, for example sake, we will need to prepare both merchant and customer accounts. In production scenario, you will need to dynamically pass this in and allow users to sign in their device interfaces. \n :::note\nDo note that you will need to have already set up: \n \n A wallet in your machine to simulate yourself as the customer as the customer is the signer of the transaction  (similar to how we set up in  Environment Setup ). \n trackingAccount  is an additional Solana Account you can pass in to track only Jupiter transactions easily.\n::: \n \n Set Up Accounts \n const privateKeyArray = JSON.parse(fs.readFileSync('/Path/to/.config/solana/id.json', 'utf8').trim());\nconst customerWallet = Keypair.fromSecretKey(new Uint8Array(privateKeyArray));\n\nconst USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'); // Your preferred token payment\nconst customerAccount = customerWallet.publicKey;\nconst merchantAccount = new PublicKey('ReplaceWithMerchantPubkey');\n// const trackingAccount = new PublicKey('ReplaceWithPubkey'); // If required\n\nconsole.log(\"USDC_MINT:\", USDC_MINT.publicKey);\nconsole.log(\"merchantAccount:\", merchantAccount.publicKey);\n// console.log(\"trackingAccount:\", trackingAccount.publicKey);\n \n Set Up  destinationTokenAccount \n One more thing you will need to set up! Later on, you will need to pass in  destinationTokenAccount  which will be your token account for your preferred token payment mint.  Do note that it is the merchant's token account and it needs to be initialized. \n // Get the associated token account for the merchant wallet\nconst merchantUSDCTokenAccount = await getAssociatedTokenAddress(\n\t  USDC_MINT,\n\t  merchantAccount,\n\t  true,\n\t  TOKEN_PROGRAM_ID,\n\t  ASSOCIATED_TOKEN_PROGRAM_ID\n);\n\nconsole.log(\"merchantUSDCTokenAccount:\", merchantUSDCTokenAccount.publicKey);\n \n 2. Set  swapMode  to  ExactOut  in Quote \n Next, the merchant have to  Get Quote  for the customer. We are using the  ExactOut  mode because we know exactly how much output amount (1 USDC) the merchant want to receive but not sure how much input amount the customer should pay with. \n By getting a quote first, the customer can know upfront the specific amount of input token before they approve and sign the transaction. \n :::warning Limitations of  ExactOut \nCurrently, there are some limitations as  ExactOut  is not widely supported across all DEXes. \n \n Supported DEXes are only Orca Whirlpool, Raydium CLMM, and Raydium CPMM. \n NOT ALL token pairs may be available.\n::: \n \n const quoteResponse = await (\n    await fetch(\n        'https://lite-api.jup.ag/swap/v1/quote?inputMint=So11111111111111111111111111111111111111112&outputMint=EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v&amount=100000&slippageBps=50&restrictIntermediateTokens=true&swapMode=ExactOut'\n    )\n  ).json();\n  \nconsole.log(JSON.stringify(quoteResponse, null, 2));\n \n From the this quote, you should get part of the response like this, where  amount  specified in the query parameter represents the  outAmount  in the response and of course,  swapMode: ExactOut . \n {\n    \"inputMint\": \"So11111111111111111111111111111111111111112\",\n    \"inAmount\": \"4434914\",\n    \"outputMint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"outAmount\": \"1000000\",\n    \"otherAmountThreshold\": \"4434914\",\n    \"swapMode\": \"ExactOut\",\n    ...\n}\n \n 3. Set  destinationTokenAccount  in Swap \n The merchant then retrieves the serialized swap transaction, but the merchant need to specify the  destinationTokenAccount  in the parameters — this will build the swap transaction to swap but send to the  merchant's specified token account which we defined earlier . \n The  destinationTokenAccount  should be the merchant’s token account to receive the payment in. Also do note that  customerAccount  should be accounted for.  You can refer to the  Build Swap Transaction  guide for other parameters to be passed in. \n const swapResponse = await (\n    await fetch('https://lite-api.jup.ag/swap/v1/swap', {\n        method: 'POST',\n        headers: {\n        'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            quoteResponse,\n            userPublicKey: customerAccount.publicKey,\n            destinationTokenAccount: merchantUSDCTokenAccount.publicKey,\n            // trackingAccount: trackingAccount.publicKey,\n        })\n    })\n).json();\n \n 4. Prepare Transaction \n We have walked through the steps here and explained some of the code, you can refer to  Send Swap Transaction - Prepare Transaction . The main difference for payments is to ensure that the customer is the fee payer (the merchant can be generous and be the fee payer too!) and the signer. \n const transactionBase64 = swapResponse.swapTransaction\nconst transaction = VersionedTransaction.deserialize(Buffer.from(transactionBase64, 'base64'));\ntransaction.feePayer = customerAccount.publicKey;\ntransaction.sign([customerWallet]);\nconst transactionBinary = transaction.serialize();\n \n 5. Send Transaction \n We have walked through the steps here and explained some of the code, you can refer to  Send Swap Transaction - Send Transaction . The main difference for payments is, you might want to try adjusting  maxRetries  to a higher count as it is not time sensitive and ideally this is used with tighter slippage and ensuring the  inputMint  is not too unstable. \n Do note that more retries will cause the user to wait slightly longer, so find the balance between the two. Read more here: https://solana.com/docs/advanced/retry. \n const signature = await connection.sendRawTransaction(transactionBinary, {\n    maxRetries: 10,\n});\n  \nconst confirmation = await connection.confirmTransaction({ signature }, \"finalized\");\n\nif (confirmation.value.err) {\n    throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}\\nhttps://solscan.io/${signature}/`);\n} else console.log(`Transaction successful: https://solscan.io/tx/${signature}/`);\n \n The succeeded Swap Transaction should show: \n \n Token A swaps from the customer's token account \n Token A swap to Token B \n Token B sends to the merchant's token account \n \n If transactions are not landing well, you can refer to this section.",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs/100-swap-api/5-payments-through-swap.md",
  "extracted_at": "2025-09-03T01:39:45.626959Z"
}