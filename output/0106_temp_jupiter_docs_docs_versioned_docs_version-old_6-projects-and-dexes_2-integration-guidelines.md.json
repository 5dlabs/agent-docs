{
  "url": "file://temp_jupiter_docs/docs_versioned_docs/version-old/6-projects-and-dexes/2-integration-guidelines.md",
  "content": "sidebar_label: \"DEX Guidelines\"\ndescription: Learn how to integrate your DEX with Jupiter. Achieve superior trading performance and user satisfaction.\ntitle: DEX Integration Guidelines \n\n     Jupiter DEX Integration Guidelines: Enhance Your Crypto Exchange \n     \n\n To facilitate integration of your DEX into the Jupiter Core Engine, you will need to provide a DEX SDK that works with the  Jupiter AMM Interface . \n pub trait Amm {\n    // Maybe trait was made too restrictive?\n    fn from_keyed_account(keyed_account: &KeyedAccount, amm_context: &AmmContext) -> Result<Self>\n    where\n        Self: Sized;\n    /// A human readable label of the underlying DEX\n    fn label(&self) -> String;\n    fn program_id(&self) -> Pubkey;\n    /// The pool state or market state address\n    fn key(&self) -> Pubkey;\n    /// The mints that can be traded\n    fn get_reserve_mints(&self) -> Vec<Pubkey>;\n    /// The accounts necessary to produce a quote\n    fn get_accounts_to_update(&self) -> Vec<Pubkey>;\n    /// Picks necessary accounts to update it's internal state\n    /// Heavy deserialization and precomputation caching should be done in this function\n    fn update(&mut self, account_map: &AccountMap) -> Result<()>;\n\n    fn quote(&self, quote_params: &QuoteParams) -> Result<Quote>;\n\n    /// Indicates which Swap has to be performed along with all the necessary account metas\n    fn get_swap_and_account_metas(&self, swap_params: &SwapParams) -> Result<SwapAndAccountMetas>;\n\n    /// Indicates if get_accounts_to_update might return a non constant vec\n    fn has_dynamic_accounts(&self) -> bool {\n        false\n    }\n\n    /// Indicates whether `update` needs to be called before `get_reserve_mints`\n    fn requires_update_for_reserve_mints(&self) -> bool {\n        false\n    }\n\n    // Indicates that whether ExactOut mode is supported\n    fn supports_exact_out(&self) -> bool {\n        false\n    }\n\n    fn get_user_setup(&self) -> Option<AmmUserSetup> {\n        None\n    }\n\n    fn clone_amm(&self) -> Box<dyn Amm + Send + Sync>;\n\n    /// It can only trade in one direction from its first mint to second mint, assuming it is a two mint AMM\n    fn unidirectional(&self) -> bool {\n        false\n    }\n\n    /// For testing purposes, provide a mapping of dependency programs to function\n    fn program_dependencies(&self) -> Vec<(Pubkey, String)> {\n        vec![]\n    }\n\n    fn get_accounts_len(&self) -> usize {\n        32 // Default to a near whole legacy transaction to penalize no implementation\n    }\n\n    /// The identifier of the underlying liquidity\n    ///\n    /// Example:\n    /// For RaydiumAmm uses Openbook market A this will return Some(A)\n    /// For Openbook market A, it will also return Some(A)\n    fn underlying_liquidities(&self) -> Option<HashSet<Pubkey>> {\n        None\n    }\n\n    /// Provides a shortcut to establish if the AMM can be used for trading\n    /// If the market is active at all\n    fn is_active(&self) -> bool {\n        true\n    }\n}\n \n get_accounts_to_update  provides the necessary accounts to fetch, they are batched and cached by the Jupiter Core Engine and delivered through  update  to the AMM instance, there might be multiple calls to  quote  using the same cache so  we do not allow any network calls  in the entire implementation. \n You can refer to the implementation guide below for easier integration with Jupiter. \n https://github.com/jup-ag/rust-amm-implementation \n Notes: \n \n We need to be able to fork your SDK. This is to ensure our users that we can guarantee maintenance, support for the SDK, and fix potential bugs related to integrated DEXs.",
  "item_type": "markdown",
  "module_path": "temp_jupiter_docs/docs_versioned_docs/version-old/6-projects-and-dexes/2-integration-guidelines.md",
  "extracted_at": "2025-09-03T01:39:45.865333Z"
}