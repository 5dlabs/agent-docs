{
  "url": "file:///tmp/cilium-repo/Documentation/contributing/development/statedb.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _statedb: \n StateDB in Cilium \n .. warning:: \n StateDB and the reconciler are still under active development and the APIs & metrics documented\nhere are not guaranteed to be stable yet. \n Introduction \n \n`StateDB <https://github.com/cilium/statedb>`__ is an in-memory database developed\nfor the Cilium project to manage control-plane state. It aims to simplify access\nand indexing of state and to increase resilience, modularity and testability by separating the\ncontrol-plane state from the controllers that operates on it. \n\nThis document focuses on how StateDB is leveraged by Cilium and how to develop new\nfeatures using it. For a detailed guide on StateDB API itself see the \n`StateDB documentation <https://github.com/cilium/statedb/blob/main/README.md>`__.\n\nWe assume familiarity with the Hive framework. If you're not familiar with it,\nconsider reading through :ref:`guide-to-the-hive` first.\n\nMotivation\n~~~~~~~~~~\n\nStateDB is a project born from lessons learned from development and production struggles. It aims to be\na tool to systematically improve the resilience, testability and inspectability of the Cilium agent.\n\nFor developers it aims to offer simpler and safer ways to extend the agent by giving a unified\nAPI (``Table[Obj]``) for accessing shared state. The immutable data structures backing StateDB allow for \nlockless readers which improves resiliency compared to the RWMutex+hashmap+callback pattern \nwhere a bug in a controller observing the state may cause critical functions to either stop or significantly\ndecrease throughput. Additionally having flexible ways to access and index the state allows for opportunities to deduplicate\nthe state. Many components of the agent have historically functioned through callback-based subscriptions to\nand maintained their own copies of state which has a significant impact on memory usage and GC overhead.\n\nUnifying state storage behind a database-like abstraction allows building reusable utilities for\ninspecting the state (``cilium-dbg shell -- db``), reconciling state (StateDB reconciler) and observing\noperations on state (StateDB metrics). At scale this leads to an architecture that is easier to \nunderstand (smaller API surface), operate (state can be inspected) and extend (easy to access data).\n\nThe separation of state from logic operating on it (e.g. moving away from kitchen-sink \"Manager\" pattern)\nalso opens up the ability to do wider and more meaningful integration testing on components of the agent. \nWhen most of the inputs and outputs of a component are tables, we can combine multiple components into an\nintegration test that is solely defined in terms of test inputs and expected outputs. This allows more validation\nto be performed with fairly simple integration tests rather than with slower and costly end-to-end tests.\n\nArchitecture vision\n \n .. image:: _static/statedb-arch.svg\n:align: center \n The agent in this architectural style can be broadly considered to consist of: \n \n \n User intent tables : objects from external data sources that tell the agent what it should do. These would be for example the Kubernetes core objects like Pods or the Cilium specific CRDs such as CiliumNetworkPolicy, or data ingested from other sources such as kvstore. \n \n \n Controllers : control-loops that observe the user intent tables and compute the\ncontents of the desired state tables. \n \n \n Desired state tables : the internal state that the controllers produce to succinctly describe what should be done. For example a desired state table could describe what the contents of a BPF map should be or what routes should be installed. \n \n \n Reconcilers : control-loops that observe the desired state\ntables and reconcile them against a target such as a BPF map or the Linux routing\ntable. The reconciler is usually an instance of the StateDB reconciler which is\ndefined in terms of a table of objects with a status field and the operations\n Update ,  Delete  and  Prune . \n \n \n Dividing the agent this way we achieve a nice separation of concerns: \n \n \n Separating the user intent into its own tables keeps the parsing and validation from the computation we'll perform on the data. It also makes it nicer to reuse as it's purely about representing the outside intent internally in an efficient way without tying it too much into implementation details of a specific feature. \n \n \n By defining the controller as essentially the function from input tables to output tables it becomes easy to understand and test. \n \n \n Separating the reconciliation from the desired state computation the complex logic of dealing with low-level errors and retrying is separate from the pure \"business logic\" computation. \n \n \n Using the generic reconcilers allows using tried-and-tested and instrumented retry implementation. \n \n \n The control-plane of the agent is essentially everything outside the reconcilers This allows us to integration test, simulate or benchmark the control-plane code without unreasonable amount of scaffolding. The easier it is to write reliable integration tests the more resilient the codebase becomes. \n \n \n What we're trying to achieve is well summarized by Fred Brooks in \"The Mythical Man Month\": \n | Show me your flowchart and conceal your tables, and I shall continue to be mystified.\n| Show me your tables, and I won't usually need your flowchart; it'll be obvious.\n \n Defining tables \n \n`StateDB documentation <https://github.com/cilium/statedb/blob/main/README.md>`__ gives a good introduction into how to create a table and its indexes, so we won't repeat that here, but instead focus on Cilium specific details.\n\nLet's start off with some guidelines that you might want to consider:\n\n* By default publicly provide ``Table[Obj]`` so new features can build on it and it can be used in tests. Also export the table's indexes or the query functions (``var ByName = nameIndex.Query``).\n\n* Do not export ``RWTable[Obj]`` if outside modules do not need to directly write into the table. If other modules do write into the table, consider defining \"writer functions\" that validate that the writes are well-formed.\n\n* If the table is closely associated with a specific feature, define it alongside the implementation of the feature. If the table is shared by many modules, consider defining it in ``daemon/k8s`` or ``pkg/datapath/tables`` so it is easy to discover.\n\n* Make sure the object can be JSON marshalled so it can be inspected. If you need to store non-marshallable data (e.g. functions), make them private or mark them with ``json:\"-\"`` struct tag.\n\n* If the object contains a map or set and it is often mutated, consider using the immutable ``part.Map`` or ``part.Set`` from ``cilium/statedb``. Since these are immutable they don't need to be deep-copied when modifying the object and there's no risk of accidentally mutating them in-place.\n\n* When designing a table consider how it can be used in tests outside your module. It's a good idea to export your table constructor (New*Table) so it can be used by itself in an integration test of a module that depends on it.\n\n* Take into account the fact that objects be immutable by designing them to be cheap to shallow-clone. For example this could mean splitting off fields that are constant from creation into their own struct that's referenced from the object.\n\n* Write benchmarks for your table to understand the cost of the indexing and storage use. See ``benchmarks_test.go`` in ``cilium/statedb`` for examples.\n\n* If the object is small (<100 bytes) prefer storing it by value instead of by reference, e.g. ``Table[MyObject]`` instead of ``Table[*MyObject]``. This reduces memory fragmentation and makes it safer to use since the fields can't be accidentally mutated (anything inside that's by reference of course can be mutated accidentally). Note though that each index will store a separate copy of the object. Measure if needed.\n\nWith that out of the way, let's get concrete with a code example of a simple\ntable and a controller that populates it:\n\n.. literalinclude:: ../../../contrib/examples/statedb/example.go\n   :language: go\n\nTo understand how the table defined by our example module can be consumed, we can\nconstruct a small mini-application:\n\n.. literalinclude:: ../../../contrib/examples/statedb/main.go\n   :language: go\n\nYou can find and run the above examples in ``contrib/examples/statedb``:\n\n.. code-block:: shell-session\n\n  $ cd contrib/examples/statedb && go run .\n\n\nPitfalls\n^^^^^^^^\n\nHere are some common mistakes to be aware of:\n\n* Object is mutated after insertion to database. Since StateDB queries do not return copies, all readers will see the modifications.\n\n* Object (stored by reference, e.g. ``*T``) returned from a query is mutated and then inserted. StateDB will catch this and panic. Objects stored by reference must be (shallow) cloned before mutating.\n\n* Query is made with ReadTxn and results are used in a WriteTxn. The results may have changed between the ReadTxn and WriteTxn! If you want optimistic concurrency control, then use CompareAndSwap in the write transaction.\n\nInspecting with cilium-dbg \n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nStateDB comes with script commands to inspect the tables. These can be invoked via\n``cilium-dbg shell``.\n\nThe ``db`` command lists all registered tables:\n\n.. code-block:: shell-session\n\n    root@kind-worker:/home/cilium# cilium-dbg shell -- db\n    Name               Object count   Deleted objects   Indexes               Initializers   Go type                       Last WriteTxn\n    health             61             0                 identifier, level     []             types.Status                  health (107.3us ago, locked for 43.7us)\n    sysctl             20             0                 name, status          []             *tables.Sysctl                sysctl (9.4m ago, locked for 12.8us)\n    mtu                2              0                 cidr                  []             mtu.RouteMTU                  mtu (19.4m ago, locked for 5.4us)\n    ...\n\nThe ``show`` command prints out the table using the *TableRow* and *TableHeader* methods:\n\n.. code-block:: shell-session\n\n    root@kind-worker:/home/cilium# cilium-dbg shell -- db/show mtu\n    Prefix      DeviceMTU   RouteMTU   RoutePostEncryptMTU\n    ::/0        1500        1450       1450\n    0.0.0.0/0   1500        1450       1450\n\nThe ``db/get``, ``db/prefix``, ``db/list`` and ``db/lowerbound`` allow querying a table, provided that the ``Index.FromString`` method has\nbeen defined:\n\n.. code-block:: shell-session\n\n    root@kind-worker:/home/cilium# cilium-dbg shell -- db prefix --index=name devices cilium\n    Name           Index   Selected   Type    MTU    HWAddr              Flags                    Addresses\n    cilium_host    3       false      veth    1500   c2:f6:99:50:af:71   up|broadcast|multicast   10.244.1.105, fe80::c0f6:99ff:fe50:af71\n    cilium_net     2       false      veth    1500   5e:70:20:4d:8a:bc   up|broadcast|multicast   fe80::5c70:20ff:fe4d:8abc\n    cilium_vxlan   4       false      vxlan   1500   b2:c6:10:14:48:47   up|broadcast|multicast   fe80::b0c6:10ff:fe14:4847\n\n\nThe shell session can also be run interactively:\n\n.. code-block:: shell-session\n\n    # cilium-dbg shell\n        /¯¯\\\n     /¯¯\\__/¯¯\\\n     \\__/¯¯\\__/  Cilium 1.17.0-dev a5b41b93507e 2024-08-08T13:18:08+02:00 go version go1.23.1 linux/amd64\n     /¯¯\\__/¯¯\\  Welcome to the Cilium Shell! Type 'help' for list of commands.\n     \\__/¯¯\\__/\n        \\__/\n\n    cilium> help db\n    db\n        Describe StateDB configuration\n\n        The 'db' command describes the StateDB configuration,\n        showing\n        ...\n\n    cilium> db\n    Name                   Object count   Zombie objects   Indexes                 Initializers   Go type                            Last WriteTxn\n    health                 65             0                identifier, level       []             types.Status                       health (993.6ms ago, locked for 25.7us)\n    sysctl                 20             0                name, status            []             *tables.Sysctl                     sysctl (5.3s ago, locked for 8.6us)\n    mtu                    2              0                cidr                    []             mtu.RouteMTU                       mtu (4.4s ago, locked for 3.1us)\n    ...\n\n    cilium> db/show mtu\n    Prefix      DeviceMTU   RouteMTU   RoutePostEncryptMTU\n    ::/0        1500        1450       1450\n    0.0.0.0/0   1500        1450       1450\n\n    cilium> db/show --out=/tmp/devices.json --format=json devices\n    ...\n\nKubernetes reflection\n^^^^^^^^^^^^^^^^^^^^^\n\nTo reflect Kubernetes objects from the API server into a table, the reflector\nutility in ``pkg/k8s`` can be used to automate this. For example, we can define\na table of pods and reflect them from Kubernetes into the table:\n\n.. literalinclude:: ../../../contrib/examples/statedb_k8s/pods.go\n   :language: go\n   :caption: contrib/examples/statedb_k8s/pods.go\n   :tab-width: 4\n\nAs earlier, we can then construct a small application to try this out:\n\n.. literalinclude:: ../../../contrib/examples/statedb_k8s/main.go\n   :language: go\n   :caption: contrib/examples/statedb_k8s/main.go\n   :tab-width: 4\n\nYou can run the example in ``contrib/examples/statedb_k8s`` to watch the pods in\nyour current cluster:\n\n.. code-block:: shell-session\n\n    $ cd contrib/examples/statedb_k8s && go run . --k8s-kubeconfig-path ~/.kube/config\n    level=info msg=Starting\n    time=\"2024-09-05T11:22:15+02:00\" level=info msg=\"Establishing connection to apiserver\" host=\"https://127.0.0.1:44261\" subsys=k8s-client\n    time=\"2024-09-05T11:22:15+02:00\" level=info msg=\"Connected to apiserver\" subsys=k8s-client\n    level=info msg=Started duration=9.675917ms\n    Pod(default/nginx): Running (revision: 1, deleted: false)\n    Pod(kube-system/cilium-envoy-8xwp7): Running (revision: 2, deleted: false)\n    ...\n\nReconcilers\n~~~~~~~~~~~\n\nThe StateDB reconciler can be used to reconcile changes on table against a\ntarget system.\n\nTo set up the reconciler you will need the following.\n\nAdd ``reconciler.Status`` as a field into your object (there can be multiple):\n\n.. code-block:: go\n\n  type MyObject struct {\n    ID uint64\n    // ...\n    Status reconciler.Status\n  }\n\nImplement the reconciliation operations (``reconciler.Operations``):\n\n.. code-block:: go\n\n  type myObjectOps struct { ... }\n\n  var _ reconciler.Operations[*MyObject] = &myObjectOps{}\n\n  // Update reconciles the changed [obj] with the target.\n  func (ops *myObjectOps) Update(ctx context.Context, txn statedb.ReadTxn, obj *MyObject) error {\n    // Synchronize the target state with [obj]. [obj] is a clone and can be updated from here.\n    // [txn] can be used to access other tables, but note that Update() is only called when [obj] is\n    // marked pending.\n    ...\n    // Return nil or an error. If not nil, the operation will be repeated with exponential backoff.\n    // If object changes the retrying will reset and Update() is called with latest object.\n    return err\n  }\n\n  // Delete removes the [obj] from the target.\n  func (ops *myObjectOps) Delete(ctx context.Context, txn statedb.ReadTxn, obj *MyObject) error { \n    ...\n    // If error is not nil the delete is retried until it succeeds or an object is recreated\n    // with the same primary key.\n    return err\n  }\n\n  // Prune removes any stale/unexpected state in the target. \n  func (ops *myObjectOps) Prune(ctx context.Context, txn statedb.ReadTxn, objs iter.Seq2[*MyObject, statedb.Revision]) error {\n    // Compute the difference between [objs] and the target and remove anything unexpected in the target.\n    ...\n    // If the returned error is not nil error is logged and metrics incremented. Failed pruning is currently not retried,\n    // but called periodically according to config.\n    return err\n  }\n\nRegister the reconciler:\n\n.. code-block:: go\n\n  func registerReconciler(\n    params reconciler.Params,\n    ops reconciler.Operations[*MyObject],\n    tbl statedb.RWTable[*MyObject],\n  ) error {\n    // Reconciler[..] is an API the reconciler provides. Often not needed.\n    // Currently only contains the Prune() method to trigger immediate pruning.\n    var r reconciler.Reconciler[*MyObject]\n    r, err := RegisterReconciler(\n      params,\n      tbl,\n      (*MyObject).Clone,\n      (*MyObject).SetStatus,\n      (*MyObject).GetStatus,\n      ops,\n      nil, /* optional batch operations */\n    )\n    return err\n  }\n\n  var Cell = cell.Module(\n    \"example\",\n    \"Example module\",\n    ...,\n    cell.Invoke(registerReconciler),\n  )\n\nInsert objects with the ``Status`` set to pending:\n\n.. code-block:: go\n\n  var myObjects statedb.RWTable[*MyObject] \n\n  wtxn := db.WriteTxn(myObjects)\n  myObjects.Insert(wtxn, &MyObject{ID: 123, Status: reconciler.StatusPending()})\n  wtxn.Commit()\n\nThe reconciler watches the tables (using ``Changes()``) and calls ``Update`` for each\nchanged object that is ``Pending`` or ``Delete`` for each deleted object. On errors the object\nwill be retried (with configurable backoff) until the operation succeeds.\n\nSee the full runnable example in the \n`StateDB repository <https://github.com/cilium/statedb/tree/main/reconciler/example>`__.\n\nThe reconciler runs a background job which reports the health status of the reconciler.\nThe status is degraded if any objects failed to be reconciled and queued for retries.\nHealth can be inspected either with ``cilium-dbg status --all-health`` or ``cilium-dbg statedb health``.\n\nBPF maps\n^^^^^^^^\n\nBPF maps can be reconciled with the operations returned by ``bpf.NewMapOps``.\nThe target object needs to implement the ``BinaryKey`` and ``BinaryValue`` to\nconstruct the BPF key and value respectively. These can either construct the binary\nvalue on the fly, or reference a struct defining the value. The example below uses\na struct as this is the prevalent style in Cilium.\n\n.. code-block:: go\n\n  // MyKey defines the raw BPF key\n  type MyKey struct { ... }\n  // MyValue defines the raw BPF key\n  type MyValue struct { ... }\n\n  type MyObject struct {\n    Key MyKey\n    Value MyValue\n    Status reconciler.Status\n  }\n\n  func (m *MyObject) BinaryKey() encoding.BinaryMarshaler {\n    return bpf.StructBinaryMarshaler{&m.Key}\n  }\n  func (m *MyObject) BinaryValue() encoding.BinaryMarshaler {\n    return bpf.StructBinaryMarshaler{&m.Value}\n  }\n\n  func registerReconciler(params reconciler.Params, objs statedb.RWTable[*MyObject], m *bpf.Map) error {  \n    ops := bpf.NewMapOps[*MyObject](m)\n    _, err := reconciler.Register(\n      params,\n      objs,\n      func(obj *MyObject) *MyObject { return obj },\n      func(obj *MyObject, s reconciler.Status) *MyObject {\n        obj.Status = obj\n        return obj\n      },\n      func(obj *MyObject) reconciler.Status {\n        return e.Status\n      },\n      ops,\n      nil,\n    )\n    return err\n  }\n\nFor a real-world example see ``pkg/maps/bwmap/cell.go``.\n\n\nScript commands\n \n StateDB comes with a rich set of script commands for inspecting and manipulating tables: \n .. code-block:: shell-session\n:caption: example.txtar \n Show the registered tables \n db \n Insert an object \n db/insert my-table example.yaml \n Compare the contents of 'my-table' with a file. Retries until matches. \n db/cmp my-table expected.table \n Show the contents of the table \n db/show \n Write the object to a file \n db/get my-table 'Foo' --format=yaml --out=foo.yaml \n Delete the object and assert that table is empty. \n db/delete my-table example.yaml\ndb/empty my-table \n -- expected.table --\nName  Color\nFoo   Red \n -- example.yaml --\nname: Foo\ncolor: Red \n See  help db  for full reference in  cilium-dbg shell  or in the  break  prompt in tests.\nA good reference is also the existing tests. These can be found with  git grep db/insert . \n Metrics \n \nMetrics are available for both StateDB and the reconciler, but they are disabled\nby default due to their fine granularity. These are defined in ``pkg/hive/statedb_metrics.go``\nand ``pkg/hive/reconciler_metrics.go``. As this documentation is manually maintained it may\nbe out-of-date so if things are not working, check the source code.\n\nThe metrics can be enabled by adding them to the helm ``prometheus.metrics`` option with\nthe syntax ``+cilium_<name>``, where ``<name>`` is the name of the metric in the table below.\nFor example, here is how to turn on all the metrics:\n\n.. code-block:: yaml\n\n  prometheus:\n    enabled: true\n    metrics:\n    - +cilium_statedb_write_txn_duration_seconds\n    - +cilium_statedb_write_txn_acquisition_seconds\n    - +cilium_statedb_table_contention_seconds\n    - +cilium_statedb_table_objects\n    - +cilium_statedb_table_revision\n    - +cilium_statedb_table_delete_trackers\n    - +cilium_statedb_table_graveyard_objects\n    - +cilium_statedb_table_graveyard_low_watermark\n    - +cilium_statedb_table_graveyard_cleaning_duration_seconds\n    - +cilium_reconciler_count\n    - +cilium_reconciler_duration_seconds\n    - +cilium_reconciler_errors_total\n    - +cilium_reconciler_errors_current\n    - +cilium_reconciler_prune_count\n    - +cilium_reconciler_prune_errors_total\n    - +cilium_reconciler_prune_duration_seconds\n\nThese are still under development and the metric names may change.\n\nThe metrics can be inspected even when disabled with the ``metrics`` and ``metrics/plot``\nscript commands as Cilium keeps samples of all metrics for the past 2 hours.\nThese metrics are also available in sysdump in HTML form (look for ``cilium-dbg-shell----metrics-html.html``).\n\n.. code-block:: shell-session\n\n    # kubectl exec -it -n kube-system ds/cilium -- cilium-dbg shell\n        /¯¯\\\n     /¯¯\\__/¯¯\\\n     \\__/¯¯\\__/  Cilium 1.17.0-dev a5b41b93507e 2024-08-08T13:18:08+02:00 go version go1.23.1 linux/amd64\n     /¯¯\\__/¯¯\\  Welcome to the Cilium Shell! Type 'help' for list of commands.\n     \\__/¯¯\\__/\n        \\__/\n\n    # Dump the sampled StateDB metrics from the last 2 hours\n    cilium> metrics --sampled statedb\n    Metric                                      Labels                                   5min                    30min          60min          120min\n    cilium_statedb_table_contention_seconds     handle=devices-controller table=devices  0s / 0s / 0s            0s / 0s / 0s   0s / 0s / 0s   0s / 0s / 0s\n    ...\n\n    # Plot the rate of change in the \"health\" table\n    # (indicative of number of object writes per second)\n    cilium> metrics/plot --rate statedb_table_revision.*health\n                      cilium_statedb_table_revision (rate per second)\n                                     [ table=health ]\n          ╭────────────────────────────────────────────────────────────────────╮\n      2.4 ┤    ....              ...               ...               .         │\n          │   .    .            .   .             .   .             . ..       │\n          │  .      ............     .............     .............    .......│\n      1.2 ┤  .                                                                 │\n          │ .                                                                  │\n          │ .                                                                  │\n      0.0 ┤.                                                                   │\n          ╰───┬───────────────────────────────┬──────────────────────────────┬─╯\n           -120min                         -60min                           now\n\n\n    # Plot the write transaction duration for the \"devices\" table\n    # (indicative of how long the table is locked during writes)\n    cilium> metrics/plot statedb_write_txn_duration.*devices\n    ... omitted p50 and p90 plots ...\n\n                      cilium_statedb_write_txn_duration_seconds (p99)\n                               [ handle=devices-controller ]\n          ╭────────────────────────────────────────────────────────────────────╮\n   47.2ms ┤                                   .                                │\n          │                                   .                                │\n          │                                  . .                               │\n   23.9ms ┤                                  .  .                              │\n          │                                 .   .                              │\n          │                 ..              .    .                   ...       │\n    0.5ms ┤.................................     ..............................│\n          ╰───┬───────────────────────────────┬──────────────────────────────┬─╯\n           -120min                         -60min                           now\n\n    # Plot the reconcilation errors for sysctl\n    cilium> metrics/plot reconciler_errors_current.*sysctl\n                             cilium_reconciler_errors_current\n                            [ module_id=agent.datapath.sysctl ]\n          ╭────────────────────────────────────────────────────────────────────╮\n      0.0 ┤                                                                    │\n          │                                                                    │\n          │                                                                    │\n      0.0 ┤                                                                    │\n          │                                                                    │\n          │                                                                    │\n      0.0 ┤....................................................................│\n          ╰───┬───────────────────────────────┬──────────────────────────────┬─╯\n           -120min                         -60min                           now\n\n\nStateDB\n^^^^^^^\n\n========================================================= ======================== =============================================\nName                                                      Labels                   Description\n========================================================= ======================== =============================================\n``statedb_write_txn_duration_seconds``                    ``tables``, ``handle``   Duration of the write transaction\n``statedb_write_txn_acquisition_seconds``                 ``tables``, ``handle``   How long it took to lock target tables\n``statedb_table_contention_seconds``                      ``table``                How long it took to lock a table for writing\n``statedb_table_objects``                                 ``table``                Number of objects in a table\n``statedb_table_revision``                                ``table``                The current revision\n``statedb_table_delete_trackers``                         ``table``                Number of delete trackers (e.g. Changes())\n``statedb_table_graveyard_objects``                       ``table``                Number of deleted objects in graveyard\n``statedb_table_graveyard_low_watermark``                 ``table``                Low watermark revision for deleting objects\n``statedb_table_graveyard_cleaning_duration_seconds``     ``table``                How long it took to GC the graveyard\n========================================================= ======================== =============================================\n\nThe label ``handle`` is the database handle name (created with ``(*DB).NewHandle``). The default handle\nis named ``DB``. The label ``table`` and ``tables`` (formatted as ``tableA+tableB``) are the StateDB tables\nwhich the metric concerns.\n\nReconciler\n^^^^^^^^^^\n\n========================================================= ======================== =================================\nName                                                      Labels                   Description\n``reconciler_count``                                      ``module_id``            Number of reconcilation rounds performed\n``reconciler_duration_seconds``                           ``module_id``, ``op``    Histogram of operation durations\n``reconciler_errors_total``                               ``module_id``            Total number of errors (update/delete)\n``reconciler_errors_current``                             ``module_id``            Current errors\n``reconciler_prune_count``                                ``module_id``            Number of pruning rounds\n``reconciler_prune_errors_total``                         ``module_id``            Total number of errors during pruning    \n``reconciler_prune_duration_seconds``                     ``module_id``            Histogram of operation durations\n========================================================= ======================== =================================\n\nThe label ``module_id`` is the identifier for the Hive module under which the reconciler\nwas registered. ``op`` is the operation performed, either ``update`` or ``delete``.",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/contributing/development/statedb.rst",
  "extracted_at": "2025-09-03T01:13:28.816602Z"
}