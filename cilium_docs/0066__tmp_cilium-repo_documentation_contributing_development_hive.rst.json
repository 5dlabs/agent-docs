{
  "url": "file:///tmp/cilium-repo/Documentation/contributing/development/hive.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _guide-to-the-hive: \n Guide to the Hive \n Introduction \n \nCilium is using dependency injection (via ``pkg/hive``) to wire up the\ninitialization, starting and stopping of its components. \n\n`Dependency injection <https://en.wikipedia.org/wiki/Dependency_injection>`_ (DI) is a\ntechnique for separating the use of objects from their creation and\ninitialization. Essentially dependency injection is about automating the\nmanual management of dependencies. Object constructors only need to declare\ntheir dependencies as function parameters and the rest is handled by the library. This\nhelps with building a loosely-coupled modular architecture as it removes the\nneed for centralization of initialization and configuration. It also reduces\nthe inclination to use global variables over explicit passing of objects,\nwhich is often a source of bugs (due to unexpected initialization order)\nand difficult to deal with in tests (as the state needs to be restored for\nthe next test). With dependency injection components are described as plain\nvalues (``Cell`` in our flavor of DI) enabling visualization of inter-component\ndependencies and opening the internal architecture up for inspection.\n\nDependency injection and the machinery described here are only a tool to\nhelp us towards the real goal: a modular software architecture that can be\neasily understood, extended, repurposed, tested and refactored by a large\ngroup of developers with minimal overlap between modules. To achieve this we\nalso need to have modularity in mind when designing the architecture and APIs.\n\nHive and Cells\n \n Cilium applications are composed using runtime dependency injection from a set\nof modular components called cells that compose together to form a hive (as in\nbee hive). A hive can then be supplied with configuration and executed. To provide\na feel for what this is about, here is how a simple modular HTTP server application\nwould leverage hive: \n .. code-block:: go \n package server\n\n// The server cell implements a generic HTTP server. Provides the 'Server' API\n// for registering request handlers.\n//\n// Module() creates a named collection of cells.\nvar Cell = cell.Module(\n   \"http-server\", // Module identifier (for e.g. logging and tracing)\n   \"HTTP Server\", // Module title (for documentation)\n\n   // Provide the application the constructor for the server.\n   cell.Provide(New),\n\n   // Config registers a configuration when provided with the defaults \n   // and an implementation of Flags() for registering the configuration flags.\n   cell.Config(defaultServerConfig),\n)\n\n// Server allows registering request handlers with the HTTP server\ntype Server interface {\n    ListenAddress() string\n    RegisterHandler(path string, fn http.HandlerFunc)\n}\n\nfunc New(lc cell.Lifecycle, cfg ServerConfig) Server { \n  // Initialize http.Server, register Start and Stop hooks to Lifecycle \n  // for starting and stopping the server and return an implementation of\n  // 'Server' for other cells for registering handlers.\n  // ...\n}\n\ntype ServerConfig struct {\n    ServerPort uint16\n}\n\nvar defaultServerConfig = ServerConfig{\n    ServerPort: 8080,\n}\n\nfunc (def ServerConfig) Flags(flags *pflag.FlagSet) {\n    // Register the \"server-port\" flag. Hive by convention maps the flag to the ServerPort \n    // field.\n    flags.Uint16(\"server-port\",  def.ServerPort, \"Sets the HTTP server listen port\")\n}\n \n With the above generic HTTP server in the  server  package, we can now implement a simple handler\nfor /hello in the  hello  package: \n .. code-block:: go \n package hello\n\n// The hello cell implements and registers a hello handler to the HTTP server.\n//\n// This cell isn't a Module, but rather just a plain Invoke. An Invoke\n// is a cell that, unlike Provide, is always executed. Invoke functions\n// can depend on values that constructors registered with Provide() can\n// return. These constructors are then called and their results remembered.\nvar Cell = cell.Invoke(registerHelloHandler)\n\nfunc helloHandler(w http.ResponseWriter, req *http.Request) {\n    w.Write([]byte(\"hello\"))\n}\n\nfunc registerHelloHandler(srv server.Server) {\n    srv.RegisterHandler(\"/hello\", helloHandler)\n}\n \n And then put the two together into a simple application: \n .. code-block:: go \n package main\n\nvar (\n    // exampleHive is an application with an HTTP server and a handler\n    // at /hello.\n    exampleHive = hive.New(\n        server.Cell,\n        hello.Cell,\n    )\n\n    // cmd is the root command for this application. Runs\n    // exampleHive when executed.\n    cmd *cobra.Command = &cobra.Command{\n        Use: \"example\",\n        Run: func(cmd *cobra.Command, args []string) {\n            // Run() will execute all invoke functions, followed by start hooks\n            // and will then wait for interrupt signal before executing stop hooks\n            // and returning.\n            exampleHive.Run()\n        },\n    }\n)\n   \nfunc main() {\n     // Register all command-line flags from each config cell to the\n     // flag-set of our command.\n \t exampleHive.RegisterFlags(cmd.Flags())\n\n     // Add the \"hive\" sub-command for inspecting the application. \n     cmd.AddCommand(exampleHive.Command()))\n\n     // Execute the root command.\n     cmd.Execute()\n}\n \n If you prefer to learn by example you can find a more complete and runnable example\napplication from  pkg/hive/example . Try running it with  go run .  and also try\n go run . hive . And if you're interested in how all this is implemented internally,\nsee  pkg/hive/example/mini , a minimal example of how to do dependency injection with reflection. \n The Hive API \n \nWith the example hopefully having now whetted the appetite, we'll take a proper look at\nthe hive API. \n\n`hive <https://pkg.go.dev/github.com/cilium/hive>`_ provides the Hive type and \n`hive.New <https://pkg.go.dev/github.com/cilium/hive#New>`_ constructor. \nThe ``hive.Hive`` type can be thought of as an application container, composed from cells:\n\n.. code-block:: go\n\n    var myHive = hive.New(foo.Cell, bar.Cell)\n\n    // Call Run() to run the hive.     \n    myHive.Run() // Start(), wait for signal (ctrl-c) and then Stop() \n\n    // Hive can also be started and stopped directly. Useful in tests.\n    if err := myHive.Start(ctx); err != nil { /* ... */ }\n    if err := myHive.Stop(ctx); err != nil { /* ... */ }\n\n    // Hive's configuration can be registered with a Cobra command:\n    hive.RegisterFlags(cmd.Flags())\n\n    // Hive also provides a sub-command for inspecting it:\n    cmd.AddCommand(hive.Command())\n\n`hive/cell <https://pkg.go.dev/github.com/hive/cell>`_ defines the Cell interface that \n``hive.New()`` consumes and the following functions for creating cells:\n\n- :ref:`api_module`: A named set of cells.\n- :ref:`api_provide`: Provides constructor(s) to the hive.  Lazy and only invoked if referenced by an Invoke function (directly or indirectly via other constructor).\n- :ref:`ProvidePrivate <api_module>`: Provides private constructor(s) to a module and its sub-modules.\n- :ref:`api_decorate`: Wraps a set of cells with a decorator function to provide these cells with augmented objects.\n- :ref:`api_config`: Provides a configuration struct to the hive.\n- :ref:`api_invoke`: Registers an invoke function to instantiate and initialize objects.\n- :ref:`api_metric`: Provides metrics to the hive.\n\nHive also by default provides the following globally available objects:\n\n- :ref:`api_lifecycle`: Methods for registering Start and Stop functions that are executed when Hive is started and stopped. \n  The hooks are appended to it in dependency order (since the constructors are invoked in dependency order).\n- :ref:`api_shutdowner`: Allows gracefully shutting down the hive from anywhere in case of a fatal error post-start.\n- ``logrus.FieldLogger``: Interface to the logger. Module() decorates it with ``subsys=<module id>``.\n\n.. _api_provide:\n\nProvide\n^^^^^^^\n\nWe'll now take a look at each of the different kinds of cells, starting with Provide(),\nwhich registers one or more constructors with the hive:\n\n.. code-block:: go\n\n    // func Provide(ctors any...) Cell\n\n    type A interface {}\n    func NewA() A { return A{} }\n    \n    type B interface {}\n    func NewB(A) B { return B{} }\n\n    // simpleCell provides A and B\n    var simpleCell cell.Cell = cell.Provide(NewA, NewB) \n\nIf the constructors take many parameters, we'll want to group them into a struct with ``cell.In``,\nand conversely if there are many return values, into a struct with ``cell.Out``. This tells\nhive to unpack them:\n\n.. code-block:: go\n\n    type params struct {\n    \tcell.In\n    \n        A A\n        B B\n        Lifecycle cell.Lifecycle\n    }\n    \n    type out struct {\n        cell.Out\n    \n        C C\n\tD D\n        E E\n    }\n    func NewCDE(params params) out { ... }\n    \n    var Cell = cell.Provide(NewCDE)\n\nSometimes we want to depend on a group of values sharing the same type, e.g. to collect API handlers or metrics. This can be done with \n`value groups <https://pkg.go.dev/go.uber.org/dig#hdr-Value_Groups>`_ by combining ``cell.In``\nand ``cell.Out`` with the ``group`` struct tag:\n\n.. code-block:: go\n\n    type HandlerOut struct {\n        cell.Out\n\n        Handler Handler `group:\"handlers\"`\n    }\n    func NewHelloHandler() HandlerOut { ... }\n    func NewEventHandler(src events.Source) HandlerOut { ... }\n\n    type ServerParams struct {\n        cell.In\n    \n        Handlers []Handler `group:\"handlers\"`\n    }\n\n    func NewServer(params ServerParams) Server {\n      // params.Handlers will have the \"Handlers\" from NewHelloHandler and \n      // NewEventHandler.\n    }\n\n    var Hive = hive.New(\n      cell.Provide(NewHelloHandler, NewEventHandler, NewServer)\n    )\n\nFor a working example of group values this, see ``hive/example``.\n\nUse ``Provide()`` when you want to expose an object or an interface to the application. If there is nothing meaningful\nto expose, consider instead using ``Invoke()`` to register lifecycle hooks for an unexported object.\n\n.. _api_invoke:\n\nInvoke\n^^^^^^\n\nInvoke is used to invoke a function to initialize some part of the application. The provided constructors\nwon't be called unless an invoke function references them, either directly or indirectly via another\nconstructor:\n\n.. code-block:: go\n\n    // func Invoke(funcs ...any) Cell\n\n    cell.Invoke(\n        // Construct both B and C and then introduce them to each other.\n        func(b B, c C) {\n           b.SetHandler(c)\n           c.SetOwner(b)\n        },\n\n        // Construct D for its side-effects only (e.g. start and stop hooks).\n        // Avoid this if you can and use Invoke() to register hooks instead of Provide() if \n        // there's no API to provide.\n        func(D){},\n    )\n\n.. _api_module:\n\nModule\n^^^^^^\n\nCells can be grouped into modules (a named set of cells):\n\n.. code-block:: go\n\n    // func Module(id, title string, cells ...Cell) Cell\n\n    var Cell = cell.Module(\n    \t\"example\",           // short identifier (for use in e.g. logging and tracing)\n\t\"An example module\", // one-line description (for documentation)\n    \n        cell.Provide(New),\n\n        innerModule,         // modules can contain other modules\n    )\n\n    var innerModule cell.Cell = cell.Module(\n        \"example-inner\",\n        \"An inner module\",\n\n        cell.Provide(newInner),\n    )\n\n\nModule() also provides the wrapped cells with a personalized ``logrus.FieldLogger``\nwith the ``subsys`` field set to module identifier (\"example\" above).\n\nThe scope created by Module() is useful when combined with ProvidePrivate():\n\n.. code-block:: go\n\n    var Cell = cell.Module(\n        \"example\",\n        \"An example module\",\n    \n        cell.ProvidePrivate(NewA), // A only accessible from this module (or sub-modules)\n        cell.Provide(NewB),        // B is accessible from anywhere\n    )\n\n.. _api_decorate:\n\nDecorate\n^^^^^^^^\n\nSometimes one may want to use a modified object inside a module, for example how above Module()\nprovided the cells with a personalized logger. This can be done with a decorator:\n\n.. code-block:: go\n\n    // func Decorate(dtor any, cells ...Cell) Cell\n\n    var Cell = cell.Decorate(\n        myLogger, // The decoration function\n\n\t// These cells will see the objects returned by the 'myLogger' decorator\n        // rather than the objects on the outside.\n        foo.Cell, \n        bar.Cell,\n    )\n\n    // myLogger is a decorator that can depend on one or more objects in the application\n    // and return one or more objects. The input parameters don't necessarily need to match\n    // the output types.\n    func myLogger(log logrus.FieldLogger) logrus.FieldLogger {\n        return log.WithField(\"lasers\", \"stun\")\n    }\n\n\n.. _api_config:\n\nConfig\n^^^^^^\n\nCilium applications use the `cobra <https://github.com/spf13/cobra>`_ and\n`pflag <https://github.com/spf13/pflag>`_ libraries for implementing the command-line\ninterface. With Cobra, one defines a ``Command``, with optional sub-commands. Each command\nhas an associated FlagSet which must be populated before a command is executed in order to\nparse or to produce usage documentation. Hive bridges to Cobra with ``cell.Config``, which\ntakes a value that implements ``cell.Flagger`` for adding flags to a command's FlagSet and\nreturns a cell that \"provides\" the parsed configuration to the application:\n\n.. code-block:: go\n\n    // type Flagger interface {\n    //    Flags(flags *pflag.FlagSet)\n    // }\n    // func Config[Cfg Flagger](defaultConfig Cfg) cell.Cell\n\n    type MyConfig struct {\n        MyOption string\n\n        SliceOption []string\n        MapOption map[string]string\n    }\n\n    func (def MyConfig) Flags(flags *pflag.FlagSet) {\n        // Register the \"my-option\" flag. This matched against the MyOption field\n        // by removing any dashes and doing case insensitive comparison.\n        flags.String(\"my-option\", def.MyOption, \"My config option\")\n\n        // Flags are supported for representing complex types such as slices and maps.\n        // * Slices are obtained splitting the input string on commas.\n        // * Maps support different formats based on how they are provided:\n        //   - CLI: key=value format, separated by commas; the flag can be\n        //     repeated multiple times.\n        //   - Environment variable or configuration file: either JSON encoded\n        //     or comma-separated key=value format.\n        flags.StringSlice(\"slice-option\", def.SliceOption, \"My slice config option\")\n        flags.StringToString(\"map-option\", def.MapOption, \"My map config option\")\n    }\n\n    var defaultMyConfig = MyConfig{\n        MyOption: \"the default value\",\n    }\n\n    func New(cfg MyConfig) MyThing\n\n    var Cell = cell.Module(\n        \"module-with-config\",\n        \"A module with a config\",\n\n        cell.Config(defaultMyConfig),\n        cell.Provide(New),\n    )\n\nEvery field in the default configuration structure must be explicitly populated.\nWhen selecting defaults for the option, consider which option will introduce\nthe minimal disruption to existing users during upgrade. For instance, if the\nflag retains existing behavior from a previous release, then the default flag\nvalue should retain that behavior. If you are introducing a new optional\nfeature, consider disabling the option by default.\n\nIn tests the configuration can be populated in various ways:\n\n.. code-block:: go\n\n    func TestCell(t *testing.T) {\n        h := hive.New(Cell)\n\n\t// Options can be set via Viper\n        h.Viper().Set(\"my-option\", \"test-value\")\n\n        // Or via pflags\n        flags := pflag.NewFlagSet(\"\", pflag.ContinueOnError)\n        h.RegisterFlags(flags)\n        flags.Set(\"my-option\", \"test-value\")\n\tflags.Parse(\"--my-option=test-value\")\n\n\t// Or the preferred way with a config override:\n\th = hive.New(\n            Cell,\n        )\n        AddConfigOverride(\n            h,\n            func(cfg *MyConfig) {\n                cfg.MyOption = \"test-override\"\n            })\n\n\t// To validate that the Cell can be instantiated and the configuration\n        // struct is well-formed without starting you can call Populate():\n        if err := h.Populate(); err != nil {\n            t.Fatalf(\"Failed to populate: %s\", err)\n        }\n    }\n\n.. _api_metric:\n\nMetric\n^^^^^^\n\nThe metric cell allows you to define a collection of metrics near a feature you\nwould like to instrument. Like the :ref:`api_provide` cell, you define a new \ntype and a constructor. In the case of a metric cell the type should be a \nstruct with only public fields. The types of these fields should implement\nboth `metric.WithMetadata <https://pkg.go.dev/github.com/cilium/cilium/pkg/metrics/metric#WithMetadata>`_\nand `prometheus.Collector <https://pkg.go.dev/github.com/prometheus/client_golang/prometheus#Collector>`_.\nThe easiest way to get such metrics is to use the types defined in `pkg/metrics/metric <https://pkg.go.dev/github.com/cilium/cilium/pkg/metrics/metric>`_.\n\nThe metric collection struct type returned by the given constructor is made \navailable in the hive just like a normal provide. In addition all of the metrics\nare made available via the ``hive-metrics`` `value group <https://pkg.go.dev/go.uber.org/dig#hdr-Value_Groups>`_.\nThis value group is consumed by the metrics package so any metrics defined \nvia a metric cell are automatically registered.\n\n.. code-block:: go\n\n    var Cell = cell.Module(\"my-feature\", \"My Feature\",\n        cell.Metric(NewFeatureMetrics),\n        cell.Provide(NewMyFeature),\n    )\n\n    type FeatureMetrics struct {\n        Calls   metric.Vec[metric.Counter]\n        Latency metric.Histogram\n    }\n\n    func NewFeatureMetrics() FeatureMetrics {\n        return FeatureMetrics{\n            Calls: metric.NewCounterVec(metric.CounterOpts{\n                ConfigName: metrics.Namespace + \"_my_feature_calls_total\",\n                Subsystem:  \"my_feature\",\n                Namespace:  metrics.Namespace,\n                Name:       \"calls_total\",\n            }, []string{\"caller\"}),\n            Latency: metric.NewHistogram(metric.HistogramOpts{\n                ConfigName: metrics.Namespace + \"_my_feature_latency_seconds\",\n                Namespace:  metrics.Namespace,\n                Subsystem:  \"my_feature\",\n                Name:       \"latency_seconds\",\n            }),\n        }\n    }\n\n    type MyFeature struct {\n        metrics FeatureMetrics\n    }\n\n    func NewMyFeature(metrics FeatureMetrics) *MyFeature {\n        return &MyFeature{\n            metrics: metrics,\n        }\n    }\n\n    func (mf *MyFeature) SomeFunction(caller string) {\n        mf.metrics.Calls.With(prometheus.Labels{\"caller\": caller}).Inc()\n\n        span := spanstat.Start()\n        // Normally we would do some actual work here\n        time.Sleep(time.Second)\n        span.End(true)\n\n        mf.metrics.Latency.Observe(span.Seconds())\n    }\n\n.. _api_lifecycle:\n\nLifecycle\n^^^^^^^^^\n\nIn addition to cells an important building block in hive is the lifecycle. A\nlifecycle is a list of start and stop hook pairs that are executed in order\n(reverse when stopping) when running the hive.\n\n.. code-block:: go\n\n    package hive\n\n    type Lifecycle {\n        Append(HookInterface)\n    }\n    type HookContext context.Context\n\n    type HookInterface interface {\n        Start(HookContext) error\n        Stop(HookContext) error\n    }\n\n    type Hook struct {\n        OnStart func(HookContext) error\n        OnStop func(HookContext) error\n    }\n\n    func (h Hook) Start(ctx HookContext) error { ... }\n    func (h Hook) Stop(ctx HookContext) error { ... }\n\nThe lifecycle hooks can be implemented either by implementing the HookInterface methods,\nor using the Hook struct. Lifecycle is accessible from any cell:\n\n.. code-block:: go\n\n    var ExampleCell = cell.Module(\n        \"example\",\n        \"Example module\",\n    \n        cell.Provide(New),\n    )\n    \n    type Example struct { /* ... */ }\n    func (e *Example) Start(ctx HookContext) error { /* ... */ }\n    func (e *Example) Stop(ctx HookContext) error { /* ... */ }\n    \n    func New(lc cell.Lifecycle) *Example {\n        e := &Example{}\n        lc.Append(e)\n        return e\n    }\n\nThese hooks are executed when hive.Run() is called. The HookContext given to\nthese hooks is there to allow graceful aborting of the starting or stopping,\neither due to user pressing ``Control-C`` or due to a timeout. By default Hive has\n5 minute start timeout and 1 minute stop timeout, but these are configurable\nwith SetTimeouts(). A grace time of 5 seconds is given on top of the timeout\nafter which the application is forcefully terminated, regardless of whether\nthe hook has finished or not.\n\n.. _api_shutdowner:\n\nShutdowner\n^^^^^^^^^^\n\nSometimes there's nothing else to do but crash. If a fatal error is encountered\nin a ``Start()`` hook it's easy: just return the error and abort the start. After\nstarting one can initiate a shutdown using the ``hive.Shutdowner``:\n\n.. code-block:: go\n\n    package hive\n\n    type Shutdowner interface {\n        Shutdown(...ShutdownOption)\n    }\n\n    func ShutdownWithError(err error) ShutdownOption { /* ... */ }\n\n    package example\n\n    type Example struct {\n        /* ... */\n        Shutdowner hive.Shutdowner\n    }\n\n    func (e *Example) eventLoop() {\n        for { \n            /* ... */\n            if err != nil {\n                // Uh oh, this is really bad, we've got to crash.\n                e.Shutdowner.Shutdown(hive.ShutdownWithError(err))\n            }\n        }\n    }     \n\nCreating and running a hive\n \n A hive is created using  hive.New() : \n .. code-block:: go \n // func New(cells ...cell.Cell) *Hive\nvar myHive = hive.New(FooCell, BarCell)\n \n New()  creates a new hive and registers all providers to it. Invoke\nfunctions are not yet executed as our application may have multiple hives\nand we need to delay object instantiation to until we know which hive to use. \n However  New  does execute an invoke function to gather all command-line flags from\nall configuration cells. These can be then registered with a Cobra command: \n .. code-block:: go \n var cmd *cobra.Command = /* ... */\nmyHive.RegisterFlags(cmd.Flags())\n \n After that the hive can be started with  myHive.Run() . \n Run() will first construct the parsed configurations and will then execute\nall invoke functions to instantiate all needed objects. As part of this the\nlifecycle hooks will have been appended (in dependency order). After that\nthe start hooks can be executed one after the other to start the hive. Once\nstarted, Run() waits for SIGTERM and SIGINT signals and upon receiving one\nwill execute the stop hooks in reverse order to bring the hive down. \n Now would be a good time to try this out in practice. You'll find a small example\napplication in  hive/example <https://github.com/cilium/hive/tree/main/example> _.\nTry running it with  go run .  and exploring the implementation (try what happens if a provider is commented out!). \n Inspecting a hive \n \nThe ``hive.Hive`` can be inspected with the 'hive' command after it's\nbeen registered with cobra:\n\n.. code-block:: go\n\n    var rootCmd *cobra.Command = /* ... */\n    rootCmd.AddCommand(myHive.Command())\n\n.. code-block:: shell-session\n\n    cilium$ go run ./daemon hive\n    Cells:\n\n    ‚ìÇÔ∏è agent (Cilium Agent):\n      ‚ìÇÔ∏è infra (Infrastructure):\n        ‚ìÇÔ∏è k8s-client (Kubernetes Client):\n             ‚öôÔ∏è (client.Config) {\n                 K8sAPIServer: (string) \"\",\n                 K8sKubeConfigPath: (string) \"\",\n                 K8sClientQPS: (float32) 0,\n                 K8sClientBurst: (int) 0,\n                 K8sHeartbeatTimeout: (time.Duration) 30s,\n                 EnableK8sAPIDiscovery: (bool) false\n             }\n \n             üöß client.newClientset (cell.go:109):\n                 ‚á® client.Config, cell.Lifecycle, logrus.FieldLogger \n                 ‚á¶ client.Clientset \n    ...\n\n    Start hooks:\n\n        ‚Ä¢ gops.registerGopsHooks.func1 (cell.go:44)\n        ‚Ä¢ cmd.newDatapath.func1 (daemon_main.go:1625)\n        ...\n\n    Stop hooks:\n        ...\n   \n\nThe hive command prints out the cells, showing what modules, providers,\nconfigurations etc. exist and what they're requiring and providing.\nFinally the command prints out all registered start and stop hooks.\nNote that these hooks often depend on the configuration (e.g. k8s-client\nwill not insert a hook unless e.g. --k8s-kubeconfig-path is given). The\nhive command takes the same command-line flags as the root command.\n\nThe provider dependencies in a hive can also be visualized as a graphviz dot-graph:\n\n.. code-block:: bash\n\n    cilium$ go run ./daemon hive dot-graph | dot -Tx11\n\nGuidelines\n~~~~~~~~~~\n\nFew guidelines one should strive to follow when implementing larger cells:\n\n* A constructor function should only do validation and allocation. Spawning\n  of goroutines or I/O operations must not be performed from constructors,\n  but rather via the Start hook. This is required as we want to inspect the\n  object graph (e.g. ``hive.PrintObjects``) and side-effectful constructors would\n  cause undesired effects.\n\n* Stop functions should make sure to block until all resources\n  (goroutines, file handles, ‚Ä¶) created by the module have been cleaned\n  up (with e.g. ``sync.WaitGroup``). This makes sure that independent\n  tests in the same test suite are not affecting each other. Use\n  `goleak <https://github.com/uber-go/goleak>`_ to check that goroutines\n  are not leaked.\n\n* Preferably each non-trivial cell would come with a test that validates that\n  it implements its public API correctly. The test also serves\n  as an example of how the cell's API is used and it also validates the\n  correctness of the cells  it depends on which helps with refactoring.\n\n* Utility cells should not Invoke(). Since cells may be used in many\n  applications it makes sense to make them lazy to allow bundling useful\n  utilities into one collection. If a utility cell has an invoke, it may be\n  instantiated even if it is never used.\n\n* For large cells, provide interfaces and not struct pointers. A cell\n  can be thought of providing a service to the rest of the application. To\n  make it accessible, one should think about what APIs the module provides and\n  express these as well documented interface types. If the interface is large,\n  try breaking it up into multiple small ones. Interface types also allows\n  integration testing with mock implementations. The rational here is the same as\n  with \"return structs, accept interfaces\": since hive works with the names of types,\n  we want to \"inject\" interfaces into the object graph and not struct\n  pointers. Extra benefit is that separating the API implemented by a module\n  into one or more interfaces it is easier to document and easier to inspect\n  as all public method declarations are in one place.\n\n* Use parameter (cell.In) and result (cell.Out) objects liberally. If a\n  constructor takes more than two parameters, consider using a parameter\n  struct instead.\n\n\nTesting with hive script\n \n The hive library comes with  script <https://pkg.go.dev/github.com/cilium/hive/script> ,\na simple scripting engine for writing tests. It is a fork of the\n internal/script <https://github.com/golang/go/tree/master/src/cmd/internal/script>  library\nused by the Go compiler for testing the compiler CLI usage. For usage with hive it has been\nextended with support for interactive use, retrying of failures and ability to inject commands\nfrom Hive cells. The same scripting language and commands provided by cells is available via\nthe  cilium-dbg shell  command for live inspection of the Cilium Agent. \n Hive scripts are  txtar <https://pkg.go.dev/golang.org/x/tools/txtar> _ (text archive) files\nthat contain a sequence of commands and a set of embedded input files. When the script is\nexecuted a temporary directory ( $WORK ) is created and the input files are extracted\nthere. \n To understand how this is put together, let's take a look at a minimal example: \n .. literalinclude:: ../../../contrib/examples/script/example.go\n:caption: contrib/examples/script/example.go\n:language: go\n:tab-width: 4 \n We've now defined a module providing  Example  object and some commands for\ninteracting with it. We can now define our test runner: \n .. literalinclude:: ../../../contrib/examples/script/example_test.go\n:caption: contrib/examples/script/example_test.go\n:language: go\n:tab-width: 4 \n And with the test runner in place we can now write our test script: \n .. literalinclude:: ../../../contrib/examples/script/testdata/example.txtar\n:caption: contrib/examples/script/testdata/example.txtar\n:language: shell \n With everything in place we can now run the tests: \n .. code-block:: shell-session \n $ cd contrib/examples/script\n$ go test .\n=== RUN   TestScript\n=== RUN   TestScript/example.txtar\nscripttest.go:251: 2025-02-26T08:32:25Z\nscripttest.go:253: $WORK=/tmp/TestScriptexample.txtar2477299450/001\nscripttest.go:72:\nDATADIR=/home/jussi/go/src/github.com/cilium/cilium/contrib/examples/script/testdata\nPWD=/tmp/TestScriptexample.txtar2477299450/001\nWORK=/tmp/TestScriptexample.txtar2477299450/001\nTMPDIR=/tmp/TestScriptexample.txtar2477299450/001/tmp \n scripttest.go:72: #! --enable-example=true\n    # ^ an (optional) shebang can be used to configure cells\n    # This is a comment that starts a section of commands (0.000s)\n    > echo 'hello'\n    [stdout]\n    hello\nlogger.go:256: level=INFO msg=\"Starting hive\"\nlogger.go:256: level=INFO msg=\"Started hive\" duration=1.53¬µs\nscripttest.go:72: # The test hive has not been started yet, let's start it! (0.000s)\n    > hive/start\nlogger.go:256: level=INFO msg=\"SayHello() called\" module=example name=foo greeting=Hello,\nscripttest.go:72: # Cells can provide custom commands (0.000s)\n    > example/hello foo\n    calling SayHello(foo, Hello,)\n    [stdout]\n    Hello, foo\n    > stdout 'Hello, foo'\n    matched: Hello, foo\nscripttest.go:72: # Check that call count equals 1 (0.000s)\n    > example/counts\n    [stdout]\n    1 SayHello()\n    > stdout '1 SayHello()'\n    matched: 1 SayHello()\nscripttest.go:72: # The file 'foo' should not be the same as 'bar' (0.000s)\n    > ! cmp foo bar\n    diff foo bar\n    --- foo\n    +++ bar\n    @@ -1,2 +1,1 @@\n    -foo\n    -\n    +bar\n\n--- PASS: TestScript/example.txtar (0.00s)\nok      github.com/cilium/cilium/contrib/examples/script        0.003s\n \n In the test execution we can see that a temporary working directory  $WORK  was created\nand our test files from the  example.txtar  extracted there. Each command was then executed\nin order. \n As many of the cells bring rich set of commands it's important that they're easy to discover.\nTo find the commands available, use the  help  command to interactively explore the available commands\nto use in tests. Try for example adding  break  as the last command in  example.txtar : \n .. code-block:: shell-session \n $ go test .\n....\n@@ -1,2 +1,1 @@\n-foo\n-\n+bar \n     > break\n \n Break! Control-d to continue.\ndebug> help example\n[stdout]\nexample/counts\nShow the call counts of the example module\nexample/hello [--greeting=string] name\nSay hello \n       Flags:\n            --greeting string   Greeting to use (default \"Hello,\")\n \n debug> example/hello --greeting=Hei Jussi\ncalling SayHello(Jussi, Hei)\n[stdout]\nHei Jussi\nlogger.go:256: level=INFO msg=\"SayHello() called\" module=example name=Jussi greeting=Hei \n Command reference\n^^^^^^^^^^^^^^^^^ \n The important default commands are: \n \n help : List available commands. Takes an optional regex to filter. \n hive : Dump the hive object graph \n hive/start : Start the test hive \n stdout regex : Grep the stdout buffer \n cmp file1 file2 : Compare two files \n exec cmd args... : Execute an external program ( $PATH  needs to be set!) \n replace old new file : Replace text in a file \n empty : Check if file is empty \n \n The commands can be modified with prefixes: \n \n ! cmd args... : Fail if the command succeeds \n * cmd args... : Retry all commands in the section until this succeeds \n !* cmd args... : Retry all commands in the section until this fails \n \n A section is defined by a  # comment  line and consists of all commands between the\ncomment and the next comment. \n New commands should use the naming scheme  <component>/<command> , e.g.  hive/start  and not\nbuild sub-commands. This makes  help  more useful and makes it easier to discover the commands. \n Cells with script support\n^^^^^^^^^^^^^^^^^^^^^^^^^ \n These cells when included in the test hive will bring useful commands that can be used in tests. \n \n FakeClientCell <https://github.com/cilium/cilium/blob/main/pkg/k8s/client/testutils/fake.go> _: Commands for interacting with the fake client to add or delete objects. See  help k8s . \n StateDB <https://github.com/cilium/statedb/blob/main/script.go> _: Commands for inspecting and manipulating StateDB. Also available via  cilium-dbg shell . See  help db . \n metrics.Cell <https://github.com/cilium/cilium/blob/main/pkg/metrics/cmd.go> _: Commands for dumping and plotting metrics. See  help metrics  and  pkg/metrics/testdata . \n \n Note that StateDB and metrics are part of Cilium's Hive wrapper defined in  pkg/hive , so if you use  (pkg/hive).New() \nthey will be included automatically. \n Example tests\n^^^^^^^^^^^^^ \n To find existing tests to use as reference you can grep for usage of scripttest.Test: \n .. code-block:: shell-session \n $ git grep 'scripttest.Test'\ncontrib/examples/script/example_test.go:        scripttest.Test(\n... \n Here's a few scripts that are worth calling out: \n \n daemon/k8s/testdata/pod.txtar : Tests populating  Table[LocalPod]  from K8s objects defined in YAML. Good reference for the  k8s/*  and  db/*  commands. \n pkg/ciliumenvoyconfig/testdata : Complex component integration tests that go from K8s objects down to BPF maps. \n pkg/datapath/linux/testdata/device-detection.txtar : Low-level test that manipulates network devices in a new network namespace \n \n Internals: Dependency injection with reflection \n \nHive is built on top of `uber/dig <https://github.com/uber-go/dig>`_, a reflection based library for building\ndependency injection frameworks. In dig, you create a container, add in your\nconstructors and then \"invoke\" to create objects:\n\n.. code-block:: go\n\n    func NewA() (A, error) { /* ... */ }\n    func NewB() B { /* ... */ }\n    func NewC(A, B) (C, error) { /* ... */ }\n    func setupC(C) error\n\n    // Create a new container for our constructors.\n    c := dig.New(dig.DeferAcyclicVerification())\n\n    // Add in the constructors. Order does not matter.\n    c.Provide(NewC)\n    c.Provide(NewB)\n    c.Provide(NewA)\n\n    // Invoke a function that can depend on any of the values supplied by the\n    // registered constructors.\n    // Since this depends on \"C\", dig will construct first A and B\n    // (as C depends on them), and then C.\n    c.Invoke(func(c *C) {\n        // Do something with C\n    })\n\n\nThis is the basis on top of which Hive is built. Hive calls dig‚Äôs Provide()\nfor each of the constructors registered with cell.Provide and then calls\ninvoke functions to construct the needed objects. The results from the\nconstructors are cached, so each constructor is called only once.\n\n``uber/dig`` uses Go‚Äôs \"reflect\" package that provides access to the\ntype information of the provide and invoke functions. For example, the\n`Provide <https://pkg.go.dev/go.uber.org/dig#Container.Provide>`_ method does\nsomething akin to this under the hood:\n\n.. code-block:: go\n\n    // 'constructor' has type \"func(...) ...\"\n    typ := reflect.TypeOf(constructor)\n    if typ.Kind() != reflect.Func { /* error */ }\n\n    in := make([]reflect.Type, 0, typ.NumIn())\n    for i := 0; i < typ.NumIn(); i++ { \n        in[i] = typ.In(i) \n    }\n\n    out := make([]reflect.Type, 0, typ.NumOut())\n    for i := 0; i < typ.NumOut(); i++ {\n        out[i] = typ.Out(i) \n    }\n\n    container.providers = append(container.providers, &provider{constructor, in, out})\n\n\n`Invoke <https://pkg.go.dev/go.uber.org/dig#Container.Invoke>`_ will similarly\nreflect on the function value to find out what are the required inputs and\nthen find the required constructors for the input objects and recursively\ntheir inputs.\n\nWhile building this on reflection is flexible, the downside is that missing\ndependencies lead to runtime errors. Luckily dig produces excellent errors and\nsuggests closely matching object types in case of typos. Due to the desire\nto avoid these runtime errors the constructed hive should be as static\nas possible, e.g. the set of constructors and invoke functions should be\ndetermined at compile time and not be dependent on runtime configuration. This\nway the hive can be validated once with a simple unit test (``daemon/cmd/cells_test.go``).\n\nCell showcase\n~~~~~~~~~~~~~\n\nLogging\n^^^^^^^\n\nLogging is provided to all cells by default with the ``*slog.Logger``. The log lines will include the attribute ``module=<module id>``.\n\n.. code-block:: go\n\n    cell.Module(\n        \"example\",\n        \"log example module\",\n    \n        cell.Provide(\n      \t    func(log *slog.Logger) Example {\n    \t  \t    log.Info(\"Hello\") // module=example msg=Hello\n                return Example{log: log}\n    \t    },\n        ),\n    )\n\nKubernetes client\n^^^^^^^^^^^^^^^^^\n\nThe `client package <https://pkg.go.dev/github.com/cilium/cilium/pkg/k8s/client>`_ provides the ``Clientset`` API \nthat combines the different clientsets used by Cilium into one composite value. Also provides ``FakeClientCell``\nfor writing integration tests for cells that interact with the K8s api-server.\n\n.. code-block:: go\n\n    var Cell = cell.Provide(New)\n\n    func New(cs client.Clientset) Example {\n         return Example{cs: cs}\n    }\n\n    func (e Example) CreateIdentity(id *ciliumv2.CiliumIdentity) error {\n        return e.cs.CiliumV2().CiliumIdentities().Create(e.ctx, id, metav1.CreateOptions{})\n    }\n\nResource and the store (see below) is the preferred way of accessing Kubernetes object\nstate to minimize traffic to the api-server. The Clientset should usually\nonly be used for creating and updating objects.\n\nKubernetes Resource and Store\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. note::\n\n   The ``Resource[T]`` pattern is being phased out in the Cilium Agent and new code should use StateDB.\n   See `daemon/k8s/tables.go <https://github.com/cilium/cilium/blob/main/daemon/k8s/tables.go>`_,\n   `pkg/k8s/statedb.go <https://github.com/cilium/cilium/blob/main/pkg/k8s/statedb.go>`_\n   and `PR 34060 <https://github.com/cilium/cilium/pull/34060>`_.\n\nWhile not a cell by itself, `pkg/k8s/resource <https://pkg.go.dev/github.com/cilium/cilium/pkg/k8s/resource>`_ \nprovides an useful abstraction for providing shared event-driven access\nto Kubernetes objects. Implemented on top of the client-go informer,\n``workqueue`` and store to codify the suggested pattern for controllers in a\ntype-safe way. This shared abstraction provides a simpler API to write and\ntest against and allows central control over what data (and at what rate)\nis pulled from the api-server and how it‚Äôs stored (in-memory or persisted).\n\nThe resources are usually made available centrally for the application,\ne.g. in cilium-agent they‚Äôre provided from `pkg/k8s/resource.go <https://github.com/cilium/cilium/blob/main/daemon/k8s/resources.go>`_.\nSee also the runnable example in `pkg/k8s/resource/example <https://github.com/cilium/cilium/tree/main/pkg/k8s/resource/example>`_.\n\n.. code-block:: go\n\n    import \"github.com/cilium/cilium/pkg/k8s/resource\"\n\n    var nodesCell = cell.Provide(\n        func(lc cell.Lifecycle, cs client.Clientset) resource.Resource[v1.Node] {\n            lw := utils.ListerWatcherFromTyped[*v1.NodeList](cs.CoreV1().Nodes())\n            return resource.New[*v1.Node](lc, lw) \n        },\n    )\n\n    var Cell = cell.Module(\n        \"resource-example\",\n        \"Example of how to use Resource\",\n\n        nodesCell,\n        cell.Invoke(printNodeUpdates),\n    )\n\n    func printNodeUpdates(nodes resource.Resource[*v1.Node]) {\n        // Store() returns a typed locally synced store of the objects.\n        // This call blocks until the store has been synchronized.\n        store, err := nodes.Store()\n        ...\n        obj, exists, err := store.Get(\"my-node\")\n        ...\n        objs, err := store.List()\n        ...\n\n        // Events() returns a channel of object change events. Closes\n        // when 'ctx' is cancelled.\n        // type Event[T] struct { Kind Kind; Key Key; Object T; Done func(err error) }\n        for ev := range nodes.Events(ctx) {\n            switch ev.Kind {\n            case resource.Sync:\n              // The store has now synced with api-server and\n              // the set of observed upsert events forms a coherent\n              // snapshot. Usually some sort of garbage collection or\n              // reconciliation is performed.\n            case resource.Upsert:\n                fmt.Printf(\"Node %s has updated: %v\\n\", ev.Key, ev.Object)\n            case resource.Delete:\n                fmt.Printf(\"Node %s has been deleted\\n\", key)\n            }\n            // Each event must be marked as handled. If non-nil error\n            // is given, the processing for this key is retried later\n            // according to rate-limiting and retry policy. The built-in\n            // retrying is often used if we perform I/O operations (like API client\n            // calls) from the handler and retrying makes sense. It should not\n            // be used on parse errors and similar.\n            ev.Done(nil)\n        }\n    }\n\nJob groups\n^^^^^^^^^^\n\nThe `job package <https://pkg.go.dev/github.com/cilium/hive/job>`_ contains logic that\nmakes it easy to manage units of work that the package refers to as \"jobs\". These jobs are \nscheduled as part of a job group.\n\nEvery job is a callback function provided by the user with additional logic which\ndiffers slightly for each job type. The jobs and groups manage a lot of the boilerplate\nsurrounding lifecycle management. The callbacks are called from the job to perform the actual\nwork.\n\nThese jobs themselves come in several varieties. The ``OneShot`` job invokes its callback just once.\nThis job type can be used for initialization after cell startup, routines that run for the full lifecycle\nof the cell, or for any other task you would normally use a plain goroutine for.\n\nThe ``Timer`` job invokes its callback periodically. This job type can be used for periodic tasks\nsuch as synchronization or garbage collection. Timer jobs can also be externally triggered in\naddition to the periodic invocations.\n\nThe ``Observer`` job invokes its callback for every message sent on a ``stream.Observable``. This job\ntype can be used to react to a data stream or events created by other cells.",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/contributing/development/hive.rst",
  "extracted_at": "2025-09-03T00:53:44.767572Z"
}