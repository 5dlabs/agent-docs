{
  "url": "file:///tmp/cilium-repo/Documentation/reference-guides/bpf/toolchain.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _bpf_dev: \n Development Tools \n Current user space tooling, introspection facilities and kernel control knobs around\nBPF are discussed in this section. \n .. note:: The tooling and infrastructure around BPF is still rapidly evolving and thus may not provide a complete picture of all available tools. \n Development Environment \n A step by step guide for setting up a development environment for BPF can be found\nbelow for both Fedora and Ubuntu. This will guide you through building, installing\nand testing a development kernel as well as building and installing iproute2. \n The step of manually building iproute2 and Linux kernel is usually not necessary\ngiven that major distributions already ship recent enough kernels by default, but\nwould be needed for testing bleeding edge versions or contributing BPF patches to\niproute2 and to the Linux kernel, respectively. Similarly, for debugging and\nintrospection purposes building bpftool is optional but recommended. \n .. tabs:: \n .. group-tab:: Fedora\n\n    The following applies to Fedora 25 or later:\n\n    .. code-block:: shell-session\n\n        $ sudo dnf install -y git gcc ncurses-devel elfutils-libelf-devel bc \\\n          openssl-devel libcap-devel clang llvm graphviz bison flex glibc-static\n\n    .. note:: If you are running some other Fedora derivative and ``dnf`` is missing,\n              try using ``yum`` instead.\n\n.. group-tab:: Ubuntu\n\n    The following applies to Ubuntu 17.04 or later:\n\n    .. code-block:: shell-session\n\n        $ sudo apt-get install -y make gcc libssl-dev bc libelf-dev libcap-dev \\\n          clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex \\\n          graphviz\n\n.. group-tab:: openSUSE Tumbleweed\n\n    The following applies to openSUSE Tumbleweed and openSUSE Leap 15.0 or later:\n\n    .. code-block:: shell-session\n\n       $ sudo zypper install -y git gcc ncurses-devel libelf-devel bc libopenssl-devel \\\n       libcap-devel clang llvm graphviz bison flex glibc-devel-static\n \n Compiling the Kernel \n \nDevelopment of new BPF features for the Linux kernel happens inside the ``net-next``\ngit tree, latest BPF fixes in the ``net`` tree. The following command will obtain\nthe kernel source for the ``net-next`` tree through git:\n\n.. code-block:: shell-session\n\n    $ git clone git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git\n\nIf the git commit history is not of interest, then ``--depth 1`` will clone the\ntree much faster by truncating the git history only to the most recent commit.\n\nIn case the ``net`` tree is of interest, it can be cloned from this url:\n\n.. code-block:: shell-session\n\n    $ git clone git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git\n\nThere are dozens of tutorials on the Internet on how to build Linux kernels, one\ngood resource is the Kernel Newbies website (https://kernelnewbies.org/KernelBuild)\nthat can be followed with one of the two git trees mentioned above.\n\nMake sure that the generated ``.config`` file contains the following ``CONFIG_*``\nentries for running BPF. These entries are also needed for Cilium.\n\n::\n\n    CONFIG_CGROUP_BPF=y\n    CONFIG_BPF=y\n    CONFIG_BPF_SYSCALL=y\n    CONFIG_NET_SCH_INGRESS=m\n    CONFIG_NET_CLS_BPF=m\n    CONFIG_NET_CLS_ACT=y\n    CONFIG_BPF_JIT=y\n    CONFIG_LWTUNNEL_BPF=y\n    CONFIG_HAVE_EBPF_JIT=y\n    CONFIG_BPF_EVENTS=y\n    CONFIG_TEST_BPF=m\n\nSome of the entries cannot be adjusted through ``make menuconfig``. For example,\n``CONFIG_HAVE_EBPF_JIT`` is selected automatically if a given architecture does\ncome with an eBPF JIT. In this specific case, ``CONFIG_HAVE_EBPF_JIT`` is optional\nbut highly recommended. An architecture not having an eBPF JIT compiler will need\nto fall back to the in-kernel interpreter with the cost of being less efficient\nexecuting BPF instructions.\n\nVerifying the Setup\n```````````````````\n\nAfter you have booted into the newly compiled kernel, navigate to the BPF selftest\nsuite in order to test BPF functionality (current working directory points to\nthe root of the cloned git tree):\n\n.. code-block:: shell-session\n\n    $ cd tools/testing/selftests/bpf/\n    $ make\n    $ sudo ./test_verifier\n\nThe verifier tests print out all the current checks being performed. The summary\nat the end of running all tests will dump information of test successes and\nfailures:\n\n::\n\n    Summary: 847 PASSED, 0 SKIPPED, 0 FAILED\n\n.. note:: For kernel releases 4.16+ the BPF selftest has a dependency on LLVM 6.0+\n          caused by the BPF function calls which do not need to be inlined\n          anymore. See section :ref:`bpf_to_bpf_calls` or the cover letter mail\n          from the kernel patch (https://lwn.net/Articles/741773/) for more information.\n          Not every BPF program has a dependency on LLVM 6.0+ if it does not\n          use this new feature. If your distribution does not provide LLVM 6.0+\n          you may compile it by following the instruction in the :ref:`tooling_llvm`\n          section.\n\nIn order to run through all BPF selftests, the following command is needed:\n\n.. code-block:: shell-session\n\n    $ sudo make run_tests\n\nIf you see any failures, please contact us on `Cilium Slack`_ with the full\ntest output.\n\nCompiling iproute2\n``````````````````\n\nSimilar to the ``net`` (fixes only) and ``net-next`` (new features) kernel trees,\nthe iproute2 git tree has two branches, namely ``master`` and ``net-next``. The\n``master`` branch is based on the ``net`` tree and the ``net-next`` branch is\nbased against the ``net-next`` kernel tree. This is necessary, so that changes\nin header files can be synchronized in the iproute2 tree.\n\nIn order to clone the iproute2 ``master`` branch, the following command can\nbe used:\n\n.. code-block:: shell-session\n\n    $ git clone https://git.kernel.org/pub/scm/network/iproute2/iproute2.git\n\nSimilarly, to clone into mentioned ``net-next`` branch of iproute2, run the\nfollowing:\n\n.. code-block:: shell-session\n\n    $ git clone -b net-next https://git.kernel.org/pub/scm/network/iproute2/iproute2.git\n\nAfter that, proceed with the build and installation:\n\n.. code-block:: shell-session\n\n    $ cd iproute2/\n    $ ./configure --prefix=/usr\n    TC schedulers\n     ATM    no\n\n    libc has setns: yes\n    SELinux support: yes\n    ELF support: yes\n    libmnl support: no\n    Berkeley DB: no\n\n    docs: latex: no\n     WARNING: no docs can be built from LaTeX files\n     sgml2html: no\n     WARNING: no HTML docs can be built from SGML\n    $ make\n    [...]\n    $ sudo make install\n\nEnsure that the ``configure`` script shows ``ELF support: yes``, so that iproute2\ncan process ELF files from LLVM's BPF back end. libelf was listed in the instructions\nfor installing the dependencies in case of Fedora and Ubuntu earlier.\n\nCompiling bpftool\n`````````````````\n\nbpftool is an essential tool around debugging and introspection of BPF programs\nand maps. It is part of the kernel tree and available under ``tools/bpf/bpftool/``.\n\nMake sure to have cloned either the ``net`` or ``net-next`` kernel tree as described\nearlier. In order to build and install bpftool, the following steps are required:\n\n.. code-block:: shell-session\n\n    $ cd <kernel-tree>/tools/bpf/bpftool/\n    $ make\n    Auto-detecting system features:\n    ...                        libbfd: [ on  ]\n    ...        disassembler-four-args: [ OFF ]\n\n      CC       xlated_dumper.o\n      CC       prog.o\n      CC       common.o\n      CC       cgroup.o\n      CC       main.o\n      CC       json_writer.o\n      CC       cfg.o\n      CC       map.o\n      CC       jit_disasm.o\n      CC       disasm.o\n    make[1]: Entering directory '/home/foo/trees/net/tools/lib/bpf'\n\n    Auto-detecting system features:\n    ...                        libelf: [ on  ]\n    ...                           bpf: [ on  ]\n\n      CC       libbpf.o\n      CC       bpf.o\n      CC       nlattr.o\n      LD       libbpf-in.o\n      LINK     libbpf.a\n    make[1]: Leaving directory '/home/foo/trees/bpf/tools/lib/bpf'\n      LINK     bpftool\n    $ sudo make install\n\n.. _tooling_llvm:\n\nLLVM\n----\n\nLLVM is currently the only compiler suite providing a BPF back end. gcc does\nnot support BPF at this point.\n\nThe BPF back end was merged into LLVM's 3.7 release. Major distributions enable\nthe BPF back end by default when they package LLVM, therefore installing clang\nand llvm is sufficient on most recent distributions to start compiling C\ninto BPF object files.\n\nThe typical workflow is that BPF programs are written in C, compiled by LLVM\ninto object / ELF files, which are parsed by user space BPF ELF loaders (such as\niproute2 or others) and pushed into the kernel through the BPF system call.\nThe kernel verifies the BPF instructions and JITs them, returning a new file\ndescriptor for the program, which then can be attached to a subsystem (e.g.\nnetworking). If supported, the subsystem could then further offload the BPF\nprogram to hardware (e.g. NIC).\n\nFor LLVM, BPF target support can be checked, for example, through the following:\n\n.. code-block:: shell-session\n\n    $ llc --version\n    LLVM (http://llvm.org/):\n    LLVM version 3.8.1\n    Optimized build.\n    Default target: x86_64-unknown-linux-gnu\n    Host CPU: skylake\n\n    Registered Targets:\n      [...]\n      bpf        - BPF (host endian)\n      bpfeb      - BPF (big endian)\n      bpfel      - BPF (little endian)\n      [...]\n\nBy default, the ``bpf`` target uses the endianness of the CPU it compiles on,\nmeaning that if the CPU's endianness is little endian, the program is represented\nin little endian format as well, and if the CPU's endianness is big endian,\nthe program is represented in big endian. This also matches the runtime behavior\nof BPF, which is generic and uses the CPU's endianness it runs on in order\nto not disadvantage architectures in any of the format.\n\nFor cross-compilation, the two targets ``bpfeb`` and ``bpfel`` were introduced,\nthanks to that BPF programs can be compiled on a node running in one endianness\n(e.g. little endian on x86) and run on a node in another endianness format (e.g.\nbig endian on arm). Note that the front end (clang) needs to run in the target\nendianness as well.\n\nUsing ``bpf`` as a target is the preferred way in situations where no mixture of\nendianness applies. For example, compilation on ``x86_64`` results in the same\noutput for the targets ``bpf`` and ``bpfel`` due to being little endian, therefore\nscripts triggering a compilation also do not have to be endian aware.\n\nA minimal, stand-alone XDP drop program might look like the following example\n(``xdp-example.c``):\n\n.. code-block:: c\n\n    #include <linux/bpf.h>\n\n    #ifndef __section\n    # define __section(NAME)                  \\\n       __attribute__((section(NAME), used))\n    #endif\n\n    __section(\"prog\")\n    int xdp_drop(struct xdp_md *ctx)\n    {\n        return XDP_DROP;\n    }\n\n    char __license[] __section(\"license\") = \"GPL\";\n\nIt can then be compiled and loaded into the kernel as follows:\n\n.. code-block:: shell-session\n\n    $ clang -O2 -Wall --target=bpf -c xdp-example.c -o xdp-example.o\n    # ip link set dev em1 xdp obj xdp-example.o\n\n.. note:: Attaching an XDP BPF program to a network device as above requires\n          Linux 4.11 with a device that supports XDP, or Linux 4.12 or later.\n\nFor the generated object file LLVM (>= 3.9) uses the official BPF machine value,\nthat is, ``EM_BPF`` (decimal: ``247`` / hex: ``0xf7``). In this example, the program\nhas been compiled with ``bpf`` target under ``x86_64``, therefore ``LSB`` (as opposed\nto ``MSB``) is shown regarding endianness:\n\n.. code-block:: shell-session\n\n    $ file xdp-example.o\n    xdp-example.o: ELF 64-bit LSB relocatable, *unknown arch 0xf7* version 1 (SYSV), not stripped\n\n``readelf -a xdp-example.o`` will dump further information about the ELF file, which can\nsometimes be useful for introspecting generated section headers, relocation entries\nand the symbol table.\n\nIn the unlikely case where clang and LLVM need to be compiled from scratch, the\nfollowing commands can be used:\n\n.. code-block:: shell-session\n\n    $ git clone https://github.com/llvm/llvm-project.git\n    $ cd llvm-project\n    $ mkdir build\n    $ cd build\n    $ cmake -DLLVM_ENABLE_PROJECTS=clang -DLLVM_TARGETS_TO_BUILD=\"BPF;X86\" -DBUILD_SHARED_LIBS=OFF -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_RUNTIME=OFF  -G \"Unix Makefiles\" ../llvm\n    $ make -j $(getconf _NPROCESSORS_ONLN)\n    $ ./bin/llc --version\n    LLVM (http://llvm.org/):\n    LLVM version x.y.zsvn\n    Optimized build.\n    Default target: x86_64-unknown-linux-gnu\n    Host CPU: skylake\n\n    Registered Targets:\n      bpf    - BPF (host endian)\n      bpfeb  - BPF (big endian)\n      bpfel  - BPF (little endian)\n      x86    - 32-bit X86: Pentium-Pro and above\n      x86-64 - 64-bit X86: EM64T and AMD64\n\n    $ export PATH=$PWD/bin:$PATH   # add to ~/.bashrc\n\nMake sure that ``--version`` mentions ``Optimized build.``, otherwise the\ncompilation time for programs when having LLVM in debugging mode will\nsignificantly increase (e.g. by 10x or more).\n\nFor debugging, clang can generate the assembler output as follows:\n\n.. code-block:: shell-session\n\n    $ clang -O2 -S -Wall --target=bpf -c xdp-example.c -o xdp-example.S\n    $ cat xdp-example.S\n        .text\n        .section    prog,\"ax\",@progbits\n        .globl      xdp_drop\n        .p2align    3\n    xdp_drop:                             # @xdp_drop\n    # BB#0:\n        r0 = 1\n        exit\n\n        .section    license,\"aw\",@progbits\n        .globl    __license               # @__license\n    __license:\n        .asciz    \"GPL\"\n\nStarting from LLVM's release 6.0, there is also assembler parser support. You can\nprogram using BPF assembler directly, then use llvm-mc to assemble it into an\nobject file. For example, you can assemble the xdp-example.S listed above back\ninto object file using:\n\n.. code-block:: shell-session\n\n    $ llvm-mc -triple bpf -filetype=obj -o xdp-example.o xdp-example.S\n\nFurthermore, more recent LLVM versions (>= 4.0) can also store debugging\ninformation in dwarf format into the object file. This can be done through\nthe usual workflow by adding ``-g`` for compilation.\n\n.. code-block:: shell-session\n\n    $ clang -O2 -g -Wall --target=bpf -c xdp-example.c -o xdp-example.o\n    $ llvm-objdump -S --no-show-raw-insn xdp-example.o\n\n    xdp-example.o:        file format ELF64-BPF\n\n    Disassembly of section prog:\n    xdp_drop:\n    ; {\n        0:        r0 = 1\n    ; return XDP_DROP;\n        1:        exit\n\nThe ``llvm-objdump`` tool can then annotate the assembler output with the\noriginal C code used in the compilation. The trivial example in this case\ndoes not contain much C code, however, the line numbers shown as ``0:``\nand ``1:`` correspond directly to the kernel's verifier log.\n\nThis means that in case BPF programs get rejected by the verifier, ``llvm-objdump``\ncan help to correlate the instructions back to the original C code, which is\nhighly useful for analysis.\n\n.. code-block:: shell-session\n\n    # ip link set dev em1 xdp obj xdp-example.o verb\n\n    Prog section 'prog' loaded (5)!\n     - Type:         6\n     - Instructions: 2 (0 over limit)\n     - License:      GPL\n\n    Verifier analysis:\n\n    0: (b7) r0 = 1\n    1: (95) exit\n    processed 2 insns\n\nAs it can be seen in the verifier analysis, the ``llvm-objdump`` output dumps\nthe same BPF assembler code as the kernel.\n\nLeaving out the ``--no-show-raw-insn`` option will also dump the raw\n``struct bpf_insn`` as hex in front of the assembly:\n\n.. code-block:: shell-session\n\n    $ llvm-objdump -S xdp-example.o\n\n    xdp-example.o:        file format ELF64-BPF\n\n    Disassembly of section prog:\n    xdp_drop:\n    ; {\n       0:       b7 00 00 00 01 00 00 00     r0 = 1\n    ; return foo();\n       1:       95 00 00 00 00 00 00 00     exit\n\nFor LLVM IR debugging, the compilation process for BPF can be split into\ntwo steps, generating a binary LLVM IR intermediate file ``xdp-example.bc``, which\ncan later on be passed to llc:\n\n.. code-block:: shell-session\n\n    $ clang -O2 -Wall --target=bpf -emit-llvm -c xdp-example.c -o xdp-example.bc\n    $ llc xdp-example.bc -march=bpf -filetype=obj -o xdp-example.o\n\nThe generated LLVM IR can also be dumped in human readable format through:\n\n.. code-block:: shell-session\n\n    $ clang -O2 -Wall -emit-llvm -S -c xdp-example.c -o -\n\nLLVM can attach debug information such as the description of used data\ntypes in the program to the generated BPF object file. By default, this is in\nDWARF format.\n\nA heavily simplified version used by BPF is called BTF (BPF Type Format). The\nresulting DWARF can be converted into BTF and is later on loaded into the\nkernel through BPF object loaders. The kernel will then verify the BTF data\nfor correctness and keeps track of the data types the BTF data is containing.\n\nBPF maps can then be annotated with key and value types out of the BTF data\nsuch that a later dump of the map exports the map data along with the related\ntype information. This allows for better introspection, debugging and value\npretty printing. Note that BTF data is a generic debugging data format and\nas such any DWARF to BTF converted data can be loaded (e.g. kernel's vmlinux\nDWARF data could be converted to BTF and loaded). Latter is in particular\nuseful for BPF tracing in the future.\n\nIn order to generate BTF from DWARF debugging information, elfutils (>= 0.173)\nis needed. If that is not available, then adding the ``-mattr=dwarfris`` option\nto the ``llc`` command is required during compilation:\n\n.. code-block:: shell-session\n\n    $ llc -march=bpf -mattr=help |& grep dwarfris\n      dwarfris - Disable MCAsmInfo DwarfUsesRelocationsAcrossSections.\n      [...]\n\nThe reason using ``-mattr=dwarfris`` is because the flag ``dwarfris`` (``dwarf\nrelocation in section``) disables DWARF cross-section relocations between DWARF\nand the ELF's symbol table since libdw does not have proper BPF relocation\nsupport, and therefore tools like ``pahole`` would otherwise not be able to\nproperly dump structures from the object.\n\nelfutils (>= 0.173) implements proper BPF relocation support and therefore\nthe same can be achieved without the ``-mattr=dwarfris`` option. Dumping\nthe structures from the object file could be done from either DWARF or BTF\ninformation. ``pahole`` uses the LLVM emitted DWARF information at this\npoint, however, future ``pahole`` versions could rely on BTF if available.\n\nFor converting DWARF into BTF, a recent pahole version (>= 1.12) is required.\nA recent pahole version can also be obtained from its official git repository\nif not available from one of the distribution packages:\n\n.. code-block:: shell-session\n\n    $ git clone https://git.kernel.org/pub/scm/devel/pahole/pahole.git\n\n``pahole`` comes with the option ``-J`` to convert DWARF into BTF from an\nobject file. ``pahole`` can be probed for BTF support as follows (note that\nthe ``llvm-objcopy`` tool is required for ``pahole`` as well, so check its\npresence, too):\n\n.. code-block:: shell-session\n\n    $ pahole --help | grep BTF\n    -J, --btf_encode           Encode as BTF\n\nGenerating debugging information also requires the front end to generate\nsource level debug information by passing ``-g`` to the ``clang`` command\nline. Note that ``-g`` is needed independently of whether ``llc``'s\n``dwarfris`` option is used. Full example for generating the object file:\n\n.. code-block:: shell-session\n\n    $ clang -O2 -g -Wall --target=bpf -emit-llvm -c xdp-example.c -o xdp-example.bc\n    $ llc xdp-example.bc -march=bpf -mattr=dwarfris -filetype=obj -o xdp-example.o\n\nAlternatively, by using clang only to build a BPF program with debugging\ninformation (again, the dwarfris flag can be omitted when having proper\nelfutils version):\n\n.. code-block:: shell-session\n\n    $ clang --target=bpf -O2 -g -c -Xclang -target-feature -Xclang +dwarfris -c xdp-example.c -o xdp-example.o\n\nAfter successful compilation ``pahole`` can be used to properly dump structures\nof the BPF program based on the DWARF information:\n\n.. code-block:: shell-session\n\n    $ pahole xdp-example.o\n    struct xdp_md {\n            __u32                      data;                 /*     0     4 */\n            __u32                      data_end;             /*     4     4 */\n            __u32                      data_meta;            /*     8     4 */\n\n            /* size: 12, cachelines: 1, members: 3 */\n            /* last cacheline: 12 bytes */\n    };\n\nThrough the option ``-J`` ``pahole`` can eventually generate the BTF from\nDWARF. In the object file DWARF data will still be retained alongside the\nnewly added BTF data. Full ``clang`` and ``pahole`` example combined:\n\n.. code-block:: shell-session\n\n    $ clang --target=bpf -O2 -Wall -g -c -Xclang -target-feature -Xclang +dwarfris -c xdp-example.c -o xdp-example.o\n    $ pahole -J xdp-example.o\n\nThe presence of a ``.BTF`` section can be seen through ``readelf`` tool:\n\n.. code-block:: shell-session\n\n    $ readelf -a xdp-example.o\n    [...]\n      [18] .BTF              PROGBITS         0000000000000000  00000671\n    [...]\n\nBPF loaders such as iproute2 will detect and load the BTF section, so that\nBPF maps can be annotated with type information.\n\nLLVM by default uses the BPF base instruction set for generating code\nin order to make sure that the generated object file can also be loaded\nwith older kernels such as long-term stable kernels (e.g. 4.9+).\n\nHowever, LLVM has a ``-mcpu`` selector for the BPF back end in order to\nselect different versions of the BPF instruction set, namely instruction\nset extensions on top of the BPF base instruction set in order to generate\nmore efficient and smaller code.\n\nAvailable ``-mcpu`` options can be queried through:\n\n.. code-block:: shell-session\n\n    $ llc -march bpf -mcpu=help\n    Available CPUs for this target:\n\n      generic - Select the generic processor.\n      probe   - Select the probe processor.\n      v1      - Select the v1 processor.\n      v2      - Select the v2 processor.\n    [...]\n\nThe ``generic`` processor is the default processor, which is also the\nbase instruction set ``v1`` of BPF. Options ``v1`` and ``v2`` are typically\nuseful in an environment where the BPF program is being cross compiled\nand the target host where the program is loaded differs from the one\nwhere it is compiled (and thus available BPF kernel features might differ\nas well).\n\nThe recommended ``-mcpu`` option which is also used by Cilium internally is\n``-mcpu=probe``! Here, the LLVM BPF back end queries the kernel for availability\nof BPF instruction set extensions and when found available, LLVM will use\nthem for compiling the BPF program whenever appropriate.\n\nA full command line example with llc's ``-mcpu=probe``:\n\n.. code-block:: shell-session\n\n    $ clang -O2 -Wall --target=bpf -emit-llvm -c xdp-example.c -o xdp-example.bc\n    $ llc xdp-example.bc -march=bpf -mcpu=probe -filetype=obj -o xdp-example.o\n\nGenerally, LLVM IR generation is architecture independent. However, there are \na few differences when using ``clang --target=bpf`` versus\nleaving ``--target=bpf`` out and thus using clang's default target which,\ndepending on the underlying architecture, might be ``x86_64``, ``arm64``\nor others.\n\nQuoting from the kernel's ``Documentation/bpf/bpf_devel_QA.txt``:\n\n* BPF programs may recursively include header file(s) with file scope\n  inline assembly codes. The default target can handle this well, while\n  bpf target may fail if bpf backend assembler does not understand\n  these assembly codes, which is true in most cases.\n\n* When compiled without -g, additional elf sections, e.g., ``.eh_frame``\n  and ``.rela.eh_frame``, may be present in the object file with default\n  target, but not with bpf target.\n\n* The default target may turn a C switch statement into a switch table\n  lookup and jump operation. Since the switch table is placed in the\n  global read-only section, the bpf program will fail to load.\n  The bpf target does not support switch table optimization. The clang\n  option ``-fno-jump-tables`` can be used to disable switch table\n  generation.\n\n* For clang ``--target=bpf``, it is guaranteed that pointer or long /\n  unsigned long types will always have a width of 64 bit, no matter\n  whether underlying clang binary or default target (or kernel) is\n  32 bit. However, when native clang target is used, then it will\n  compile these types based on the underlying architecture's\n  conventions, meaning in case of 32 bit architecture, pointer or\n  long / unsigned long types e.g. in BPF context structure will have\n  width of 32 bit while the BPF LLVM back end still operates in 64 bit.\n\nThe native target is mostly needed in tracing for the case of walking\nthe kernel's ``struct pt_regs`` that maps CPU registers, or other kernel\nstructures where CPU's register width matters. In all other cases such\nas networking, the use of ``clang --target=bpf`` is the preferred choice.\n\nAlso, LLVM started to support 32-bit subregisters and BPF ALU32 instructions since\nLLVM's release 7.0. A new code generation attribute ``alu32`` is added. When it is\nenabled, LLVM will try to use 32-bit subregisters whenever possible, typically\nwhen there are operations on 32-bit types. The associated ALU instructions with\n32-bit subregisters will become ALU32 instructions. For example, for the\nfollowing sample code:\n\n.. code-block:: shell-session\n\n    $ cat 32-bit-example.c\n        void cal(unsigned int *a, unsigned int *b, unsigned int *c)\n        {\n          unsigned int sum = *a + *b;\n          *c = sum;\n        }\n\nAt default code generation, the assembler looks like:\n\n.. code-block:: shell-session\n\n    $ clang --target=bpf -emit-llvm -S 32-bit-example.c\n    $ llc -march=bpf 32-bit-example.ll\n    $ cat 32-bit-example.s\n        cal:\n          r1 = *(u32 *)(r1 + 0)\n          r2 = *(u32 *)(r2 + 0)\n          r2 += r1\n          *(u32 *)(r3 + 0) = r2\n          exit\n\n64-bit registers are used, hence the addition means 64-bit addition. Now, if you\nenable the new 32-bit subregisters support by specifying ``-mattr=+alu32``, then\nthe assembler looks like:\n\n.. code-block:: shell-session\n\n    $ llc -march=bpf -mattr=+alu32 32-bit-example.ll\n    $ cat 32-bit-example.s\n        cal:\n          w1 = *(u32 *)(r1 + 0)\n          w2 = *(u32 *)(r2 + 0)\n          w2 += w1\n          *(u32 *)(r3 + 0) = w2\n          exit\n\n``w`` register, meaning 32-bit subregister, will be used instead of 64-bit ``r``\nregister.\n\nEnable 32-bit subregisters might help reducing type extension instruction\nsequences. It could also help kernel eBPF JIT compiler for 32-bit architectures\nfor which registers pairs are used to model the 64-bit eBPF registers and extra\ninstructions are needed for manipulating the high 32-bit. Given read from 32-bit\nsubregister is guaranteed to read from low 32-bit only even though write still\nneeds to clear the high 32-bit, if the JIT compiler has known the definition of\none register only has subregister reads, then instructions for setting the high\n32-bit of the destination could be eliminated.\n\nWhen writing C programs for BPF, there are a couple of pitfalls to be aware\nof, compared to usual application development with C. The following items\ndescribe some of the differences for the BPF model:\n\n1. **Everything needs to be inlined, there are no function calls (on older\n   LLVM versions) or shared library calls available.**\n\n   Shared libraries, etc cannot be used with BPF. However, common library\n   code used in BPF programs can be placed into header files and included in\n   the main programs. For example, Cilium makes heavy use of it (see ``bpf/lib/``).\n   However, this still allows for including header files, for example, from\n   the kernel or other libraries and reuse their static inline functions or\n   macros / definitions.\n\n   Unless a recent kernel (4.16+) and LLVM (6.0+) is used where BPF to BPF\n   function calls are supported, then LLVM needs to compile and inline the\n   entire code into a flat sequence of BPF instructions for a given program\n   section. In such case, best practice is to use an annotation like ``__inline``\n   for every library function as shown below. The use of ``always_inline``\n   is recommended, since the compiler could still decide to uninline large\n   functions that are only annotated as ``inline``.\n\n   In case the latter happens, LLVM will generate a relocation entry into\n   the ELF file, which BPF ELF loaders such as iproute2 cannot resolve and\n   will thus produce an error since only BPF maps are valid relocation entries\n   which loaders can process.\n\n   .. code-block:: c\n\n    #include <linux/bpf.h>\n\n    #ifndef __section\n    # define __section(NAME)                  \\\n       __attribute__((section(NAME), used))\n    #endif\n\n    #ifndef __inline\n    # define __inline                         \\\n       inline __attribute__((always_inline))\n    #endif\n\n    static __inline int foo(void)\n    {\n        return XDP_DROP;\n    }\n\n    __section(\"prog\")\n    int xdp_drop(struct xdp_md *ctx)\n    {\n        return foo();\n    }\n\n    char __license[] __section(\"license\") = \"GPL\";\n\n2. **Multiple programs can reside inside a single C file in different sections.**\n\n   C programs for BPF make heavy use of section annotations. A C file is\n   typically structured into 3 or more sections. BPF ELF loaders use these\n   names to extract and prepare the relevant information in order to load\n   the programs and maps through the bpf system call. For example, iproute2\n   uses ``maps`` and ``license`` as default section name to find metadata\n   needed for map creation and the license for the BPF program, respectively.\n   On program creation time the latter is pushed into the kernel as well,\n   and enables some of the helper functions which are exposed as GPL only\n   in case the program also holds a GPL compatible license, for example\n   ``bpf_ktime_get_ns()``, ``bpf_probe_read()`` and others.\n\n   The remaining section names are specific for BPF program code, for example,\n   the below code has been modified to contain two program sections, ``ingress``\n   and ``egress``. The toy example code demonstrates that both can share a map\n   and common static inline helpers such as the ``account_data()`` function.\n\n   The ``xdp-example.c`` example has been modified to a ``tc-example.c``\n   example that can be loaded with tc and attached to a netdevice's ingress\n   and egress hook.  It accounts the transferred bytes into a map called\n   ``acc_map``, which has two map slots, one for traffic accounted on the\n   ingress hook, one on the egress hook.\n\n   .. code-block:: c\n\n    #include <linux/bpf.h>\n    #include <linux/pkt_cls.h>\n    #include <stdint.h>\n    #include <iproute2/bpf_elf.h>\n\n    #ifndef __section\n    # define __section(NAME)                  \\\n       __attribute__((section(NAME), used))\n    #endif\n\n    #ifndef __inline\n    # define __inline                         \\\n       inline __attribute__((always_inline))\n    #endif\n\n    #ifndef lock_xadd\n    # define lock_xadd(ptr, val)              \\\n       ((void)__sync_fetch_and_add(ptr, val))\n    #endif\n\n    #ifndef BPF_FUNC\n    # define BPF_FUNC(NAME, ...)              \\\n       (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n    #endif\n\n    static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);\n\n    struct bpf_elf_map acc_map __section(\"maps\") = {\n        .type           = BPF_MAP_TYPE_ARRAY,\n        .size_key       = sizeof(uint32_t),\n        .size_value     = sizeof(uint32_t),\n        .pinning        = PIN_GLOBAL_NS,\n        .max_elem       = 2,\n    };\n\n    static __inline int account_data(struct __sk_buff *skb, uint32_t dir)\n    {\n        uint32_t *bytes;\n\n        bytes = map_lookup_elem(&acc_map, &dir);\n        if (bytes)\n                lock_xadd(bytes, skb->len);\n\n        return TC_ACT_OK;\n    }\n\n    __section(\"ingress\")\n    int tc_ingress(struct __sk_buff *skb)\n    {\n        return account_data(skb, 0);\n    }\n\n    __section(\"egress\")\n    int tc_egress(struct __sk_buff *skb)\n    {\n        return account_data(skb, 1);\n    }\n\n    char __license[] __section(\"license\") = \"GPL\";\n\n  The example also demonstrates a couple of other things which are useful\n  to be aware of when developing programs. The code includes kernel headers,\n  standard C headers and an iproute2 specific header containing the\n  definition of ``struct bpf_elf_map``. iproute2 has a common BPF ELF loader\n  and as such the definition of ``struct bpf_elf_map`` is the very same for\n  XDP and tc typed programs.\n\n  A ``struct bpf_elf_map`` entry defines a map in the program and contains\n  all relevant information (such as key / value size, etc) needed to generate\n  a map which is used from the two BPF programs. The structure must be placed\n  into the ``maps`` section, so that the loader can find it. There can be\n  multiple map declarations of this type with different variable names, but\n  all must be annotated with ``__section(\"maps\")``.\n\n  The ``struct bpf_elf_map`` is specific to iproute2. Different BPF ELF\n  loaders can have different formats, for example, the libbpf in the kernel\n  source tree, which is mainly used by ``perf``, has a different specification.\n  iproute2 guarantees backwards compatibility for ``struct bpf_elf_map``.\n  Cilium follows the iproute2 model.\n\n  The example also demonstrates how BPF helper functions are mapped into\n  the C code and being used. Here, ``map_lookup_elem()`` is defined by\n  mapping this function into the ``BPF_FUNC_map_lookup_elem`` enum value\n  which is exposed as a helper in ``uapi/linux/bpf.h``. When the program is later\n  loaded into the kernel, the verifier checks whether the passed arguments\n  are of the expected type and re-points the helper call into a real\n  function call. Moreover, ``map_lookup_elem()`` also demonstrates how\n  maps can be passed to BPF helper functions. Here, ``&acc_map`` from the\n  ``maps`` section is passed as the first argument to ``map_lookup_elem()``.\n\n  Since the defined array map is global, the accounting needs to use an\n  atomic operation, which is defined as ``lock_xadd()``. LLVM maps\n  ``__sync_fetch_and_add()`` as a built-in function to the BPF atomic\n  add instruction, that is, ``BPF_STX | BPF_XADD | BPF_W`` for word sizes.\n\n  Last but not least, the ``struct bpf_elf_map`` tells that the map is to\n  be pinned as ``PIN_GLOBAL_NS``. This means that tc will pin the map\n  into the BPF pseudo file system as a node. By default, it will be pinned\n  to ``/sys/fs/bpf/tc/globals/acc_map`` for the given example. Due to the\n  ``PIN_GLOBAL_NS``, the map will be placed under ``/sys/fs/bpf/tc/globals/``.\n  ``globals`` acts as a global namespace that spans across object files.\n  If the example used ``PIN_OBJECT_NS``, then tc would create a directory\n  that is local to the object file. For example, different C files with\n  BPF code could have the same ``acc_map`` definition as above with a\n  ``PIN_GLOBAL_NS`` pinning. In that case, the map will be shared among\n  BPF programs originating from various object files. ``PIN_NONE`` would\n  mean that the map is not placed into the BPF file system as a node,\n  and as a result, will not be accessible from user space after tc quits. It\n  would also mean that tc creates two separate map instances for each\n  program, since it cannot retrieve a previously pinned map under that\n  name. The ``acc_map`` part from the mentioned path is the name of the\n  map as specified in the source code.\n\n  Thus, upon loading of the ``ingress`` program, tc will find that no such\n  map exists in the BPF file system and creates a new one. On success, the\n  map will also be pinned, so that when the ``egress`` program is loaded\n  through tc, it will find that such map already exists in the BPF file\n  system and will reuse that for the ``egress`` program. The loader also\n  makes sure in case maps exist with the same name that also their properties\n  (key / value size, etc) match.\n\n  Just like tc can retrieve the same map, also third party applications\n  can use the ``BPF_OBJ_GET`` command from the bpf system call in order\n  to create a new file descriptor pointing to the same map instance, which\n  can then be used to lookup / update / delete map elements.\n\n  The code can be compiled and loaded via iproute2 as follows:\n\n  .. code-block:: shell-session\n\n    $ clang -O2 -Wall --target=bpf -c tc-example.c -o tc-example.o\n\n    # tc qdisc add dev em1 clsact\n    # tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress\n    # tc filter add dev em1 egress bpf da obj tc-example.o sec egress\n\n    # tc filter show dev em1 ingress\n    filter protocol all pref 49152 bpf\n    filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f\n\n    # tc filter show dev em1 egress\n    filter protocol all pref 49152 bpf\n    filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714\n\n    # mount | grep bpf\n    sysfs on /sys/fs/bpf type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)\n    bpf on /sys/fs/bpf type bpf (rw,relatime,mode=0700)\n\n    # tree /sys/fs/bpf/\n    /sys/fs/bpf/\n    +-- ip -> /sys/fs/bpf/tc/\n    +-- tc\n    |   +-- globals\n    |       +-- acc_map\n    +-- xdp -> /sys/fs/bpf/tc/\n\n    4 directories, 1 file\n\n  As soon as packets pass the ``em1`` device, counters from the BPF map will\n  be increased.\n\n3. **There are no global variables allowed.**\n\n  For the reasons already mentioned in point 1, BPF cannot have global variables\n  as often used in normal C programs.\n\n  However, there is a work-around in that the program can simply use a BPF map\n  of type ``BPF_MAP_TYPE_PERCPU_ARRAY`` with just a single slot of arbitrary\n  value size. This works, because during execution, BPF programs are guaranteed\n  to never get preempted by the kernel and therefore can use the single map entry\n  as a scratch buffer for temporary data, for example, to extend beyond the stack\n  limitation. This also functions across tail calls, since it has the same\n  guarantees with regards to preemption.\n\n  Otherwise, for holding state across multiple BPF program runs, normal BPF\n  maps can be used.\n\n4. **There are no const strings or arrays allowed.**\n\n  Defining ``const`` strings or other arrays in the BPF C program does not work\n  for the same reasons as pointed out in sections 1 and 3, which is, that relocation\n  entries will be generated in the ELF file which will be rejected by loaders due\n  to not being part of the ABI towards loaders (loaders also cannot fix up such\n  entries as it would require large rewrites of the already compiled BPF sequence).\n\n  In the future, LLVM might detect these occurrences and early throw an error\n  to the user.\n\n  Helper functions such as ``trace_printk()`` can be worked around as follows:\n\n  .. code-block:: c\n\n    static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);\n\n    #ifndef printk\n    # define printk(fmt, ...)                                      \\\n        ({                                                         \\\n            char ____fmt[] = fmt;                                  \\\n            trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n        })\n    #endif\n\n  The program can then use the macro naturally like ``printk(\"skb len:%u\\n\", skb->len);``.\n  The output will then be written to the trace pipe. ``tc exec bpf dbg`` can be\n  used to retrieve the messages from there.\n\n  The use of the ``trace_printk()`` helper function has a couple of disadvantages\n  and thus is not recommended for production usage. Constant strings like the\n  ``\"skb len:%u\\n\"`` need to be loaded into the BPF stack each time the helper\n  function is called, but also BPF helper functions are limited to a maximum\n  of 5 arguments. This leaves room for only 3 additional variables which can be\n  passed for dumping.\n\n  Therefore, despite being helpful for quick debugging, it is recommended (for networking\n  programs) to use the ``skb_event_output()`` or the ``xdp_event_output()`` helper,\n  respectively. They allow for passing custom structs from the BPF program to\n  the perf event ring buffer along with an optional packet sample. For example,\n  Cilium's monitor makes use of these helpers in order to implement a debugging\n  framework, notifications for network policy violations, etc. These helpers pass\n  the data through a lockless memory mapped per-CPU ``perf`` ring buffer, and\n  is thus significantly faster than ``trace_printk()``.\n\n5. **Use of LLVM built-in functions for memset()/memcpy()/memmove()/memcmp().**\n\n  Since BPF programs cannot perform any function calls other than those to BPF\n  helpers, common library code needs to be implemented as inline functions. In\n  addition, also LLVM provides some built-ins that the programs can use for\n  constant sizes (here: ``n``) which will then always get inlined:\n\n  .. code-block:: c\n\n    #ifndef memset\n    # define memset(dest, chr, n)   __builtin_memset((dest), (chr), (n))\n    #endif\n\n    #ifndef memcpy\n    # define memcpy(dest, src, n)   __builtin_memcpy((dest), (src), (n))\n    #endif\n\n    #ifndef memmove\n    # define memmove(dest, src, n)  __builtin_memmove((dest), (src), (n))\n    #endif\n\n  The ``memcmp()`` built-in had some corner cases where inlining did not take place\n  due to an LLVM issue in the back end, and is therefore not recommended to be\n  used until the issue is fixed.\n\n6. **There are no loops available (yet).**\n\n  The BPF verifier in the kernel checks that a BPF program does not contain\n  loops by performing a depth first search of all possible program paths besides\n  other control flow graph validations. The purpose is to make sure that the\n  program is always guaranteed to terminate.\n\n  A very limited form of looping is available for constant upper loop bounds\n  by using ``#pragma unroll`` directive. Example code that is compiled to BPF:\n\n  .. code-block:: c\n\n    #pragma unroll\n        for (i = 0; i < IPV6_MAX_HEADERS; i++) {\n            switch (nh) {\n            case NEXTHDR_NONE:\n                return DROP_INVALID_EXTHDR;\n            case NEXTHDR_FRAGMENT:\n                return DROP_FRAG_NOSUPPORT;\n            case NEXTHDR_HOP:\n            case NEXTHDR_ROUTING:\n            case NEXTHDR_AUTH:\n            case NEXTHDR_DEST:\n                if (skb_load_bytes(skb, l3_off + len, &opthdr, sizeof(opthdr)) < 0)\n                    return DROP_INVALID;\n\n                nh = opthdr.nexthdr;\n                if (nh == NEXTHDR_AUTH)\n                    len += ipv6_authlen(&opthdr);\n                else\n                    len += ipv6_optlen(&opthdr);\n                break;\n            default:\n                *nexthdr = nh;\n                return len;\n            }\n        }\n\n  Another possibility is to use tail calls by calling into the same program\n  again and using a ``BPF_MAP_TYPE_PERCPU_ARRAY`` map for having a local\n  scratch space. While being dynamic, this form of looping however is limited\n  to a maximum of 34 iterations (the initial program, plus 33 iterations from\n  the tail calls).\n\n  In the future, BPF may have some native, but limited form of implementing loops.\n\n7. **Partitioning programs with tail calls.**\n\n  Tail calls provide the flexibility to atomically alter program behavior during\n  runtime by jumping from one BPF program into another. In order to select the\n  next program, tail calls make use of program array maps (``BPF_MAP_TYPE_PROG_ARRAY``),\n  and pass the map as well as the index to the next program to jump to. There is no\n  return to the old program after the jump has been performed, and in case there was\n  no program present at the given map index, then execution continues on the original\n  program.\n\n  For example, this can be used to implement various stages of a parser, where\n  such stages could be updated with new parsing features during runtime.\n\n  Another use case are event notifications, for example, Cilium can opt in packet\n  drop notifications during runtime, where the ``skb_event_output()`` call is\n  located inside the tail called program. Thus, during normal operations, the\n  fall-through path will always be executed unless a program is added to the\n  related map index, where the program then prepares the metadata and triggers\n  the event notification to a user space daemon.\n\n  Program array maps are quite flexible, enabling also individual actions to\n  be implemented for programs located in each map index. For example, the root\n  program attached to XDP or tc could perform an initial tail call to index 0\n  of the program array map, performing traffic sampling, then jumping to index 1\n  of the program array map, where firewalling policy is applied and the packet\n  either dropped or further processed in index 2 of the program array map, where\n  it is mangled and sent out of an interface again. Jumps in the program array\n  map can, of course, be arbitrary. The kernel will eventually execute the\n  fall-through path when the maximum tail call limit has been reached.\n\n  Minimal example extract of using tail calls:\n\n  .. code-block:: c\n\n    [...]\n\n    #ifndef __stringify\n    # define __stringify(X)   #X\n    #endif\n\n    #ifndef __section\n    # define __section(NAME)                  \\\n       __attribute__((section(NAME), used))\n    #endif\n\n    #ifndef __section_tail\n    # define __section_tail(ID, KEY)          \\\n       __section(__stringify(ID) \"/\" __stringify(KEY))\n    #endif\n\n    #ifndef BPF_FUNC\n    # define BPF_FUNC(NAME, ...)              \\\n       (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n    #endif\n\n    #define BPF_JMP_MAP_ID   1\n\n    static void BPF_FUNC(tail_call, struct __sk_buff *skb, void *map,\n                         uint32_t index);\n\n    struct bpf_elf_map jmp_map __section(\"maps\") = {\n        .type           = BPF_MAP_TYPE_PROG_ARRAY,\n        .id             = BPF_JMP_MAP_ID,\n        .size_key       = sizeof(uint32_t),\n        .size_value     = sizeof(uint32_t),\n        .pinning        = PIN_GLOBAL_NS,\n        .max_elem       = 1,\n    };\n\n    __section_tail(BPF_JMP_MAP_ID, 0)\n    int looper(struct __sk_buff *skb)\n    {\n        printk(\"skb cb: %u\\n\", skb->cb[0]++);\n        tail_call(skb, &jmp_map, 0);\n        return TC_ACT_OK;\n    }\n\n    __section(\"prog\")\n    int entry(struct __sk_buff *skb)\n    {\n        skb->cb[0] = 0;\n        tail_call(skb, &jmp_map, 0);\n        return TC_ACT_OK;\n    }\n\n    char __license[] __section(\"license\") = \"GPL\";\n\n  When loading this toy program, tc will create the program array and pin it\n  to the BPF file system in the global namespace under ``jmp_map``. Also, the\n  BPF ELF loader in iproute2 will also recognize sections that are marked as\n  ``__section_tail()``. The provided ``id`` in ``struct bpf_elf_map`` will be\n  matched against the id marker in the ``__section_tail()``, that is, ``JMP_MAP_ID``,\n  and the program therefore loaded at the user specified program array map index,\n  which is ``0`` in this example. As a result, all provided tail call sections\n  will be populated by the iproute2 loader to the corresponding maps. This mechanism\n  is not specific to tc, but can be applied with any other BPF program type\n  that iproute2 supports (such as XDP, lwt).\n\n  The generated elf contains section headers describing the map id and the\n  entry within that map:\n\n  .. code-block:: shell-session\n\n    $ llvm-objdump -S --no-show-raw-insn prog_array.o | less\n    prog_array.o:   file format ELF64-BPF\n\n    Disassembly of section 1/0:\n    looper:\n           0:       r6 = r1\n           1:       r2 = *(u32 *)(r6 + 48)\n           2:       r1 = r2\n           3:       r1 += 1\n           4:       *(u32 *)(r6 + 48) = r1\n           5:       r1 = 0 ll\n           7:       call -1\n           8:       r1 = r6\n           9:       r2 = 0 ll\n          11:       r3 = 0\n          12:       call 12\n          13:       r0 = 0\n          14:       exit\n    Disassembly of section prog:\n    entry:\n           0:       r2 = 0\n           1:       *(u32 *)(r1 + 48) = r2\n           2:       r2 = 0 ll\n           4:       r3 = 0\n           5:       call 12\n           6:       r0 = 0\n           7:       exi\n\n  In this case, the ``section 1/0`` indicates that the ``looper()`` function\n  resides in the map id ``1`` at position ``0``.\n\n  The pinned map can be retrieved by user space applications (e.g. Cilium daemon),\n  but also by tc itself in order to update the map with new programs. Updates\n  happen atomically, the initial entry programs that are triggered first from the\n  various subsystems are also updated atomically.\n\n  Example for tc to perform tail call map updates:\n\n  .. code-block:: shell-session\n\n    # tc exec bpf graft m:globals/jmp_map key 0 obj new.o sec foo\n\n  In case iproute2 would update the pinned program array, the ``graft`` command\n  can be used. By pointing it to ``globals/jmp_map``, tc will update the\n  map at index / key ``0`` with a new program residing in the object file ``new.o``\n  under section ``foo``.\n\n8. **Limited stack space of maximum 512 bytes.**\n\n  Stack space in BPF programs is limited to only 512 bytes, which needs to be\n  taken into careful consideration when implementing BPF programs in C. However,\n  as mentioned earlier in point 3, a ``BPF_MAP_TYPE_PERCPU_ARRAY`` map with a\n  single entry can be used in order to enlarge scratch buffer space.\n\n9. **Use of BPF inline assembly possible.**\n\n  LLVM 6.0 or later allows use of inline assembly for BPF for the rare cases where it\n  might be needed. The following (nonsense) toy example shows a 64 bit atomic\n  add. Due to lack of documentation, LLVM source code in ``lib/Target/BPF/BPFInstrInfo.td``\n  as well as ``test/CodeGen/BPF/`` might be helpful for providing some additional\n  examples. Test code:\n\n  .. code-block:: c\n\n    #include <linux/bpf.h>\n\n    #ifndef __section\n    # define __section(NAME)                  \\\n       __attribute__((section(NAME), used))\n    #endif\n\n    __section(\"prog\")\n    int xdp_test(struct xdp_md *ctx)\n    {\n        __u64 a = 2, b = 3, *c = &a;\n        /* just a toy xadd example to show the syntax */\n        asm volatile(\"lock *(u64 *)(%0+0) += %1\" : \"=r\"(c) : \"r\"(b), \"0\"(c));\n        return a;\n    }\n\n    char __license[] __section(\"license\") = \"GPL\";\n\n  The above program is compiled into the following sequence of BPF\n  instructions:\n\n  ::\n\n    Verifier analysis:\n\n    0: (b7) r1 = 2\n    1: (7b) *(u64 *)(r10 -8) = r1\n    2: (b7) r1 = 3\n    3: (bf) r2 = r10\n    4: (07) r2 += -8\n    5: (db) lock *(u64 *)(r2 +0) += r1\n    6: (79) r0 = *(u64 *)(r10 -8)\n    7: (95) exit\n    processed 8 insns (limit 131072), stack depth 8\n\n10. **Remove struct padding with aligning members by using #pragma pack.**\n\n  In modern compilers, data structures are aligned by default to access memory\n  efficiently. Structure members are packed to memory addresses and padding is\n  added for the proper alignment with the processor word size (e.g. 8-byte for\n  64-bit processors, 4-byte for 32-bit processors). Because of this, the size of\n  struct may often grow larger than expected.\n\n  .. code-block:: c\n\n    struct called_info {\n        u64 start;  // 8-byte\n        u64 end;    // 8-byte\n        u32 sector; // 4-byte\n    }; // size of 20-byte ?\n\n    printf(\"size of %d-byte\\n\", sizeof(struct called_info)); // size of 24-byte\n\n    // Actual compiled composition of struct called_info\n    // 0x0(0)                   0x8(8)\n    //  ↓________________________↓\n    //  |        start (8)       |\n    //  |________________________|\n    //  |         end  (8)       |\n    //  |________________________|\n    //  |  sector(4) |  PADDING  | <= address aligned to 8\n    //  |____________|___________|     with 4-byte PADDING.\n\n  The BPF verifier in the kernel checks the stack boundary that a BPF program does\n  not access outside of boundary or uninitialized stack area. Using struct with the\n  padding as a map value, will cause ``invalid indirect read from stack`` failure on\n  ``bpf_prog_load()``.\n\n  Example code:\n\n  .. code-block:: c\n\n    struct called_info {\n        u64 start;\n        u64 end;\n        u32 sector;\n    };\n\n    struct bpf_map_def SEC(\"maps\") called_info_map = {\n        .type = BPF_MAP_TYPE_HASH,\n        .key_size = sizeof(long),\n        .value_size = sizeof(struct called_info),\n        .max_entries = 4096,\n    };\n\n    SEC(\"kprobe/submit_bio\")\n    int submit_bio_entry(struct pt_regs *ctx)\n    {\n        char fmt[] = \"submit_bio(bio=0x%lx) called: %llu\\n\";\n        u64 start_time = bpf_ktime_get_ns();\n        long bio_ptr = PT_REGS_PARM1(ctx);\n        struct called_info called_info = {\n                .start = start_time,\n                .end = 0,\n                .sector = 0\n        };\n\n        bpf_map_update_elem(&called_info_map, &bio_ptr, &called_info, BPF_ANY);\n        bpf_trace_printk(fmt, sizeof(fmt), bio_ptr, start_time);\n        return 0;\n    }\n\n  Corresponding output on ``bpf_load_program()``::\n\n    bpf_load_program() err=13\n    0: (bf) r6 = r1\n    ...\n    19: (b7) r1 = 0\n    20: (7b) *(u64 *)(r10 -72) = r1\n    21: (7b) *(u64 *)(r10 -80) = r7\n    22: (63) *(u32 *)(r10 -64) = r1\n    ...\n    30: (85) call bpf_map_update_elem#2\n    invalid indirect read from stack off -80+20 size 24\n\n  At ``bpf_prog_load()``, an eBPF verifier ``bpf_check()`` is called, and it'll\n  check stack boundary by calling ``check_func_arg() -> check_stack_boundary()``.\n  From the upper error shows, ``struct called_info`` is compiled to 24-byte size,\n  and the message says reading a data from +20 is an invalid indirect read.\n  And as we discussed earlier, the address 0x14(20) is the place where PADDING is.\n\n  .. code-block:: c\n\n    // Actual compiled composition of struct called_info\n    // 0x10(16)    0x14(20)    0x18(24)\n    //  ↓____________↓___________↓\n    //  |  sector(4) |  PADDING  | <= address aligned to 8\n    //  |____________|___________|     with 4-byte PADDING.\n\n  The ``check_stack_boundary()`` internally loops through the every ``access_size`` (24)\n  byte from the start pointer to make sure that it's within stack boundary and all\n  elements of the stack are initialized. Since the padding isn't supposed to be used,\n  it gets the 'invalid indirect read from stack' failure. To avoid this kind of\n  failure, removing the padding from the struct is necessary.\n\n  Removing the padding by using ``#pragma pack(n)`` directive:\n\n  .. code-block:: c\n\n    #pragma pack(4)\n    struct called_info {\n        u64 start;  // 8-byte\n        u64 end;    // 8-byte\n        u32 sector; // 4-byte\n    }; // size of 20-byte ?\n\n    printf(\"size of %d-byte\\n\", sizeof(struct called_info)); // size of 20-byte\n\n    // Actual compiled composition of packed struct called_info\n    // 0x0(0)                   0x8(8)\n    //  ↓________________________↓\n    //  |        start (8)       |\n    //  |________________________|\n    //  |         end  (8)       |\n    //  |________________________|\n    //  |  sector(4) |             <= address aligned to 4\n    //  |____________|                 with no PADDING.\n\n  By locating ``#pragma pack(4)`` before of ``struct called_info``, the compiler will align\n  members of a struct to the least of 4-byte and their natural alignment. As you can\n  see, the size of ``struct called_info`` has been shrunk to 20-byte and the padding\n  no longer exists.\n\n  But, removing the padding has downsides too. For example, the compiler will generate\n  less optimized code. Since we've removed the padding, processors will conduct\n  unaligned access to the structure and this might lead to performance degradation.\n  And also, unaligned access might get rejected by verifier on some architectures.\n\n  However, there is a way to avoid downsides of packed structure. By simply adding the\n  explicit padding ``u32 pad`` member at the end will resolve the same problem without\n  packing of the structure.\n\n  .. code-block:: c\n\n    struct called_info {\n        u64 start;  // 8-byte\n        u64 end;    // 8-byte\n        u32 sector; // 4-byte\n        u32 pad;    // 4-byte\n    }; // size of 24-byte ?\n\n    printf(\"size of %d-byte\\n\", sizeof(struct called_info)); // size of 24-byte\n\n    // Actual compiled composition of struct called_info with explicit padding\n    // 0x0(0)                   0x8(8)\n    //  ↓________________________↓\n    //  |        start (8)       |\n    //  |________________________|\n    //  |         end  (8)       |\n    //  |________________________|\n    //  |  sector(4) |  pad (4)  | <= address aligned to 8\n    //  |____________|___________|     with explicit PADDING.\n\n11. **Accessing packet data via invalidated references**\n\n  Some networking BPF helper functions such as ``bpf_skb_store_bytes`` might\n  change the size of a packet data. As verifier is not able to track such\n  changes, any a priori reference to the data will be invalidated by verifier.\n  Therefore, the reference needs to be updated before accessing the data to\n  avoid verifier rejecting a program.\n\n  To illustrate this, consider the following snippet:\n\n  .. code-block:: c\n\n    struct iphdr *ip4 = (struct iphdr *) skb->data + ETH_HLEN;\n\n    skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &new_saddr, 4, 0);\n\n    if (ip4->protocol == IPPROTO_TCP) {\n        // do something\n    }\n\n  Verifier will reject the snippet due to dereference of the invalidated\n  ``ip4->protocol``:\n\n  ::\n\n      R1=pkt_end(id=0,off=0,imm=0) R2=pkt(id=0,off=34,r=34,imm=0) R3=inv0\n      R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=4294967295,var_off=(0x0; 0xffffffff))\n      R8=inv4294967162 R9=pkt(id=0,off=0,r=34,imm=0) R10=fp0,call_-1\n      ...\n      18: (85) call bpf_skb_store_bytes#9\n      19: (7b) *(u64 *)(r10 -56) = r7\n      R0=inv(id=0) R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=2,var_off=(0x0; 0x3))\n      R8=inv4294967162 R9=inv(id=0) R10=fp0,call_-1 fp-48=mmmm???? fp-56=mmmmmmmm\n      21: (61) r1 = *(u32 *)(r9 +23)\n      R9 invalid mem access 'inv'\n\n  To fix this, the reference to ``ip4`` has to be updated:\n\n  .. code-block:: c\n\n    struct iphdr *ip4 = (struct iphdr *) skb->data + ETH_HLEN;\n\n    skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &new_saddr, 4, 0);\n\n    ip4 = (struct iphdr *) skb->data + ETH_HLEN;\n\n    if (ip4->protocol == IPPROTO_TCP) {\n        // do something\n    }\n\niproute2\n--------\n\nThere are various front ends for loading BPF programs into the kernel such as bcc,\nperf, iproute2 and others. The Linux kernel source tree also provides a user space\nlibrary under ``tools/lib/bpf/``, which is mainly used and driven by perf for\nloading BPF tracing programs into the kernel. However, the library itself is\ngeneric and not limited to perf only. bcc is a toolkit providing many useful\nBPF programs mainly for tracing that are loaded ad-hoc through a Python interface\nembedding the BPF C code. Syntax and semantics for implementing BPF programs\nslightly differ among front ends in general, though. Additionally, there are also\nBPF samples in the kernel source tree (``samples/bpf/``) which parse the generated\nobject files and load the code directly through the system call interface.\n\nThis and previous sections mainly focus on the iproute2 suite's BPF front end for\nloading networking programs of XDP, tc or lwt type, since Cilium's programs are\nimplemented against this BPF loader. In future, Cilium will be equipped with a\nnative BPF loader, but programs will still be compatible to be loaded through\niproute2 suite in order to facilitate development and debugging.\n\nAll BPF program types supported by iproute2 share the same BPF loader logic\ndue to having a common loader back end implemented as a library (``lib/bpf.c``\nin iproute2 source tree).\n\nThe previous section on LLVM also covered some iproute2 parts related to writing\nBPF C programs, and later sections in this document are related to tc and XDP\nspecific aspects when writing programs. Therefore, this section will rather focus\non usage examples for loading object files with iproute2 as well as some of the\ngeneric mechanics of the loader. It does not try to provide a complete coverage\nof all details, but enough for getting started.\n\n**1. Loading of XDP BPF object files.**\n\n  Given a BPF object file ``prog.o`` has been compiled for XDP, it can be loaded\n  through ``ip`` to a XDP-supported netdevice called ``em1`` with the following\n  command:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp obj prog.o\n\n  The above command assumes that the program code resides in the default section\n  which is called ``prog`` in XDP case. Should this not be the case, and the\n  section is named differently, for example, ``foobar``, then the program needs\n  to be loaded as:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp obj prog.o sec foobar\n\n  Note that it is also possible to load the program out of the ``.text`` section.\n  Changing the minimal, stand-alone XDP drop program by removing the ``__section()``\n  annotation from the ``xdp_drop`` entry point would look like the following:\n\n  .. code-block:: c\n\n    #include <linux/bpf.h>\n\n    #ifndef __section\n    # define __section(NAME)                  \\\n       __attribute__((section(NAME), used))\n    #endif\n\n    int xdp_drop(struct xdp_md *ctx)\n    {\n        return XDP_DROP;\n    }\n\n    char __license[] __section(\"license\") = \"GPL\";\n\n  And can be loaded as follows:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp obj prog.o sec .text\n\n  By default, ``ip`` will throw an error in case a XDP program is already attached\n  to the networking interface, to prevent it from being overridden by accident. In\n  order to replace the currently running XDP program with a new one, the ``-force``\n  option must be used:\n\n  .. code-block:: shell-session\n\n    # ip -force link set dev em1 xdp obj prog.o\n\n  Most XDP-enabled drivers today support an atomic replacement of the existing\n  program with a new one without traffic interruption. There is always only a\n  single program attached to an XDP-enabled driver due to performance reasons,\n  hence a chain of programs is not supported. However, as described in the\n  previous section, partitioning of programs can be performed through tail\n  calls to achieve a similar use case when necessary.\n\n  The ``ip link`` command will display an ``xdp`` flag if the interface has an XDP\n  program attached. ``ip link | grep xdp`` can thus be used to find all interfaces\n  that have XDP running. Further introspection facilities are provided through\n  the detailed view with ``ip -d link`` and ``bpftool`` can be used to retrieve\n  information about the attached program based on the BPF program ID shown in\n  the ``ip link`` dump.\n\n  In order to remove the existing XDP program from the interface, the following\n  command must be issued:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp off\n\n  In the case of switching a driver's operation mode from non-XDP to native XDP\n  and vice versa, typically the driver needs to reconfigure its receive (and\n  transmit) rings in order to ensure received packet are set up linearly\n  within a single page for BPF to read and write into. However, once completed,\n  then most drivers only need to perform an atomic replacement of the program\n  itself when a BPF program is requested to be swapped.\n\n  In total, XDP supports three operation modes which iproute2 implements as well:\n  ``xdpdrv``, ``xdpoffload`` and ``xdpgeneric``.\n\n  ``xdpdrv`` stands for native XDP, meaning the BPF program is run directly in\n  the driver's receive path at the earliest possible point in software. This is\n  the normal / conventional XDP mode and requires drivers to implement XDP\n  support, which all major 10G/40G/+ networking drivers in the upstream Linux\n  kernel already provide.\n\n  ``xdpgeneric`` stands for generic XDP and is intended as an experimental test\n  bed for drivers which do not yet support native XDP. Given the generic XDP hook\n  in the ingress path comes at a much later point in time when the packet already\n  enters the stack's main receive path as a ``skb``, the performance is significantly\n  less than with processing in ``xdpdrv`` mode. ``xdpgeneric`` therefore is for\n  the most part only interesting for experimenting, less for production environments.\n\n  Last but not least, the ``xdpoffload`` mode is implemented by SmartNICs such\n  as those supported by Netronome's nfp driver and allow for offloading the entire\n  BPF/XDP program into hardware, thus the program is run on each packet reception\n  directly on the card. This provides even higher performance than running in\n  native XDP although not all BPF map types or BPF helper functions are available\n  for use compared to native XDP. The BPF verifier will reject the program in\n  such case and report to the user what is unsupported. Other than staying in\n  the realm of supported BPF features and helper functions, no special precautions\n  have to be taken when writing BPF C programs.\n\n  When a command like ``ip link set dev em1 xdp obj [...]`` is used, then the\n  kernel will attempt to load the program first as native XDP, and in case the\n  driver does not support native XDP, it will automatically fall back to generic\n  XDP. Thus, for example, using explicitly ``xdpdrv`` instead of ``xdp``, the\n  kernel will only attempt to load the program as native XDP and fail in case\n  the driver does not support it, which provides a guarantee that generic XDP\n  is avoided altogether.\n\n  Example for enforcing a BPF/XDP program to be loaded in native XDP mode,\n  dumping the link details and unloading the program again:\n\n  .. code-block:: shell-session\n\n     # ip -force link set dev em1 xdpdrv obj prog.o\n     # ip link show\n     [...]\n     6: em1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdp qdisc mq state UP mode DORMANT group default qlen 1000\n         link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n         prog/xdp id 1 tag 57cd311f2e27366b\n     [...]\n     # ip link set dev em1 xdpdrv off\n\n  Same example now for forcing generic XDP, even if the driver would support\n  native XDP, and additionally dumping the BPF instructions of the attached\n  dummy program through bpftool:\n\n  .. code-block:: shell-session\n\n    # ip -force link set dev em1 xdpgeneric obj prog.o\n    # ip link show\n    [...]\n    6: em1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdpgeneric qdisc mq state UP mode DORMANT group default qlen 1000\n        link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n        prog/xdp id 4 tag 57cd311f2e27366b                <-- BPF program ID 4\n    [...]\n    # bpftool prog dump xlated id 4                       <-- Dump of instructions running on em1\n    0: (b7) r0 = 1\n    1: (95) exit\n    # ip link set dev em1 xdpgeneric off\n\n  And last but not least offloaded XDP, where we additionally dump program\n  information via bpftool for retrieving general metadata:\n\n  .. code-block:: shell-session\n\n     # ip -force link set dev em1 xdpoffload obj prog.o\n     # ip link show\n     [...]\n     6: em1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000\n         link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n         prog/xdp id 8 tag 57cd311f2e27366b\n     [...]\n     # bpftool prog show id 8\n     8: xdp  tag 57cd311f2e27366b dev em1                  <-- Also indicates a BPF program offloaded to em1\n         loaded_at Apr 11/20:38  uid 0\n         xlated 16B  not jited  memlock 4096B\n     # ip link set dev em1 xdpoffload off\n\n  Note that it is not possible to use ``xdpdrv`` and ``xdpgeneric`` or other\n  modes at the same time, meaning only one of the XDP operation modes must be\n  picked.\n\n  A switch between different XDP modes e.g. from generic to native or vice\n  versa is not atomically possible. Only switching programs within a specific\n  operation mode is:\n\n  .. code-block:: shell-session\n\n     # ip -force link set dev em1 xdpgeneric obj prog.o\n     # ip -force link set dev em1 xdpoffload obj prog.o\n     RTNETLINK answers: File exists\n     # ip -force link set dev em1 xdpdrv obj prog.o\n     RTNETLINK answers: File exists\n     # ip -force link set dev em1 xdpgeneric obj prog.o    <-- Succeeds due to xdpgeneric\n     #\n\n  Switching between modes requires to first leave the current operation mode\n  in order to then enter the new one:\n\n  .. code-block:: shell-session\n\n     # ip -force link set dev em1 xdpgeneric obj prog.o\n     # ip -force link set dev em1 xdpgeneric off\n     # ip -force link set dev em1 xdpoffload obj prog.o\n     # ip l\n     [...]\n     6: em1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000\n         link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n         prog/xdp id 17 tag 57cd311f2e27366b\n     [...]\n     # ip -force link set dev em1 xdpoffload off\n\n**2. Loading of tc BPF object files.**\n\n  Given a BPF object file ``prog.o`` has been compiled for tc, it can be loaded\n  through the tc command to a netdevice. Unlike XDP, there is no driver dependency\n  for supporting attaching BPF programs to the device. Here, the netdevice is called\n  ``em1``, and with the following command the program can be attached to the networking\n  ``ingress`` path of ``em1``:\n\n  .. code-block:: shell-session\n\n    # tc qdisc add dev em1 clsact\n    # tc filter add dev em1 ingress bpf da obj prog.o\n\n  The first step is to set up a ``clsact`` qdisc (Linux queueing discipline). ``clsact``\n  is a dummy qdisc similar to the ``ingress`` qdisc, which can only hold classifier\n  and actions, but does not perform actual queueing. It is needed in order to attach\n  the ``bpf`` classifier. The ``clsact`` qdisc provides two special hooks called\n  ``ingress`` and ``egress``, where the classifier can be attached to. Both ``ingress``\n  and ``egress`` hooks are located in central receive and transmit locations in the\n  networking data path, where every packet on the device passes through. The ``ingress``\n  hook is called from ``__netif_receive_skb_core() -> sch_handle_ingress()`` in the\n  kernel and the ``egress`` hook from ``__dev_queue_xmit() -> sch_handle_egress()``.\n\n  The equivalent for attaching the program to the ``egress`` hook looks as follows:\n\n  .. code-block:: shell-session\n\n    # tc filter add dev em1 egress bpf da obj prog.o\n\n  The ``clsact`` qdisc is processed lockless from ``ingress`` and ``egress``\n  direction and can also be attached to virtual, queue-less devices such as\n  ``veth`` devices connecting containers.\n\n  Next to the hook, the ``tc filter`` command selects ``bpf`` to be used in ``da``\n  (direct-action) mode. ``da`` mode is recommended and should always be specified.\n  It basically means that the ``bpf`` classifier does not need to call into external\n  tc action modules, which are not necessary for ``bpf`` anyway, since all packet\n  mangling, forwarding or other kind of actions can already be performed inside\n  a single BPF program, and is therefore significantly\n  faster.\n\n  At this point, the program has been attached and is executed once packets traverse\n  the device. Like in XDP, should the default section name not be used, then it\n  can be specified during load, for example, in case of section ``foobar``:\n\n  .. code-block:: shell-session\n\n    # tc filter add dev em1 egress bpf da obj prog.o sec foobar\n\n  iproute2's BPF loader allows for using the same command line syntax across\n  program types, hence the ``obj prog.o sec foobar`` is the same syntax as with\n  XDP mentioned earlier.\n\n  The attached programs can be listed through the following commands:\n\n  .. code-block:: shell-session\n\n    # tc filter show dev em1 ingress\n    filter protocol all pref 49152 bpf\n    filter protocol all pref 49152 bpf handle 0x1 prog.o:[ingress] direct-action id 1 tag c5f7825e5dac396f\n\n    # tc filter show dev em1 egress\n    filter protocol all pref 49152 bpf\n    filter protocol all pref 49152 bpf handle 0x1 prog.o:[egress] direct-action id 2 tag b2fd5adc0f262714\n\n  The output of ``prog.o:[ingress]`` tells that program section ``ingress`` was\n  loaded from the file ``prog.o``, and ``bpf`` operates in ``direct-action`` mode.\n  The program ``id`` and ``tag`` is appended for each case, where the latter denotes\n  a hash over the instruction stream which can be correlated with the object file\n  or ``perf`` reports with stack traces, etc. Last but not least, the ``id``\n  represents the system-wide unique BPF program identifier that can be used along\n  with ``bpftool`` to further inspect or dump the attached BPF program.\n\n  tc can attach more than just a single BPF program, it provides various other\n  classifiers which can be chained together. However, attaching a single BPF program\n  is fully sufficient since all packet operations can be contained in the program\n  itself thanks to ``da`` (``direct-action``) mode, meaning the BPF program itself\n  will already return the tc action verdict such as ``TC_ACT_OK``, ``TC_ACT_SHOT``\n  and others. For optimal performance and flexibility, this is the recommended usage.\n\n  In the above ``show`` command, tc also displays ``pref 49152`` and\n  ``handle 0x1`` next to the BPF related output. Both are auto-generated in\n  case they are not explicitly provided through the command line. ``pref``\n  denotes a priority number, which means that in case multiple classifiers are\n  attached, they will be executed based on ascending priority, and ``handle``\n  represents an identifier in case multiple instances of the same classifier have\n  been loaded under the same ``pref``. Since in case of BPF, a single program is\n  fully sufficient, ``pref`` and ``handle`` can typically be ignored.\n\n  Only in the case where it is planned to atomically replace the attached BPF\n  programs, it would be recommended to explicitly specify ``pref`` and ``handle``\n  a priori on initial load, so that they do not have to be queried at a later\n  point in time for the ``replace`` operation. Thus, creation becomes:\n\n  .. code-block:: shell-session\n\n    # tc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar\n\n    # tc filter show dev em1 ingress\n    filter protocol all pref 1 bpf\n    filter protocol all pref 1 bpf handle 0x1 prog.o:[foobar] direct-action id 1 tag c5f7825e5dac396f\n\n  And for the atomic replacement, the following can be issued for updating the\n  existing program at ``ingress`` hook with the new BPF program from the file\n  ``prog.o`` in section ``foobar``:\n\n  .. code-block:: shell-session\n\n    # tc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar\n\n  Last but not least, in order to remove all attached programs from the ``ingress``\n  respectively ``egress`` hook, the following can be used:\n\n  .. code-block:: shell-session\n\n    # tc filter del dev em1 ingress\n    # tc filter del dev em1 egress\n\n  For removing the entire ``clsact`` qdisc from the netdevice, which implicitly also\n  removes all attached programs from the ``ingress`` and ``egress`` hooks, the\n  below command is provided:\n\n  .. code-block:: shell-session\n\n    # tc qdisc del dev em1 clsact\n\n  tc BPF programs can also be offloaded if the NIC and driver has support for it,\n  like XDP BPF programs. Netronome's nfp supported NICs offer both\n  types of BPF offload.\n\n  .. code-block:: shell-session\n\n    # tc qdisc add dev em1 clsact\n    # tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o\n    Error: TC offload is disabled on net device.\n    We have an error talking to the kernel\n\n  If the above error is shown, then tc hardware offload first needs to be enabled\n  for the device through ethtool's ``hw-tc-offload`` setting:\n\n  .. code-block:: shell-session\n\n    # ethtool -K em1 hw-tc-offload on\n    # tc qdisc add dev em1 clsact\n    # tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o\n    # tc filter show dev em1 ingress\n    filter protocol all pref 1 bpf\n    filter protocol all pref 1 bpf handle 0x1 prog.o:[classifier] direct-action skip_sw in_hw id 19 tag 57cd311f2e27366b\n\n  The ``in_hw`` flag confirms that the program has been offloaded to the NIC.\n\n  Note that BPF offloads for both tc and XDP cannot be loaded at the same time,\n  either the tc or XDP offload option must be selected.\n\n**3. Testing BPF offload interface via netdevsim driver.**\n\n  The netdevsim driver which is part of the Linux kernel provides a dummy driver\n  which implements offload interfaces for XDP BPF and tc BPF programs and\n  facilitates testing kernel changes or low-level user space programs\n  implementing a control plane directly against the kernel's UAPI.\n\n  A netdevsim device can be created as follows:\n\n  .. code-block:: shell-session\n\n    # modprobe netdevsim\n    // [ID] [PORT_COUNT]\n    # echo \"1 1\" > /sys/bus/netdevsim/new_device\n    # devlink dev\n    netdevsim/netdevsim1\n    # devlink port\n    netdevsim/netdevsim1/0: type eth netdev eth0 flavour physical\n    # ip l\n    [...]\n    4: eth0: <BROADCAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n        link/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff\n\n  After that step, XDP BPF or tc BPF programs can be test loaded as shown\n  in the various examples earlier:\n\n  .. code-block:: shell-session\n\n    # ip -force link set dev eth0 xdpoffload obj prog.o\n    # ip l\n    [...]\n    4: eth0: <BROADCAST,NOARP,UP,LOWER_UP> mtu 1500 xdpoffload qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n        link/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff\n        prog/xdp id 16 tag a04f5eef06a7f555\n\nThese two workflows are the basic operations to load XDP BPF respectively tc BPF\nprograms with iproute2.\n\nThere are other various advanced options for the BPF loader that apply both to XDP\nand tc, some of them are listed here. In the examples only XDP is presented for\nsimplicity.\n\n**1. Verbose log output even on success.**\n\n  The option ``verb`` can be appended for loading programs in order to dump the\n  verifier log, even if no error occurred:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp obj xdp-example.o verb\n\n    Prog section 'prog' loaded (5)!\n     - Type:         6\n     - Instructions: 2 (0 over limit)\n     - License:      GPL\n\n    Verifier analysis:\n\n    0: (b7) r0 = 1\n    1: (95) exit\n    processed 2 insns\n\n**2. Load program that is already pinned in BPF file system.**\n\n  Instead of loading a program from an object file, iproute2 can also retrieve\n  the program from the BPF file system in case some external entity pinned it\n  there and attach it to the device:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp pinned /sys/fs/bpf/prog\n\n  iproute2 can also use the short form that is relative to the detected mount\n  point of the BPF file system:\n\n  .. code-block:: shell-session\n\n    # ip link set dev em1 xdp pinned m:prog\n\nWhen loading BPF programs, iproute2 will automatically detect the mounted\nfile system instance in order to perform pinning of nodes. In case no mounted\nBPF file system instance was found, then tc will automatically mount it\nto the default location under ``/sys/fs/bpf/``.\n\nIn case an instance has already been found, then it will be used and no additional\nmount will be performed:\n\n.. code-block:: shell-session\n\n    # mkdir /var/run/bpf\n    # mount --bind /var/run/bpf /var/run/bpf\n    # mount -t bpf bpf /var/run/bpf\n    # tc filter add dev em1 ingress bpf da obj tc-example.o sec prog\n    # tree /var/run/bpf\n    /var/run/bpf\n    +-- ip -> /run/bpf/tc/\n    +-- tc\n    |   +-- globals\n    |       +-- jmp_map\n    +-- xdp -> /run/bpf/tc/\n\n    4 directories, 1 file\n\nBy default tc will create an initial directory structure as shown above,\nwhere all subsystem users will point to the same location through symbolic\nlinks for the ``globals`` namespace, so that pinned BPF maps can be reused\namong various BPF program types in iproute2. In case the file system instance\nhas already been mounted and an existing structure already exists, then tc will\nnot override it. This could be the case for separating ``lwt``, ``tc`` and\n``xdp`` maps in order to not share ``globals`` among all.\n\nAs briefly covered in the previous LLVM section, iproute2 will install a\nheader file upon installation which can be included through the standard\ninclude path by BPF programs:\n\n.. code-block:: c\n\n    #include <iproute2/bpf_elf.h>\n\nThe purpose of this header file is to provide an API for maps and default section\nnames used by programs. It's a stable contract between iproute2 and BPF programs.\n\nThe map definition for iproute2 is ``struct bpf_elf_map``. Its members have\nbeen covered earlier in the LLVM section of this document.\n\nWhen parsing the BPF object file, the iproute2 loader will walk through\nall ELF sections. It initially fetches ancillary sections like ``maps`` and\n``license``. For ``maps``, the ``struct bpf_elf_map`` array will be checked\nfor validity and whenever needed, compatibility workarounds are performed.\nSubsequently all maps are created with the user provided information, either\nretrieved as a pinned object, or newly created and then pinned into the BPF\nfile system. Next the loader will handle all program sections that contain\nELF relocation entries for maps, meaning that BPF instructions loading\nmap file descriptors into registers are rewritten so that the corresponding\nmap file descriptors are encoded into the instructions immediate value, in\norder for the kernel to be able to convert them later on into map kernel\npointers. After that all the programs themselves are created through the BPF\nsystem call, and tail called maps, if present, updated with the program's file\ndescriptors.",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/reference-guides/bpf/toolchain.rst",
  "extracted_at": "2025-09-03T00:53:44.727092Z"
}