{
  "url": "file:///tmp/cilium-repo/Documentation/observability/hubble/configuration/tls.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _hubble_enable_tls: \n \n Configure TLS with Hubble \n \n This page provides guidance to configure Hubble with TLS in a way that suits your\nenvironment. Instructions to enable Hubble are provided as part of each\nCilium :ref: getting_started  guide. \n Enable TLS on the Hubble API \n When Hubble Relay is deployed, Hubble listens on a TCP port on the host network.\nThis allows Hubble Relay to communicate with all Hubble instances in the\ncluster. Connections between Hubble instances and Hubble Relay are secured using\nmutual TLS (mTLS) by default. \n TLS certificates can be generated automatically or manually provided. \n The following options are available to configure TLS certificates automatically: \n \n cilium's  certgen <https://github.com/cilium/certgen> __ (using a Kubernetes  CronJob ) \n cert-manager <https://cert-manager.io/> __ \n Helm <https://helm.sh/docs/chart_template_guide/function_list/#gensignedcert> __ \n \n Each of these method handles certificate rotation differently, but the end\nresult is the secrets containing the key pair will be updated. As Hubble server\nand Hubble Relay support TLS certificates hot reloading, including CA\ncertificates, this does not disrupt any existing connection. New connections\nare automatically established using the new certificates without having to\nrestart Hubble server or Hubble Relay. \n .. tabs:: \n .. group-tab:: CronJob (certgen)\n\n    When using certgen, TLS certificates are generated at installation time\n    and a Kubernetes ``CronJob`` is scheduled to renew them (regardless of\n    their expiration date). The certgen method is easier to implement than\n    cert-manager but less flexible.\n\n    ::\n\n        --set hubble.tls.auto.enabled=true               # enable automatic TLS certificate generation\n        --set hubble.tls.auto.method=cronJob             # auto generate certificates using cronJob method\n        --set hubble.tls.auto.certValidityDuration=1095  # certificates validity duration in days (default 3 years)\n        --set hubble.tls.auto.schedule=\"0 0 1 */4 *\"     # schedule for certificates re-generation (crontab syntax)\n\n.. group-tab:: cert-manager\n\n    This method relies on `cert-manager <https://cert-manager.io/>`__ to generate\n    the TLS certificates. cert-manager has becomes the de facto way to manage TLS on\n    Kubernetes, and it has the following advantages compared to the other\n    documented methods:\n\n    * Support for multiple issuers (e.g. a custom CA,\n      `Vault <https://www.vaultproject.io/>`__,\n      `Let's Encrypt <https://letsencrypt.org/>`__,\n      `Google's Certificate Authority Service <https://cloud.google.com/certificate-authority-service>`__,\n      and more) allowing to choose the issuer fitting your organization's\n      requirements.\n    * Manages certificates via a\n      `CRD <https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/>`__\n      which is easier to inspect with Kubernetes tools than PEM files.\n\n    **Installation steps**:\n\n    #. First, install `cert-manager <https://cert-manager.io/docs/installation/>`__\n       and setup an `issuer <https://cert-manager.io/docs/configuration/>`_.\n       Please make sure that your issuer is able to create certificates under the\n       ``cilium.io`` domain name.\n    #. Install/upgrade Cilium including the following Helm flags:\n\n    ::\n\n        --set hubble.tls.auto.enabled=true                                 # enable automatic TLS certificate generation\n        --set hubble.tls.auto.method=certmanager                           # auto generate certificates using cert-manager\n        --set hubble.tls.auto.certValidityDuration=1095                    # certificates validity duration in days (default 3 years)\n        --set hubble.tls.auto.certManagerIssuerRef.group=\"cert-manager.io\" # Reference to cert-manager's issuer\n        --set hubble.tls.auto.certManagerIssuerRef.kind=\"ClusterIssuer\"\n        --set hubble.tls.auto.certManagerIssuerRef.name=\"ca-issuer\"\n\n.. group-tab:: Helm\n\n    When using Helm, TLS certificates are (re-)generated every time Helm is used\n    for install or upgrade.\n\n    ::\n\n        --set hubble.tls.auto.enabled=true               # enable automatic TLS certificate generation\n        --set hubble.tls.auto.method=helm                # auto generate certificates using helm method\n        --set hubble.tls.auto.certValidityDuration=1095  # certificates validity duration in days (default 3 years)\n\n    The downside of the Helm method is that while certificates are automatically\n    generated, they are not automatically renewed.  Consequently, running\n    ``helm upgrade`` is required when certificates are about to expire (i.e. before\n    the configured ``hubble.tls.auto.certValidityDuration``).\n\n.. group-tab:: User Provided Certificates\n\n    In order to provide your own TLS certificates, ``hubble.tls.auto.enabled`` must be\n    set to ``false``, secrets containing the certificates must be created in the\n    ``kube-system`` namespace, and the secret names must be provided to Helm.\n\n    Provided files must be **base64 encoded** PEM certificates.\n\n    In addition, the **Common Name (CN)** and **Subject Alternative Name (SAN)**\n    of the certificate for Hubble server MUST be set to\n    ``*.{cluster-name}.hubble-grpc.cilium.io`` where ``{cluster-name}`` is the\n    cluster name defined by ``cluster.name`` (defaults to ``default``).\n\n    Once the certificates have been issued, the secrets must be created in the ``kube-system`` namespace.\n\n    Each secret must contain the following keys:\n\n    - ``tls.crt``: The certificate file.\n    - ``tls.key``: The private key file.\n    - ``ca.crt``: The CA certificate file.\n\n    The following examples demonstrates how to create the secrets.\n\n    Create the hubble server certificate secret:\n\n    .. code-block:: shell-session\n\n      $ kubectl -n kube-system create secret generic hubble-server-certs --from-file=hubble-server.crt --from-file=hubble-server.key --from-file=ca.crt\n\n    If hubble-relay is enabled, the following secrets must be created:\n\n    .. code-block:: shell-session\n\n      $ kubectl -n kube-system create secret generic hubble-relay-server-certs --from-file=hubble-relay-server.crt --from-file=hubble-relay-server.key --from-file=ca.crt\n      $ kubectl -n kube-system create secret generic hubble-relay-client-certs --from-file=hubble-relay-client.crt --from-file=hubble-relay-client.key --from-file=ca.crt\n\n    If hubble-ui is enabled, the following secret must be created:\n\n    .. code-block:: shell-session\n\n      $ kubectl -n kube-system create secret generic hubble-ui-client-certs --from-file=hubble-ui-client.crt --from-file=hubble-ui-client.key --from-file=ca.crt\n\n    Lastly, if the Hubble metrics API is enabled, the following secret must be created:\n\n    .. code-block:: shell-session\n\n      $ kubectl -n kube-system create secret generic hubble-metrics-certs --from-file=hubble-metrics.crt --from-file=hubble-metrics.key --from-file=ca.crt\n\n    After the secrets have been created, the secret names must be provided to Helm and automatic certificate generation must be disabled:\n\n    ::\n\n        --set hubble.tls.auto.enabled=false                                       # Disable automatic TLS certificate generation\n        --set hubble.tls.server.existingSecret=\"hubble-server-certs\"\n        --set hubble.relay.tls.server.enabled=true                                # Enable TLS on Hubble Relay (optional)\n        --set hubble.relay.tls.server.existingSecret=\"hubble-relay-server-certs\"\n        --set hubble.relay.tls.client.existingSecret=\"hubble-relay-client-certs\"\n        --set hubble.ui.tls.client.existingSecret=\"hubble-ui-client-certs\"\n        --set hubble.metrics.tls.enabled=true                                     # Enable TLS on the Hubble metrics API (optional)\n        --set hubble.metrics.tls.server.existingSecret=\"hubble-metrics-certs\"\n\n    - ``hubble.relay.tls.server.existingSecret`` and ``hubble.ui.tls.client.existingSecret``\n      only need to be provided when ``hubble.relay.tls.server.enabled=true`` (default ``false``).\n    - ``hubble.ui.tls.client.existingSecret`` only needs to be provided when ``hubble.ui.enabled`` (default ``false``).\n    - ``hubble.metrics.tls.server.existingSecret`` only needs to be provided when ``hubble.metrics.tls.enabled`` (default ``false``).\n      For more details on configuring the Hubble metrics API with TLS, see :ref:`hubble_configure_metrics_tls`.\n \n .. _hubble_enable_tls_troubleshooting: \n Troubleshooting \n If you encounter issues after enabling TLS, you can use the following instructions to help diagnose the problem. \n .. tabs:: \n .. group-tab:: cert-manager\n\n\n    While installing Cilium or cert-manager you may get the following error:\n\n    ::\n\n        Error: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp x.x.x.x:443: connect: connection refused\n\n    This happens when cert-manager's webhook (which is used to verify the\n    ``Certificate``'s CRD resources) is not available. There are several ways to\n    resolve this issue. Pick one of the following options:\n\n    .. tabs::\n\n        .. tab:: Install CRDs first\n\n            Install cert-manager CRDs before Cilium and cert-manager (see `cert-manager's documentation about installing CRDs with kubectl <https://cert-manager.io/docs/installation/helm/#option-1-installing-crds-with-kubectl>`__):\n\n            .. code-block:: shell-session\n\n                $ kubectl create -f cert-manager.crds.yaml\n\n            Then install cert-manager, configure an issuer, and install Cilium.\n\n        .. tab:: Upgrade Cilium\n\n            Upgrade Cilium from an installation with TLS disabled:\n\n            .. code-block:: shell-session\n\n                $ helm install cilium cilium/cilium \\\n                    --set hubble.tls.enabled=false \\\n                    ...\n\n            Then install cert-manager, configure an issuer, and upgrade Cilium enabling TLS:\n\n            .. code-block:: shell-session\n\n                $ helm install cilium cilium/cilium --set hubble.tls.enabled=true\n\n        .. tab:: Disable webhook\n\n            Disable cert-manager validation (assuming Cilium is installed in the ``kube-system`` namespace):\n\n            .. code-block:: shell-session\n\n                $ kubectl label namespace kube-system cert-manager.io/disable-validation=true\n\n            Then install Cilium, cert-manager, and configure an issuer.\n\n        .. tab:: Host network webhook\n\n            Configure cert-manager to expose its webhook within the host network namespace:\n\n            .. code-block:: shell-session\n\n                $ helm install cert-manager jetstack/cert-manager \\\n                        --set webhook.hostNetwork=true \\\n                        --set webhook.tolerations='[\"operator\": \"Exists\"]'\n\n            Then configure an issuer and install Cilium.\n\n.. group-tab:: CronJob (certgen)\n\n    If you are using ArgoCD, you may encounter issues on the initial\n    installation because of how ArgoCD handles Helm hooks specified in the\n    ``helm.sh/hook`` annotation.\n\n    The ``hubble-generate-certs`` Job specifies a ``post-install`` Helm\n    hook in order to generate the required Certificates at initial install time, since\n    the CronJob will only run on the configured schedule which could be\n    hours or days after the initial installation.\n\n    Since ArgoCD will only run ``post-install`` hooks after all pods are\n    ready and running, you may encounter a situation where the\n    ``hubble-generate-certs`` Job is never run.\n\n    It cannot be configured as a ``pre-install`` hook because it requires Cilium\n    to be running first, and Hubble Relay cannot become ready until\n    certificates are provisioned.\n\n    To work around this, you can manually run the ``certgen`` CronJob:\n\n    .. code-block:: shell-session\n\n        $ kubectl -n kube-system create job hubble-generate-certs-initial --from cronjob/hubble-generate-certs\n\n.. group-tab:: Helm\n\n    When using Helm certificates are not automatically renewed. If you\n    encounter issues with expired certificates, you can manually renew them\n    by running ``helm upgrade`` to renew the certificates.\n\n.. group-tab:: User Provided Certificates\n\n    If you encounter issues with the certificates, you can check the\n    certificates and keys by decoding them:\n\n    .. code-block:: shell-session\n\n        $ kubectl -n kube-system get secret hubble-server-certs -o jsonpath='{.data.tls\\.crt}' | base64 -d | openssl x509 -text -noout\n        $ kubectl -n kube-system get secret hubble-server-certs -o jsonpath='{.data.tls\\.key}' | base64 -d | openssl rsa -text -noout\n        $ kubectl -n kube-system get secret hubble-server-certs -o jsonpath='{.data.ca\\.crt}' | base64 -d | openssl x509 -text -noout\n\n    The same commands can be used for the other secrets as well.\n\n    If hubble-relay is enabled but not responding or the pod is failing it's readiness probe,\n    check the certificates and ensure the client certificate is issued by the CA (``ca.crt``) specified in the ``hubble-server-certs`` secret.\n\n    Additionally you must ensure the **Common Name (CN)** and **Subject Alternative Name (SAN)**\n    of the certificate for Hubble server MUST be set to\n    ``*.{cluster-name}.hubble-grpc.cilium.io`` where ``{cluster-name}`` is\n    the cluster name defined by ``cluster.name`` (defaults to ``default``).\n \n Validating the Installation \n The following section guides you through validating that TLS is enabled for Hubble\nand the connection between Hubble Relay and Hubble Server is using mTLS to secure the session.\nAdditionally, the commands below can be used to troubleshoot issues with your TLS configuration if you encounter any issues. \n Before beginning verify TLS has been configured correctly by running the following command: \n .. code-block:: shell-session \n $ kubectl get configmap -n kube-system cilium-config -oyaml | grep hubble-disable-tls\nhubble-disable-tls: \"false\" \n You should see that the  hubble-disable-tls  configuration option is set to  false . \n Start by creating a Hubble CLI pod within the namespace that Hubble components are running in (for example:  kube-system ): \n .. code-block:: shell-session \n $ kubectl apply -n kube-system -f https://raw.githubusercontent.com/cilium/cilium/main/examples/hubble/hubble-cli.yaml\n \n List Hubble Servers by running  hubble watch peers  within the newly created pod: \n .. code-block:: shell-session \n $ kubectl exec -it -n kube-system deployment/hubble-cli -- \\\nhubble watch peers --server unix:///var/run/cilium/hubble.sock\n\nPEER_ADDED   172.18.0.2 kind-worker (TLS.ServerName: kind-worker.default.hubble-grpc.cilium.io)\nPEER_ADDED   172.18.0.3 kind-control-plane (TLS.ServerName: kind-control-plane.kind.hubble-grpc.cilium.io)\n \n Copy the IP and the server name of the first peer into the following environment variables for the next steps: \n .. note:: \n If the ``TLS.ServerName`` is missing from your output then TLS is not enabled for the Hubble server and the following steps will not work.\nIf this is the case, please refer to the previous sections to enable TLS.\n \n .. code-block:: shell-session \n $ IP=172.18.0.2\n$ SERVERNAME=kind-worker.default.hubble-grpc.cilium.io\n \n Connect to the first peer with the Hubble Relay client certificate to confirm\nthat the Hubble server is accepting connections from clients who present the\ncorrect certificate: \n .. code-block:: shell-session \n $ kubectl exec -it -n kube-system deployment/hubble-cli -- \\\nhubble observe --server tls://${IP?}:4244 \\\n    --tls-server-name ${SERVERNAME?} \\\n    --tls-ca-cert-files /var/lib/hubble-relay/tls/hubble-server-ca.crt \\\n    --tls-client-cert-file /var/lib/hubble-relay/tls/client.crt \\\n    --tls-client-key-file /var/lib/hubble-relay/tls/client.key\n\nDec 13 08:49:58.888: 10.20.1.124:60588 (host) -> kube-system/coredns-565d847f94-pp8zs:8181 (ID:7518) to-endpoint FORWARDED (TCP Flags: SYN)\nDec 13 08:49:58.888: 10.20.1.124:36308 (host) <- kube-system/coredns-565d847f94-pp8zs:8080 (ID:7518) to-stack FORWARDED (TCP Flags: SYN, ACK)\nDec 13 08:49:58.888: 10.20.1.124:60588 (host) <- kube-system/coredns-565d847f94-pp8zs:8181 (ID:7518) to-stack FORWARDED (TCP Flags: SYN, ACK)\n...\n...\n \n Now try to query the Hubble server without providing any client certificate: \n .. code-block:: shell-session \n $ kubectl exec -it -n kube-system deployment/hubble-cli -- \\\nhubble observe --server tls://${IP?}:4244 \\\n    --tls-server-name ${SERVERNAME?} \\\n    --tls-ca-cert-files /var/lib/hubble-relay/tls/hubble-server-ca.crt\n\nfailed to connect to '172.18.0.2:4244': context deadline exceeded: connection error: desc = \"error reading server preface: remote error: tls: certificate requiredd\"\ncommand terminated with exit code 1\n \n You can also try to connect without TLS: \n .. code-block:: shell-session \n $ kubectl exec -it -n kube-system deployment/hubble-cli -- \\\nhubble observe --server ${IP?}:4244\n\nfailed to connect to '172.18.0.2:4244': context deadline exceeded: connection error: desc = \"error reading server preface: EOF\"\ncommand terminated with exit code 1\n \n To troubleshoot the connection, install OpenSSL in the Hubble CLI pod: \n .. code-block:: shell-session \n $ kubectl exec -it -n kube-system deployment/hubble-cli -- apk add --update openssl\n \n Then, use OpenSSL to connect to the Hubble server get more details about the TLS handshake: \n .. code-block:: shell-session \n $ kubectl exec -it -n kube-system deployment/hubble-cli -- \\\nopenssl s_client -showcerts -servername ${SERVERNAME} -connect ${IP?}:4244 \\\n-CAfile /var/lib/hubble-relay/tls/hubble-server-ca.crt\n\nCONNECTED(00000004)\ndepth=1 C = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\nverify return:1\ndepth=0 CN = *.default.hubble-grpc.cilium.io\nverify return:1\n---\nCertificate chain\n 0 s:CN = *.default.hubble-grpc.cilium.io\n   i:C = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\n   a:PKEY: id-ecPublicKey, 256 (bit); sigalg: ecdsa-with-SHA256\n   v:NotBefore: Aug 15 17:39:00 2024 GMT; NotAfter: Aug 15 17:39:00 2027 GMT\n-----BEGIN CERTIFICATE-----\nMIICNzCCAd2gAwIBAgIUAlgykDuc1J+mzseHS0pREX6Uv3cwCgYIKoZIzj0EAwIw\naDELMAkGA1UEBhMCVVMxFjAUBgNVBAgTDVNhbiBGcmFuY2lzY28xCzAJBgNVBAcT\nAkNBMQ8wDQYDVQQKEwZDaWxpdW0xDzANBgNVBAsTBkNpbGl1bTESMBAGA1UEAxMJ\nQ2lsaXVtIENBMB4XDTI0MDgxNTE3MzkwMFoXDTI3MDgxNTE3MzkwMFowKjEoMCYG\nA1UEAwwfKi5kZWZhdWx0Lmh1YmJsZS1ncnBjLmNpbGl1bS5pbzBZMBMGByqGSM49\nAgEGCCqGSM49AwEHA0IABGjtY50MM21TolEy5RUrBa6WqHsw7PjNB3MhYLCsuJmO\naQ1tIy6J2e7a9Cw2jmBlyj+dL8g0YLhRQX4n+leItSSjgaIwgZ8wDgYDVR0PAQH/\nBAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwHQYDVR0O\nBBYEFCDf5epVs8yyyZCdtBzc90HrQzpFMB8GA1UdIwQYMBaAFDKuJMmhNPJ71FvB\nAyHEMztI62NbMCoGA1UdEQQjMCGCHyouZGVmYXVsdC5odWJibGUtZ3JwYy5jaWxp\ndW0uaW8wCgYIKoZIzj0EAwIDSAAwRQIhAP0kyl0Eb7FBQw1uZE+LWnRyr5GDsB3+\n6rA/Rx042XZgAiBZML3lOW60tWMI1Pyn4cR4trFbzZpsUSwnQmOAb+paEw==\n-----END CERTIFICATE-----\n---\nServer certificate\nsubject=CN = *.default.hubble-grpc.cilium.io\nissuer=C = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\n---\nAcceptable client certificate CA names\nC = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\nRequested Signature Algorithms: RSA-PSS+SHA256:ECDSA+SHA256:Ed25519:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:ECDSA+SHA384:ECDSA+SHA512:RSA+SHA1:ECDSA+SHA1\nShared Requested Signature Algorithms: RSA-PSS+SHA256:ECDSA+SHA256:Ed25519:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:ECDSA+SHA384:ECDSA+SHA512\nPeer signing digest: SHA256\nPeer signature type: ECDSA\nServer Temp Key: X25519, 253 bits\n---\nSSL handshake has read 1106 bytes and written 437 bytes\nVerification: OK\n---\nNew, TLSv1.3, Cipher is TLS_AES_128_GCM_SHA256\nServer public key is 256 bit\nThis TLS version forbids renegotiation.\nNo ALPN negotiated\nEarly data was not sent\nVerify return code: 0 (ok)\n---\n08EBFFFFFF7F0000:error:0A00045C:SSL routines:ssl3_read_bytes:tlsv13 alert certificate required:ssl/record/rec_layer_s3.c:1605:SSL alert number 116\ncommand terminated with exit code 1\n \n Breaking the output down: \n \n Server Certificate : This is the server certificate presented by the server. \n Acceptable client certificate CA names : These are the CA names that the server accepts for client certificates. \n SSL handshake has read 1108 bytes and written 387 bytes : Details on the handshake. Errors could be presented here if any occurred. \n Verification: OK : The server certificate is valid. \n Verify return code: 0 (ok) : The server certificate was verified successfully. \n error:0A00045C:SSL routines:ssl3_read_bytes:tlsv13 alert certificate required : The server requires a client certificate to be provided. Since a client certificate was not provided, the connection failed. \n \n If you provide the correct client certificate and key, the connection should be successful: \n .. code-block:: shell-session \n $ kubectl exec -i -n kube-system deployment/hubble-cli -- \\\nopenssl s_client -showcerts -servername ${SERVERNAME} -connect ${IP?}:4244 \\\n  -CAfile /var/lib/hubble-relay/tls/hubble-server-ca.crt \\\n  -cert /var/lib/hubble-relay/tls/client.crt \\\n  -key /var/lib/hubble-relay/tls/client.key\n\nCONNECTED(00000004)\ndepth=1 C = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\nverify return:1\ndepth=0 CN = *.default.hubble-grpc.cilium.io\nverify return:1\n---\nCertificate chain\n 0 s:CN = *.default.hubble-grpc.cilium.io\n   i:C = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\n   a:PKEY: id-ecPublicKey, 256 (bit); sigalg: ecdsa-with-SHA256\n   v:NotBefore: Aug 15 17:39:00 2024 GMT; NotAfter: Aug 15 17:39:00 2027 GMT\n-----BEGIN CERTIFICATE-----\nMIICNzCCAd2gAwIBAgIUAlgykDuc1J+mzseHS0pREX6Uv3cwCgYIKoZIzj0EAwIw\naDELMAkGA1UEBhMCVVMxFjAUBgNVBAgTDVNhbiBGcmFuY2lzY28xCzAJBgNVBAcT\nAkNBMQ8wDQYDVQQKEwZDaWxpdW0xDzANBgNVBAsTBkNpbGl1bTESMBAGA1UEAxMJ\nQ2lsaXVtIENBMB4XDTI0MDgxNTE3MzkwMFoXDTI3MDgxNTE3MzkwMFowKjEoMCYG\nA1UEAwwfKi5kZWZhdWx0Lmh1YmJsZS1ncnBjLmNpbGl1bS5pbzBZMBMGByqGSM49\nAgEGCCqGSM49AwEHA0IABGjtY50MM21TolEy5RUrBa6WqHsw7PjNB3MhYLCsuJmO\naQ1tIy6J2e7a9Cw2jmBlyj+dL8g0YLhRQX4n+leItSSjgaIwgZ8wDgYDVR0PAQH/\nBAQDAgWgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwHQYDVR0O\nBBYEFCDf5epVs8yyyZCdtBzc90HrQzpFMB8GA1UdIwQYMBaAFDKuJMmhNPJ71FvB\nAyHEMztI62NbMCoGA1UdEQQjMCGCHyouZGVmYXVsdC5odWJibGUtZ3JwYy5jaWxp\ndW0uaW8wCgYIKoZIzj0EAwIDSAAwRQIhAP0kyl0Eb7FBQw1uZE+LWnRyr5GDsB3+\n6rA/Rx042XZgAiBZML3lOW60tWMI1Pyn4cR4trFbzZpsUSwnQmOAb+paEw==\n-----END CERTIFICATE-----\n---\nServer certificate\nsubject=CN = *.default.hubble-grpc.cilium.io\nissuer=C = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\n---\nAcceptable client certificate CA names\nC = US, ST = San Francisco, L = CA, O = Cilium, OU = Cilium, CN = Cilium CA\nRequested Signature Algorithms: RSA-PSS+SHA256:ECDSA+SHA256:Ed25519:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:ECDSA+SHA384:ECDSA+SHA512:RSA+SHA1:ECDSA+SHA1\nShared Requested Signature Algorithms: RSA-PSS+SHA256:ECDSA+SHA256:Ed25519:RSA-PSS+SHA384:RSA-PSS+SHA512:RSA+SHA256:RSA+SHA384:RSA+SHA512:ECDSA+SHA384:ECDSA+SHA512\nPeer signing digest: SHA256\nPeer signature type: ECDSA\nServer Temp Key: X25519, 253 bits\n---\nSSL handshake has read 1106 bytes and written 1651 bytes\nVerification: OK\n---\nNew, TLSv1.3, Cipher is TLS_AES_128_GCM_SHA256\nServer public key is 256 bit\nThis TLS version forbids renegotiation.\nNo ALPN negotiated\nEarly data was not sent\nVerify return code: 0 (ok)\n---\n---\nPost-Handshake New Session Ticket arrived:\nSSL-Session:\n    Protocol  : TLSv1.3\n    Cipher    : TLS_AES_128_GCM_SHA256\n    Session-ID: 9ADFAFBDFFB876A9A8D4CC025470168D25485FF51929615199E9561F46FBF97B\n    Session-ID-ctx:\n    Resumption PSK: 58DD7621E7B353BD5C6FC3AAB5A907FF3D3251FAA184D28D2C69560E96806495\n    PSK identity: None\n    PSK identity hint: None\n    SRP username: None\n    TLS session ticket lifetime hint: 604800 (seconds)\n    TLS session ticket:\n    0000 - 55 93 99 70 30 37 6a 77-43 d7 0c 34 9f 24 51 40   U..p07jwC..4.$Q@\n    ...\n    ...\n    0690 - 11 6d 26 ec 99 3a 6e a9-56 c9 ad a0 49 e2 f5 6a   .m&..:n.V...I..j\n \n Press  ctrl-d  to signal the TLS session and connection should be terminated.\nAfter the session has ended you will see output similar to the following: \n .. code-block:: shell-session \n @DONE\n    06a0 - bf eb 8b 1d 8d 43 46 2a-07 02 e1 44 35 45 b1 a0   .....CF*...D5E..\n    06b0 - 7d bb 27 2f 1a 35 b2 da-0d 00 15 fd 6c 1f 00 3b   }.'/.5......l..;\n    06c0 - 9a 6e ff c9 5d ad 6b af-f7 20 39 99 5b ae 72 03   .n..].k.. 9.[.r.\n    06d0 - c8 2d 93 7a e5 a7 e0 d5-70 95 8f b5 0b 56 9c      .-.z....p....V.\n\n    Start Time: 1723744378\n    Timeout   : 7200 (sec)\n    Verify return code: 0 (ok)\n    Extended master secret: no\n    Max Early Data: 0\n---\nread R BLOCK\n \n The output of this OpenSSL command is similar to the previous output, but without the error message. \n There is also an additional section, starting with  Post-Handshake New Session Ticket arrived , the presence of which indicates that the client\ncertificate is valid and a TLS session was established. The summary of the TLS\nsession printed after the connection has ended can also be used as an indicator\nof the established TLS session. \n .. _hubble_configure_metrics_tls: \n Hubble Metrics TLS and Authentication \n Starting with Cilium 1.16, Hubble supports configuring TLS on the Hubble\nmetrics API in addition to the Hubble observer API. \n This can be done by specifying the following options to Helm at install or\nupgrade time, along with the TLS configuration options described in the\nprevious section. \n .. note:: \n This section assumes that you have already enabled :ref: Hubble metrics<hubble_metrics> . \n To enable TLS on the Hubble metrics API, add the following Helm flag to your\nlist of options: \n :: \n --set hubble.metrics.tls.enabled=true # Enable TLS on the Hubble metrics API\n \n If you also want to enable authentication using mTLS on the Hubble metrics API,\nfirst create a ConfigMap with a CA certificate to use for verifying client\ncertificates: \n :: \n kubectl -n kube-system create configmap hubble-metrics-ca --from-file=ca.crt\n \n Then, add the following flags to your Helm command to enable mTLS: \n :: \n --set hubble.metrics.tls.enabled=true                       # Enable TLS on the Hubble metrics API\n--set hubble.metrics.tls.server.mtls.enabled=true           # Enable mTLS authentication on the Hubble metrics API\n--set hubble.metrics.tls.server.mtls.name=hubble-metrics-ca # Use the CA certificate from the ConfigMap\n \n After the configuration is applied, clients will be required to authenticate\nusing a certificate signed by the configured CA certificate to access the\nHubble metrics API. \n .. note:: \n When using TLS with the Hubble metrics API you will need to update your\nPrometheus scrape configuration to use HTTPS by setting a  tls_config  and\nprovide the path to the CA certificate. When using mTLS you will also need to\nprovide a client certificate and key signed by the CA certificate for\nPrometheus to authenticate to the Hubble metrics API. \n .. _hubble_api_tls: \n Access the Hubble API with TLS Enabled \n The examples are adapted from :ref: hubble_cli . \n Before you can access the Hubble API with TLS enabled, you need to obtain the\nCA certificate from the secret that was created when enabling TLS. The\nfollowing examples demonstrate how to obtain the CA certificate and use it to\naccess the Hubble API. \n Run the following command to obtain the CA certificate from the  hubble-relay-server-certs  secret: \n .. code-block:: shell-session \n $ kubectl -n kube-system get secret hubble-relay-server-certs -o jsonpath='{.data.ca\\.crt}' | base64 -d > hubble-ca.crt\n \n After obtaining the CA certificate you can use the   --tls  to enable TLS and\n --tls-ca-cert-files  flag to specify the CA certificate. Additionally, when\nport-forwarding to Hubble Relay, you will need to specify the\n --tls-server-name  flag: \n .. code-block:: shell-session \n $ hubble observe --tls --tls-ca-cert-files ./hubble-ca.crt --tls-server-name hubble.hubble-relay.cilium.io --pod deathstar --protocol http\nMay  4 13:23:40.501: default/tiefighter:42690 -> default/deathstar-c74d84667-cx5kp:80 http-request FORWARDED (HTTP/1.1 POST http://deathstar.default.svc.cluster.local/v1/request-landing)\nMay  4 13:23:40.502: default/tiefighter:42690 <- default/deathstar-c74d84667-cx5kp:80 http-response FORWARDED (HTTP/1.1 200 0ms (POST http://deathstar.default.svc.cluster.local/v1/request-landing))\nMay  4 13:23:43.791: default/tiefighter:42742 -> default/deathstar-c74d84667-cx5kp:80 http-request DROPPED (HTTP/1.1 PUT http://deathstar.default.svc.cluster.local/v1/exhaust-port)\n \n To persist these options for the shell session, set the following environment variables: \n .. code-block:: shell-session \n $ export HUBBLE_TLS=true\n$ export HUBBLE_TLS_CA_CERT_FILES=./hubble-ca.crt\n$ export HUBBLE_TLS_SERVER_NAME=hubble.hubble-relay.cilium.io",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/observability/hubble/configuration/tls.rst",
  "extracted_at": "2025-09-03T01:13:29.325597Z"
}