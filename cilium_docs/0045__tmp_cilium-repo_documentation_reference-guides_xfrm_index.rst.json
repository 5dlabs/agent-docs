{
  "url": "file:///tmp/cilium-repo/Documentation/reference-guides/xfrm/index.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _xfrm_guide: \n \n XFRM Reference Guide \n \n .. note:: This documentation section is targeted at developers and users who\nwant to understand the Linux XFRM subsystem. While reading this\nreference guide may help broaden your understanding of Cilium, it is\nnot a requirement to use Cilium. Please refer to the\n:ref: getting_started  guide and :ref: ebpf_datapath  for a higher\nlevel introduction. \n Overview \n IPsec encryption in the Linux kernel relies on  XFRM _. XFRM is an IP framework intended for packet\ntransformations, from encryption to compression. It is configured via a set of  policy  and  state \nobjects, which for IPsec, correspond to Security Policies and Security Associations. \n .. _XFRM: https://man7.org/linux/man-pages/man8/ip-xfrm.8.html \n XFRM Policies and States \n At a high-level, XFRM policies define what traffic to accept and reject, whereas states define how to\nperform the encryption and decryption. Policies can match on the direction ( out ,  in , or\n fwd ), the source and destination IP addresses with CIDRs, and the packet mark. As an example,\nthe following policy matches egressing packets with any source IP address, 10.56.1.X destination IP\naddresses, and  0xcb93eXX  packet marks. Policies default to allowing traffic as done here. \n .. code-block:: text \n src 0.0.0.0/0 dst 10.56.1.0/24 \n    dir out priority 0 \n    mark 0xcb93e00/0xffffff00 \n    [...]\n \n States are relatively similar, except that they are agnostic to the direction and can only match on\nexact IP addresses (or 0.0.0.0 to match all). The following state will apply to packets with IP\naddresses 10.56.0.17 -> 10.56.1.238, the same packet marks as above. In the case of tunnel-mode\nIPsec, these IP addresses correspond to the outer IP addresses. For ingressing, encrypted packets,\nthe SPI will also be used (discussed below). \n .. code-block:: text \n src 10.56.0.17 dst 10.56.1.238\n    proto esp spi 0x00000003 reqid 1 mode tunnel\n    replay-window 0 \n    mark 0xcb93e00/0xffffff00 output-mark 0xe00/0xffffff00\n    aead rfc4106(gcm(aes)) 0x6254fced5f7a5ea9401b9015ecf10d65eac51a69 128\n    anti-replay context: seq 0x0, oseq 0x36, bitmap 0x00000000\n    sel src 0.0.0.0/0 dst 0.0.0.0/0\n \n You may notice that nothing specifies if this state should perform encryption or decryption. That's\nbecause it can actually do both. As said above, states are agnostic to the direction of traffic so\nthe same state may theoretically be used for both encryption and decryption. What to do will be\ndetermined based on where in the stack the state is matched (ex., decryption on ingress). \n Policy Templates \n XFRM policies also typically define a template, as below: \n .. code-block:: text \n src 0.0.0.0/0 dst 10.56.1.0/24 \n    dir out priority 0 \n    mark 0xcb93e00/0xffffff00 \n    tmpl src 10.56.0.17 dst 10.56.1.238\n        proto esp spi 0x00000003 reqid 1 mode tunnel\n \n How this template is used depends on the direction. For egressing traffic, the template defines the\nencoding to perform. For example, the above template will encapsulate packets with an IP header and\nan ESP header. The IP header will have IP addresses 10.56.0.17 and 10.56.1.238. The ESP header will\nhave SPI 3. \n For ingressing and forwarded traffic however, the template acts as an additional filter. The\nfollowing XFRM policy for example will only allow packets if they are ESP packets with outer IP\naddresses 10.56.1.238 and 10.56.0.17, in addition to having a packet mark matching  0xd00/0xf00 . \n .. code-block:: text \n src 0.0.0.0/0 dst 10.56.0.0/24 \n    dir in priority 0 \n    mark 0xd00/0xf00 \n    tmpl src 10.56.1.238 dst 10.56.0.17\n        proto esp reqid 1 mode tunnel\n \n Note that when using tunnel mode as is the case here, we should always see XFRM states matching the\ntemplate of XFRM OUT policies. That is because, on egress, the states are matched after the\ntemplate is applied. The IP addresses, the SPI, the protocol, the mode, and the reqid should all\nmatch between the XFRM state and the template in that case. \n XFRM Packet Flows \n The following diagram represents the usual Netfilter packet flow with the XFRM elements in purple: \n .. image:: /images/netfilter-with-xfrm.png\n:align: center \n Egress Packet Flow \n On egress, packets will first hit one of the \"XFRM OUT policy\" blocks. At this point, a lookup is\nperformed against the XFRM OUT policies. If a match is found, the packet goes to the \"XFRM encode\"\nblock, any template is applied (ex., encapsulation), and the packet is then matched against XFRM\nstates. If a state is found, its information is used to encrypt the packet. \n The encrypted packet will then navigate again through the OUTPUT and POSTROUTING chains. \n Ingress Packet Flow \n On ingress, encrypted packets (ex., ESP packets) will hit the \"XFRM decode\" after they navigate\nthrough the INPUT chain. \n In tunnel mode, encrypted packets will typically have one of the server's IP addresses as the outer\ndestination address, so they should automatically be routed through the INPUT chain. If not, it may\nbe necessary to add IP routes to redirect packets to the INPUT chain. As an example, Cilium\nidentifies IPsec traffic on tc-bpf ingress and marks them with a special value which is then used\nto reroute those packets to the INPUT chain. \n At the \"XFRM decode\", if packets match an XFRM state, they will be decoded (i.e., decapsulated and\ndecrypted) using the state's information. The match is based on the source & destination addresses,\nthe mark, the SPI, and the protocol. In case of any decode error (ex., wrong key), the packet is\ndropped and an error counter is increased. \n As illustrated on the diagram, an XFRM policy matching the packet isn't required for the decoding\nto happen (it goes directly to \"XFRM decode\"), but is required for the packet to proceed to a\nlocal process or through the FORWARD chain. An XFRM policy with an optional template (i.e.,\n level use ) will allow all decoded packets through. Traffic that was never encrypted, and\ntherefore does not come from \"XFRM decode\", is allowed by default. \n After a packet is decoded, it is recirculated in the stack, as if coming from the interface it was\ninitially received on. More specifically, packets are recirculated before the tc layer, such that\nthey are visible on the tc-bpf hook a second time (once before decryption, once after). The packet\nmark is preserved when recirculated, so it's possible to identify and trace packets that have been\ndecrypted and recirculated. \n Output Description of  ip xfrm \n Outputs are from iproute2-6.1.0. More fields will likely appear in newer versions. For example,\nXFRM states have a  dir  field in newer kernels (v6.10+), which will likely appear in the\n ip xfrm state  output at some point. \n In the  ip xfrm  output, policies are ordered by date of creation, with newer policies at the\ntop. This is important because, in case two policies match a packet and have the same priority,\nthe newest one is used. \n .. code-block:: bash \n $ ip xfrm policy\n# - `src 0.0.0.0/0` is the CIDR to match against the source IP address\n# - `dst 0.0.0.0/0` is the CIDR to match against the destination IP address\nsrc 0.0.0.0/0 dst 0.0.0.0/0 uid 0\n    # - `dir fwd` states the direction. It defines where in the Linux stack this policy will be\n    #   used, between ingress, egress, and forwarding.\n    # - `action allow` is the action to take on matching packets. Packets can only be allowed\n    #   through (by default) or dropped.\n    # - `index 18` is used to differentiate between different policies which might have the\n    #   same or overlapping selectors. If not given or if it already exists, it is\n    #   automatically (re-)generated (cf., `xfrm_gen_index`). The three LSBs encode the\n    #   direction (ex., 1 for `XFRM_POLICY_OUT`). The MSBs are simply incremented by one (that\n    #   is, the index is incremented by 8) until a free index is found.\n    # - `priority 2975` states the priority for this policy in case multiple could match the\n    #   packet. 0 is the highest priority.\n    # - `share any` is always set to `any` and unused today\n    #    (https://elixir.bootlin.com/linux/v6.9.5/source/net/xfrm/xfrm_user.c#L1914).\n    # - `flag (0x00000000)` set of flags for XFRM policies. Only `XFRM_POLICY_ICMP` (0x2) is\n    #   supported at the moment; `XFRM_POLICY_LOCALOK` (0x1) is not implemented (anymore?).\n    #   When `XFRM_POLICY_ICMP` is given, the policy will also apply to ICMP packet with a\n    #   payload packet that matches the policy's selector.\n    dir fwd action allow index 18 priority 2975 share any flag  (0x00000000)\n    lifetime config:\n      # Various limits and expiration times for the policy, based on the number of bytes\n      # received, the number of packets received, the time since the policy was added, or the\n      # time since the policy was last matched by a packet. When a soft limit or expiration\n      # time is reached, a notification is sent to userspace via netlink\n      # (`struct xfrm_user_expire`). When a hard limit or expiration time is reached, the\n      # policy is deleted.\n      limit: soft (INF)(bytes), hard (INF)(bytes)\n      limit: soft (INF)(packets), hard (INF)(packets)\n      expire add: soft 0(sec), hard 0(sec)\n      expire use: soft 0(sec), hard 0(sec)\n    lifetime current:\n      # Counters for bytes and packets matched by this policy, to be used if limits have\n      # been set.\n      0(bytes), 0(packets)\n      # Timestamps for when the policy was added and when it was last matched by a packet, to\n      # be used if expiration times have been set.\n      add 2024-06-17 11:24:49 use 2024-06-17 11:25:01\n    # - `src 0.0.0.0` See Policy Templates for how this field is used.\n    # - `dst 10.92.0.164` See Policy Templates for how this field is used.\n    tmpl src 0.0.0.0 dst 10.92.0.164\n        # - `proto esp` See Policy Templates for how this field is used.\n        # - `spi 0x00000000(0)` See Policy Templates for how this field is used.\n        # - `reqid 1(0x00000001)` See Policy Templates for how this field is used.\n        # - `mode tunnel` See Policy Templates for how this field is used.\n        proto esp spi 0x00000000(0) reqid 1(0x00000001) mode tunnel\n        # - `level use` is the nonsensical way to indicate this template is optional, the\n        #   alternative being `level required`. If no XFRM state matching the template is\n        #   found, the template will be skipped if optional. Otherwise, the packet will be\n        #   dropped with `XfrmInTmplMismatch`.\n        # - `share any` is not implemented and will always be `any`.\n        level use share any\n        # - `enc-mask ffffffff` Bit mask defining the list of allowed encryption algorithms.\n        #   See Encryption algorithms in include/uapi/linux/pfkeyv2.h for the list of possible\n        #   values.\n        # - `auth-mask ffffffff` Bit mask defining the list of allowed authentication\n        #   algorithms. See Authentication algorithms in include/uapi/linux/pfkeyv2.h for the\n        #   list of possible values.\n        # - `comp-mask ffffffff` Non-implemented bit mask (was probably defined for compression\n        #   algorithms).\n        enc-mask ffffffff auth-mask ffffffff comp-mask ffffffff\n \n .. code-block:: bash \n $ ip xfrm state\n# - `src 10.92.1.189` is the IP address to match against the packets' source IP addresses.\n# - `dst 10.92.0.164` is the IP address to match against the packets' destination IP addresses.\nsrc 10.92.1.189 dst 10.92.0.164\n    # - `proto esp` states the IPsec protocol to use.\n    # - `spi 0x00000000(0)` is the Security Parameter Index. A tag to distinguish between\n    #   multiple IPsec streams that may be using different algorithms and/or keys. Particularly\n    #   useful during key rotations.\n    # - `reqid 1(0x00000001)` is an ID only used to ensure the XFRM policy template and the\n    #   state match. It doesn't seem to be used for anything else in the kernel.\n    # - `mode tunnel` states whether the packet is encapsulated (`tunnel`) or if the ESP header\n    #   is simply added to the existing packet (`transport`).\n    proto esp spi 0x00000003(3) reqid 1(0x00000001) mode tunnel\n    # - `replay-window 0` size of the replay window used for the anti-replay checks (i.e.,\n    #   toleration setting).\n    # - `seq 0x000000000`\n    # - `flag (0x000000000)` holds various flags including `XFRM_STATE_ESN` (0x80) for ESN\n    #   mode.\n    replay-window 0 seq 0x00000000 flag  (0x00000000)\n    # - `mark 0x4db50d00/0xffff0f00` are the value and mask used to match against the packets'\n    #   marks.\n    # - `output-mark 0xd00/0xffffff00` are the value and mask to apply to the packets' marks\n    #   after they have been encrypted or decrypted.\n    mark 0x4db50d00/0xffff0f00 output-mark 0xd00/0xffffff00\n    # - `aead rfc4106(gcm(aes))` are the type and name of algorithm in use.\n    # - `0x856f15d0ccabe682286b4286bccf5d595b88b168 (160 bits)` is the key and its size. It's\n    #   of course sensitive information that should be treated as such.\n    # - `128` is the ICV length. Which lengths are supported depends on the algorithm in use.\n    aead rfc4106(gcm(aes)) 0x856f15d0ccabe682286b4286bccf5d595b88b168 (160 bits) 128\n    # - `seq 0x0` holds the current receive-side sequence number, for the anti-replay check.\n    # - `oseq 0x0` is the last emitted sequence number. If this number overflows (on 32-bits),\n    #   packets are dropped and the error counter `XfrmOutStateSeqError` is increased. In ESN\n    #   mode, this sequence number is coded on 64-bits.\n    # - `bitmap 0x00000000` tracks the sequence numbers that have already been seen in the replay\n    #   window.\n    anti-replay context: seq 0x0, oseq 0x0, bitmap 0x00000000\n    # - `sel src 0.0.0.0/0 dst 0.0.0.0/0` is an additional filter applying to the decrypted\n    #   packets, to ensure the inner packets are coming and going where you expect.\n    # - `uid 0` this field appears to be unused (`user` in `struct xfrm_selector`).\n    sel src 0.0.0.0/0 dst 0.0.0.0/0 uid 0\n    lifetime config:\n      # Various limits and expiration times for the state, based on the number of bytes\n      # received, the number of packets received, the time since the state was added, or the\n      # time since the state was last used for a packet. When a soft limit or expiration time\n      # is reached, a notification is sent to userspace via netlink\n      # (`struct xfrm_user_expire`). When a hard limit or expiration time is reached, the state\n      # is deleted.\n      limit: soft (INF)(bytes), hard (INF)(bytes)\n      limit: soft (INF)(packets), hard (INF)(packets)\n      expire add: soft 0(sec), hard 0(sec)\n      expire use: soft 0(sec), hard 0(sec)\n    lifetime current:\n      # Counters for bytes and packets matched by this policy, to be used if limits have been\n      # set.\n      20124(bytes), 83(packets)\n      # Timestamps for when the policy was added and when it was last matched by a packet, to\n      # be used if expiration times have been set.\n      add 2024-06-17 11:15:48 use 2024-06-17 11:16:02\n    stats:\n      # - `replay-window 0` is incremented whenever a packet is received with a sequence number\n      #   outside the window.\n      # - `replay 0` is incremented whenever a packet is received with a sequence number in the\n      #   replay window that was already observed.\n      # - `failed 0` (full name `integrity_failed` on kernel's side) is incremented when the\n      #   checksums for authentication or encryption headers are incorrect.\n      #   `XfrmInStateProtoError` is always incremented when this counter is incremented.\n      replay-window 0 replay 0 failed 0\n \n XFRM Errors \n All XFRM errors correspond to packet drops. Some of them may also be associated with per-state\ncounters increasing.  CONFIG_XFRM_STATISTICS  is required to see these error counters in\n /proc/net/xfrm_stat . \n \n XfrmInError:  If the kernel fails to allocate memory during encryption. \n XfrmInBufferError: \n \n If a packet is going through too many XFRM states. The maximum is set to\n XFRM_MAX_DEPTH  (6). \n If too many XFRM policy templates apply to a packet. The maximum is also set to\n XFRM_MAX_DEPTH  (6). \n \n \n XfrmInHdrError: \n \n If the SPI portion of the packet is malformed. \n If the outer IP header is malformed. \n \n \n XfrmInNoStates:  If no XFRM IN state was found that matches the AH or ESP packet ingressing on\nthe INPUT chain. \n XfrmInStateProtoError: \n \n If the AH or ESP checksum is incorrect. \n If the packet's IPsec protocol (ex., AH, ESP) doesn't match the protocol specified by the\nXFRM state. \n Also includes all protocol specific errors (ex., from  esp_input ) listed below: \n If decryption/encryption fails (ex., because the key specified in the XFRM IN state doesn't\nmatch the key with which the packet was encrypted). \n If the protocol headers (ex., ESP) or trailers are malformed. \n If there is not enough memory to perform encryption/decryption. \n \n \n XfrmInStateModeError:  If the packet is in IPsec tunnel mode, but the matched XFRM state is in\ntransport mode. \n XfrmInStateSeqError:  If the anti-replay check rejected the packet. If the check failed\nbecause the sequence number was outside the window, the  replay-window  counter of the\nassociated XFRM state will be incremented. If it failed because the sequence number was seen\nalready, the  replay  counter is incremented instead. \n XfrmInStateExpired:  There can be a delay between when a state expires (hard limits) and when\nit's actually deleted. During that time, matching packets are dropped with  XfrmInStateExpired \non ingress. \n XfrmInStateMismatch: \n \n If the encapsulation protocol of the XFRM state (ex.,  espinudp  in  encap  field of\n ip xfrm state ) doesn't match the encapsulation protocol of the packet. \n If the decrypted packet doesn't match the selector ( sel  field) of the used XFRM state. \n \n \n XfrmInStateInvalid:  If received packet matched an XFRM state that is being deleted or that\nexpired. \n XfrmInTmplMismatch: \n \n If a packet matches an XFRM policy with a non-optional template, but the template doesn't\nmatch any of the XFRM states used to decrypt the packet (yes, a packet can be decoded\nmultiple times). \n If an XFRM state with  mode tunnel  was used on the packet and it doesn't match any XFRM\npolicy template. \n \n \n XfrmInNoPols:  If the ingressing packet doesn't match any XFRM policy and the default action\nis set to  block . See  ip xfrm policy {get,set}default  to view and set the default XFRM\npolicy actions. \n XfrmInPolBlock:  If the packet matches an XFRM IN policy with  action block . \n XfrmOutError: \n \n If the kernel fails to allocate memory during encryption. \n In some cases, if the packet to encrypt is malformed. \n \n \n XfrmOutBundleCheckError:  Unused. \n XfrmOutNoStates:  If the packet matched an XFRM OUT policy, but no XFRM state was found that\nmatches the policy's template. \n XfrmOutStateProtoError:  If a protocol-specific (ex., ESP) encryption error happens. \n XfrmOutStateModeError:  If the packet exceeds the MTU once encapsulated and it shouldn't be\nfragmented. \n XfrmOutStateSeqError:  The output sequence number ( oseq ) of an XFRM state reached its\nmaximum value,  UINT32_MAX  when not using ESN mode. \n XfrmOutStateExpired:  There can be a delay between when a state expires (hard limits) and when\nit's actually deleted. During that time, matching packets are dropped with\n XfrmOutStateExpired  on egress. \n XfrmOutPolBlock:  If the packet matches an XFRM OUT policy with  action block . \n XfrmOutPolDead:  Unused.  XfrmOutStateInvalid  is reported instead for XFRM states that in\nthe process of being deleted. \n XfrmOutPolError: \n \n If too many XFRM policy templates apply to a packet. The maximum is also set to\n XFRM_MAX_DEPTH  (6). \n If no XFRM state is found for a non-optional template of the matching XFRM policy. \n \n \n XfrmFwdHdrError:  If the packet is malformed when going through the FWD policy check. \n XfrmOutStateInvalid:  If egressing packet matched an XFRM state that is being deleted or that\nexpired. \n XfrmOutStateDirError:  If the direction of the XFRM state found during the lookup is defined\nand isn't  XFRM_SA_DIR_OUT . Only on kernels v6.10 and newer. \n XfrmInStateDirError:  If the direction of the XFRM state found during the lookup is defined\nand isn't  XFRM_SA_DIR_IN . Only on kernels v6.10 and newer. \n \n Performance Considerations \n This section describes the data structures used to hold the XFRM policies and states. This is\nuseful to understand when dealing with a large number of states and policies as the information\nthey hold can help improve indexing and speed up the lookups. When dealing with thousands of\npolicies and states, the lookup cost can become non-negligible even when compared to the\nencryption/decryption cost. \n Data Structure for XFRM Policies \n XFRM policies are stored in a rather complex data structure made of multiple red-black trees and\nhash tables. At the root, everything is contained in a  resizable hashtable _ indexed by network\nnamespace, IP family, direction, and interface (in case XFRM interfaces are used). Each entry in\nthis resizable hash table contains several black-red trees, which themselves hold the XFRM\npolicies. Those entries are represented by the structure  xfrm_pol_inexact_bin . \n .. _resizable hashtable: https://lwn.net/Articles/751974 \n .. image:: /images/xfrm_policies_data_structure.png\n:align: center \n Once  xfrm_pol_inexact_bin  has been retrieved (based on current IP family, namespace, and\ndirection), each of its red-black trees is looked up using the source and destination IP addresses.\nThe  root_s  tree contains policies sorted by source IP addresses; the  root_d  tree contains\npolicies sorted by destination IP addresses. In addition, leaf nodes of the  root_d  tree also\ncontain another tree with policies sorted by source IP addresses. That allows the lookups into\n root_s  and  root_d  to return three lists of candidate  (src_ip; dst_ip)  policies from the\nleaf nodes: \n \n A list of  (src_ip; any)  candidates from  root_s . \n A list of  (any; dst_ip)  candidates from  root_d . \n A list of  (src_ip; dst_ip)  candidates from the trees pointed by the leaf nodes of\n root_d . \n \n These three lists of candidate XFRM policies are completed by a list of  (any; any)  candidates\ndirectly stored in the  xfrm_pol_inexact_bin  entry. \n Note that an XFRM policy will only be present in one of the four candidate lists, according to its\nsource and destination CIDRs. \n These four lists of candidate XFRM policies are then evaluated. The kernel iterates through each\nlist, looking for the highest-priority (lowest  priority  number) candidate that matches the\npacket. If two policies match and have the same priority, the newest one is preferred. It's also\nonly during this linear evaluation of candidates that the packet mark is compared with the policy\nmarks. \n Data Structure for XFRM States \n XFRM states are organized in four hash tables, with different XFRM fields used for indexing and\ndifferent purposes: \n \n net->xfrm.state_bydst  is indexed by source and destination IP addresses as well as reqid. \n net->xfrm.state_bysrc  is indexed only by source and destination IP addresses. \n net->xfrm.state_byspi  is indexed by destination IP address, SPI, and protocol. \n net->xfrm.state_byseq  is indexed by sequence number only. \n \n net->xfrm.state_byspi  is used when looking up an XFRM state for ingressing packets. This makes\nsense to speed up the search as each XFRM state is encouraged to have its own SPI (cf.,  RFC4301 _,\nsection 4.1) and the encrypted packets carry the SPI. \n .. _RFC4301: https://datatracker.ietf.org/doc/html/rfc4301 \n When searching for the XFRM state that corresponds to an XFRM policy template (before encryption),\n net->xfrm.state_bydst  is used. That makes sense because the indexing information is what the\nXFRM policy template provides. That hash table is typically also the one being used when iterating\nthrough all XFRM states (ex., when flushing them), but any hash table would do the job for that. \n net->xfrm.state_bysrc  and  net->xfrm.state_byseq  are used for various other management\ntasks, such as looking up an XFRM state to update, answering a netlink query from the user, or\nchecking for existing states before adding a new one.",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/reference-guides/xfrm/index.rst",
  "extracted_at": "2025-09-03T00:53:44.718710Z"
}