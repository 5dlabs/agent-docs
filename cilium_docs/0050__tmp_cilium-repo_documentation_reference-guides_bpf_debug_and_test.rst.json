{
  "url": "file:///tmp/cilium-repo/Documentation/reference-guides/bpf/debug_and_test.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _bpf_debug: \n Debugging and Testing \n bpftool \n bpftool is the main introspection and debugging tool around BPF and developed\nand shipped along with the Linux kernel tree under  tools/bpf/bpftool/ . \n The tool can dump all BPF programs and maps that are currently loaded in\nthe system, or list and correlate all BPF maps used by a specific program.\nFurthermore, it allows to dump the entire map's key / value pairs, or\nlookup, update, delete individual ones as well as retrieve a key's neighbor\nkey in the map. Such operations can be performed based on BPF program or\nmap IDs or by specifying the location of a BPF file system pinned program\nor map. The tool additionally also offers an option to pin maps or programs\ninto the BPF file system. \n For a quick overview of all BPF programs currently loaded on the host\ninvoke the following command: \n .. code-block:: shell-session \n  # bpftool prog\n 398: sched_cls  tag 56207908be8ad877\n    loaded_at Apr 09/16:24  uid 0\n    xlated 8800B  jited 6184B  memlock 12288B  map_ids 18,5,17,14\n 399: sched_cls  tag abc95fb4835a6ec9\n    loaded_at Apr 09/16:24  uid 0\n    xlated 344B  jited 223B  memlock 4096B  map_ids 18\n 400: sched_cls  tag afd2e542b30ff3ec\n    loaded_at Apr 09/16:24  uid 0\n    xlated 1720B  jited 1001B  memlock 4096B  map_ids 17\n 401: sched_cls  tag 2dbbd74ee5d51cc8\n    loaded_at Apr 09/16:24  uid 0\n    xlated 3728B  jited 2099B  memlock 4096B  map_ids 17\n [...]\n \n Similarly, to get an overview of all active maps: \n .. code-block:: shell-session \n # bpftool map\n5: hash  flags 0x0\n    key 20B  value 112B  max_entries 65535  memlock 13111296B\n6: hash  flags 0x0\n    key 20B  value 20B  max_entries 65536  memlock 7344128B\n7: hash  flags 0x0\n    key 10B  value 16B  max_entries 8192  memlock 790528B\n8: hash  flags 0x0\n    key 22B  value 28B  max_entries 8192  memlock 987136B\n9: hash  flags 0x0\n    key 20B  value 8B  max_entries 512000  memlock 49352704B\n[...]\n \n Note that for each command, bpftool also supports json based output by\nappending  --json  at the end of the command line. An additional\n --pretty  improves the output to be more human readable. \n .. code-block:: shell-session \n  # bpftool prog --json --pretty\n \n For dumping the post-verifier BPF instruction image of a specific BPF\nprogram, one starting point could be to inspect a specific program, e.g.\nattached to the tc ingress hook: \n .. code-block:: shell-session \n  # tc filter show dev cilium_host egress\n filter protocol all pref 1 bpf chain 0\n filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \\\n                     direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited\n \n The program from the object file  bpf_host.o , section  from-netdev  has\na BPF program ID of  406  as denoted in  id 406 . Based on this information\nbpftool can provide some high-level metadata specific to the program: \n .. code-block:: shell-session \n  # bpftool prog show id 406\n 406: sched_cls  tag e0362f5bd9163a0a\n      loaded_at Apr 09/16:24  uid 0\n      xlated 11144B  jited 7721B  memlock 12288B  map_ids 18,20,8,5,6,14\n \n The program of ID 406 is of type  sched_cls  ( BPF_PROG_TYPE_SCHED_CLS ),\nhas a  tag  of  e0362f5bd9163a0a  (SHA sum over the instruction sequence),\nit was loaded by root  uid 0  on  Apr 09/16:24 . The BPF instruction\nsequence is  11,144 bytes  long and the JITed image  7,721 bytes . The\nprogram itself (excluding maps) consumes  12,288 bytes  that are accounted /\ncharged against user  uid 0 . And the BPF program uses the BPF maps with\nIDs  18 ,  20 ,  8 ,  5 ,  6  and  14 . The latter IDs can further\nbe used to get information or dump the map themselves. \n Additionally, bpftool can issue a dump request of the BPF instructions the\nprogram runs: \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 406\n  0: (b7) r7 = 0\n  1: (63) *(u32 *)(r1 +60) = r7\n  2: (63) *(u32 *)(r1 +56) = r7\n  3: (63) *(u32 *)(r1 +52) = r7\n [...]\n 47: (bf) r4 = r10\n 48: (07) r4 += -40\n 49: (79) r6 = *(u64 *)(r10 -104)\n 50: (bf) r1 = r6\n 51: (18) r2 = map[id:18]                    <-- BPF map id 18\n 53: (b7) r5 = 32\n 54: (85) call bpf_skb_event_output#5656112  <-- BPF helper call\n 55: (69) r1 = *(u16 *)(r6 +192)\n [...]\n \n bpftool correlates BPF map IDs into the instruction stream as shown above\nas well as calls to BPF helpers or other BPF programs. \n The instruction dump reuses the same 'pretty-printer' as the kernel's BPF\nverifier. Since the program was JITed and therefore the actual JIT image\nthat was generated out of above  xlated  instructions is executed, it\ncan be dumped as well through bpftool: \n .. code-block:: shell-session \n  # bpftool prog dump jited id 406\n  0:        push   %rbp\n  1:        mov    %rsp,%rbp\n  4:        sub    $0x228,%rsp\n  b:        sub    $0x28,%rbp\n  f:        mov    %rbx,0x0(%rbp)\n 13:        mov    %r13,0x8(%rbp)\n 17:        mov    %r14,0x10(%rbp)\n 1b:        mov    %r15,0x18(%rbp)\n 1f:        xor    %eax,%eax\n 21:        mov    %rax,0x20(%rbp)\n 25:        mov    0x80(%rdi),%r9d\n [...]\n \n Mainly for BPF JIT developers, the option also exists to interleave the\ndisassembly with the actual native opcodes: \n .. code-block:: shell-session \n  # bpftool prog dump jited id 406 opcodes\n  0:        push   %rbp\n            55\n  1:        mov    %rsp,%rbp\n            48 89 e5\n  4:        sub    $0x228,%rsp\n            48 81 ec 28 02 00 00\n  b:        sub    $0x28,%rbp\n            48 83 ed 28\n  f:        mov    %rbx,0x0(%rbp)\n            48 89 5d 00\n 13:        mov    %r13,0x8(%rbp)\n            4c 89 6d 08\n 17:        mov    %r14,0x10(%rbp)\n            4c 89 75 10\n 1b:        mov    %r15,0x18(%rbp)\n            4c 89 7d 18\n [...]\n \n The same interleaving can be done for the normal BPF instructions which\ncan sometimes be useful for debugging in the kernel: \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 406 opcodes\n  0: (b7) r7 = 0\n     b7 07 00 00 00 00 00 00\n  1: (63) *(u32 *)(r1 +60) = r7\n     63 71 3c 00 00 00 00 00\n  2: (63) *(u32 *)(r1 +56) = r7\n     63 71 38 00 00 00 00 00\n  3: (63) *(u32 *)(r1 +52) = r7\n     63 71 34 00 00 00 00 00\n  4: (63) *(u32 *)(r1 +48) = r7\n     63 71 30 00 00 00 00 00\n  5: (63) *(u32 *)(r1 +64) = r7\n     63 71 40 00 00 00 00 00\n  [...]\n \n The basic blocks of a program can also be visualized with the help of\n graphviz . For this purpose, bpftool has a  visual  dump mode that\ngenerates a dot file instead of the plain BPF  xlated  instruction\ndump that can later be converted to a png file: \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 406 visual &> output.dot\n $ dot -Tpng output.dot -o output.png\n \n Another option would be to pass the dot file to dotty as a viewer, that\nis  dotty output.dot , where the result for the  bpf_host.o  program\nlooks as follows (small extract): \n .. image:: /images/bpf_dot.png\n:align: center \n Note that the  xlated  instruction dump provides the post-verifier BPF\ninstruction image which means that it dumps the instructions as if they\nwere to be run through the BPF interpreter. In the kernel, the verifier\nperforms various rewrites of the original instructions provided by the\nBPF loader. \n One example of rewrites is the inlining of helper functions in order to\nimprove runtime performance, here in the case of a map lookup for hash\ntables: \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 3\n  0: (b7) r1 = 2\n  1: (63) *(u32 *)(r10 -4) = r1\n  2: (bf) r2 = r10\n  3: (07) r2 += -4\n  4: (18) r1 = map[id:2]                      <-- BPF map id 2\n  6: (85) call __htab_map_lookup_elem#77408   <-+ BPF helper inlined rewrite\n  7: (15) if r0 == 0x0 goto pc+2                |\n  8: (07) r0 += 56                              |\n  9: (79) r0 = *(u64 *)(r0 +0)                <-+\n 10: (15) if r0 == 0x0 goto pc+24\n 11: (bf) r2 = r10\n 12: (07) r2 += -4\n [...]\n \n bpftool correlates calls to helper functions or BPF to BPF calls through\nkallsyms. Therefore, make sure that JITed BPF programs are exposed to\nkallsyms ( bpf_jit_kallsyms ) and that kallsyms addresses are not\nobfuscated (calls are otherwise shown as  call bpf_unspec#0 ): \n .. code-block:: shell-session \n  # echo 0 > /proc/sys/kernel/kptr_restrict\n # echo 1 > /proc/sys/net/core/bpf_jit_kallsyms\n \n BPF to BPF calls are correlated as well for both, interpreter as well\nas JIT case. In the latter, the tag of the subprogram is shown as\ncall target. In each case, the  pc+2  is the pc-relative offset of\nthe call target, which denotes the subprogram. \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 1\n 0: (85) call pc+2#__bpf_prog_run_args32\n 1: (b7) r0 = 1\n 2: (95) exit\n 3: (b7) r0 = 2\n 4: (95) exit\n \n JITed variant of the dump: \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 1\n 0: (85) call pc+2#bpf_prog_3b185187f1855c4c_F\n 1: (b7) r0 = 1\n 2: (95) exit\n 3: (b7) r0 = 2\n 4: (95) exit\n \n In the case of tail calls, the kernel maps them into a single instruction\ninternally, bpftool will still correlate them as a helper call for ease\nof debugging: \n .. code-block:: shell-session \n  # bpftool prog dump xlated id 2\n [...]\n 10: (b7) r2 = 8\n 11: (85) call bpf_trace_printk#-41312\n 12: (bf) r1 = r6\n 13: (18) r2 = map[id:1]\n 15: (b7) r3 = 0\n 16: (85) call bpf_tail_call#12\n 17: (b7) r1 = 42\n 18: (6b) *(u16 *)(r6 +46) = r1\n 19: (b7) r0 = 0\n 20: (95) exit\n\n # bpftool map show id 1\n 1: prog_array  flags 0x0\n       key 4B  value 4B  max_entries 1  memlock 4096B\n \n Dumping an entire map is possible through the  map dump  subcommand\nwhich iterates through all present map elements and dumps the key /\nvalue pairs. \n If no BTF (BPF Type Format) data is available for a given map, then\nthe key / value pairs are dumped as hex: \n .. code-block:: shell-session \n  # bpftool map dump id 5\n key:\n f0 0d 00 00 00 00 00 00  0a 66 00 00 00 00 8a d6\n 02 00 00 00\n value:\n 00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n key:\n 0a 66 1c ee 00 00 00 00  00 00 00 00 00 00 00 00\n 01 00 00 00\n value:\n 00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00\n 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n [...]\n Found 6 elements\n \n However, with BTF, the map also holds debugging information about\nthe key and value structures. For example, BTF in combination with\nBPF maps and the BPF_ANNOTATE_KV_PAIR() macro from iproute2 will\nresult in the following dump ( test_xdp_noinline.o  from kernel\nselftests): \n .. code-block:: shell-session \n  # cat tools/testing/selftests/bpf/test_xdp_noinline.c\n   [...]\n    struct ctl_value {\n          union {\n                  __u64 value;\n                  __u32 ifindex;\n                  __u8 mac[6];\n          };\n    };\n\n    struct bpf_map_def __attribute__ ((section(\"maps\"), used)) ctl_array = {\n           .type\t\t= BPF_MAP_TYPE_ARRAY,\n           .key_size\t= sizeof(__u32),\n           .value_size\t= sizeof(struct ctl_value),\n           .max_entries\t= 16,\n           .map_flags\t= 0,\n    };\n    BPF_ANNOTATE_KV_PAIR(ctl_array, __u32, struct ctl_value);\n\n    [...]\n \n The BPF_ANNOTATE_KV_PAIR() macro forces a map-specific ELF section\ncontaining an empty key and value, this enables the iproute2 BPF loader\nto correlate BTF data with that section and thus allows to choose the\ncorresponding types out of the BTF for loading the map. \n Compiling through LLVM and generating BTF through debugging information\nby  pahole : \n .. code-block:: shell-session \n  # clang [...] -O2 --target=bpf -g -emit-llvm -c test_xdp_noinline.c -o - |\n   llc -march=bpf -mcpu=probe -mattr=dwarfris -filetype=obj -o test_xdp_noinline.o\n # pahole -J test_xdp_noinline.o\n \n Now loading into kernel and dumping the map via bpftool: \n .. code-block:: shell-session \n  # ip -force link set dev lo xdp obj test_xdp_noinline.o sec xdp-test\n # ip a\n 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 xdpgeneric/id:227 qdisc noqueue state UNKNOWN group default qlen 1000\n     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n     inet 127.0.0.1/8 scope host lo\n        valid_lft forever preferred_lft forever\n     inet6 ::1/128 scope host\n        valid_lft forever preferred_lft forever\n [...]\n # bpftool prog show id 227\n 227: xdp  tag a85e060c275c5616  gpl\n     loaded_at 2018-07-17T14:41:29+0000  uid 0\n     xlated 8152B  not jited  memlock 12288B  map_ids 381,385,386,382,384,383\n # bpftool map dump id 386\n  [{\n       \"key\": 0,\n       \"value\": {\n           \"\": {\n               \"value\": 0,\n               \"ifindex\": 0,\n               \"mac\": []\n           }\n       }\n   },{\n       \"key\": 1,\n       \"value\": {\n           \"\": {\n               \"value\": 0,\n               \"ifindex\": 0,\n               \"mac\": []\n           }\n       }\n   },{\n [...]\n \n Lookup, update, delete, and 'get next key' operations on the map for specific\nkeys can be performed through bpftool as well. \n If the BPF program has been successfully loaded with BTF debugging information,\nthe BTF ID will be shown in  prog show  command result denoted in  btf_id . \n .. code-block:: shell-session \n  # bpftool prog show id 72\n 72: xdp  name balancer_ingres  tag acf44cabb48385ed  gpl\n    loaded_at 2020-04-13T23:12:08+0900  uid 0\n    xlated 19104B  jited 10732B  memlock 20480B  map_ids 126,130,131,127,129,128\n    btf_id 60\n \n This can also be confirmed with  btf show  command which dumps all BTF\nobjects loaded on a system. \n .. code-block:: shell-session \n  # bpftool btf show\n 60: size 12243B  prog_ids 72  map_ids 126,130,131,127,129,128\n \n And the subcommand  btf dump  can be used to check which debugging information\nis included in the BTF. With this command, BTF dump can be formatted either\n'raw' or 'c', the one that is used in C code. \n .. code-block:: shell-session \n  # bpftool btf dump id 60 format c\n   [...]\n    struct ctl_value {\n          union {\n                  __u64 value;\n                  __u32 ifindex;\n                  __u8 mac[6];\n          };\n    };\n\n    typedef unsigned int u32;\n    [...]\n \n .. admonition:: Video\n:class: attention \n To learn more about bpftool, check out  eCHO episode 11: Exploring   bpftool <https://www.youtube.com/watch?v=1EOLh3zzWP4&t=650s> __ with Quentin Monnet, maintainer of bpftool. \n Kernel Testing \n The Linux kernel ships a BPF selftest suite, which can be found in the kernel\nsource tree under  tools/testing/selftests/bpf/ . \n .. code-block:: shell-session \n $ cd tools/testing/selftests/bpf/\n$ make\n# make run_tests\n \n The test suite contains test cases against the BPF verifier, program tags,\nvarious tests against the BPF map interface and map types. It contains various\nruntime tests from C code for checking LLVM back end, and eBPF as well as cBPF\nasm code that is run in the kernel for testing the interpreter and JITs. \n JIT Debugging \n For JIT developers performing audits or writing extensions, each compile run\ncan output the generated JIT image into the kernel log through: \n .. code-block:: shell-session \n # echo 2 > /proc/sys/net/core/bpf_jit_enable\n \n Whenever a new BPF program is loaded, the JIT compiler will dump the output,\nwhich can then be inspected with  dmesg , for example: \n :: \n [ 3389.935842] flen=6 proglen=70 pass=3 image=ffffffffa0069c8f from=tcpdump pid=20583\n[ 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68\n[ 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00\n[ 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00\n[ 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00\n[ 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3\n \n flen  is the length of the BPF program (here, 6 BPF instructions), and  proglen \ntells the number of bytes generated by the JIT for the opcode image (here, 70 bytes\nin size).  pass  means that the image was generated in 3 compiler passes, for\nexample,  x86_64  can have various optimization passes to further reduce the image\nsize when possible.  image  contains the address of the generated JIT image,  from \nand  pid  the user space application name and PID respectively, which triggered the\ncompilation process. The dump output for eBPF and cBPF JITs is the same format. \n In the kernel tree under  tools/bpf/ , there is a tool called  bpf_jit_disasm . It\nreads out the latest dump and prints the disassembly for further inspection: \n .. code-block:: shell-session \n # ./bpf_jit_disasm\n70 bytes emitted from JIT compiler (pass:3, flen:6)\nffffffffa0069c8f + <x>:\n   0:       push   %rbp\n   1:       mov    %rsp,%rbp\n   4:       sub    $0x60,%rsp\n   8:       mov    %rbx,-0x8(%rbp)\n   c:       mov    0x68(%rdi),%r9d\n  10:       sub    0x6c(%rdi),%r9d\n  14:       mov    0xd8(%rdi),%r8\n  1b:       mov    $0xc,%esi\n  20:       callq  0xffffffffe0ff9442\n  25:       cmp    $0x800,%eax\n  2a:       jne    0x0000000000000042\n  2c:       mov    $0x17,%esi\n  31:       callq  0xffffffffe0ff945e\n  36:       cmp    $0x1,%eax\n  39:       jne    0x0000000000000042\n  3b:       mov    $0xffff,%eax\n  40:       jmp    0x0000000000000044\n  42:       xor    %eax,%eax\n  44:       leaveq\n  45:       retq\n \n Alternatively, the tool can also dump related opcodes along with the disassembly. \n .. code-block:: shell-session \n # ./bpf_jit_disasm -o\n70 bytes emitted from JIT compiler (pass:3, flen:6)\nffffffffa0069c8f + <x>:\n   0:       push   %rbp\n    55\n   1:       mov    %rsp,%rbp\n    48 89 e5\n   4:       sub    $0x60,%rsp\n    48 83 ec 60\n   8:       mov    %rbx,-0x8(%rbp)\n    48 89 5d f8\n   c:       mov    0x68(%rdi),%r9d\n    44 8b 4f 68\n  10:       sub    0x6c(%rdi),%r9d\n    44 2b 4f 6c\n  14:       mov    0xd8(%rdi),%r8\n    4c 8b 87 d8 00 00 00\n  1b:       mov    $0xc,%esi\n    be 0c 00 00 00\n  20:       callq  0xffffffffe0ff9442\n    e8 1d 94 ff e0\n  25:       cmp    $0x800,%eax\n    3d 00 08 00 00\n  2a:       jne    0x0000000000000042\n    75 16\n  2c:       mov    $0x17,%esi\n    be 17 00 00 00\n  31:       callq  0xffffffffe0ff945e\n    e8 28 94 ff e0\n  36:       cmp    $0x1,%eax\n    83 f8 01\n  39:       jne    0x0000000000000042\n    75 07\n  3b:       mov    $0xffff,%eax\n    b8 ff ff 00 00\n  40:       jmp    0x0000000000000044\n    eb 02\n  42:       xor    %eax,%eax\n    31 c0\n  44:       leaveq\n    c9\n  45:       retq\n    c3\n \n More recently,  bpftool  adapted the same feature of dumping the BPF JIT\nimage based on a given BPF program ID already loaded in the system (see\nbpftool section). \n For performance analysis of JITed BPF programs,  perf  can be used as\nusual. As a prerequisite, JITed programs need to be exported through kallsyms\ninfrastructure. \n .. code-block:: shell-session \n # echo 1 > /proc/sys/net/core/bpf_jit_enable\n# echo 1 > /proc/sys/net/core/bpf_jit_kallsyms\n \n Enabling or disabling  bpf_jit_kallsyms  does not require a reload of the\nrelated BPF programs. Next, a small workflow example is provided for profiling\nBPF programs. A crafted tc BPF program is used for demonstration purposes,\nwhere perf records a failed allocation inside  bpf_clone_redirect()  helper.\nDue to the use of direct write,  bpf_try_make_head_writable()  failed, which\nwould then release the cloned  skb  again and return with an error message.\n perf  thus records all  kfree_skb  events. \n .. code-block:: shell-session \n # tc qdisc add dev em1 clsact\n# tc filter add dev em1 ingress bpf da obj prog.o sec main\n# tc filter show dev em1 ingress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle 0x1 prog.o:[main] direct-action id 1 tag 8227addf251b7543\n\n# cat /proc/kallsyms\n[...]\nffffffffc00349e0 t fjes_hw_init_command_registers    [fjes]\nffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    [fjes]\nffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    [fjes]\nffffffffc004b000 t bpf_prog_8227addf251b7543\n\n# perf record -a -g -e skb:kfree_skb sleep 60\n# perf script --kallsyms=/proc/kallsyms\n[...]\nksoftirqd/0     6 [000]  1004.578402:    skb:kfree_skb: skbaddr=0xffff9d4161f20a00 protocol=2048 location=0xffffffffc004b52c\n   7fffb8745961 bpf_clone_redirect (/lib/modules/4.10.0+/build/vmlinux)\n   7fffc004e52c bpf_prog_8227addf251b7543 (/lib/modules/4.10.0+/build/vmlinux)\n   7fffc05b6283 cls_bpf_classify (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb875957a tc_classify (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb8729840 __netif_receive_skb_core (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb8729e38 __netif_receive_skb (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb872ae05 process_backlog (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb872a43e net_rx_action (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb886176c __do_softirq (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb80ac5b9 run_ksoftirqd (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb80ca7fa smpboot_thread_fn (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb80c6831 kthread (/lib/modules/4.10.0+/build/vmlinux)\n   7fffb885e09c ret_from_fork (/lib/modules/4.10.0+/build/vmlinux)\n \n The stack trace recorded by  perf  will then show the  bpf_prog_8227addf251b7543() \nsymbol as part of the call trace, meaning that the BPF program with the\ntag  8227addf251b7543  was related to the  kfree_skb  event, and\nsuch program was attached to netdevice  em1  on the ingress hook as\nshown by tc. \n Introspection \n The Linux kernel provides various tracepoints around BPF and XDP which\ncan be used for additional introspection, for example, to trace interactions\nof user space programs with the bpf system call. \n Tracepoints for BPF: \n .. code-block:: shell-session \n # perf list | grep bpf:\nbpf:bpf_map_create                                 [Tracepoint event]\nbpf:bpf_map_delete_elem                            [Tracepoint event]\nbpf:bpf_map_lookup_elem                            [Tracepoint event]\nbpf:bpf_map_next_key                               [Tracepoint event]\nbpf:bpf_map_update_elem                            [Tracepoint event]\nbpf:bpf_obj_get_map                                [Tracepoint event]\nbpf:bpf_obj_get_prog                               [Tracepoint event]\nbpf:bpf_obj_pin_map                                [Tracepoint event]\nbpf:bpf_obj_pin_prog                               [Tracepoint event]\nbpf:bpf_prog_get_type                              [Tracepoint event]\nbpf:bpf_prog_load                                  [Tracepoint event]\nbpf:bpf_prog_put_rcu                               [Tracepoint event]\n \n Example usage with  perf  (alternatively to  sleep  example used here,\na specific application like  tc  could be used here instead, of course): \n .. code-block:: shell-session \n # perf record -a -e bpf:* sleep 10\n# perf script\nsock_example  6197 [005]   283.980322:      bpf:bpf_map_create: map type=ARRAY ufd=4 key=4 val=8 max=256 flags=0\nsock_example  6197 [005]   283.980721:       bpf:bpf_prog_load: prog=a5ea8fa30ea6849c type=SOCKET_FILTER ufd=5\nsock_example  6197 [005]   283.988423:   bpf:bpf_prog_get_type: prog=a5ea8fa30ea6849c type=SOCKET_FILTER\nsock_example  6197 [005]   283.988443: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=4 key=[06 00 00 00] val=[00 00 00 00 00 00 00 00]\n[...]\nsock_example  6197 [005]   288.990868: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=4 key=[01 00 00 00] val=[14 00 00 00 00 00 00 00]\n     swapper     0 [005]   289.338243:    bpf:bpf_prog_put_rcu: prog=a5ea8fa30ea6849c type=SOCKET_FILTER\n \n For the BPF programs, their individual program tag is displayed. \n For debugging, XDP also has a tracepoint that is triggered when exceptions are raised: \n .. code-block:: shell-session \n # perf list | grep xdp:\nxdp:xdp_exception                                  [Tracepoint event]\n \n Exceptions are triggered in the following scenarios: \n \n The BPF program returned an invalid / unknown XDP action code. \n The BPF program returned with  XDP_ABORTED  indicating a non-graceful exit. \n The BPF program returned with  XDP_TX , but there was an error on transmit,\nfor example, due to the port not being up, due to the transmit ring being full,\ndue to allocation failures, etc. \n \n Both tracepoint classes can also be inspected with a BPF program itself\nattached to one or more tracepoints, collecting further information\nin a map or punting such events to a user space collector through the\n bpf_perf_event_output()  helper, for example. \n Tracing pipe \n When a BPF program makes a call to  bpf_trace_printk() , the output is sent\nto the kernel tracing pipe. Users may read from this file to consume events\nthat are traced to this buffer: \n .. code-block:: shell-session \n tail -f /sys/kernel/debug/tracing/trace_pipe \n ... \n Miscellaneous \n BPF programs and maps are memory accounted against  RLIMIT_MEMLOCK  similar\nto  perf . The currently available size in unit of system pages which may be\nlocked into memory can be inspected through  ulimit -l . The setrlimit system\ncall man page provides further details. \n The default limit is usually insufficient to load more complex programs or\nlarger BPF maps, so that the BPF system call will return with  errno \nof  EPERM . In such situations a workaround with  ulimit -l unlimited  or\nwith a sufficiently large limit could be performed. The  RLIMIT_MEMLOCK  is\nmainly enforcing limits for unprivileged users. Depending on the setup,\nsetting a higher limit for privileged users is often acceptable.",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/reference-guides/bpf/debug_and_test.rst",
  "extracted_at": "2025-09-03T01:13:28.782359Z"
}