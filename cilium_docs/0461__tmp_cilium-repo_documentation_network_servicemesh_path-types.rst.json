{
  "url": "file:///tmp/cilium-repo/Documentation/network/servicemesh/path-types.rst",
  "content": ".. only:: not (epub or latex or html) \n WARNING: You are looking at unreleased Cilium documentation.\nPlease use the official rendered version released here:\nhttps://docs.cilium.io\n \n .. _gs_ingress_path_types: \n \n Ingress Path Types Example \n \n This example walks through how various path types interact and allows you to\ntest that Cilium is working as it should. \n This example requires that Cilium Ingress is enabled, and  kubectl  and  jq \nmust be installed. \n Deploy the example app \n This deploys five copies of the ingress-conformance-echo tool, that will allow\nus to see what paths are forwarded to what backends. \n .. code-block:: shell-session \n $ # Apply the base definitions\n$ kubectl apply -f https://raw.githubusercontent.com/cilium/cilium/main/examples/kubernetes/servicemesh/ingress-path-types.yaml\n$ # Apply the Ingress\n$ kubectl apply -f https://raw.githubusercontent.com/cilium/cilium/main/examples/kubernetes/servicemesh/ingress-path-types-ingress.yaml\n \n Review the Ingress \n Here is the Ingress used: \n .. literalinclude:: ../../../examples/kubernetes/servicemesh/ingress-path-types-ingress.yaml\n:language: yaml \n You can see here that there are five matches, one for each of our deployments. \n The Ingress deliberately has the rules in a different order to what they will be\nconfigured in Envoy. \n \n For Exact matches, we only match  /exact  and send that to the  exactpath  Service. \n For Prefix matches, we match  / , send that to the  prefixpath  Service,\nand match  /prefix  and send that to the  prefixpath2  Service. \n For ImplementationSpecific matches, we match  /impl.+  (a full regex), and\nsend that to the  implpath2  Service. We also match  /impl  (without regex\ncharacters) and send that to the  implpath  Service. \n \n The intent here is to allow us to tell which rule we have matched by consulting\nthe echoed response from the ingress-conformance-echo containers. \n Check that the Ingress has provisioned correctly \n Firstly, we need to check that the Ingress has been provisioned correctly. \n .. code-block:: shell-session \n $ export PATHTYPE_IP=`k get ing multiple-path-types -o json | jq -r '.status.loadBalancer.ingress[0].ip'`\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/ | jq\n{\n\"path\": \"/\",\n\"host\": \"pathtypes.example.com\",\n\"method\": \"GET\",\n\"proto\": \"HTTP/1.1\",\n\"headers\": {\n    \"Accept\": [\n    \"*/*\"\n    ],\n    \"User-Agent\": [\n    \"curl/7.81.0\"\n    ],\n    \"X-Envoy-External-Address\": [\n    \"your-ip-here\"\n    ],\n    \"X-Forwarded-For\": [\n    \"your-ip-here\"\n    ],\n    \"X-Forwarded-Proto\": [\n    \"http\"\n    ],\n    \"X-Request-Id\": [\n    \"6bb145e8-addb-4fd5-a76f-b53d07bd1867\"\n    ]\n},\n\"namespace\": \"default\",\n\"ingress\": \"\",\n\"service\": \"\",\n\"pod\": \"prefixpath-7cb697f5cd-wvv7b\"\n}\n \n Here you can see that the Ingress has been provisioned correctly and is responding\nto requests. Also, you can see that the  /  path has been served by the\n prefixpath  deployment, which is as expected from the Ingress. \n Check that paths perform as expected \n The following example uses  jq  to extract the first element out of the  pod \nfield, which is the name of the associated deployment. So,  prefixpath-7cb697f5cd-wvv7b \nwill return  prefixpath . \n .. code-block:: shell-session \n $ echo Should show \"prefixpath\"\nShould show prefixpath\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/ | jq '.pod | split(\"-\")[0]'\n\"prefixpath\"\n$ echo Should show \"exactpath\"\nShould show exactpath\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/exact | jq '.pod | split(\"-\")[0]'\n\"exactpath\"\n$ echo Should show \"prefixpath2\"\nShould show prefixpath2\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/prefix | jq '.pod | split(\"-\")[0]'\n\"prefixpath2\"\n$ echo Should show \"implpath\"\nShould show implpath\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/impl | jq '.pod | split(\"-\")[0]'\n\"implpath\"\n$ echo Should show \"implpath2\"\nShould show implpath2\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/implementation | jq '.pod | split(\"-\")[0]'\n\"implpath2\"\n \n (You can use the \"Copy Commands\" button above to do less copy-and-paste.) \n The most interesting example here is the last one, where we send  /implementation \nto the  implpath2  Service, while  /impl  goes to  implpath . This is because\n /implementation  matches the  /impl.+  regex, and  /impl  matches the\n /impl  regex. \n If we now patch the Ingress object to use the regex  /impl.*  instead (note the\n * , which matches  zero or more  characters of the type instead of the\nprevious  + , which matches  one or more  characters), then we will get a\ndifferent result for the last two checks: \n .. code-block:: shell-session \n $ echo Should show \"implpath2\"\nShould show implpath\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/impl | jq '.pod | split(\"-\")[0]'\n\"implpath\"\n$ echo Should show \"implpath2\"\nShould show implpath2\n$ curl -s -H \"Host: pathtypes.example.com\" http://$PATHTYPE_IP/implementation | jq '.pod | split(\"-\")[0]'\n\"implpath2\"\n \n The request to  /impl  now matches the  longer  pattern  /impl.* . \n The moral here is to be careful with your regular expressions! \n Clean up the example \n Finally, we clean up our example: \n .. code-block:: shell-session \n $ # Apply the base definitions\n$ kubectl delete -f https://raw.githubusercontent.com/cilium/cilium/main/examples/kubernetes/servicemesh/ingress-path-types.yaml\n$ # Apply the Ingress\n$ kubectl delete -f https://raw.githubusercontent.com/cilium/cilium/main/examples/kubernetes/servicemesh/ingress-path-types-ingress.yaml",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/network/servicemesh/path-types.rst",
  "extracted_at": "2025-09-03T01:13:29.153553Z"
}