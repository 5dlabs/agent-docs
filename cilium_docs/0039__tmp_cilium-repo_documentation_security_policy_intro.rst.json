{
  "url": "file:///tmp/cilium-repo/Documentation/security/policy/intro.rst",
  "content": ".. only:: not (epub or latex or html)\n\n    WARNING: You are looking at unreleased Cilium documentation.\n    Please use the official rendered version released here:\n    https://docs.cilium.io\n\n.. _policy_guide:\n\n.. _policy_enforcement_modes:\n\nPolicy Enforcement Modes\n========================\n\nThe configuration of the Cilium agent and the Cilium Network Policy determines whether an endpoint accepts traffic from a source or not. The agent can be put into the following three policy enforcement modes:\n\ndefault\n  This is the default behavior for policy enforcement. In this mode, endpoints\n  have unrestricted network access until selected by policy. Upon being selected by\n  a policy, the endpoint permits only allowed traffic. This state is per-direction\n  and can be adjusted on a per-policy basis. For more details, :ref:`see the dedicated section on default mode<policy_mode_default>`.\n\nalways\n  With always mode, policy enforcement is enabled on all endpoints even if no\n  rules select specific endpoints.\n\n  If you want to configure health entity to check cluster-wide connectivity when \n  you start cilium-agent with ``enable-policy: always``, you will likely want to\n  enable communications to and from the health endpoint. See :ref:`health_endpoint`.\n\nnever\n  With never mode, policy enforcement is disabled on all endpoints, even if\n  rules do select specific endpoints. In other words, all traffic is allowed\n  from any source (on ingress) or destination (on egress).\n\nTo :ref:`configure <k8s_configuration>` the policy enforcement mode, adjust the Helm value\n``policyEnforcementMode`` or the corresponding configuration flag ``enable-policy``.\n\n.. _policy_mode_default:\n\nEndpoint default policy\n-----------------------\n\nBy default, all egress and ingress traffic is allowed for all endpoints. When\nan endpoint is selected by a network policy, it transitions to a default-deny\nstate, where only **explicitly allowed** traffic is permitted. This state is\nper-direction:\n\n* If any rule selects an :ref:`endpoint` and the rule has an ingress\n  section, the endpoint goes into default deny-mode for ingress.\n* If any rule selects an :ref:`endpoint` and the rule has an egress section, the\n  endpoint goes into default-deny mode for egress.\n\nThis means that endpoints start without any restrictions, and the first\npolicy will switch the endpoint's default enforcement mode (per direction).\n\nIt is possible to create policies that do not enable the default-deny mode for selected\nendpoints. The field ``EnableDefaultDeny`` configures this. Rules with ``EnableDefaultDeny``\ndisabled are ignored when determining the default mode.\n\nFor example, this policy causes all DNS traffic to be intercepted, but does not\nblock any traffic, even if it is the first policy to apply to an endpoint. An\nadministrator can safely apply this policy cluster-wide, without the risk that\nit transitions an endpoint in to default-deny and causes legitimate traffic to be dropped.\n\n.. warning::\n  ``EnableDefaultDeny`` does not apply to :ref:`layer-7 policy <l7_policy>`.\n  Adding a layer-7 rule that does not include a layer-7 allow-all will cause drops,\n  even when default-deny is explicitly disabled.\n\n.. code-block:: yaml\n\n  apiVersion: cilium.io/v2\n  kind: CiliumClusterwideNetworkPolicy\n  metadata:\n    name: intercept-all-dns\n  spec:\n    endpointSelector:\n      matchExpressions:\n        - key: \"io.kubernetes.pod.namespace\"\n          operator: \"NotIn\"\n          values:\n          - \"kube-system\"\n        - key: \"k8s-app\"\n          operator: \"NotIn\"\n          values:\n          - kube-dns\n    enableDefaultDeny:\n      egress: false\n      ingress: false\n    egress:\n      - toEndpoints:\n          - matchLabels:\n              io.kubernetes.pod.namespace: kube-system\n              k8s-app: kube-dns\n        toPorts:\n          - ports:\n            - port: \"53\"\n              protocol: TCP\n            - port: \"53\"\n              protocol: UDP\n            rules:\n              dns:\n                - matchPattern: \"*\"\n\n.. _policy_rule:\n\nRule Basics\n===========\n\nAll policy rules are based upon a whitelist model, that is, each rule in the\npolicy allows traffic that matches the rule. If two rules exist, and one\nwould match a broader set of traffic, then all traffic matching the broader\nrule will be allowed. If there is an intersection between two or more rules,\nthen traffic matching the union of those rules will be allowed. Finally, if\ntraffic does not match any of the rules, it will be dropped pursuant to the\n`policy_enforcement_modes`.\n\nPolicy rules share a common base type which specifies which endpoints the\nrule applies to and common metadata to identify the rule. Each rule is split\ninto an ingress section and an egress section. The ingress section contains\nthe rules which must be applied to traffic entering the endpoint, and the\negress section contains rules applied to traffic coming from the endpoint\nmatching the endpoint selector. Either ingress, egress, or both can be\nprovided. If both ingress and egress are omitted, the rule has no effect.\n\n.. code-block:: go\n\n        type Rule struct {\n                // EndpointSelector selects all endpoints which should be subject to\n                // this rule. EndpointSelector and NodeSelector cannot be both empty and\n                // are mutually exclusive.\n                //\n                // +optional\n                EndpointSelector EndpointSelector `json:\"endpointSelector,omitempty\"`\n\n                // NodeSelector selects all nodes which should be subject to this rule.\n                // EndpointSelector and NodeSelector cannot be both empty and are mutually\n                // exclusive. Can only be used in CiliumClusterwideNetworkPolicies.\n                //\n                // +optional\n                NodeSelector EndpointSelector `json:\"nodeSelector,omitempty\"`\n\n                // Ingress is a list of IngressRule which are enforced at ingress.\n                // If omitted or empty, this rule does not apply at ingress.\n                //\n                // +optional\n                Ingress []IngressRule `json:\"ingress,omitempty\"`\n\n                // Egress is a list of EgressRule which are enforced at egress.\n                // If omitted or empty, this rule does not apply at egress.\n                //\n                // +optional\n                Egress []EgressRule `json:\"egress,omitempty\"`\n\n                // Labels is a list of optional strings which can be used to\n                // re-identify the rule or to store metadata. It is possible to lookup\n                // or delete strings based on labels. Labels are not required to be\n                // unique, multiple rules can have overlapping or identical labels.\n                //\n                // +optional\n                Labels labels.LabelArray `json:\"labels,omitempty\"`\n\n                // Description is a free form string, it can be used by the creator of\n                // the rule to store human readable explanation of the purpose of this\n                // rule. Rules cannot be identified by comment.\n                //\n                // +optional\n                Description string `json:\"description,omitempty\"`\n        }\n\n----\n\nendpointSelector / nodeSelector\n  Selects the endpoints or nodes which the policy rules apply to. The policy\n  rules will be applied to all endpoints which match the labels specified in\n  the selector. For additional details, see the :ref:`EndpointSelector` and\n  :ref:`NodeSelector` sections.\n\ningress\n  List of rules which must apply at ingress of the endpoint, i.e. to all\n  network packets which are entering the endpoint.\n\negress\n  List of rules which must apply at egress of the endpoint, i.e. to all network\n  packets which are leaving the endpoint.\n\nlabels\n  Labels are used to identify the rule. Rules can be listed and deleted by\n  labels. Policy rules which are imported via :ref:`kubernetes<k8s_policy>`\n  automatically get the label ``io.cilium.k8s.policy.name=NAME`` assigned where\n  ``NAME`` corresponds to the name specified in the `NetworkPolicy` or\n  `CiliumNetworkPolicy` resource.\n\ndescription\n  Description is a string which is not interpreted by Cilium. It can be used to\n  describe the intent and scope of the rule in a human readable form.\n\n.. _EndpointSelector:\n\nEndpoint Selector\n-----------------\n\nThe Endpoint Selector is based on the `Kubernetes LabelSelector`_. It is called\nEndpoint Selector because it only applies to labels associated with an\n:ref:`Endpoint <endpoint>`.\n\n.. _NodeSelector:\n\nNode Selector\n-------------\n\nLike the :ref:`Endpoint Selector <EndpointSelector>`, the Node Selector is\nbased on the `Kubernetes LabelSelector`_, although rather than\nmatching on labels associated with Endpoints, it applies to labels associated\nwith :ref:`Nodes <node>` in the cluster.\n\nNode Selectors can only be used in :ref:`CiliumClusterwideNetworkPolicies\n<CiliumClusterwideNetworkPolicy>`. For details on the scope of node-level\npolicies, see :ref:`HostPolicies`.\n\n.. _Kubernetes LabelSelector: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors\n",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/security/policy/intro.rst",
  "extracted_at": "2025-09-03T00:53:44.709610Z"
}