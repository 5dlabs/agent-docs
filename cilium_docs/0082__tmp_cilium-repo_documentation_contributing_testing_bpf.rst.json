{
  "url": "file:///tmp/cilium-repo/Documentation/contributing/testing/bpf.rst",
  "content": ".. only:: not (epub or latex or html)\n\n    WARNING: You are looking at unreleased Cilium documentation.\n    Please use the official rendered version released here:\n    https://docs.cilium.io\n\n.. _bpf_testing:\n\n********************************\nBPF Unit and Integration Testing\n********************************\n\nOur BPF datapath has its own test framework, which allows us to write unit and integration tests that\nverify that our BPF code works as intended, independently from the other Cilium components. The\nframework uses the ``BPF_PROG_RUN`` feature to run eBPF programs in the kernel without attaching\nthem to actual hooks.\n\nThe framework is designed to allow datapath developers to quickly write tests\nfor the code they are working on. The tests themselves are fully written in C to minimize context\nswitching. Tests pass results back to the framework which will outputs the results in Go test output,\nfor optimal integration with CI and other tools.\n\nRunning tests\n=============\n\nTo run the tests in your local environment, execute the following command from the project root:\n\n.. code-block:: shell-session\n\n    $ make run_bpf_tests\n\n.. note::\n\n    Running BPF tests requires Docker and is only expected to work on Linux.\n\nTo run a single test, specify its name without extension. For example:\n\n    $ make run_bpf_tests BPF_TEST_FILE=\"xdp_nodeport_lb4_nat_lb\"\n\nWriting tests\n=============\n\nAll BPF tests live in the ``bpf/tests`` directory. All ``.c`` files in this directory are assumed to\ncontain BPF test programs which can be independently compiled, loaded, and executed using\n``BPF_PROG_RUN``. All files in this directory are automatically picked up, so all you have to do is\ncreate a new ``.c`` file and start writing. All other files like ``.h`` files are ignored and can be\nused for sharing code for example.\n\nEach ``.c`` file must at least have one ``CHECK`` program. The ``CHECK`` macro replaces the ``SEC`` which is\ntypically used in BPF programs. The ``CHECK`` macro takes two arguments, the first being the program\ntype (for example ``xdp`` or ``tc``. See `the list of recognized types in the Go library\n<https://github.com/cilium/ebpf/blob/v0.13.2/elf_sections.go#L9>`__),\nthe second being the name of the test which will appear in the output. All macros are defined in\n``bpf/tests/common.h``, so all programs should start by including this file: ``#include \"common.h\"``.\n\nEach ``CHECK`` program should start with ``test_init()`` and end with ``test_finish()``, ``CHECK`` programs\nwill return implicitly with the result of the test, a user doesn't need to add ``return`` statements\nto the code manually. A test will PASS if it reaches ``test_finish()``, unless it is marked as\nfailed(``test_fail()``, ``test_fail_now()``, ``test_fatal()``) or skipped(``test_skip()``, ``test_skip_now()``).\n\nThe name of the function has no significance for the tests themselves. The function names are still\nused as indicators in the kernel (at least the first 15 chars), used to populate tail call maps,\nand should be unique for the purposes of compilation.\n\n.. code-block:: c\n\n    #include \"common.h\"\n\n    CHECK(\"xdp\", \"nodeport-lb4\")\n    int nodeportLB4(struct __ctx_buff *ctx)\n    {\n\t    test_init();\n\n        /* ensure preconditions are met */\n        /* call the functions you would like to test */\n        /* check that everything works as expected */\n\n        test_finish();\n    }\n\nSub-tests\n---------\n\nEach ``CHECK`` program may contain sub-tests, each of which has its own test status. A sub-test is\ncreated with the ``TEST`` macro like so:\n\n.. code-block:: c\n\n    #include \"common.h\"\n\n    #include <bpf/ctx/xdp.h>\n    #include <lib/jhash.h>\n    #include \"bpf/section.h\"\n\n    CHECK(\"xdp\", \"jhash\")\n    int bpf_test(__maybe_unused struct xdp_md *ctx)\n    {\n        test_init();\n\n        TEST(\"Non-zero\", {\n            unsigned int hash = jhash_3words(123, 234, 345, 456);\n\n            if (hash != 2698615579)\n                test_fatal(\"expected '2698615579' got '%lu'\", hash);\n        });\n\n        TEST(\"Zero\", {\n            unsigned int hash = jhash_3words(0, 0, 0, 0);\n\n            if (hash != 459859287)\n                test_fatal(\"expected '459859287' got '%lu'\", hash);\n        });\n\n        test_finish();\n    }\n\nSince all sub-tests are part of the same BPF program they are executed consecutively in one\n``BPF_PROG_RUN`` invocation and can share setup code which can improve run speed and reduce code duplication.\nThe name passed to the ``TEST`` macro for each sub-test serves to self-document the steps and makes it easier to spot what part of a test fails.\n\nIntegration tests\n-----------------\n\nWriting tests for a single function or small group of functions should be fairly straightforward,\nonly requiring a ``CHECK`` program. Testing functionality across tail calls requires an additional step:\ngiven that the program does not return to the ``CHECK`` function after making a tail call, we can't check whether it was successful.\n\nThe workaround is to use ``PKTGEN`` and ``SETUP`` programs in addition to a ``CHECK`` program.\nThese programs will run before the ``CHECK`` program with the same name.\nIntended usage is that the ``PKGTEN`` program builds a BPF context (for example fill a ``struct __sk_buff`` for TC programs), and passes it on\nto the ``SETUP`` program, which performs further setup steps (for example fill a BPF map). The two-stage pattern is needed so that ``BPF_PROG_RUN`` gets\ninvoked with the actual packet content (and for example fills ``skb->protocol``).\n\nThe BPF context is then passed to the ``CHECK`` program, which can inspect the result. By executing the test setup and executing the tail\ncall in ``SETUP`` we can execute complete programs.  The return code of the ``SETUP`` program is prepended as a ``u32`` to the start of the\npacket data passed to ``CHECK``, meaning that the ``CHECK`` program will find the actual packet data at ``(void *)data + 4``.\n\nThis is an abbreviated example showing the key components:\n\n.. code-block:: c\n\n    #include \"common.h\"\n\n    #include \"bpf/ctx/xdp.h\"\n    #include \"bpf_xdp.c\"\n\n    struct {\n        __uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n        __uint(key_size, sizeof(__u32));\n        __uint(max_entries, 2);\n        __array(values, int());\n    } entry_call_map __section(\".maps\") = {\n        .values = {\n            [0] = &cil_xdp_entry,\n        },\n    };\n\n    PKTGEN(\"xdp\", \"l2_example\")\n    int test1_pktgen(struct __ctx_buff *ctx)\n    {\n        /* Create room for our packet to be crafted */\n        unsigned int data_len = ctx->data_end - ctx->data;\n        int offset = offset = sizeof(struct ethhdr) - data_len;\n        bpf_xdp_adjust_tail(ctx, offset);\n\n        void *data = (void *)(long)ctx->data;\n        void *data_end = (void *)(long)ctx->data_end;\n\n        if (data + sizeof(struct ethhdr) > data_end)\n            return TEST_ERROR;\n\n        /* Writing just the L2 header for brevity */\n        struct ethhdr l2 = {\n            .h_source = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},\n            .h_dest = {0x12, 0x23, 0x34, 0x45, 0x56, 0x67},\n            .h_proto = bpf_htons(ETH_P_IP)\n        };\n        memcpy(data, &l2, sizeof(struct ethhdr));\n\n        return 0;\n    }\n\n    SETUP(\"xdp\", \"l2_example\")\n    int test1_setup(struct __ctx_buff *ctx)\n    {\n        /* OMITTED setting up map state */\n\n        /* Jump into the entrypoint */\n        tail_call_static(ctx, entry_call_map, 0);\n        /* Fail if we didn't jump */\n        return TEST_ERROR;\n    }\n\n    CHECK(\"xdp\", \"l2_example\")\n    int test1_check(__maybe_unused const struct __ctx_buff *ctx)\n    {\n        test_init();\n\n        void *data = (void *)(long)ctx->data;\n        void *data_end = (void *)(long)ctx->data_end;\n\n        if (data + sizeof(__u32) > data_end)\n            test_fatal(\"status code out of bounds\");\n\n        __u32 *status_code = data;\n\n        if (*status_code != XDP_TX)\n            test_fatal(\"status code != XDP_TX\");\n\n        data += sizeof(__u32);\n\n        if (data + sizeof(struct ethhdr) > data_end)\n            test_fatal(\"ctx doesn't fit ethhdr\");\n\n        struct ethhdr *l2 = data;\n\n        data += sizeof(struct ethhdr);\n\n        if (memcmp(l2->h_source, fib_smac, sizeof(fib_smac)))\n            test_fatal(\"l2->h_source != fib_smac\");\n\n        if (memcmp(l2->h_dest, fib_dmac, sizeof(fib_dmac)))\n            test_fatal(\"l2->h_dest != fib_dmac\");\n\n        if (data + sizeof(struct iphdr) > data_end)\n            test_fatal(\"ctx doesn't fit iphdr\");\n\n        test_finish();\n    }\n\nFunction reference\n------------------\n\n* ``test_log(fmt, args...)`` - writes a log message. The conversion specifiers supported by *fmt* are the same as for\n  ``bpf_trace_printk()``. They are **%d**, **%i**, **%u**, **%x**, **%ld**, **%li**, **%lu**, **%lx**, **%lld**, **%lli**,\n  **%llu**, **%llx**. No modifier (size of field, padding with zeroes, etc.) is available.\n\n* ``test_fail()`` - marks the current test or sub-test as failed but will continue execution.\n\n* ``test_fail_now()`` - marks the current test or sub-test as failed and will stop execution of the\n  test or sub-test (If called in a sub-test, the other sub-tests will still run).\n\n* ``test_fatal(fmt, args...)`` - writes a log and then calls ``test_fail_now()``\n\n* ``assert(stmt)`` - asserts that the statement within is true and call ``test_fail_now()`` otherwise.\n  ``assert`` will log the file and line number of the assert statement.\n\n* ``test_skip()`` - marks the current test or sub-test as skipped but will continue execution.\n\n* ``test_skip_now()`` - marks the current test or sub-test as skipped and will stop execution of the\n  test or sub-test (If called in a sub-test, the other sub-tests will still run).\n\n* ``test_init()`` - initializes the internal state for the test and must be called before any of the\n  functions above can be called.\n\n* ``test_finish()`` - submits the results and returns from the current function.\n\n.. warning::\n    Functions that halt the execution (``test_fail_now()``, ``test_fatal()``, ``test_skip_now()``) can't be\n    used within both a sub-test (``TEST``) and ``for``, ``while``, or ``switch/case`` blocks since they use the ``break`` keyword to stop a\n    sub-test. These functions can still be used from within ``for``, ``while`` and ``switch/case`` blocks if no\n    sub-tests are used, because in that case the flow interruption happens via ``return``.\n\nFunction mocking\n----------------\n\nBeing able to mock out a function is a great tool to have when creating tests for a number of\nreasons. You might for example want to test what happens if a specific function returns an error\nto see if it is handled gracefully. You might want to proxy function calls to record if the function\nunder test actually called specific dependencies. Or you might want to test code that uses helpers\nwhich rely on a state we can't set in BPF, like the routing table.\n\nMocking is easy with this framework:\n\n1. Create a function with a unique name and the same signature as the function it is replacing.\n\n2. Create a macro with the exact same name as the function we want to replace and point it to the\n   function created in step 1. For example ``#define original_function our_mocked_function``\n\n3. Include the file which contains the definition we are replacing.\n\nThe following example mocks out the fib_lookup helper call and replaces it with our\nmocked version, since we don't actually have routes for the IPs we want to test:\n\n.. code-block:: c\n\n    #include \"common.h\"\n\n    #include \"bpf/ctx/xdp.h\"\n\n    #define fib_lookup mock_fib_lookup\n\n    static const char fib_smac[6] = {0xDE, 0xAD, 0xBE, 0xEF, 0x01, 0x02};\n    static const char fib_dmac[6] = {0x13, 0x37, 0x13, 0x37, 0x13, 0x37};\n\n    long mock_fib_lookup(__maybe_unused void *ctx, struct bpf_fib_lookup *params,\n                __maybe_unused int plen, __maybe_unused __u32 flags)\n    {\n        memcpy(params->smac, fib_smac, sizeof(fib_smac));\n        memcpy(params->dmac, fib_dmac, sizeof(fib_dmac));\n        return 0;\n    }\n\n    #include \"bpf_xdp.c\"\n    #include \"lib/nodeport.h\"\n\nLimitations\n-----------\n\nFor all its benefits there are some limitations to this way of testing:\n\n* Code must pass the verifier, so our setup and test code has to obey the same rules as other BPF\n  programs. A side effect is that it automatically guarantees that all code that passes will also\n  load. The biggest concern is the complexity limit on older kernels, this can be somewhat mitigated\n  by separating heavy setup work into its own ``SETUP`` program and optionally tail calling into the\n  code to be tested, to ensure the testing harness doesn't push us over the complexity limit.\n\n* Test functions like ``test_log()``, ``test_fail()``, ``test_skip()`` can only be executed within the\n  scope of the main program or a ``TEST``. These functions rely on local variables set by ``test_init()``\n  and will produce errors when used in other functions.\n\n* Functions that halt the execution (``test_fail_now()``, ``test_fatal()``, ``test_skip_now()``) can't be\n  used within both a sub-test (``TEST``) and ``for``, ``while``, or ``switch/case`` blocks since they use the ``break`` keyword to stop a\n  sub-test. These functions can still be used from within ``for``, ``while`` and ``switch/case`` blocks if no\n  sub-tests are used, because in that case the flow interruption happens via ``return``.\n\n* Sub-test names can't use more than 127 characters.\n\n* Log messages can't use more than 127 characters and have no more than 12 arguments.\n",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/contributing/testing/bpf.rst",
  "extracted_at": "2025-09-03T01:13:28.838030Z"
}