{
  "url": "file:///tmp/cilium-repo/Documentation/contributing/development/datapath_config.rst",
  "content": ".. only:: not (epub or latex or html)\n\n    WARNING: You are looking at unreleased Cilium documentation.\n    Please use the official rendered version released here:\n    https://docs.cilium.io\n\n.. _dpconfig:\n\nConfiguring the Datapath\n========================\n\nIntroduction\n~~~~~~~~~~~~\n\nIn order for the Cilium datapath to function, it needs access to configuration\ndata such as feature flags, addresses, timeouts, security IDs and all sorts of\ntunables and user configuration. These values are provided by the agent at the\ntime of loading the BPF program. This page outlines the configuration mechanism,\nsome recommendations, how to migrate legacy configuration, as well as practical\nexamples.\n\nGetting Started\n~~~~~~~~~~~~~~~\n\nFirst, let's look at a practical example to illustrate the configuration API and\nsee the configuration process in action. This will help you understand how to\ndeclare, assign, and use configuration variables effectively in the Cilium\ndatapath.\n\nDeclaring C Variable\n^^^^^^^^^^^^^^^^^^^^\n\nTo start off, let's take a look at a straightforward example of a configuration\nvalue used in the datapath. This is an example from\n``bpf/include/bpf/config/lxc.h``, included by ``bpf_lxc.c``:\n\n.. code-block:: c\n\n  DECLARE_CONFIG(__u16, endpoint_id, \"The endpoint's security ID\")\n\nThis invokes the ``DECLARE_CONFIG`` macro, which declares the 16-bit unsigned\ninteger config value named ``endpoint_id``, followed by a description. We'll see\nwhy the description is useful later on.\n\nWith our variable declared, ``make`` the ``bpf/`` directory to rebuild the\ndatapath and run ``dpgen`` to generate Go code:\n\n.. code-block:: bash\n\n  make -C bpf -j$(nproc)\n\nThis will emit our variable to one of the Go config scaffoldings in the\n``pkg/datapath/config`` Go package.\n\nWiring up Go Values\n^^^^^^^^^^^^^^^^^^^\n\nOne of the files in package ``config`` will now contain a new struct field that\ncan be populated at BPF load time.\n\n.. code-block:: go\n\n  type BPFLXC struct {\n    ...\n    // The endpoint's security ID.\n    EndpointID uint16 `config:\"endpoint_id\"`\n    ...\n  }\n\nAs shown in the preceding snippet, the new struct field carries our helpful\ncomment we provided in the C code and refers to the ``endpoint_id`` variable we\ndeclared.\n\n.. note::\n\n  At the time of writing, populating Go configuration scaffolding still mostly\n  happens in ``pkg/datapath/loader`` and is scattered between a few places. The\n  goal is to create StateDB tables for each configuration object. These can be\n  managed from Hive Cells and automatically trigger a reload of the necessary\n  BPF programs when any of the values change. This document will be updated\n  along with these changes.\n\nNow, we need to wire up the field with an actual value. Depending on which\nobject you're adding configuration to and depending on whether the value is\n\"node configuration\" (more below) or object-specific, you may need to look in\ndifferent places. For example, adding a value to ``bpf_lxc.c`` like in this\nexample, the value is typically set in ``endpointRewrites()``:\n\n.. code-block:: go\n\n  func endpointRewrites(...) ... {\n    ...\n    cfg.InterfaceIfindex = uint32(ep.GetIfIndex())\n    ...\n  }\n\n.. warning::\n\n  This plumbing needs to be done for every object that needs access to the\n  variable! For example, if you declare a variable in a header common to both\n  ``bpf_lxc.c`` and ``bpf_host.c``, you'll need to make sure the agent supplies\n  the value to both structs.\n\nIf this document no longer matches the codebase, grep around for uses of the\nvarious structs and their fields, and extend the existing code. Over time, Hive\nCells will be able to write to these structs using StateDB tables.\n\nReading the Variable in C\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWe've declared our global config variable. We've generated Go code and wired up\na value from the agent. Now, we need to put the variable to use!\n\nIn datapath BPF code, we can refer to it using the ``CONFIG()`` macro. This\nmacro resolves to a special variable name representing our configuration value,\nwhich could change in the future. The macro is there to avoid cross-cutting code\nchanges if we ever need to make changes here.\n\n.. note::\n\n  The variable is not a compile-time constant, so it cannot be used to control\n  things like BPF map sizes or to initialize other global ``const`` variables at\n  compile time.\n\n.. code-block:: C\n\n  CONFIG(endpoint_id)\n\nUse the macro like you would typically use a variable:\n\n.. code-block:: c\n\n  __u16 endpoint_id = CONFIG(endpoint_id);\n\nor in a branch:\n\n.. code-block:: c\n\n  if (CONFIG(endpoint_id) != 0) {\n    ...\n  }\n\nNode Configuration\n~~~~~~~~~~~~~~~~~~\n\n.. warning::\n\n  Historically, most of the agent's configuration was presented to the datapath\n  as \"node configuration\" (in ``node_config.h``), but this pattern is\n  discouraged going forward and may go away at some point in the future. More on\n  this in :ref:`guidelines`.\n\nTo make migration from ``#define``-style configuration more straightforward,\nwe've kept the concept of node configuration, albeit with runtime-provided\nvalues instead of ``#ifdef``.\n\nNode configuration can be declared in ``bpf/include/bpf/config/node.h``:\n\n.. code-block:: c\n\n  NODE_CONFIG(__u64, foo, \"The foo value\")\n\nThis will show up in the Go scaffolding as:\n\n.. code-block:: go\n\n   type Node struct {\n      // The foo value.\n      Foo uint64 `config:\"foo\"`\n    }\n\nPopulate it in the agent through ``pkg/datapath/loader.nodeConfig()``:\n\n.. code-block:: go\n\n  func nodeConfig(lnc *datapath.LocalNodeConfiguration) config.Node {\n    ...\n    node.Foo = 42\n    ...\n  }\n\nIt behaves identically with regards to ``CONFIG()``.\n\n.. _guidelines:\n\nGuidelines and Recommendations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA few guiding principles:\n\n- Avoid dead code in the form of variables that are never set by the agent. For\n  example, if only ``bpf_lxc.c`` uses your variable, don't put it in a shared\n  header across multiple BPF objects. To share types with other objects, put\n  those in a separate header instead.\n- Declare variables close to where they're used, e.g. in header files\n  implementing a feature.\n- Avoid conditional ``#include`` statements.\n\nUse the following procedure to determine where to declare your configuration:\n\n1. For new features, use ``DECLARE_CONFIG()`` in the header implementing your\n   feature. Only import the header in the BPF object(s) where the feature is\n   utilized.\n2. For new config in existing features, ``DECLARE_CONFIG()`` as close as\n   possible to the code that consumes it.\n3. For porting over node configuration from ``node_config.h``\n   (``WriteNodeConfig``), try narrowing down where the config is used and see if\n   it can use ``DECLARE_CONFIG()`` in a header imported by a small number of BPF\n   objects instead. Refactoring is worth it here, since it avoids dead code in\n   objects that don't use the node config.\n4. If none of the above cases apply, use ``NODE_CONFIG()``.\n\n.. _defaults:\n\nDefaults\n~~~~~~~~\n\nTo assign a default value other than 0 to a configuration variable directly from\nC, the ``ASSIGN_CONFIG()`` macro can be used after declaring the variable. This\ncan be useful for setting sane defaults that will automatically apply even when\nthe agent doesn't supply a value.\n\nFor example, the agent uses this for device MTU:\n\n.. code-block:: c\n\n  DECLARE_CONFIG(__u16, device_mtu, \"MTU of the device the bpf program is attached to\")\n  ASSIGN_CONFIG(__u16, device_mtu, MTU)\n\n.. warning::\n\n  ``ASSIGN_CONFIG()`` can only be used once per variable per compilation unit.\n  This makes it so the variable cannot be overridden from tests without a\n  workaround, so use sparingly. See :ref:`testing` for more details.\n\n.. _testing:\n\nTesting\n~~~~~~~\n\nWhen writing tests, you may need to override configuration values to test\ndifferent code paths. This can be done by using the ``ASSIGN_CONFIG()`` macro in\na test file as described in :ref:`defaults` after importing the main object\nunder test, e.g. ``bpf_lxc.c``. See the test suite itself for the most\nup-to-date examples.\n\nNote that there are some restrictions, primarily that the literal passed to\n``ASSSIGN_CONFIG()`` must be compile-time constant, and can't e.g. be the name\nof another variable.\n\nOccasionally, you may need to override a config that already has a default value\nset using ``ASSIGN_CONFIG()``, in which case a workaround is needed:\n\n.. code-block:: c\n\n  #ifndef OVERRIDABLE_CONFIG\n  DECLARE_CONFIG(__u8, overridable, \"Config with a default and an override from tests\")\n  ASSIGN_CONFIG(__u8, overridable, 42)\n  #define OVERRIDABLE_CONFIG CONFIG(overridable)\n  #endif\n\nThen, from the test file, set ``#define OVERRIDABLE_CONFIG`` before including\nthe object under test to make the override take precedence.\n\n.. code-block:: c\n\n  #define OVERRIDABLE_CONFIG 1337\n  #include \"bpf_lxc.c\"\n\nThis is somewhat surprising, so use sparingly and consider refactoring the code\nto avoid the need for this.\n\nKnown Limitations\n~~~~~~~~~~~~~~~~~\n\n- Runtime-based configuration cannot currently be set during verifier tests.\n  This means that if you have a branch behind a (boolean) config, it will\n  currently not be evaluated by the verifier, and there may be latent verifier\n  errors that pop up when enabled through agent configuration. However, with the\n  new configuration mechanism, we can now fully automate testing all\n  permutations of config flags, without having to maintain them manually going\n  forward. Hold off on migrating ``ENABLE_`` defines until this is resolved.\n- Generating Go scaffolding for struct variables is not yet supported.\n\nBackground\n~~~~~~~~~~\n\nHistorically, configuration was fed into the datapath using ``#define``\nstatements generated at runtime, with sections of optional code cordoned off by\n``#ifdef`` and similar mechanisms. This has served us well over the years, but\nwith the increasing complexity of the agent and the datapath, it has become\nclear that we need a more structured and maintainable way to configure the\ndatapath.\n\nLinux kernels 5.2 and later support read-only maps to store config data that\ncannot be changed after the kernel verified the program. If these values are\nused in branches, the verifier can then perform dead code elimination,\neliminating branches it deems unreachable. This minimizes the amount of work the\nverifier needs to do in subsequent verification steps and ensures the BPF\nprogram image is as lean as possible.\n\nThis also means we no longer need to conditionally compile out parts of code we\ndon't need, so we can adopt an approach where the datapath's BPF code is built\nand embedded into the agent at compile time. This, in turn, means we no longer\nneed to ship LLVM with the agent (maybe you've heard of the term\n``clang-free``), reducing the size of the agent container image and\nsignificantly cutting down on agent startup time and CPU usage. Endpoints will\nalso regenerate faster during configuration changes.\n",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/contributing/development/datapath_config.rst",
  "extracted_at": "2025-09-03T01:13:28.795447Z"
}