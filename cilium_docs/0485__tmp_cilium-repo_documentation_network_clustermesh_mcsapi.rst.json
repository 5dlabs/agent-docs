{
  "url": "file:///tmp/cilium-repo/Documentation/network/clustermesh/mcsapi.rst",
  "content": ".. _gs_clustermesh_mcsapi: \n \n Multi-Cluster Services API (Beta) \n \n .. include:: ../../beta.rst \n This tutorial will guide you to through the support of  Multi-Cluster Services API (MCS-API) _ in Cilium. \n .. _Multi-Cluster Services API (MCS-API): https://github.com/kubernetes/enhancements/blob/master/keps/sig-multicluster/1645-multi-cluster-services-api/README.md \n .. _clustermesh_mcsapi_prereqs: \n Prerequisites\n############# \n You need to have a functioning Cluster Mesh setup, please follow the\n:ref: gs_clustermesh  guide to set it up. \n Make sure you are running CoreDNS 1.12.2 or later. \n You first need to install the required MCS-API CRDs: \n .. code-block:: shell-session \n   kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/mcs-api/62ede9a032dcfbc41b3418d7360678cb83092498/config/crd/multicluster.x-k8s.io_serviceexports.yaml\n  kubectl apply -f https://raw.githubusercontent.com/kubernetes-sigs/mcs-api/62ede9a032dcfbc41b3418d7360678cb83092498/config/crd/multicluster.x-k8s.io_serviceimports.yaml\n \n To install Cilium with MCS-API support, run: \n .. parsed-literal:: \n   helm install cilium |CHART_RELEASE| \\\\\n  --namespace kube-system \\\\\n  --set clustermesh.mcsapi.enabled=true\n \n To enable MCS-API support on an existing Cilium installation, run: \n .. parsed-literal:: \n   helm upgrade cilium |CHART_RELEASE| \\\\\n  --namespace kube-system \\\\\n  --reuse-values \\\\\n  --set clustermesh.mcsapi.enabled=true\n \n Also checkout the :ref: EndpointSlice synchronization <endpointslicesync>  feature\nif you need Headless Services support. \n If you set ```clustermesh.mcsapi.corednsAutoConfigure.enabled to true``, Cilium\nwill automatically configure and rollout CoreDNS for MCS-API support. Otherwise to\nconfigure CoreDNS manually, you need to execute the following steps: \n .. code-block:: shell-session \n   # Adding RBAC to read SericeImports\n  kubectl create clusterrole coredns-mcsapi \\\n     --verb=list,watch --resource=serviceimports.multicluster.x-k8s.io\n  kubectl create clusterrolebinding coredns-mcsapi \\\n     --clusterrole=coredns-mcsapi --serviceaccount=kube-system:coredns\n\n  # Configure CoreDNS to support MCS-API\n  kubectl get configmap -n kube-system coredns -o yaml | \\\n     sed -e 's/cluster\\.local/cluster.local clusterset.local/g' | \\\n     sed -E 's/^(.*)kubernetes(.*)\\{/\\1kubernetes\\2{\\n\\1   multicluster clusterset.local/' | \\\n     kubectl replace -f-\n\n  # Rollout CoreDNS to apply the change\n  kubectl rollout deployment -n kube-system coredns\n \n Exporting a Service\n################### \n To export a service you should create a ServiceExport resource. As a result\nyour Service will be exported to all clusters, provided that the Service\nNamespace is present on those clusters. \n .. code-block:: yaml \n   apiVersion: multicluster.x-k8s.io/v1alpha1\n  kind: ServiceExport\n  metadata:\n     name: rebel-base\n \n In all the clusters and for each set of exported Services that have the same name and namespace,\na ServiceImport resource will be automatically created. All the Endpoints from those exported Services\nwith the same name and namespace will be merged and made globally available. \n An exported Service through MCS-API is available by default on the  <svc>.<ns>.svc.clusterset.local  domain.\nIf you have defined any hostname (via a Statefulset for instance) on your pods\neach pods would also be available available through the  <hostname>.<clustername>.<svc>.<ns>.svc.clusterset.local  domain. \n .. note:: \n   The ``<clustername>.<svc>.<ns>.svc.clusterset.local`` domain that would allow\n  to get all the endpoints of a Service in a specific cluster is not allowed!\n\n  We recommend creating one service per cluster and/or region and exporting it\n  accordingly if you do want to have this kind of behavior, for instance\n  creating and exporting services ``mysvc-eu`` and ``mysvc-us`` instead of only\n  one service. For more information checkout the `dedicated section in the MCS-API KEP`_\n  explaining this behavior.\n \n .. _dedicated section in the MCS-API KEP: https://github.com/kubernetes/enhancements/blob/master/keps/sig-multicluster/1645-multi-cluster-services-api/README.md#not-allowing-cluster-specific-targeting-via-dns \n The ServiceImport has also a logic to merge different Service properties: \n \n SessionAffinity \n Ports (Union of the different ServiceExports) \n Type (ClusterSetIP/Headless) \n Annotations & Labels (via the ServiceExport  exportedLabels  and  exportedAnnotations  fields) \n \n If any conflict arises on any of these properties, the oldest ServiceExport will\nhave precedence to resolve the conflict. This means that you should get a\nconsistent behavior globally for the same set of exported Services that has\nthe same name and namespace. If any conflicts arises, you would be able to see\ndetails about it in the ServiceExport status Conditions. \n Deploying a Simple Example Service using MCS-API \n \n \n In cluster 1, deploy: \n .. parsed-literal:: \n kubectl apply -f \\ |SCM_WEB|\\/examples/kubernetes/clustermesh/cluster1.yaml\nkubectl apply -f \\ |SCM_WEB|\\/examples/kubernetes/clustermesh/mcsapi-example.yaml\n \n \n \n In cluster 2, deploy: \n .. parsed-literal:: \n kubectl apply -f \\ |SCM_WEB|\\/examples/kubernetes/clustermesh/cluster2.yaml\nkubectl apply -f \\ |SCM_WEB|\\/examples/kubernetes/clustermesh/mcsapi-example.yaml\n \n \n \n From either cluster, access the exported service: \n .. parsed-literal:: \n kubectl exec -ti deployment/x-wing -- curl rebel-base-mcsapi.default.svc.clusterset.local \n You will see replies from pods in both clusters. \n \n \n Gateway-API\n########### \n Gateway-API has optional support for MCS-API via  GEP1748 _ by specifying a\nServiceImport backend, for example: \n .. code-block:: yaml \n apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\nname: rebel-base-mcsapi\nnamespace: default\nspec:\nparentRefs:\n- group: gateway.networking.k8s.io\nkind: Gateway\nname: my-gateway\nnamespace: default\nrules:\n- backendRefs:\n- group: multicluster.x-k8s.io\nkind: ServiceImport\nname: rebel-base-mcsapi\nport: 80\nmatches:\n- method: GET\npath:\ntype: PathPrefix\nvalue: / \n The Gateway API implementation of Cilium fully support its own MCS-API implementation. \n If you want to use another Gateway API implementation with the Cilium MCS-API implementation,\nthe Gateway API implementation you are using should officially support MCS-API /  GEP1748 _. \n On the other hands, the Cilium Gateway API implementation only supports MCS-API\nimplementations using an underlying Service associated with a ServiceImport, and with\nthe annotation  multicluster.kubernetes.io/derived-service  on ServiceImport resources. \n .. _GEP1748: https://github.com/kubernetes/enhancements/blob/master/keps/sig-multicluster/1645-multi-cluster-services-api/README.md",
  "item_type": "unknown",
  "module_path": "/tmp/cilium-repo/Documentation/network/clustermesh/mcsapi.rst",
  "extracted_at": "2025-09-03T01:13:29.191945Z"
}