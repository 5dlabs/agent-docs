# Multi-stage Docker build with cargo-chef optimization for dependency caching
# and distroless runtime for minimal attack surface

# Chef stage for cargo-chef installation and dependency management
# Use a recent Rust toolchain that supports edition 2024
FROM lukemathwalker/cargo-chef:latest AS chef
WORKDIR /app

# Planner stage - generates recipe.json with dependency information
FROM chef AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

# Builder stage - builds dependencies first (cached layer), then application
FROM chef AS builder

# Copy and build dependencies (this layer will be cached)
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json

# Copy source code and build application
COPY . .
RUN cargo build --release --bin http_server

# Additional binary optimization is handled by Cargo.toml (strip) for reproducibility

# Runtime stage using distroless for minimal attack surface
FROM gcr.io/distroless/cc-debian12 AS runtime

# Copy optimized binary from builder
COPY --from=builder /app/target/release/http_server /usr/local/bin/http_server

# Use distroless nonroot user for security
USER nonroot:nonroot

# Configure environment
ENV RUST_LOG=info
ENV PORT=3001

# Expose port
EXPOSE 3001

# Health check using application's built-in health endpoint
# Note: Since distroless has no shell or curl, we rely on the application's health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD ["/usr/local/bin/http_server", "--health-check"]

# Set proper signal for container orchestration
STOPSIGNAL SIGTERM

# Run the optimized server
ENTRYPOINT ["/usr/local/bin/http_server"]