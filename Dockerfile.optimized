# Multi-stage Docker build with cargo-chef optimization for dependency caching
# and distroless runtime for minimal attack surface

# Chef stage for cargo-chef installation and dependency management
FROM lukemathwalker/cargo-chef:latest-rust-1.70 AS chef
WORKDIR /app

# Planner stage - generates recipe.json with dependency information
FROM chef AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

# Builder stage - builds dependencies first (cached layer), then application
FROM chef AS builder

# Install additional tools for binary optimization
RUN apt-get update && apt-get install -y \
    upx-ucl \
    binutils \
    --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

# Copy and build dependencies (this layer will be cached)
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json

# Copy source code and build application
COPY . .
RUN cargo build --release --bin http_server

# Additional binary optimization (strip is already configured in Cargo.toml)
RUN upx --best target/release/http_server

# Runtime stage using distroless for minimal attack surface
FROM gcr.io/distroless/cc-debian12 AS runtime

# Copy optimized binary from builder
COPY --from=builder /app/target/release/http_server /usr/local/bin/http_server

# Use distroless nonroot user for security
USER nonroot:nonroot

# Configure environment
ENV RUST_LOG=info
ENV PORT=3001

# Expose port
EXPOSE 3001

# Health check using application's built-in health endpoint
# Note: Since distroless has no shell or curl, we rely on the application's health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD ["/usr/local/bin/http_server", "--health-check"]

# Set proper signal for container orchestration
STOPSIGNAL SIGTERM

# Run the optimized server
ENTRYPOINT ["/usr/local/bin/http_server"]